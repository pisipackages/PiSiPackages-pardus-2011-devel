diff -Naur taglib-1.6/taglib/wma/asf.cpp taglib-patched/taglib/wma/asf.cpp
--- taglib-1.6/taglib/wma/asf.cpp	1970-01-01 02:00:00.000000000 +0200
+++ taglib-patched/taglib/wma/asf.cpp	2008-02-26 00:02:00.000000000 +0200
@@ -0,0 +1,403 @@
+/*
+ * ASF compatible decoder.
+ * Copyright (c) 2000, 2001 Fabrice Bellard.
+ * Modifications (Header parsing only version) Copyright (c) 2005 Umesh Shankar.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+//#include "avformat.h"
+//#include "avi.h"
+//#include "mpegaudio.h"
+#include <tdebug.h>
+#include "asf.h"
+#include "wmafile.h"
+#include "wmatag.h"
+#include <cstring>
+
+using namespace TagLib;
+
+#undef NDEBUG
+#include <assert.h>
+
+#define FRAME_HEADER_SIZE 17
+// Fix Me! FRAME_HEADER_SIZE may be different. 
+
+static const GUID index_guid = {
+        0x33000890, 0xe5b1, 0x11cf, { 0x89, 0xf4, 0x00, 0xa0, 0xc9, 0x03, 0x49, 0xcb },
+};
+
+/**********************************/
+/* decoding */
+
+//#define DEBUG
+
+static uint64_t get_le64(WMA::File *f)
+{
+  ByteVector bv = f->readBlock(8);
+  return bv.toLongLong(false);  
+}
+
+static unsigned int get_le32(WMA::File *f)
+{
+  ByteVector bv = f->readBlock(4);
+  return bv.toUInt(false);
+}
+
+static unsigned int get_le16(WMA::File *f)
+{
+  ByteVector bv = f->readBlock(2);
+  return bv.toShort(false);
+}
+
+static int get_byte(WMA::File *f)
+{
+  ByteVector bv = f->readBlock(1);
+  return bv[0];
+}
+
+static void get_guid(WMA::File *f, GUID *g)
+{
+  int i;
+
+  g->v1 = get_le32(f);
+  g->v2 = get_le16(f);
+  g->v3 = get_le16(f);
+  for(i=0;i<8;i++)
+          g->v4[i] = get_byte(f);
+}
+
+#if 0
+static void get_str16(WMA::File *f, String& s)
+{
+  int len; //, c;
+  //  char *q;
+  
+  len = get_le16(f);
+
+  ByteVector bv = f->readBlock(len * 2); // len is number of wide characters (see below)
+  bv.append( ByteVector::fromShort(0) ); // NULL terminator
+  s = String((wchar_t *) bv.data(), String::UTFLE16);
+
+//   q = buf;
+//   while (len > 0) {
+//     c = get_le16(f);
+//     if ((q - buf) < buf_size - 1)
+//             *q++ = c;
+//     len--;
+//   }
+//   *q = '\0';
+}
+#endif
+
+static void get_str16_nolen(WMA::File *f, int len, String& s)
+{
+  ByteVector bv = f->readBlock(len); // len here is apparently in bytes (see code below)
+  bv.append( ByteVector::fromShort(0) ); // NULL terminator
+  s = String(bv, String::UTF16LE);
+
+//   int c;
+//   char *q;
+
+//   q = buf;
+//   while (len > 0) {
+//     c = get_le16(f);
+//     if ((q - buf) < buf_size - 1)
+//             *q++ = c;
+//     len-=2;
+//   }
+//   *q = '\0';
+}
+
+
+
+/* We could be given one of the three possible structures here:
+ * WAVEFORMAT, PCMWAVEFORMAT or WAVEFORMATEX. Each structure
+ * is an expansion of the previous one with the fields added
+ * at the bottom. PCMWAVEFORMAT adds 'WORD wBitsPerSample' and
+ * WAVEFORMATEX adds 'WORD  cbSize' and basically makes itself
+ * an openended structure.
+ */
+void WMA::File::getWavHeader(int size)
+{
+    int id;
+
+    if ( properties ) {
+      id = get_le16(this);
+      properties->m_channels = get_le16(this);
+      properties->m_sampleRate = get_le32(this);
+      properties->m_bitrate = (get_le32(this) * 8) / 1000; // in kb/s
+      /*codec->block_align = */get_le16(this);
+    } else {
+      seek(2 + 2 + 4 + 4 + 2, TagLib::File::Current);
+    }
+    
+    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */
+      //      codec->bits_per_sample = 8;
+    } else
+            /* codec->bits_per_sample = */ get_le16(this);
+
+    if (size > 16) {  /* We're obviously dealing with WAVEFORMATEX */
+      unsigned int extradata_size = get_le16(this);
+      if (extradata_size > 0) {
+        if (extradata_size > size - 18)
+	        extradata_size = size - 18;
+        seek(extradata_size, TagLib::File::Current); // Just skip the extra data
+      } else {
+        extradata_size = 0;
+      }
+      
+      /* It is possible for the chunk to contain garbage at the end */
+      if (size - extradata_size - 18 > 0)
+              seek(size - extradata_size - 18, TagLib::File::Current);
+    }
+}
+
+
+int WMA::File::asfReadHeader()
+{
+  ASFContext asf;
+  GUID g;
+  int size, i;
+  int64_t gsize;
+
+  get_guid(this, &g);
+  if (memcmp(&g, &asf_header, sizeof(GUID)))
+          goto fail;
+  get_le64(this);
+  get_le32(this);
+  get_byte(this);
+  get_byte(this);
+  //  memset(&asf->asfid2avid, -1, sizeof(asf->asfid2avid));
+  for(;;) {
+    get_guid(this, &g);
+    gsize = get_le64(this);
+// #ifdef DEBUG
+//     printf("%08Lx: ", url_ftell(f) - 24);
+//     print_guid(&g);
+//     printf("  size=0x%Lx\n", gsize);
+// #endif
+    if (gsize < 24)
+            goto fail;
+    if (!memcmp(&g, &file_header, sizeof(GUID))) {
+      get_guid(this, &g);
+      // asf.hdr.file_size		= 
+              get_le64(this);
+      // asf.hdr.create_time	=
+              get_le64(this);
+      // asf.hdr.packets_count	=
+              get_le64(this);
+      // asf.hdr.play_time	
+              int64_t play_time = get_le64(this);
+              // play_time is in 100ns = 10^-7s units
+              if (properties) 
+                      properties->m_length = (play_time / 10000000L);
+      // asf.hdr.send_time		=
+              get_le64(this);
+      // asf.hdr.preroll		=
+              get_le32(this);
+      // asf.hdr.ignore		=
+              get_le32(this);
+      // asf.hdr.flags		=
+              get_le32(this);
+      // asf.hdr.min_pktsize	=
+              get_le32(this);
+      // asf.hdr.max_pktsize	=
+              get_le32(this);
+      // asf.hdr.max_bitrate	=
+              get_le32(this);
+      // asf.packet_size = asf.hdr.max_pktsize;
+      // asf.nb_packets = asf.hdr.packets_count;
+    } else if (!memcmp(&g, &stream_header, sizeof(GUID))) {
+      int type, total_size, type_specific_size;
+      unsigned int tag1;
+      int64_t pos1, pos2;
+
+      pos1 = tell();
+
+      get_guid(this, &g);
+      if (!memcmp(&g, &audio_stream, sizeof(GUID))) {
+        //        type = CODEC_TYPE_AUDIO;
+      } else {
+        debug("TagLib::WMA: File contains non-audio streams!");
+        return false;
+      }
+
+      get_guid(this, &g);
+      total_size = get_le64(this);
+      type_specific_size = get_le32(this);
+      get_le32(this);
+      get_le16(this) & 0x7f; /* stream id */
+
+      get_le32(this);
+//       st->codec.codec_type = type;
+//       /* 1 fps default (XXX: put 0 fps instead) */
+//       st->codec.frame_rate = 1000; 
+//       st->codec.frame_rate_base = 1;
+
+      //      if (type == CODEC_TYPE_AUDIO) {
+        getWavHeader(type_specific_size);
+        //        st->need_parsing = 1;
+        /* We have to init the frame size at some point .... */
+        pos2 = tell();
+        if (gsize > (pos2 + 8 - pos1 + 24)) {
+          /* asf_st.ds_span = */ get_byte(this);
+          /* asf_st.ds_packet_size = */ get_le16(this);
+          // asf_st.ds_chunk_size = 
+                  get_le16(this);
+         //  asf_st.ds_data_size =
+                  get_le16(this);
+          // asf_st.ds_silence_data =
+                  get_byte(this);
+        }
+
+      pos2 = tell();
+      seek(gsize - (pos2 - pos1 + 24), TagLib::File::Current);
+    } else if (!memcmp(&g, &data_header, sizeof(GUID))) {
+      break;
+    } else if (!memcmp(&g, &comment_header, sizeof(GUID))) {
+      int len1, len2, len3, len4, len5;
+
+      len1 = get_le16(this);
+      len2 = get_le16(this);
+      len3 = get_le16(this);
+      len4 = get_le16(this);
+      len5 = get_le16(this);
+
+      if (wmaTag) {
+        String s;
+        char buf[1];
+
+        get_str16_nolen(this, len1, s);
+        wmaTag->setTitle(s);
+
+        get_str16_nolen(this, len2, s);
+        wmaTag->setArtist(s);
+
+        get_str16_nolen(this, len3, s); // Copyright notice
+
+        get_str16_nolen(this, len4, s);
+        wmaTag->setComment(s);
+
+        seek(len5, TagLib::File::Current);
+      } else {
+        seek(len1+len2+len3+len4+len5, TagLib::File::Current);
+      }
+    } else if (!memcmp(&g, &extended_content_header, sizeof(GUID))) {
+      int desc_count, i;
+
+      desc_count = get_le16(this);
+      for(i=0;i<desc_count;i++)
+              {
+                int name_len,value_type,value_len = 0;
+                int64_t value_num;
+                String name, value;
+
+                name_len = get_le16(this);
+                get_str16_nolen(this, name_len, name);
+                value_type = get_le16(this);
+                value_len = get_le16(this);
+                
+                //debug (name);
+                //                printf ("value_type is %d; name_len is %d\n", value_type, name_len);
+
+                if ((value_type == 0) || (value_type == 1)) // unicode or byte
+                        {
+                          get_str16_nolen(this, value_len, value);
+                          //debug ("string value:");
+                          //debug(value);
+                          if ( wmaTag ) {
+                            if (strcmp(name.toCString(),"WM/AlbumTitle")==0) { wmaTag->setAlbum(value); }
+                            if (strcmp(name.toCString(),"WM/Genre")==0) { wmaTag->setGenre(value); }
+                            if (strcmp(name.toCString(),"WM/Year")==0) { wmaTag->setYear(value.toInt()); }
+                          }
+                                                }
+                if ((value_type >= 2) || (value_type <= 5)) // boolean or DWORD or QWORD or WORD
+                        {
+                          if (value_type==2) value_num = get_le32(this);
+                          if (value_type==3) value_num = get_le32(this);
+                          if (value_type==4) value_num = get_le64(this);
+                          if (value_type==5) value_num = get_le16(this);
+
+                          //printf("numerical value: %d\n", value_num);                          
+                          if (wmaTag) {
+                            if (strcmp(name.toCString(),"WM/Track")==0) wmaTag->setTrack(value_num + 1);
+                            if (strcmp(name.toCString(),"WM/TrackNumber")==0) wmaTag->setTrack(value_num);
+                          }
+                        }
+              }
+#if 0
+    } else if (!memcmp(&g, &head1_guid, sizeof(GUID))) {
+      int v1, v2;
+      get_guid(f, &g);
+      v1 = get_le32(this);
+      v2 = get_le16(this);
+    } else if (!memcmp(&g, &codec_comment_header, sizeof(GUID))) {
+      int len, v1, n, num;
+      char str[256], *q;
+      char tag[16];
+
+      get_guid(this, &g);
+      print_guid(&g);
+
+      n = get_le32(this);
+      for(i=0;i<n;i++) {
+        num = get_le16(this); /* stream number */
+        get_str16(this, str, sizeof(str));
+        get_str16(this, str, sizeof(str));
+        len = get_le16(this);
+        q = tag;
+        while (len > 0) {
+          v1 = get_byte(this);
+          if ((q - tag) < sizeof(tag) - 1)
+                  *q++ = v1;
+          len--;
+        }
+        *q = '\0';
+      }
+#endif
+      // FIXME: Can we eliminate all further reads?
+
+  // FIXME: implement EOF check
+//     } else if (url_feof(f)) {
+//       goto fail;
+    } else {
+      seek(gsize - 24, TagLib::File::Current);
+    }
+  }
+  get_guid(this, &g);
+  get_le64(this);
+  get_byte(this);
+  get_byte(this);
+  // FIXME: implement EOF check
+//   if (url_feof(f))
+//           goto fail;
+//   asf->data_offset = url_ftell(f);
+//   asf->packet_size_left = 0;
+
+  return true;
+
+        fail:
+  return false;
+//   for(i=0;i<s->nb_streams;i++) {
+//     AVStream *st = s->streams[i];
+//     if (st) {
+//       av_free(st->priv_data);
+//       av_free(st->codec.extradata);
+//     }
+//     av_free(st);
+//   }
+//   return -1;
+}
diff -Naur taglib-1.6/taglib/wma/asf.h taglib-patched/taglib/wma/asf.h
--- taglib-1.6/taglib/wma/asf.h	1970-01-01 02:00:00.000000000 +0200
+++ taglib-patched/taglib/wma/asf.h	2008-02-26 00:02:00.000000000 +0200
@@ -0,0 +1,245 @@
+/*
+ * Copyright (c) 2000, 2001 Fabrice Bellard.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define PACKET_SIZE 3200
+
+// typedef struct {
+//     int num;
+//     unsigned char seq;
+//     /* use for reading */
+//     AVPacket pkt;
+//     int frag_offset;
+//     int timestamp;
+//     int64_t duration;
+
+//     int ds_span;		/* descrambling  */
+//     int ds_packet_size;
+//     int ds_chunk_size;
+//     int ds_data_size;
+//     int ds_silence_data;
+    
+//     int packet_pos;
+
+// } ASFStream;
+
+#include <inttypes.h>
+
+typedef struct {
+    uint32_t v1;
+    uint16_t v2;
+    uint16_t v3;
+    uint8_t v4[8];
+} GUID;
+
+typedef struct {
+    GUID guid;			// generated by client computer
+    uint64_t file_size;		// in bytes
+                                // invalid if broadcasting
+    uint64_t create_time;	// time of creation, in 100-nanosecond units since 1.1.1601
+                                // invalid if broadcasting
+    uint64_t packets_count;	// how many packets are there in the file
+                                // invalid if broadcasting
+    uint64_t play_time;		// play time, in 100-nanosecond units
+                                // invalid if broadcasting
+    uint64_t send_time;		// time to send file, in 100-nanosecond units
+                                // invalid if broadcasting (could be ignored)
+    uint32_t preroll;		// timestamp of the first packet, in milliseconds
+    				// if nonzero - substract from time
+    uint32_t ignore;            // preroll is 64bit - but let's just ignore it
+    uint32_t flags;		// 0x01 - broadcast
+    				// 0x02 - seekable
+                                // rest is reserved should be 0
+    uint32_t min_pktsize;	// size of a data packet
+                                // invalid if broadcasting
+    uint32_t max_pktsize;	// shall be the same as for min_pktsize
+                                // invalid if broadcasting
+    uint32_t max_bitrate;	// bandwith of stream in bps
+    				// should be the sum of bitrates of the
+                                // individual media streams
+} ASFMainHeader;
+
+
+typedef struct {
+    uint32_t seqno;
+    unsigned int packet_size;
+    int is_streamed;
+    int asfid2avid[128];        /* conversion table from asf ID 2 AVStream ID */
+        //    ASFStream streams[128];	/* it's max number and it's not that big */
+    /* non streamed additonnal info */
+    int64_t nb_packets;
+    int64_t duration; /* in 100ns units */
+    /* packet filling */
+    unsigned char multi_payloads_present;
+    int packet_size_left;
+    int prev_packet_sent_time;
+    int packet_timestamp_start;
+    int packet_timestamp_end;
+    unsigned int packet_nb_payloads;
+    int packet_nb_frames;
+    uint8_t packet_buf[PACKET_SIZE];
+        //    ByteIOContext pb;
+    /* only for reading */
+    uint64_t data_offset; /* begining of the first data packet */
+
+        //    ASFMainHeader hdr;
+
+    int packet_flags;
+    int packet_property;
+    int packet_timestamp;
+    int packet_segsizetype;
+    int packet_segments;
+    int packet_seq;
+    int packet_replic_size;
+    int packet_key_frame;
+    int packet_padsize;
+    int packet_frag_offset;
+    int packet_frag_size;
+    int packet_frag_timestamp;
+    int packet_multi_size;
+    int packet_obj_size;
+    int packet_time_delta;
+    int packet_time_start;
+    int packet_pos;
+
+    int stream_index;
+        //    ASFStream* asf_st; /* currently decoded stream */
+} ASFContext;
+
+static const GUID asf_header = {
+    0x75B22630, 0x668E, 0x11CF, { 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C },
+};
+
+static const GUID file_header = {
+    0x8CABDCA1, 0xA947, 0x11CF, { 0x8E, 0xE4, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65 },
+};
+
+static const GUID stream_header = {
+    0xB7DC0791, 0xA9B7, 0x11CF, { 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65 },
+};
+
+static const GUID audio_stream = {
+    0xF8699E40, 0x5B4D, 0x11CF, { 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B },
+};
+
+static const GUID audio_conceal_none = {
+    // 0x49f1a440, 0x4ece, 0x11d0, { 0xa3, 0xac, 0x00, 0xa0, 0xc9, 0x03, 0x48, 0xf6 },
+    // New value lifted from avifile
+    0x20fb5700, 0x5b55, 0x11cf, { 0xa8, 0xfd, 0x00, 0x80, 0x5f, 0x5c, 0x44, 0x2b },
+};
+
+static const GUID video_stream = {
+    0xBC19EFC0, 0x5B4D, 0x11CF, { 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B },
+};
+
+static const GUID video_conceal_none = {
+    0x20FB5700, 0x5B55, 0x11CF, { 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B },
+};
+
+
+static const GUID comment_header = {
+    0x75b22633, 0x668e, 0x11cf, { 0xa6, 0xd9, 0x00, 0xaa, 0x00, 0x62, 0xce, 0x6c },
+};
+
+static const GUID codec_comment_header = {
+    0x86D15240, 0x311D, 0x11D0, { 0xA3, 0xA4, 0x00, 0xA0, 0xC9, 0x03, 0x48, 0xF6 },
+};
+static const GUID codec_comment1_header = {
+    0x86d15241, 0x311d, 0x11d0, { 0xa3, 0xa4, 0x00, 0xa0, 0xc9, 0x03, 0x48, 0xf6 },
+};
+
+static const GUID data_header = {
+    0x75b22636, 0x668e, 0x11cf, { 0xa6, 0xd9, 0x00, 0xaa, 0x00, 0x62, 0xce, 0x6c },
+};
+
+static const GUID head1_guid = {
+    0x5fbf03b5, 0xa92e, 0x11cf, { 0x8e, 0xe3, 0x00, 0xc0, 0x0c, 0x20, 0x53, 0x65 },
+};
+
+static const GUID head2_guid = {
+    0xabd3d211, 0xa9ba, 0x11cf, { 0x8e, 0xe6, 0x00, 0xc0, 0x0c, 0x20, 0x53, 0x65 },
+};
+
+static const GUID extended_content_header = {
+        0xD2D0A440, 0xE307, 0x11D2, { 0x97, 0xF0, 0x00, 0xA0, 0xC9, 0x5E, 0xA8, 0x50 },
+};
+
+/* I am not a number !!! This GUID is the one found on the PC used to
+   generate the stream */
+static const GUID my_guid = {
+    0, 0, 0, { 0, 0, 0, 0, 0, 0, 0, 0 },
+};
+
+#define ASF_PACKET_FLAG_ERROR_CORRECTION_PRESENT 0x80 //1000 0000
+
+
+//   ASF data packet structure
+//   =========================
+//
+//
+//  -----------------------------------
+// | Error Correction Data             |  Optional
+//  -----------------------------------
+// | Payload Parsing Information (PPI) |
+//  -----------------------------------
+// | Payload Data                      |
+//  -----------------------------------
+// | Padding Data                      |
+//  -----------------------------------
+
+
+// PPI_FLAG - Payload parsing information flags
+#define ASF_PPI_FLAG_MULTIPLE_PAYLOADS_PRESENT 1
+
+#define ASF_PPI_FLAG_SEQUENCE_FIELD_IS_BYTE  0x02 //0000 0010
+#define ASF_PPI_FLAG_SEQUENCE_FIELD_IS_WORD  0x04 //0000 0100
+#define ASF_PPI_FLAG_SEQUENCE_FIELD_IS_DWORD 0x06 //0000 0110
+#define ASF_PPI_MASK_SEQUENCE_FIELD_SIZE     0x06 //0000 0110
+
+#define ASF_PPI_FLAG_PADDING_LENGTH_FIELD_IS_BYTE  0x08 //0000 1000
+#define ASF_PPI_FLAG_PADDING_LENGTH_FIELD_IS_WORD  0x10 //0001 0000
+#define ASF_PPI_FLAG_PADDING_LENGTH_FIELD_IS_DWORD 0x18 //0001 1000
+#define ASF_PPI_MASK_PADDING_LENGTH_FIELD_SIZE     0x18 //0001 1000
+
+#define ASF_PPI_FLAG_PACKET_LENGTH_FIELD_IS_BYTE  0x20 //0010 0000
+#define ASF_PPI_FLAG_PACKET_LENGTH_FIELD_IS_WORD  0x40 //0100 0000
+#define ASF_PPI_FLAG_PACKET_LENGTH_FIELD_IS_DWORD 0x60 //0110 0000
+#define ASF_PPI_MASK_PACKET_LENGTH_FIELD_SIZE     0x60 //0110 0000
+
+// PL_FLAG - Payload flags
+#define ASF_PL_FLAG_REPLICATED_DATA_LENGTH_FIELD_IS_BYTE   0x01 //0000 0001
+#define ASF_PL_FLAG_REPLICATED_DATA_LENGTH_FIELD_IS_WORD   0x02 //0000 0010
+#define ASF_PL_FLAG_REPLICATED_DATA_LENGTH_FIELD_IS_DWORD  0x03 //0000 0011
+#define ASF_PL_MASK_REPLICATED_DATA_LENGTH_FIELD_SIZE      0x03 //0000 0011
+
+#define ASF_PL_FLAG_OFFSET_INTO_MEDIA_OBJECT_LENGTH_FIELD_IS_BYTE  0x04 //0000 0100
+#define ASF_PL_FLAG_OFFSET_INTO_MEDIA_OBJECT_LENGTH_FIELD_IS_WORD  0x08 //0000 1000
+#define ASF_PL_FLAG_OFFSET_INTO_MEDIA_OBJECT_LENGTH_FIELD_IS_DWORD 0x0c //0000 1100
+#define ASF_PL_MASK_OFFSET_INTO_MEDIA_OBJECT_LENGTH_FIELD_SIZE     0x0c //0000 1100
+
+#define ASF_PL_FLAG_MEDIA_OBJECT_NUMBER_LENGTH_FIELD_IS_BYTE  0x10 //0001 0000
+#define ASF_PL_FLAG_MEDIA_OBJECT_NUMBER_LENGTH_FIELD_IS_WORD  0x20 //0010 0000
+#define ASF_PL_FLAG_MEDIA_OBJECT_NUMBER_LENGTH_FIELD_IS_DWORD 0x30 //0011 0000
+#define ASF_PL_MASK_MEDIA_OBJECT_NUMBER_LENGTH_FIELD_SIZE     0x30 //0011 0000
+
+#define ASF_PL_FLAG_STREAM_NUMBER_LENGTH_FIELD_IS_BYTE  0x40 //0100 0000
+#define ASF_PL_MASK_STREAM_NUMBER_LENGTH_FIELD_SIZE     0xc0 //1100 0000
+
+#define ASF_PL_FLAG_PAYLOAD_LENGTH_FIELD_IS_BYTE  0x40 //0100 0000
+#define ASF_PL_FLAG_PAYLOAD_LENGTH_FIELD_IS_WORD  0x80 //1000 0000
+#define ASF_PL_MASK_PAYLOAD_LENGTH_FIELD_SIZE     0xc0 //1100 0000
+
+#define ASF_PL_FLAG_KEY_FRAME 0x80 //1000 0000
diff -Naur taglib-1.6/taglib/wma/CMakeLists.txt taglib-patched/taglib/wma/CMakeLists.txt
--- taglib-1.6/taglib/wma/CMakeLists.txt	1970-01-01 02:00:00.000000000 +0200
+++ taglib-patched/taglib/wma/CMakeLists.txt	2008-02-26 00:02:00.000000000 +0200
@@ -0,0 +1,2 @@
+INSTALL( FILES wmafile.h wmatag.h wmaproperties.h asf.h DESTINATION ${INCLUDE_INSTALL_DIR}/taglib )
+
diff -Naur taglib-1.6/taglib/wma/wmafile.cpp taglib-patched/taglib/wma/wmafile.cpp
--- taglib-1.6/taglib/wma/wmafile.cpp	1970-01-01 02:00:00.000000000 +0200
+++ taglib-patched/taglib/wma/wmafile.cpp	2008-02-26 00:02:00.000000000 +0200
@@ -0,0 +1,80 @@
+/***************************************************************************
+    copyright            : (C) 2005 by Umesh Shankar
+    email                : ushankar@cs.berkeley.edu
+ ***************************************************************************/
+
+/***************************************************************************
+ *   This library is free software; you can redistribute it and/or modify  *
+ *   it  under the terms of the GNU Lesser General Public License version  *
+ *   2.1 as published by the Free Software Foundation.                     *
+ *                                                                         *
+ *   This library is distributed in the hope that it will be useful, but   *
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
+ *   Lesser General Public License for more details.                       *
+ *                                                                         *
+ *   You should have received a copy of the GNU Lesser General Public      *
+ *   License along with this library; if not, write to the Free Software   *
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  *
+ *   USA                                                                   *
+ ***************************************************************************/
+
+#include "wmatag.h"
+#include <tdebug.h>
+#include <tfile.h>
+#include <audioproperties.h>
+
+namespace TagLib {
+////////////////////////////////////////////////////////////////////////////////
+// public members
+////////////////////////////////////////////////////////////////////////////////
+
+WMA::File::File(const char *file, bool readProperties,
+                 Properties::ReadStyle propertiesStyle) : TagLib::File(file)
+{
+  wmaTag = NULL;
+  if(isOpen()) {
+    wmaTag = new WMATag();
+    read(readProperties, propertiesStyle);
+  }
+}
+
+WMA::File::~File()
+{ 
+  delete wmaTag; 
+}
+
+TagLib::Tag *WMA::File::tag() const
+{
+  return wmaTag;
+}
+
+TagLib::WMA::WMATag *WMA::File::getWMATag() const
+{
+  return wmaTag;
+}
+
+WMA::Properties *WMA::File::audioProperties() const
+{
+  return properties;
+}
+
+bool WMA::File::save()
+{
+  debug ("WMA::File: Saving not supported yet.");
+  return false;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// private members
+////////////////////////////////////////////////////////////////////////////////
+
+void WMA::File::read(bool readProperties, Properties::ReadStyle propertiesStyle)
+{
+  if(readProperties)
+    properties = new Properties(propertiesStyle);
+
+  bool success = asfReadHeader();
+}
+}
diff -Naur taglib-1.6/taglib/wma/wmafile.h taglib-patched/taglib/wma/wmafile.h
--- taglib-1.6/taglib/wma/wmafile.h	1970-01-01 02:00:00.000000000 +0200
+++ taglib-patched/taglib/wma/wmafile.h	2008-02-26 00:02:00.000000000 +0200
@@ -0,0 +1,107 @@
+/***************************************************************************
+    copyright            : (C) 2005 by Umesh Shankar
+    email                : ushankar@cs.berkeley.edu
+ ***************************************************************************/
+
+/***************************************************************************
+ *   This library is free software; you can redistribute it and/or modify  *
+ *   it  under the terms of the GNU Lesser General Public License version  *
+ *   2.1 as published by the Free Software Foundation.                     *
+ *                                                                         *
+ *   This library is distributed in the hope that it will be useful, but   *
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
+ *   Lesser General Public License for more details.                       *
+ *                                                                         *
+ *   You should have received a copy of the GNU Lesser General Public      *
+ *   License along with this library; if not, write to the Free Software   *
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  *
+ *   USA                                                                   *
+ ***************************************************************************/
+
+#ifndef TAGLIB_WMAFILE_H
+#define TAGLIB_WMAFILE_H
+
+#include <tfile.h>
+#include "wmaproperties.h"
+
+namespace TagLib { 
+
+  namespace WMA {
+
+  class WMATag;
+
+    //! A WMA file class with some useful methods specific to WMA
+    //! Most of the real parsing is ripped from MPlayer
+
+    /*!
+     * This implements the generic TagLib::File API
+     */
+
+    class File : public TagLib::File
+    {
+    public:
+      /*!
+       * Contructs a WMA file from \a file.  If \a readProperties is true the
+       * file's audio properties will also be read using \a propertiesStyle.  If
+       * false, \a propertiesStyle is ignored.
+       *
+       * \deprecated This constructor will be dropped in favor of the one below
+       * in a future version.
+       */
+      File(const char *file, bool readProperties = true,
+           Properties::ReadStyle propertiesStyle = Properties::Average);
+
+      /*!
+       * Destroys this instance of the File.
+       */
+      virtual ~File();
+
+      /*!
+       * Returns a pointer to the WMATag class, which provides the
+       * basic TagLib::Tag fields
+       *
+       * \see WMATag()
+       */
+      virtual Tag *tag() const;
+
+      /*!
+       * Returns the WMA::Properties for this file.  If no audio properties
+       * were read then this will return a null pointer.
+       */
+      virtual Properties *audioProperties() const;
+
+      /*!
+       * Save the file.  
+       * This is the same as calling save(AllTags);
+       *
+       * \note As of now, saving WMA tags is not supported.
+       */
+      virtual bool save();
+
+      /*!
+       * Returns a pointer to the WMATag of the file.
+       *
+       * \note The Tag <b>is still</b> owned by the WMA::File and should not be
+       * deleted by the user.  It will be deleted when the file (object) is
+       * destroyed.
+       */
+      WMATag *getWMATag() const;
+
+    protected:
+      File(const File &);
+      File &operator=(const File &);
+      
+      void getWavHeader(int size);
+
+      int asfReadHeader();
+
+      void read(bool readProperties, Properties::ReadStyle propertiesStyle);
+      
+      WMATag *wmaTag;
+      Properties *properties;
+    };
+  }
+}
+
+#endif
diff -Naur taglib-1.6/taglib/wma/wmaproperties.cpp taglib-patched/taglib/wma/wmaproperties.cpp
--- taglib-1.6/taglib/wma/wmaproperties.cpp	1970-01-01 02:00:00.000000000 +0200
+++ taglib-patched/taglib/wma/wmaproperties.cpp	2008-02-26 00:02:00.000000000 +0200
@@ -0,0 +1,65 @@
+/***************************************************************************
+    copyright            : (C) 2005 by Umesh Shankar
+    email                : ushankar@cs.berkeley.edu
+ ***************************************************************************/
+
+/***************************************************************************
+ *   This library is free software; you can redistribute it and/or modify  *
+ *   it  under the terms of the GNU Lesser General Public License version  *
+ *   2.1 as published by the Free Software Foundation.                     *
+ *                                                                         *
+ *   This library is distributed in the hope that it will be useful, but   *
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
+ *   Lesser General Public License for more details.                       *
+ *                                                                         *
+ *   You should have received a copy of the GNU Lesser General Public      *
+ *   License along with this library; if not, write to the Free Software   *
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  *
+ *   USA                                                                   *
+ ***************************************************************************/
+
+#include <tdebug.h>
+#include <tstring.h>
+
+#include "wmaproperties.h"
+#include "wmafile.h"
+  
+using namespace TagLib;
+
+
+////////////////////////////////////////////////////////////////////////////////
+// public members
+////////////////////////////////////////////////////////////////////////////////
+
+WMA::Properties::Properties(Properties::ReadStyle style) : AudioProperties(style)
+{
+  m_length = 0;
+  m_bitrate = 0;
+  m_sampleRate = 0;
+  m_channels = 0;
+}
+
+WMA::Properties::~Properties()
+{
+}
+
+int WMA::Properties::length() const
+{
+  return m_length;
+}
+
+int WMA::Properties::bitrate() const
+{
+  return m_bitrate;
+}
+
+int WMA::Properties::sampleRate() const
+{
+  return m_sampleRate;
+}
+
+int WMA::Properties::channels() const
+{
+  return m_channels;
+}
diff -Naur taglib-1.6/taglib/wma/wmaproperties.h taglib-patched/taglib/wma/wmaproperties.h
--- taglib-1.6/taglib/wma/wmaproperties.h	1970-01-01 02:00:00.000000000 +0200
+++ taglib-patched/taglib/wma/wmaproperties.h	2008-02-26 00:02:00.000000000 +0200
@@ -0,0 +1,77 @@
+/***************************************************************************
+    copyright            : (C) 2005 by Umesh Shankar
+    email                : ushankar@cs.berkeley.edu
+ ***************************************************************************/
+
+/***************************************************************************
+ *   This library is free software; you can redistribute it and/or modify  *
+ *   it  under the terms of the GNU Lesser General Public License version  *
+ *   2.1 as published by the Free Software Foundation.                     *
+ *                                                                         *
+ *   This library is distributed in the hope that it will be useful, but   *
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
+ *   Lesser General Public License for more details.                       *
+ *                                                                         *
+ *   You should have received a copy of the GNU Lesser General Public      *
+ *   License along with this library; if not, write to the Free Software   *
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  *
+ *   USA                                                                   *
+ ***************************************************************************/
+
+#ifndef TAGLIB_WMAPROPERTIES_H
+#define TAGLIB_WMAPROPERTIES_H
+
+#include <audioproperties.h>
+#include <tstring.h>
+
+namespace TagLib {
+    
+    namespace WMA {
+        
+        class File;
+        
+        /*!
+         * This reads the data from a WMA stream to support the
+         * AudioProperties API.
+         */
+        
+        class Properties : public AudioProperties
+        {
+          public:
+            /*!
+             * Initialize this structure
+             */
+            Properties(Properties::ReadStyle style);
+
+            /*!
+             * Destroys this WMA Properties instance.
+             */
+            virtual ~Properties();
+
+            // Reimplementations.
+
+            virtual int length() const;
+            virtual int bitrate() const;
+            virtual int sampleRate() const;
+            virtual int channels() const;
+
+          private:
+            friend class WMA::File;
+
+            int m_length;
+            int m_bitrate;
+            int m_sampleRate;
+            int m_channels;
+
+            Properties(const Properties &);
+            Properties &operator=(const Properties &);
+
+            void read();
+        };
+
+    }
+
+}
+
+#endif
diff -Naur taglib-1.6/taglib/wma/wmatag.cpp taglib-patched/taglib/wma/wmatag.cpp
--- taglib-1.6/taglib/wma/wmatag.cpp	1970-01-01 02:00:00.000000000 +0200
+++ taglib-patched/taglib/wma/wmatag.cpp	2008-02-26 00:02:00.000000000 +0200
@@ -0,0 +1,34 @@
+#include <tag.h>
+#include "wmatag.h"
+
+
+using namespace TagLib;
+
+WMA::WMATag::WMATag() : Tag::Tag() {
+  m_title = String::null;
+  m_artist = String::null;
+  m_album = String::null;
+  m_comment = String::null;
+  m_genre = String::null;
+  m_year = 0;
+  m_track = 0;
+}
+
+WMA::WMATag::~WMATag() {
+}
+
+bool WMA::WMATag::isEmpty() const {
+  return  m_title == String::null &&
+          m_artist == String::null &&
+          m_album == String::null && 
+          m_comment == String::null &&
+          m_genre == String::null &&
+          m_year == 0 &&
+          m_track == 0;
+}
+
+void WMA::WMATag::duplicate(const Tag *source, Tag *target, bool overwrite) {
+  // No nonstandard information stored yet
+  Tag::duplicate(source, target, overwrite);
+}
+
diff -Naur taglib-1.6/taglib/wma/wmatag.h taglib-patched/taglib/wma/wmatag.h
--- taglib-1.6/taglib/wma/wmatag.h	1970-01-01 02:00:00.000000000 +0200
+++ taglib-patched/taglib/wma/wmatag.h	2008-02-26 00:02:00.000000000 +0200
@@ -0,0 +1,162 @@
+/***************************************************************************
+    copyright            : (C) 2005 by Umesh Shankar
+    email                : ushankar@cs.berkeley.edu
+ ***************************************************************************/
+
+/***************************************************************************
+ *   This library is free software; you can redistribute it and/or modify  *
+ *   it  under the terms of the GNU Lesser General Public License version  *
+ *   2.1 as published by the Free Software Foundation.                     *
+ *                                                                         *
+ *   This library is distributed in the hope that it will be useful, but   *
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
+ *   Lesser General Public License for more details.                       *
+ *                                                                         *
+ *   You should have received a copy of the GNU Lesser General Public      *
+ *   License along with this library; if not, write to the Free Software   *
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  *
+ *   USA                                                                   *
+ ***************************************************************************/
+
+#ifndef TAGLIB_WMATAG_H
+#define TAGLIB_WMATAG_H
+
+#include <tag.h>
+#include "wmafile.h"
+
+namespace TagLib {
+
+  namespace WMA {
+    /*!
+     * This implements the generic TagLib::Tag API
+     */
+    class WMATag : public TagLib::Tag
+    {
+      public:
+      WMATag();
+
+      /*!
+       * Detroys this WMATag instance.
+       */
+      virtual ~WMATag();
+
+      /*!
+       * Returns the track name; if no track name is present in the tag
+       * String::null will be returned.
+       */
+      virtual String title() const { return m_title; }
+
+      /*!
+       * Returns the artist name; if no artist name is present in the tag
+       * String::null will be returned.
+       */
+      virtual String artist() const { return m_artist; }
+
+      /*!
+       * Returns the album name; if no album name is present in the tag
+       * String::null will be returned.
+       */
+      virtual String album() const { return m_album; }
+
+      /*!
+       * Returns the track comment; if no comment is present in the tag
+       * String::null will be returned.
+       */
+      virtual String comment() const { return m_comment; }
+
+      /*!
+       * Returns the genre name; if no genre is present in the tag String::null
+       * will be returned.
+       */
+      virtual String genre() const { return m_genre; }
+
+      /*!
+       * Returns the year; if there is no year set, this will return 0.
+       */
+      virtual uint year() const { return m_year; }
+
+      /*!
+       * Returns the track number; if there is no track number set, this will
+       * return 0.
+       */
+      virtual uint track() const { return m_track; }
+
+      /*!
+       * Sets the title to \a s.  If \a s is String::null then this value will be
+       * cleared.
+       */
+      virtual void setTitle(const String &s) { m_title = s; }
+
+      /*!
+       * Sets the artist to \a s.  If \a s is String::null then this value will be
+       * cleared.
+       */
+      virtual void setArtist(const String &s) { m_artist = s; }
+
+      /*!
+       * Sets the album to \a s.  If \a s is String::null then this value will be
+       * cleared.
+       */
+      virtual void setAlbum(const String &s) { m_album = s; } 
+
+      /*!
+       * Sets the album to \a s.  If \a s is String::null then this value will be
+       * cleared.
+       */
+      virtual void setComment(const String &s) { m_comment = s; }
+
+      /*!
+       * Sets the genre to \a s.  If \a s is String::null then this value will be
+       * cleared.  For tag formats that use a fixed set of genres, the appropriate
+       * value will be selected based on a string comparison.  A list of available
+       * genres for those formats should be available in that type's
+       * implementation.
+       */
+      virtual void setGenre(const String &s) { m_genre = s; }
+
+      /*!
+       * Sets the year to \a i.  If \a s is 0 then this value will be cleared.
+       */
+      virtual void setYear(uint i) { m_year = i; }
+
+      /*!
+       * Sets the track to \a i.  If \a s is 0 then this value will be cleared.
+       */
+      virtual void setTrack(uint i) { m_track = i; }
+
+      /*!
+       * Returns true if the tag does not contain any data.  This should be
+       * reimplemented in subclasses that provide more than the basic tagging
+       * abilities in this class.
+       */
+      virtual bool isEmpty() const;
+
+      /*!
+       * Copies the generic data from one tag to another.
+       *
+       * \note This will no affect any of the lower level details of the tag.  For
+       * instance if any of the tag type specific data (maybe a URL for a band) is
+       * set, this will not modify or copy that.  This just copies using the API
+       * in this class.
+       *
+       * If \a overwrite is true then the values will be unconditionally copied.
+       * If false only empty values will be overwritten.
+       */
+      static void duplicate(const Tag *source, Tag *target, bool overwrite = true);
+
+      protected:
+      String m_title;
+      String m_artist;
+      String m_album;
+      String m_comment;
+      String m_genre;
+      uint m_year;
+      uint m_track;
+
+      // The WMA::File class does the reading of the tag itself
+      
+    };
+  }
+}
+#endif
