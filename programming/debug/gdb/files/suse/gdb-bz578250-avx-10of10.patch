[ Backported.  ]

git://git.kernel.org/pub/scm/devel/gdb/hjl/avx.git
hjl/avxh
aebae36c2a8b73ae51319fff54fc39f220f0824a

--- ./bfd/ChangeLog.xstate	1970-01-01 01:00:00.000000000 +0100
+++ ./bfd/ChangeLog.xstate	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,14 @@
+2010-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* elf.c (elfcore_grok_note): Replace NT_386_XSTATE with
+	NT_X86_XSTATE.
+	(elfcore_write_xstatereg): Likewise.
+
+2010-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* elf-bfd.h (elfcore_write_xstatereg): New.
+
+	* elf.c (elfcore_grok_xstatereg): New.
+	(elfcore_write_xstatereg): Likewise.
+	(elfcore_grok_note): Handle NT_386_XSTATE.
+	(elfcore_write_register_note): Handle .reg-xstate section.
--- ./gdb/ChangeLog.avx	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/ChangeLog.avx	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,306 @@
+2010-03-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* common/i386-xstate.h (I386_XSTATE_SSE_MASK_STRING): Removed.
+	(I386_XSTATE_AVX_MASK_STRING): Likewise.
+	(I386_XSTATE_MAX_MASK_STRING): Likewise.
+	(I386_XSTATE_SSE_SIZE_STRING): Likewise.
+	(I386_XSTATE_AVX_SIZE_STRING): Likewise.
+	(I386_XSTATE_MAX_SIZE_STRING): Likewise.
+
+	* i386-tdep.c (i386_gdbarch_init): Replace
+	I386_XSTATE_MAX_SIZE_STRING/I386_XSTATE_MAX_MASK_STRING with
+	I386_XSTATE_MAX_SIZE/I386_XSTATE_MAX_MASK.
+
+2010-03-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_supply_xstateregset): Don't check
+	sizeof_xstateregset.
+	(amd64_collect_xstateregset): Likewise.
+	(amd64_regset_from_core_section): Likewise.
+	(amd64_init_abi): Don't set sizeof_xstateregset.
+
+	* i386-tdep.c (i386_supply_xstateregset): Don't check
+	sizeof_xstateregset.
+	(i386_collect_xstateregset): Likewise.
+	(i386_regset_from_core_section): Likewise.
+	(i386_gdbarch_init): Don't set sizeof_xstateregset.
+
+	* i386-tdep.h (gdbarch_tdep): Remove sizeof_xstateregset.
+
+2010-03-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_read_description): Call
+	i386_linux_update_xstateregset.
+	* i386-linux-nat.c (i386_linux_read_description): Likewise.
+
+	* i386-linux-tdep.c (i386_linux_update_xstateregset): New.
+	* i386-linux-tdep.h (i386_linux_update_xstateregset): Likewise.
+
+2010-03-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (xstate_size): New.
+	(xstate_size_n_of_int64): Likewise.
+	(amd64_linux_fetch_inferior_registers): Updated.
+	(amd64_linux_store_inferior_registers): Likewise.
+	(amd64_linux_read_description): Use I386_XSTATE_SSE_SIZE
+	instead of I386_XSTATE_MAX_SIZE.  Set xstate_size and
+	xstate_size_n_of_int64.
+
+	* i386-linux-nat.c (xstate_size): New.
+	(xstate_size_n_of_int64): Likewise.
+	(fetch_xstateregs): Updated.
+	(store_xstateregs): Likewise.
+	(i386_linux_read_description): Use I386_XSTATE_SSE_SIZE
+	instead of I386_XSTATE_MAX_SIZE.  Set xstate_size and
+	xstate_size_n_of_int64.
+
+	* common/i386-xstate.h (I386_XSTATE_SIZE): New.
+
+2010-03-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/djgpp/fnchange.lst: Add x86 AVX XML files.
+
+2010-03-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (XSTATE_MAX_SIZE_N_OF_INT64): New.
+	(amd64_linux_fetch_inferior_registers): Updated.
+	(amd64_linux_store_inferior_registers): Likewise.
+	(amd64_linux_read_description): Likewise.
+	* amd64-linux-tdep.c (amd64_linux_core_read_description): Likewise.
+
+	* i386-linux-nat.c  (XSTATE_MAX_SIZE_N_OF_INT64): New.
+	(fetch_xstateregs): Updated.
+	(store_xstateregs): Likewise.
+	(i386_linux_read_description): Likewise.
+
+	* i386-linux-tdep.c (i386_linux_core_read_xcr0): Updated.
+	(i386_linux_core_read_xcr0): Likewise.
+	(i386_linux_core_read_description): Likewise.
+
+	* i386-tdep.c (i386_register_reggroup_p): Updated.
+	(i386_validate_tdesc_p): Likewise.
+	(i386_gdbarch_init): Likewise.
+
+	* i387-tdep.c (i387_supply_fxsave): Updated.
+	(i387_collect_xsave): Likewise.
+
+	* common/i386-xstate.h: Change XSTATE to I386_XSTATE in macros.
+
+2010-03-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Makefile.in (i386-xstate.o): Removed.
+
+	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Use
+	XSTATE_MAX_SIZE_N_OF_INT64 and XSTATE_MAX_SIZE.
+	(amd64_linux_store_inferior_registers): Likewise.
+	(amd64_linux_read_description): Add static xcr0 and get it
+	from I386_LINUX_XSAVE_XCR0_OFFSET.  Use XSTATE_MAX_SIZE_N_OF_INT64
+	and XSTATE_MAX_SIZE.
+	(_initialize_amd64_linux_nat): Don't call i386_xstate_init.
+
+	* configure.ac: Remove check for cpuid.h.
+	* config.in: Regenerated.
+	* configure: Likewise.
+
+	* i386-linux-nat.c (fetch_xstateregs): Use
+	XSTATE_MAX_SIZE_N_OF_INT64 and XSTATE_MAX_SIZE.
+	(store_xstateregs): Likewise.
+	(i386_linux_read_description): Add static xcr0 and get it
+	from I386_LINUX_XSAVE_XCR0_OFFSET.  Use XSTATE_MAX_SIZE_N_OF_INT64
+	and XSTATE_MAX_SIZE.
+	(_initialize_i386_linux_nat): Don't call i386_xstate_init.
+
+	* common/i386-cpuid.h: Removed.
+	* common/i386-xstate.c: Likewise.
+
+	* common/i386-xstate.h (xstate_status): Removed.
+	(i386_xstate_type): Likewise.
+	(i386_xstate): Likewise.
+	(i386_xstate_init): Likewise.
+	(XSTATE_MAX_SIZE_N_OF_INT64): New.
+
+	* config/i386/linux.mh (NATDEPFILES): Remove i386-xstate.o.
+	* config/i386/linux64.mh (NATDEPFILES): Likewise.
+
+2010-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c (amd64_linux_g_packet_size): Make it const.
+	* amd64-tdep.c (amd64_g_packet_size): Likewise.
+	* i386-linux-tdep.c (i386_linux_g_packet_size): Likewise.
+	* i386-tdep.c (i386_g_packet_size): Likewise.
+
+	* i386-linux-tdep.c (i386_linux_init_abi): Remove
+	i386_linux_g_packet_size.
+
+	* i386-tdep.c (i386_register_g_packet_guesses): Updated.
+	* i386-tdep.h (i386_register_g_packet_guesses): Likewise.
+
+2010-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c (amd64_linux_g_packet_size): Add key.
+	* i386-linux-tdep.c (i386_linux_g_packet_size): Likewise.
+	* i386-tdep.c (i386_g_packet_size): Likewise.
+
+	* amd64-tdep.c (amd64_g_packet_size): New.
+	(amd64_init_abi): Call i386_register_g_packet_guesses.
+
+	* i386-tdep.c (I386_PROPERTY_SSE): Removed.
+	(I386_PROPERTY_AVX): Likewise.
+	(i386_tdesc_sse): Likewise.
+	(i386_tdesc_avx): Likewise.
+	(i386_init_tdesc): Likewise.
+	(i386_register_g_packet_guesses): Updated.
+	(i386_gdbarch_vector_unit_init): Likewise.
+
+	* i386-tdep.h (I386_PROPERTY_SSE): New.
+	(I386_PROPERTY_AVX): Likewise.
+	(AMD64_PROPERTY_SSE): Likewise.
+	(AMD64_PROPERTY_AVX): Likewise.
+	(i386_g_packet_size): Add key.
+	(i386_register_g_packet_guesses): Updated.
+
+2010-01-31  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* regformats/reg-i386-avx-linux.dat: Add a comment for osabi.
+	* regformats/reg-x86-64-avx-linux.dat: Likewise.
+
+2010-01-31  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* regformats/reg-i386-avx-linux.dat: Add a comment for xmlarch.
+	* regformats/reg-i386-avx.dat: Likewise.
+	* regformats/reg-x86-64-avx-linux.dat: Likewise.
+	* regformats/reg-x86-64-avx.dat: Likewise.
+
+2010-01-31  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c (amd64_linux_g_packet_size): New.
+	(amd64_linux_init_abi): Pass amd64_linux_g_packet_size to
+	i386_register_g_packet_guesses.
+
+	* i386-linux-tdep.c (i386_linux_g_packet_size): New.
+	(i386_linux_init_abi): Pass i386_linux_g_packet_size to
+	i386_register_g_packet_guesses.
+
+	* i386-tdep.c (i386_register_g_packet_guesses): Updated to
+	take an array of the g/G packet sizes.
+	(i386_g_packet_size): New.
+	(i386_gdbarch_init): Pass i386_g_packet_size to
+	i386_register_g_packet_guesses.
+
+	* i386-tdep.h (i386_g_packet_size_index): New.
+	(i386_register_g_packet_guesses): Updated.
+
+2010-01-31  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.h (AMD64_G_PACKET_SIZE_AVX): Correct comments.
+	* i386-tdep.h (I386_G_PACKET_SIZE_AVX): Likewise.
+	
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (i387_supply_fxsave): Remove vector unit check.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_vector_unit_init): Remove the
+	duplicate.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_vector_unit_init): Call 
+	i386_xstate_init and initialize vector_unit properly.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_vector_unit_init): Initialize
+	vector_unit only if target_desc isn't NULL.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_sse_type): Renamed to ...
+	(i386_vector_type): This.  Updated.
+	(i386_register_type): Updated.
+
+	* i386-tdep.h (i386_sse_type): Renamed to ...
+	(i386_vector_type): This.
+
+	* amd64-tdep.c (amd64_register_type): Updated.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_register_name): Replace sse_unit with
+	vector_unit.
+	(amd64_init_abi): Likewise.
+	* i386-tdep.c (i386_register_name): Likewise.
+	(i386_sse_type): Likewise.
+	(i386_register_g_packet_guesses): Likewise.
+	(i386_gdbarch_sse_unit_init): Renamed to ...
+	(i386_gdbarch_vector_unit_init): This.
+	(i386_gdbarch_init): Updated.
+
+	* i386-tdep.h (x86_sse_unit): Renamed to ...
+	(x86_vector_unit): This.
+	(i386_gdbarch_sse_unit_init): Renamed to ...
+	(i386_gdbarch_vector_unit_init): This.
+
+	* i387-tdep.c (i387_supply_fxsave): Replace sse_unit with
+	vector_unit.
+
+2009-10-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c (amd64_linux_init_abi): Call
+	register_remote_g_packet_guess.
+
+	* amd64-tdep.c (amd64_register_names): Renamed to ...
+	(amd64_sse_register_names): This.  Remove AVX registers.
+	(amd64_avx_register_names): New.
+	(AMD64_NUM_REGS): Updated.
+	(amd64_register_name): Handle sse_unit.
+	(amd64_register_type): Remove AVX registers.
+	(amd64_init_abi): Call i386_gdbarch_sse_unit_init to
+	initialize sse_unit.
+
+	* amd64-tdep.h (AMD64_G_PACKET_SIZE_SSE): New.
+	(AMD64_G_PACKET_SIZE_AVX): Likewise.
+
+	* defs.h (MAX_REGISTER_SIZE): Increase to 32.
+
+	* i386-linux-tdep.c (i386_linux_init_abi): Call
+	i386_register_g_packet_guesses.
+
+	* i386-tdep.c: Include "remote.h" and "target-descriptions.h".
+	(I386_PROPERTY_SSE): New.
+	(I386_PROPERTY_AVX): Likewise.
+	(i386_tdesc_sse): Likewise.
+	(i386_tdesc_avx): Likewise.
+	(i386_avx_register_names): Likewise.
+	(i386_vec128_type): Likewise.
+	(i386_vec256_type): Likewise.
+	(i386_init_tdesc): Likewise.
+	(i386_register_g_packet_guesses): Likewise.
+	(i386_gdbarch_sse_unit_init): Likewise.
+	(i386_register_names): Renamed to ...
+	(i386_sse_register_names): This.
+	(i386_num_register_names): Updated.
+	(i386_register_name): Handle sse_unit.
+	(i386_sse_type): Likewise.
+	(i386_gdbarch_init): Call i386_gdbarch_sse_unit_init to
+	initialize sse_unit.  Call i386_register_g_packet_guesses.
+	(_initialize_i386_tdep): Call i386_tdesc_init.
+
+	* i386-tdep.h (x86_sse_unit): New.
+	(I386_G_PACKET_SIZE_SSE): Likewise.
+	(I386_G_PACKET_SIZE_AVX): Likewise.
+	(i386_register_g_packet_guesses): Likewise.
+	(i386_gdbarch_sse_unit_init): Likewise.
+	(gdbarch_tdep): Add sse_unit.
+	(I386_MAX_REGISTER_SIZE): Increase to 32.
+
+	* i387-tdep.c (i387_supply_fxsave): Assert sse_unit on SSE
+	registers.
+
+	* regformats/reg-i386-avx-linux.dat: New.
+	* regformats/reg-i386-avx.dat: Likewise.
+	* regformats/reg-x86-64-avx-linux.dat: Likewise.
+	* regformats/reg-x86-64-avx.dat: Likewise.
+
+	* regformats/reg-x86-64.dat: Add xmlarch.
--- ./gdb/ChangeLog.pseudo	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/ChangeLog.pseudo	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,189 @@
+2010-02-25  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_mmx_regnum_p): Optimized.
+	(i386_byte_regnum_p): Likewise.
+	(i386_word_regnum_p): Likewise.
+	(i386_dword_regnum_p): Likewise.
+
+2010-02-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_register_reggroup_p): Minimize function
+	calls.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_register_reggroup_p): Don't include pseudo
+	registers, except for MXX, in any register groups.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Set mm0_regnum only once.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_pseudo_register_name): Don't check MMX
+	pseudo registers.  Call i386_pseudo_register_name.
+	(amd64_init_abi): Restore num_xmm_regs.
+
+	* i386-tdep.c (i386_mmx_names): Make it static.
+	(i386_mmx_regnum_p): Likewise.
+	(i386_pseudo_register_name): Make it global.
+
+	* i386-tdep.h (i386_mmx_regnum_p): Removed.
+	(i386_mmx_names): Likewise.
+	(i386_pseudo_register_name): New.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Call set_gdbarch_num_pseudo_regs
+	before tdesc_use_registers.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_pseudo_register_read): Check invalid
+	register number.
+	(i386_pseudo_register_write): Likewise.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_pseudo_register_read): New.
+	(amd64_pseudo_register_write): Likewise.
+	(amd64_init_abi): Call set_gdbarch_pseudo_register_read and
+	set_gdbarch_pseudo_register_write.
+
+	* i386-tdep.c (i386_pseudo_register_read): Make it global.
+	Don't handle 64bit nor DWORD.
+	(i386_pseudo_register_write): Likewise.
+
+	* i386-tdep.h (i386_pseudo_register_read): New.
+	(i386_pseudo_register_write): Likewise.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_byte_names): Make it static.
+	(amd64_word_names): Likewise.
+	(amd64_dword_names): Likewise.
+	(amd64_pseudo_register_name): New.
+	(amd64_init_abi): Set num_byte_regs, num_word_regs, num_dword_regs
+	and num_mmx_regs.  Call set_tdesc_pseudo_register_name.
+
+	* i386-tdep.c (i386_mmx_names): Make it global.
+	(i386_mmx_regnum_p): Likewise.
+	(i386_byte_regnum_p): Likewise.
+	(i386_word_regnum_p): Likewise.
+	(i386_dword_regnum_p): Likewise.
+	(i386_pseudo_register_name): Remove XBFD64.
+	(i386_pseudo_register_read): Remove BFD64.
+	(i386_pseudo_register_write): Likewise.
+	(i386_gdbarch_init): Move set_gdbarch_pseudo_register_read and
+	set_gdbarch_pseudo_register_write before gdbarch_init_osabi.
+
+	* i386-tdep.h (i386_byte_regnum_p): New.
+	(i386_word_regnum_p): Likewise.
+	(i386_dword_regnum_p): Likewise.
+	(i386_mmx_regnum_p): Likewise.
+	(i386_mmx_names): Likewise.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (AMD64_NUM_REGS): Restored.
+
+	* amd64-tdep.h (AMD64_NUM_GREGS): Removed.
+
+2010-02-10  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (AMD64_NUM_REGS): Removed.
+
+	* amd64-tdep.h (AMD64_NUM_GREGS): New.
+
+	* i386-nto-tdep.c (i386nto_regset_id): Replace I386_NUM_FREGS
+	with I387_NUM_REGS.
+	* i386-tdep.c (i386_go32_init_abi): Likewise.
+	(i386_gdbarch_init): Likewise.
+
+	* i386-tdep.h (i386_regnum): Add I386_MXCSR_REGNUM.
+	(I386_NUM_FREGS): Removed.
+	(I386_SSE_NUM_REGS): Defined with I386_MXCSR_REGNUM.
+
+	* i387-tdep.h (I387_NUM_REGS): New.
+
+2010-02-10  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_init_abi): Don't set num_xmm_regs.
+
+2010-02-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c (amd64_linux_register_reggroup_p): Call
+	i386_register_reggroup_p instead of default_register_reggroup_p.
+
+	* amd64-tdep.c (amd64_num_pseudo_regs): Removed.
+	(amd64_init_abi): Don't call set_gdbarch_num_pseudo_regs. Don't
+	set mm0_regnum.
+
+	* i386-tdep.c (i386_num_mmx_regs): Removed.
+	(i386_num_pseudo_regs): Likewise.
+	(i386_mmx_regnum_p): Updated.
+	(i386_register_reggroup_p): Don't include pseudo byte, word,
+	dword registers in general_reggroup.
+	(i386_gdbarch_init): Updated.
+
+	* i386-tdep.h (gdbarch_tdep): Add num_mmx_regs.
+
+2010-02-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_word_names): Add a missing ','.
+	(amd64_dword_names): New.
+	(amd64_num_pseudo_regs): Updated.
+
+	* amd64-tdep.h (amd64_dword_names): New.
+
+	* i386-tdep.c (i386_dword_regnum_p): New.
+	(i386_pseudo_register_name): Use i386_dword_regnum_p.
+	(i386_pseudo_register_type): Likewise.
+	(i386_pseudo_register_read): Likewise.
+	(i386_pseudo_register_write): Likewise.
+	(i386_gdbarch_init): Set num_dword_regs and eax_regnum.
+
+2010-02-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Optimized.
+
+2010-02-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_byte_names): New.
+	(amd64_word_names): Likewise.
+	(amd64_num_pseudo_regs): Likewise.
+	(amd64_init_abi): Call set_gdbarch_num_pseudo_regs with
+	amd64_num_pseudo_regs,
+
+	* amd64-tdep.h (amd64_byte_names): New.
+	(amd64_word_names): Likewise.
+
+	* i386-tdep.c (i386_num_byte_regs): Removed.
+	(i386_num_word_regs): Likewise.
+	(i386_byte_regnum_p): Updated.
+	(i386_word_regnum_p): Likewise.
+	(i386_pseudo_register_name): Support 64bit.
+	(i386_pseudo_register_read): Likewise.
+	(i386_pseudo_register_write): Likewise.
+
+2010-02-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_byte_names): New.
+	(i386_word_names): Likewise.
+	(i386_num_byte_regs): Likewise.
+	(i386_num_word_regs): Likewise.
+	(i386_num_pseudo_regs): Likewise.
+	(i386_byte_regnum_p): Likewise.
+	(i386_word_regnum_p): Likewise.
+	(i386_pseudo_register_name): Handle byte and word pseudo-registers.
+	(i386_pseudo_register_type): Likewise.
+	(i386_pseudo_register_read): Likewise.
+	(i386_pseudo_register_write): Likewise.
+	(i386_gdbarch_init): Call set_gdbarch_num_pseudo_regs with
+	i386_num_pseudo_regs.  Set num_byte_regs, num_word_regs,
+	al_regnum, ax_regnum.  Put MMX pseudo-registers after word
+	pseudo-registers.
+
+	* i386-tdep.h (gdbarch_tdep): Add num_byte_regs, al_regnum,
+	num_word_regs, ax_regnum, num_dword_regs and eax_regnum.
--- ./gdb/ChangeLog.xcr	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/ChangeLog.xcr	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,1304 @@
+2010-04-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_read_description): Call
+	i386_linux_update_xstateregset.
+
+2010-04-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_process_record): Replace i386_sse_regnum_p
+	with i386_xmm_regnum_p.
+
+2010-03-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_read_description): Call
+	amd64_linux_update_xstateregset instead of
+	i386_linux_update_xstateregset.
+
+	* amd64-linux-tdep.c (amd64_linux_regset_sections): Make it
+	static.
+	(amd64_linux_update_xstateregset): New.
+
+	* amd64-linux-tdep.h (amd64_linux_regset_sections): Removed.
+	(amd64_linux_update_xstateregset): New.
+
+	* i386-linux-nat.c (i386_linux_read_description): Remove
+	i386_linux_regset_sections from i386_linux_update_xstateregset.
+
+	* i386-linux-tdep.c (i386_linux_regset_sections): Make it
+	static.
+	(i386_linux_update_xstateregset): Remove regset_sections.  Use
+	i386_linux_regset_sections.
+
+	* i386-linux-tdep.h (i386_linux_regset_sections): Removed.
+	(i386_linux_update_xstateregset): Remove regset_sections.
+	i386_linux_regset_sections.
+
+2010-03-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-nat.c (fetch_xstateregs): Don't cast &iov to int.
+	(store_xstateregs): Likewise.
+	(i386_linux_read_description): Don't cast &iov to long.
+
+2010-03-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.h (I386_LINUX_XSAVE_XCR0_OFFSET): Update
+	comments.
+
+2010-03-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (xstate_size): Removed.
+	(amd64_linux_fetch_inferior_registers): Replace xstate_size
+	with I386_XSTATE_MAX_SIZE.
+	(amd64_linux_store_inferior_registers): Likewise.
+	(amd64_linux_read_description): Updated.
+
+	* i386-linux-nat.c (xstate_size): Removed.
+	(fetch_xstateregs): Replace xstate_size with
+	I386_XSTATE_MAX_SIZE.
+	(fetch_xstateregs): Likewise.
+	(i386_linux_read_description): Updated.
+
+	* common/i386-xstate.h (I386_XSTATE_MAX_SIZE): New.
+
+2010-03-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_read_description): Replace
+	unsigned long long with uint64_t.
+	* amd64-linux-tdep.c (amd64_linux_core_read_description):
+	Likewise.
+	* i386-linux-nat.c (i386_linux_read_description): Likewise.
+	* i386-linux-tdep.h (i386_linux_core_read_xcr0): Likewise.
+
+	* i386-linux-tdep.c (i386_linux_core_read_xcr0): Replace
+	unsigned long long with uint64_t.  Don't assert section size.
+	(i386_linux_core_read_description): Replace unsigned long long
+	with uint64_t.
+
+	* i386-tdep.c (i386_ymm_type): Fix typos in comments.
+	(i386_pseudo_register_read): Change 16byte to 128bits in
+	comments.
+	(i386_validate_tdesc_p): Update comments.
+	(i386_gdbarch_init): Likewise.
+
+	* i386-tdep.h (gdbarch_tdep): Replace unsigned long long with
+	uint64_t.  Replace gdb with GDB in comments.
+
+2010-03-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Replace "x86=xml" with
+	"xmlRegisters+".
+
+2010-03-12  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (xstate_size_n_of_int64): Removed.
+	(amd64_linux_fetch_inferior_registers): Updated.
+	(amd64_linux_store_inferior_registers): Likewise.
+	(amd64_linux_read_description): Likewise.
+
+	* i386-linux-nat.c (xstate_size_n_of_int64): Removed.
+	(fetch_xstateregs): Updated.
+	(store_xstateregs): Likewise.
+	(i386_linux_read_description): Likewise.
+
+2010-03-12  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c: Include "i386-xstate.h".
+	(PTRACE_GETREGSET): New.
+	(PTRACE_SETREGSET): Likewise.
+	* i386-linux-nat.c: Likewise.
+
+	* amd64-linux-tdep.c: Include "i386-xstate.h".
+
+	* config/i386/linux64.mh (NAT_FILE): Set to config/nm-linux.h.
+
+	* config/i386/nm-linux.h: Don't include
+	"config/i386/nm-linux-xstate.h".
+
+	* config/i386/nm-linux-xstate.h: Removed.
+	* config/i386/nm-linux64.h: Likewise.
+
+2010-03-12  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (i387_supply_xsave): Replace I386_XSTATE_MAX_MASK
+	with I386_XSTATE_AVX_MASK.
+
+	* common/i386-xstate.h (I386_XSTATE_MAX_MASK): Removed.
+	(I386_XSTATE_MAX_SIZE): Likewise.
+
+2010-03-12  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_register_reggroup_p): Replace
+	bit_I386_XSTATE_XXX with I386_XSTATE_XXX.
+	* i387-tdep.c (i387_supply_xsave): Likewise.
+	(i387_collect_xsave): Likewise.
+
+	* common/i386-xstate.h (bit_I386_XSTATE_XXX): Renamed to ...
+	(I386_XSTATE_XXX): This.
+	(I386_XSTATE_XXX_MASK): Replace bit_I386_XSTATE_XXX with
+	I386_XSTATE_XXX.
+	(I386_XSTATE_SIZE): Likewise.
+
+2010-03-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_dwarf_reg_to_regnum): Return %ymmN
+	register number for %xmmN if AVX is available.
+
+	* i386-tdep.c (i386_xmm_regnum_p): Make it global.
+	(i386_dbx_reg_to_regnum): Return %ymmN register number for
+	%xmmN if AVX is available.
+
+	* i386-tdep.h (i386_xmm_regnum_p): New.
+
+2010-03-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_init_abi): Replace AMD64_AVX_NUM_REGS
+	with AMD64_NUM_REGS.
+
+	* amd64-tdep.h (AMD64_AVX_NUM_REGS): Renamed to ...
+	(AMD64_NUM_REGS): This.
+
+	* i386-linux-nat.c (GETFPXREGS_SUPPLIES): Replace
+	I386_AVX_NUM_REGS with I386_SSE_NUM_REGS.
+	(GETXSTATEREGS_SUPPLIES): New.
+	(i386_linux_fetch_inferior_registers): Use GETXSTATEREGS_SUPPLIES.
+	(i386_linux_store_inferior_registers): Likewise.
+
+2010-03-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.c (i386_linux_gregset_reg_offset): Count 8
+	upper YMM registers.
+
+2010-03-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_register_reggroup_p): For all_group, don't
+	include upper YMM registers nor XMM registers when AVX is
+	supported.
+
+2010-03-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (i387_collect_xsave): Replace regcache_raw_read
+	with regcache_raw_collect.
+
+2010-03-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_register_reggroup_p): Don't return 0
+	for uppper YMM nor XMM registers.
+
+	* i387-tdep.c (xsave_sse_offset): Removed.
+	(XSAVE_SSE_ADDR): Likewise.
+	(i387_supply_xsave): Replace XSAVE_SSE_ADDR with FXSAVE_ADDR.
+	(i387_collect_xsave): Likewise.  Replace the second
+	regcache_raw_collect with memcpy.
+
+2010-03-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (xsave_offset): Removed.
+	(XSAVE_ADDR): Likewise.
+	(xsave_sse_offset): New.
+	(XSAVE_SSE_ADDR): Likewise.
+	(xsave_avxh_offset): Likewise.
+	(XSAVE_AVXH_ADDR): Likewise.
+	(i387_supply_xsave): Updated.
+	(i387_collect_xsave): Likewise.
+
+2010-03-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (i387_supply_xsave): Fix typos.
+	(i387_collect_xsave): Properly handle gcore.
+
+2010-03-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_gregset64_reg_offset): Count
+	16 upper YMM registers.
+	(amd64_linux_gregset32_reg_offset): Count 8 upper YMM registers.
+
+	* amd64-linux-tdep.h (AMD64_LINUX_ORIG_RAX_REGNUM): Replace
+	AMD64_MXCSR_REGNUM with AMD64_YMM15H_REGNUM.
+
+	* amd64-tdep.c (amd64_sse_register_names): Renamed to ...
+	(amd64_register_names): This.
+	(amd64_avx_register_names): Removed.
+	(amd64_xmm_names): Likewise.
+	(AMD64_NUM_REGS): Likewise.
+	(amd64_ymm_names): New.
+	(amd64_ymmh_names): Likewise.
+	(amd64_register_name): Likewise.
+	(amd64_pseudo_register_name): Remove i386_xmm_regnum_p.  Add
+	i386_ymm_regnum_p.
+	(amd64_init_abi): Set ymmh_register_names, num_ymm_regs
+	and ymm0h_regnum.  Call set_gdbarch_register_name.  Replace
+	num_vector_regs with num_xmm_regs.  Replace AMD64_NUM_REGS
+	with AMD64_AVX_NUM_REGS.
+
+	* amd64-tdep.h (amd64_regnum): Add AMD64_YMM0H_REGNUM and
+	AMD64_YMM15H_REGNUM.
+	(AMD64_AVX_NUM_REGS): New.
+	(amd64_register_name): Removed.
+	(amd64_register_type): Likewise.
+
+	* i386-darwin-tdep.c (i386_darwin_init_abi): Replace
+	num_vector_regs with num_xmm_regs.
+
+	* i386-linux-nat.c (regmap): Count 8 upper YMM registers.
+	(GETFPXREGS_SUPPLIES): Replace I386_SSE_NUM_REGS with
+	I386_AVX_NUM_REGS.
+	* i386-linux-tdep.h (I386_LINUX_ORIG_EAX_REGNUM): Likewise.
+
+	* i386-nto-tdep.c (i386nto_register_area): Replace
+	I387_VECTOR0_REGNUM with I387_XMM0_REGNUM.
+
+	* i386-tdep.c (i386_sse_register_names): Renamed to ...
+	(i386_register_names): This.
+	(i386_avx_register_names): Removed.
+	(i386_xmm_names): Likewise.
+	(i386_vector_regnum_p): Likewise.
+	(i386_xmm_type): Likewise.
+	(): Likewise.
+	(): Likewise.
+	(i386_ymm_names): New.
+	(i386_ymmh_names): Likewise.
+	(i386_ymmh_regnum_p): Likewise.
+	(i386_ymm_regnum_p): Likewise.
+	(i386_register_name): Likewise.
+	(i386_ymm_type): Likewise.
+	(): Likewise.
+	(i386_mxcsr_regnum_p): Replace I387_VECTOR0_REGNUM with
+	I387_XMM0_REGNUM.
+	(i386_dbx_reg_to_regnum): Likewise.
+	(i386_pseudo_register_name): Remove i386_xmm_regnum_p.  Add
+	i386_ymm_regnum_p.
+	(i386_pseudo_register_type): Likewise.
+	(i386_pseudo_register_read): Likewise.
+	(i386_pseudo_register_write): Likewise.
+	(i386_go32_init_abi): Replace num_vector_regs with num_xmm_regs.
+	(i386_register_reggroup_p): Replace i386_vector_regnum_p. Add
+	i386_ymm_regnum_p.
+	(i386_validate_tdesc_p): Get SSE registers.  Try AVX registers.
+	(i386_gdbarch_init): Replace num_vector_regs with num_xmm_regs.
+	Call set_gdbarch_register_name.  Replace I386_SSE_NUM_REGS
+	with I386_AVX_NUM_REGS.  Set ymmh_register_names, ymm0h_regnum,
+	num_ymm_regs and ymm0_regnum.  Call set_gdbarch_qsupported
+	with "x86=xml".
+
+	* i386-tdep.h (gdbarch_tdep): Add num_ymm_regs, ymm0_regnum,
+	ymm0h_regnum, ymmh_register_names and i386_ymm_type.  Remove
+	xmm0_regnum, num_vector_regs and i386_xmm_type.
+	(i386_regnum): Add I386_YMM0H_REGNUM and I386_YMM7H_REGNUM.
+	(I386_AVX_NUM_REGS): New.
+	(i386_ymm_regnum_p): Likewise.
+	(i386_ymmh_regnum_p): Likewise.
+	(I386_MAX_REGISTER_SIZE): Changed to 16.
+	(i386_xmm_regnum_p): Removed.
+
+	* i387-tdep.c (i387_supply_fsave): Replace I387_VECTOR0_REGNUM
+	with I387_XMM0_REGNUM.
+	(i387_collect_fsave): Likewise.
+	(i387_supply_fxsave): Replace I387_VECTOR0_REGNUM/num_vector_regs
+	with I387_XMM0_REGNUM/num_vector_regs.
+	(i387_collect_fxsave): Likewise.
+	(xsave_sse_offset): Removed.
+	(XSAVE_SSE_ADDR): Likewise.
+	(xsave_avxh_offset): Likewise.
+	(XSAVE_AVXH_ADDR): Likewise.
+	(xsave_offset): New.
+	(XSAVE_ADDR): Likewise.
+	(i387_supply_xsave): Rewrite.
+	(i387_collect_xsave): Likewise.
+
+	* i387-tdep.h (I387_NUM_VECTOR_REGS): Renamed to ...
+	(I387_NUM_XMM_REGS): This.
+	(I387_NUM_YMM_REGS): New.
+	(I387_YMM0H_REGNUM): Likewise.
+	(I387_VECTOR0_REGNUM): Renamed to ...
+	(I387_XMM0_REGNUM): This.
+	(I387_MXCSR_REGNUM): Updated.
+	(I387_YMMENDH_REGNUM): New.
+
+2010-03-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* features/i386/32bit-avx.xml: Only define upper YMM registers.
+	* features/i386/64bit-avx.xml: Likewise.
+
+	* features/i386/amd64-avx-linux.xml: Include 64bit-sse.xml.
+	* features/i386/amd64-avx.xml: Likewise.
+
+	* features/i386/i386-avx-linux.xml: Include 32bit-sse.xml.
+	* features/i386/i386-avx.xml: Likewise.
+
+	* features/i386/amd64-avx-linux.c: Regenerated.
+	* features/i386/amd64-avx.c: Likewise.
+	* features/i386/i386-avx-linux.c: Likewise.
+	* features/i386/i386-avx.c: Likewise.
+	* regformats/i386/amd64-avx-linux.dat: Likewise.
+	* regformats/i386/amd64-avx.dat: Likewise.
+	* regformats/i386/i386-avx-linux.dat: Likewise.
+	* regformats/i386/i386-avx.dat: Likewise.
+
+2010-03-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.h (XSAVE_XCR0_OFFSET): Renamed to ...
+	(I386_LINUX_XSAVE_XCR0_OFFSET): This.
+	* amd64-linux-tdep.c (amd64_linux_init_abi): Updated.
+	* i386-linux-tdep.c (i386_linux_core_read_xcr0): Likewise.
+	(i386_linux_init_abi): Likewise.
+
+2010-03-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c (amd64_linux_init_abi): Set xsave_xcr0_offset.
+	* i386-linux-tdep.c (i386_linux_init_abi): Likewise.
+
+	* i386-tdep.c (i386_gdbarch_init): Set xsave_xcr0_offset to -1.
+
+	* i387-tdep.c (i387_collect_xsave): Updated.
+
+	* i387-tdep.h (XSAVE_XCR0_OFFSET): Moved to ...
+	* i386-linux-tdep.h (XSAVE_XCR0_OFFSET): Here.
+
+2010-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* features/i386/32bit-avx.xml: Define i386_mxcsr.
+	* features/i386/64bit-avx.xml: Likewise.
+
+	* features/i386/amd64-avx-linux.c: Regenerated.
+	* features/i386/amd64-avx.c: Likewise.
+	* features/i386/i386-avx-linux.c: Likewise.
+	* features/i386/i386-avx.c: Likewise.
+
+2010-02-25  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_xmm_regnum_p): Optimized.
+	(i386_vector_regnum_p): Likewise.
+
+2010-02-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_store_inferior_registers): Pass
+	0 to amd64_collect_xsave.
+
+	* amd64-tdep.c (amd64_collect_xstateregset): Pass 1 to
+	amd64_collect_xsave.
+	(amd64_collect_xsave): Add an integer argument and pass it to
+	i387_collect_xsave.
+
+	* amd64-tdep.h (amd64_collect_xsave): Add an integer argument.
+	* i387-tdep.h (i387_collect_xsave): Likewise.
+
+	* i386-linux-nat.c (store_xstateregs): Pass 1 to
+	i387_collect_xsave.
+	* i386-tdep.c (i386_collect_xstateregset): Likewise.
+
+	* i387-tdep.c (i387_collect_xsave): Add an integer argument
+	to indicate gcore.  Update the first 8 bytes of the
+	sw_usable_bytes[464..467] and `xstate_bv' with XCR0 for gcore.
+
+2010-02-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (i387_collect_xsave): Fix more typos.
+
+2010-02-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (i387_collect_xsave): Fix a typo.
+
+2010-02-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_read_description): Fix a typo.
+
+	* i386-tdep.c (i386_register_reggroup_p): Return 0 for pseudo
+	XMM registers if group isn't SSE.
+
+2010-02-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c: Include "regset.h".
+	(amd64_linux_read_description): Set .reg-xstate section size if
+	it is supported.
+	(_initialize_amd64_linux_nat): Call i386_xstate_init.
+
+	* amd64-linux-tdep.c: Include "regset.h" before
+	"amd64-linux-tdep.h".
+	(amd64_linux_regset_sections): Make it global.
+	(_initialize_amd64_linux_tdep): Don't call i386_xstate_init.
+
+	* amd64-linux-tdep.h (amd64_linux_regset_sections): New.
+
+	* config/i386/nm-linux-xstate.h (FILL_XSTATEREGSET): Removed.
+
+	* i386-linux-nat.c: Include "regset.h".
+	(i386_linux_read_description): Set .reg-xstate section size if
+	it is supported.
+	(_initialize_i386_linux_nat): Call i386_xstate_init.
+
+	* i386-linux-tdep.c: Include "regset.h" before "inferior.h".
+	(i386_linux_regset_sections): Make it global.
+	(_initialize_i386_linux_tdep): Don't call i386_xstate_init.
+
+	* i386-linux-tdep.h (i386_linux_regset_sections): New.
+
+2010-02-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_validate_tdesc_p): Use num_vector_regs instead
+	of num_xmm_regs to check vector registers.
+
+2010-02-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* features/i386/Makefile: New.
+
+2010-02-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (i387_supply_xsave): Remove one regcache_raw_supply
+	for x87.
+
+2010-02-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (have_ptrace_getregset): Make it static
+	and initialized to -1.
+	(amd64_linux_fetch_inferior_registers): Error if PTRACE_GETREGSET
+	fails.
+	(amd64_linux_store_inferior_registers): Likewise.
+	(amd64_linux_read_description): Set have_ptrace_getregset.
+	Check the native XCR0 only if PTRACE_GETREGSET is available.
+	(_initialize_amd64_linux_nat): Don't set have_ptrace_getregset.
+
+	* i386-linux-nat.c (have_ptrace_getregset): Make it static
+	and initialized to -1.
+	(fetch_xstateregs): Error if PTRACE_GETREGSET fails.
+	(store_xstateregs): Likewise.
+	(i386_linux_read_description): Set have_ptrace_getregset.
+	Check the native XCR0 only if PTRACE_GETREGSET is available.
+	(_initialize_i386_linux_nat): Don't set have_ptrace_getregset.
+
+2010-02-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* common/i386-xstate.h (XSTATE_SSE_MASK): Add bit_XSTATE_X87.
+	(XSTATE_MAX_MASK): Defined with XSTATE_AVX_MASK only.
+	(XSTATE_SSE_MASK_STRING): Updated.
+	(XSTATE_AVX_MASK_STRING): Likewise.
+
+	* i387-tdep.c (i387_supply_xsave): Also check x87 registers.
+	(i387_collect_xsave): Likewise.
+
+2010-02-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Use num_vector_regs instead
+	of num_xmm_regs to check vector registers.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_init_abi): Set num_xmm_regs based on
+	vector feature.
+	* i386-tdep.c (i386_gdbarch_init): Likewise.
+
+	* i386-darwin-tdep.c (i386_darwin_init_abi): Replace num_xmm_regs
+	with num_vector_regs.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_init_abi): Set num_vector_regs to 16.
+
+	* i386-tdep.c (i386_gdbarch_init): Add num_xmm_regs to
+	set_gdbarch_num_pseudo_regs.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_read_description): Check the
+	native XCR0.
+
+	* amd64-linux-tdep.c: Include "features/i386/amd64-avx-linux.c".
+	(amd64_linux_core_read_description): Check XCR0 from core dump.
+	(_initialize_amd64_linux_tdep): Call
+	initialize_tdesc_amd64_avx_linux.
+
+	* amd64-tdep.c: Include "features/i386/amd64-avx.c".
+	(AMD64_NUM_REGS): Use amd64_sse_register_names.
+	(amd64_xmm_names): Make it static.
+	(amd64_pseudo_register_name): Handle XMM pseud registers.
+	(amd64_init_abi): Set register_names based on target description.
+	(_initialize_amd64_tdep): Call initialize_tdesc_amd64_avx.
+
+	* i386-linux-nat.c (i386_linux_read_description): Check the
+	native XCR0.
+
+	* i386-linux-tdep.c (i386_linux_core_read_xcr0): New.
+	(i386_linux_core_read_description): Use it.  Remove BFD64.
+	(i386_linux_read_description): Removed.
+	(_initialize_i386_linux_tdep): Call
+	initialize_tdesc_i386_avx_linux.
+
+	* i386-tdep.c (i386_xmm_regnum_p): Make it global.
+	(i386_pseudo_register_name): Remove BFD64.
+	(i386_pseudo_register_read): Likewise.
+	(i386_pseudo_register_write): Likewise.
+	(i386_gdbarch_init): Set register_names based on target
+	description.
+
+2010-02-13  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.c (i386_linux_core_read_description): Properly
+	check extended state size.
+	(i386_linux_read_description): Properly check the native XCR0.
+
+2010-02-13  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* common/i386-xstate.h (XSTATE_SSE_MASK): Defined with
+	bit_XSTATE_SSE.
+	(XSTATE_AVX_MASK): Defined with XSTATE_SSE_MASK and bit_XSTATE_AVX.
+	(XSTATE_MAX_MASK): Defined with XSTATE_AVX_MASK and bit_XSTATE_X87.
+	(XSTATE_SSE_MASK_STRING): Updated.
+	(XSTATE_AVX_MASK_STRING): Likewise.
+
+	* 386-linux-tdep.c (i386_linux_core_read_description): Use
+	XSTATE_XXX_MASK.
+	(i386_linux_core_read_description): Likewise.
+
+	* i386-tdep.c (i386_register_reggroup_p): Check xcr0 instead
+	of vector_unit.
+	(i386_gdbarch_init): Set xcr0 instead of vector_unit.
+
+	* i386-tdep.h (x86_vector_unit): Removed.
+	(gdbarch_tdep): Remove vector_unit.  Add xcr0.
+
+	* i387-tdep.c (i387_supply_fxsave): Check xcr0 instead of
+	vector_unit.
+	(i387_supply_xsave): Likewise.
+	(i387_collect_xsave): Likewise.
+
+2010-02-11  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Don't set xcr0 on x86 host.
+	(_initialize_i386_tdep): Don't call i386_xstate_init on x86 host.
+
+	* i386-tdep.h (gdbarch_tdep): Remove xcr0.
+
+	* i387-tdep.c (i387_supply_xsave): Replace tdep->xcr0 with
+	i386_xstate.xcr0.
+	(i387_collect_xsave): Likewise.
+
+2010-02-11  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.c (i386_linux_core_read_description): Don't
+	set xcr0 here.
+
+2010-02-11  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c (_initialize_amd64_linux_tdep): Re-indent.
+
+	* i386-linux-tdep.c (i386_linux_read_description): Don't set
+	xcr0 here.
+	(_initialize_i386_linux_tdep): Re-indent.
+
+	* i386-tdep.c (i386_gdbarch_init): Set xcr0 on x86 host.
+	(_initialize_i386_tdep): Call i386_xstate_init on x86 host.
+
+	* i386-tdep.h (gdbarch_tdep): Mention xcr0 is used only for
+	native debug.
+
+2010-02-11  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Cast
+	NT_X86_XSTATE to unsigned int.
+	(amd64_linux_store_inferior_registers): Likewise.
+	* i386-linux-nat.c (fetch_xstateregs): Likewise.
+	(store_xstateregs): Likewise.
+
+2010-02-10  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c: Include "elf/common.h" and <sys/uio.h>.
+	(amd64_linux_fetch_inferior_registers): Use iovec.
+	(amd64_linux_store_inferior_registers): Likewise.
+
+	* amd64-linux-tdep.c (_initialize_amd64_linux_tdep): Don't
+	check i386_xstate.size.
+	* i386-linux-tdep.c (_initialize_i386_linux_tdep): Likewise.
+
+	* config/i386/nm-linux-xstate.h: Don't include "elf/common.h".
+	(PTRACE_REGSET_NT_SHIFT): Removed.
+	(PTRACE_REGSET_MAX_SIZE): Likewise.
+	(PTRACE_REGSET_XSTATE_ADDR): Likewise.
+
+	* i386-linux-nat.c: Include "elf/common.h" and <sys/uio.h>.
+	(fetch_xstateregs): Use iovec.
+	(store_xstateregs): Likewise.
+
+2010-02-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_pseudo_register_read): Properly convert
+	XMM pseudo register to vector register.
+	(i386_pseudo_register_write): Likewise.
+
+2010-02-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* features/i386/32bit-avx.xml: Fix typos.
+	* features/i386/64bit-avx.xml: Likewise.
+
+	* features/i386/amd64-avx-linux.c: Regenerated.
+	* features/i386/amd64-avx.c: Likewise.
+	* features/i386/i386-avx-linux.c: Likewise.
+	* features/i386/i386-avx.c: Likewise.
+
+2010-02-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Count XMM pseudo registers.
+
+2010-02-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.h (I387_XMM0_REGNUM): Renamed to ...
+	(I387_VECTOR0_REGNUM): This.
+	(I387_MXCSR_REGNUM): Updated.
+
+	* i386-nto-tdep.c (i386nto_register_area): Replace
+	I387_XMM0_REGNUM with I387_VECTOR0_REGNUM.
+
+	* i386-tdep.c (i386_sse_regnum_p): Renamed to ...
+	(i386_vector_regnum_p): This.  Replace I387_XMM0_REGNUM
+	with I387_VECTOR0_REGNUM.
+	(i386_fpc_regnum_p): Replace I387_XMM0_REGNUM with
+	I387_VECTOR0_REGNUM.
+	(i386_register_reggroup_p): Updated.  Handle XMM pseudo
+	registers.
+
+	* i387-tdep.c (i386_fpc_regnum_p): Replace I387_XMM0_REGNUM
+	with I387_VECTOR0_REGNUM.
+	(i387_supply_fxsave): Likewise.
+	(i387_collect_fxsave): Likewise.
+	(XSAVE_SSE_ADDR): Likewise.
+	(XSAVE_AVXH_ADDR): Likewise.
+	(i387_supply_xsave): Likewise.
+	(i387_collect_xsave): Likewise.
+
+2010-02-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_pseudo_register_name): Handle XMM pseudo
+	registers.
+	(i386_pseudo_register_type): Likewise.
+	(i386_pseudo_register_read): Likewise.
+	(i386_pseudo_register_write): Likewise.
+	(i386_gdbarch_init): Likewise.
+	(i386_xmm_type): New.
+
+	* 386-tdep.h (gdbarch_tdep): Add num_xmm_regs, xmm0_regnum
+	and i386_xmm_type.
+
+2010-02-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_xmm_names): New.
+	(amd64_num_pseudo_regs): Updated.
+
+	* amd64-tdep.h (amd64_xmm_names): New.
+
+	* i386-tdep.c (i386_xmm_names): New.
+	(i386_xmm_regnum_p): Likewise.
+	(i386_num_pseudo_regs): Updated.
+
+2010-02-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.h (gdbarch_tdep): Rename num_xmm_regs to
+	num_vector_regs.
+
+	* i387-tdep.h (I387_NUM_XMM_REGS): Removed.
+	(I387_NUM_VECTOR_REGS): New.
+	(I387_MXCSR_REGNUM): Updated.
+
+	* amd64-tdep.c (amd64_init_abi): Updated.
+	* i386-tdep.c (i386_sse_regnum_p): Likewise.
+	(i386_mxcsr_regnum_p): Likewise.
+	(i386_go32_init_abi): Likewise.
+	(i386_gdbarch_init): Likewise.
+	* i387-tdep.c (i387_supply_fxsave): Likewise.
+	(i387_collect_fxsave): Likewise.
+	(i387_supply_xsave): Likewise.
+	(i387_collect_xsave): Likewise.
+
+2010-02-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c: Replace PTRACE_GETXSTATEREGS with
+	PTRACE_GETREGSET in comments.
+	(have_ptrace_getxstateregs): Renamed to ...
+	(have_ptrace_getregset): This.
+	(amd64_linux_fetch_inferior_registers): Updated to use
+	PTRACE_GETREGSET.
+	(amd64_linux_store_inferior_registers): Updated to use
+	PTRACE_GETREGSET and PTRACE_SETREGSET.
+
+	* amd64-linux-tdep.c (_initialize_amd64_linux_tdep): Assert
+	the XSAVE extended state size.
+
+	* i386-linux-nat.c: Replace PTRACE_GETXSTATEREGS with
+	PTRACE_GETREGSET in comments.
+	(have_ptrace_getxstateregs): Renamed to ...
+	(have_ptrace_getregset): This.
+	(fetch_xstateregs): Updated to use PTRACE_GETREGSET.
+	(store_xstateregs): Updated to use PTRACE_GETREGSET and
+	PTRACE_SETREGSET.
+
+	* i386-linux-tdep.c (_initialize_i386_linux_tdep): Assert
+	the XSAVE extended state size.
+
+	* config/i386/nm-linux-xstate.h: Include "elf/common.h".
+	(PTRACE_GETXSTATEREGS): Removed.
+	(PTRACE_SETXSTATEREGS): Likewise.
+	(PTRACE_GETREGSET): New.
+	(PTRACE_SETREGSET): Likewise.
+	(PTRACE_REGSET_NT_SHIFT): Likewise.
+	(PTRACE_REGSET_MAX_SIZE): Likewise.
+	(PTRACE_REGSET_XSTATE_ADDR): Likewise.
+
+2010-02-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.c: Replace x86-64/x86_64 with amd64.
+	* i386-tdep.c: Likewise.
+
+	* features/Makefile: Replace x86-64 with amd64.
+	* features/i386/*: Rename x86-64* to amd64*.
+
+	* regformats/i386/*: Rename x86-64* to amd64*.
+
+2010-02-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* common/i386-xstate.c: Don't include "config.h" if XSTATE_MAIN
+	is defined.
+	(main): Fix typo.
+
+2010-02-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* common/i386-xstate.c (main): New.  Defined only if XSTATE_MAIN
+	is defined.
+
+2010-02-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Set vector_unit.
+
+2010-02-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/nm-linux-xstate.h: Don't include <sys/ptrace.h>.
+
+	* i386-linux-tdep.c (i386_linux_read_description): Don't use
+	ptrace.
+
+2010-02-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Pass
+	i386_xstate.size to XSTATE ptrace.
+	(amd64_linux_store_inferior_registers): Likewise.
+	* i386-linux-nat.c (fetch_xstateregs): Likewise.
+	(store_xstateregs): Likewise.
+
+2010-02-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (PTRACE_GETXSTATEREGS): Don't define.
+	(PTRACE_SETXSTATEREGS): Likewise.
+	* i386-linux-nat.c (PTRACE_GETXSTATEREGS):
+	(PTRACE_SETXSTATEREGS): Likewise.
+
+	* config/i386/nm-linux.h: Include "config/i386/nm-linux-xstate.h".
+	* config/i386/nm-linux64.h: Likewise.
+
+	* 386-linux-tdep.c (i386_linux_read_description): Define only if
+	FILL_XSTATEREGSET is defined.  Use ptrace to get xcr0 from
+	kernel.
+
+2010-02-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c (_initialize_amd64_linux_tdep): Update
+	comments.
+
+	* i386-linux-tdep.c: Include features/i386/i386-avx-linux.c
+	and features/i386/x86-64-avx-linux.c.
+	(i386_linux_core_read_description): Handle AVX.
+	(_initialize_i386_linux_tdep): Call initialize_tdesc_i386_avx_linux
+	and initialize_tdesc_x86_64_avx_linux.
+
+	* i386-tdep.c: Include features/i386/i386-avx.c and
+	features/i386/x86-64-avx.c.
+	(_initialize_i386_tdep): Call initialize_tdesc_i386_avx and
+	initialize_tdesc_x86_64_avx.
+
+2010-02-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Try org.gnu.gdb.i386.avx.
+
+2010-02-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* features/i386/32bit-avx.xml: New.
+	* features/i386/64bit-avx.xml: Likewise.
+	* features/i386/i386-avx-linux.c: Likewise.
+	* features/i386/i386-avx-linux.xml: Likewise.
+	* features/i386/i386-avx.c: Likewise.
+	* features/i386/i386-avx.xml: Likewise.
+	* features/i386/x86-64-avx-linux.c: Likewise.
+	* features/i386/x86-64-avx-linux.xml: Likewise.
+	* features/i386/x86-64-avx.c: Likewise.
+	* features/i386/x86-64-avx.xml: Likewise.
+
+	* features/Makefile (WHICH): Add i386/i386-avx,
+	i386/i386-avx-linux, i386/x86-64-avx and i386/x86-64-avx-linux.
+	(i386/i386-avx-expedite): New.
+	(i386/i386-avx-linux-expedite): Likewise.
+	(i386/x86-64-avx-expedite):Likewise.
+	(i386/x86-64-avx-linux-expedite): Likewise.
+	($(outdir)/i386/i386-avx.dat): New dependency.
+	($(outdir)/i386/i386-avx-linux.dat): Likewise.
+	($(outdir)/i386/x86-avx-64.dat): Likewise.
+	($(outdir)/i386/x86-64-avx-linux.dat): Likewise.
+
+	* regformats/reg-i386-avx-linux.dat: Moved to ..
+	* regformats/i386/i386-avx-linux.dat: Here.
+
+	* regformats/reg-i386-avx.dat: Moved to ..
+	* regformats/i386/i386-avx.dat: Here.
+
+	* regformats/reg-x86-64-avx-linux.dat: Moved to ...
+	* regformats/i386/x86-64-avx-linux.dat: Here.
+
+	* regformats/reg-x86-64-avx.dat: Moved to ...
+	* regformats/i386/x86-64-avx.dat: Here.
+
+2010-02-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_sse_register_names): Make it global.
+	(amd64_avx_register_names): Likewise.
+	(amd64_init_abi): Don't call i386_gdbarch_vector_unit_init.
+
+	* i386-tdep.c (i386_gdbarch_vector_unit_init): Removed.
+	(i386_gdbarch_init): Don't call i386_gdbarch_vector_unit_init.
+	* i386-tdep.h (i386_gdbarch_vector_unit_init): Removed.
+
+2010-02-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.c (i386_linux_core_read_description): Check
+	core size for AVX support.
+
+2010-02-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (i387_supply_fxsave): Optimize xstate_bv == 0.
+
+2010-02-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (i387_supply_fxsave): Don't use
+	regcache_raw_supply_part.
+	(i387_supply_xsave): Likewise.
+	(i387_collect_fxsave): Don't use regcache_raw_collect_part.
+	(i387_collect_xsave): Likewise.
+
+	* regcache.c (regcache_raw_supply_part): Removed.
+	(regcache_raw_collect_part): Likewise.
+	* regcache.h (regcache_raw_supply_part): Likewise.
+	(regcache_raw_collect_part): Likewise.
+
+2010-02-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.c (i386_linux_core_read_description): Update
+	warning message for xcr0.
+
+	* i387-tdep.c (i387_collect_xsave): Move comments on xstate_bv.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_vector_unit_init): Check
+	FILL_XSTATEREGSET instead of bit_XSTATE_AVX.
+
+	* config/i386/nm-linux.h (FILL_XSTATEREGSET): Update comments.
+	* config/i386/nm-linux64.h (FILL_XSTATEREGSET): Likewise.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c: Include "i386-xstate.h".
+	* i387-tdep.c: Likewise.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_vector_unit_init): Check if
+	bit_XSTATE_AVX is defined before using it.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Makefile.in (xstate-nat.o): Renamed to ...
+	(i386-xstate.o): This.
+
+	* i386-linux-tdep.c: Include "i386-xstate.h" instead of
+	"xstate-nat.h".
+	* config/i386/nm-linux.h: Likewise.
+	* config/i386/nm-linux64.h: Likewise.
+
+	* common/xstate-nat.c: Moved to ...
+	* common/i386-xstate.c: This.
+
+	* common/xstate-nat.h: Moved to ...
+	* common/i386-xstate.h: This.
+
+	* config/i386/linux.mh (NATDEPFILES): Replace xstate-nat.o with
+	i386-xstate.o.
+	* config/i386/linux64.mh (NATDEPFILES): Likewise.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_gregset64_reg_offset): Remove
+	xstate_bv offset.
+	(amd64_linux_gregset32_reg_offset): Likewise.
+
+	* amd64-linux-tdep.h (AMD64_LINUX_ORIG_RAX_REGNUM): Updated.
+
+	* amd64-tdep.c (amd64_sse_register_names): Remove xstate_bv.
+	(amd64_avx_register_names): Likewise.
+	(amd64_register_name): Remove AMD64_XSTATE_BV_REGNUM.
+	(amd64_register_type): Likewise.
+
+	* amd64-tdep.h (AMD64_XSTATE_BV_REGNUM): Removed.
+
+	* i386-linux-nat.c (regmap): Remove xstate_bv.
+
+	* i386-tdep.c (i386_sse_register_names): Remove xstate_bv.
+	(i386_avx_register_names): Likewise.
+	(i386_xstate_regnum_p): Removed.
+	(i386_register_name): Remove I387_XSTATE_BV_REGNUM.
+
+	* i386-tdep.h (I386_SSE_NUM_REGS): Remove xstate_bv.
+
+	* i387-tdep.c (XSAVE_XSTATE_BV_ADDR): Update comments.
+
+	* i387-tdep.h (I387_XSTATE_BV_REGNUM): Removed.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_init_abi): Update call to
+	i386_gdbarch_vector_unit_init.
+
+	* gdbarch.c (gdbarch_qsupported_process_ack): Return void.
+	* gdbarch.h (gdbarch_qsupported_process_ack_ftype): Likewise.
+	(gdbarch_qsupported_process_ack): Likewise.
+
+	* i386-tdep.c (remote_xcr0): New.
+	(i386_gdbarch_vector_unit_init): Use remote_xcr0 for remote
+	client.
+	(i386_qsupported_process_ack): Set remote_xcr0.
+	(i386_gdbarch_init): Update i386_gdbarch_vector_unit_init call.
+
+	* i386-tdep.h (i386_gdbarch_vector_unit_init): Updated.
+
+	* remote.c (remote_query_supported): Call
+	gdbarch_qsupported_process_ack with NULL to prepare qSupported
+	ACK processing.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* regformats/reg-i386-avx-linux.dat: Add xmlarch and osabi.
+	* regformats/reg-x86-64-avx-linux.dat: Likewise.
+
+	* regformats/reg-i386-avx.dat: Add xmlarch.
+	* regformats/reg-x86-64-avx.dat: Likewise.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.c (i386_linux_core_read_description): Use
+	XSTATE_SSE_SIZE instead of 576.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c (amd64_linux_g_packet_size): Removed.
+	(amd64_linux_init_abi): Remove i386_register_g_packet_guesses.
+
+	* amd64-tdep.c (amd64_g_packet_size): Removed.
+	(amd64_init_abi): Update i386_gdbarch_vector_unit_init call.
+	Remove i386_register_g_packet_guesses.
+
+	* amd64-tdep.h (AMD64_G_PACKET_SIZE_SSE): Removed.
+	(AMD64_G_PACKET_SIZE_AVX): Likewise.
+
+	* gdbarch.c (gdbarch_qsupported_process_ack): Add value.
+	* gdbarch.h (gdbarch_qsupported_process_ack_ftype): Likewise.
+	(gdbarch_qsupported_process_ack): Likewise.
+
+	* i386-linux-tdep.c (i386_linux_g_packet_size): Removed.
+	(i386_linux_init_abi): Remove i386_register_g_packet_guesses.
+
+	* i386-tdep.c: Don't include "remote.h" nor
+	"target-descriptions.h".
+	(i386_register_g_packet_guesses): Removed.
+	(i386_g_packet_size): Likewise.
+	(386_gdbarch_vector_unit_init): Rewrite.
+	(i386_qsupported_process_ack): New.
+	(i386_gdbarch_init): Update i386_gdbarch_vector_unit_init call.
+	Remove i386_register_g_packet_guesses. Call
+	set_gdbarch_qsupported_process_ack.
+
+	* i386-tdep.h (x86_vector_unit): Remove unknown.
+	(I386_G_PACKET_SIZE_SSE): Removed.
+	(I386_G_PACKET_SIZE_AVX): Likewise.
+	(I386_PROPERTY_SSE): Likewise.
+	(I386_PROPERTY_AVX): Likewise.
+	(AMD64_PROPERTY_SSE): Likewise.
+	(AMD64_PROPERTY_AVX): Likewise.
+	(i386_g_packet_size): Likewise.
+	(i386_register_g_packet_guesses): Likewise.
+	(i386_gdbarch_vector_unit_init): Updated.
+
+	* remote.c (remote_query_supported): Pass value to
+	gdbarch_qsupported_process_ack.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (i387_collect_xsave): Optimized.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* regformats/reg-i386-avx-linux.dat: Remove xcr0.
+	* regformats/reg-i386-avx.dat: Likewise.
+	* regformats/reg-x86-64-avx-linux.dat: Likewise.
+	* regformats/reg-x86-64-avx.dat: Likewise.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* common/xstate-nat.h (XSTATE_SSE_MASK): New.
+	(XSTATE_AVX_MASK): Likewise.
+	(XSTATE_MAX_MASK): Likewise.
+	(XSTATE_SSE_MASK_STRING): Likewise.
+	(XSTATE_AVX_MASK_STRING): Likewise.
+	(XSTATE_MAX_MASK_STRING): Likewise.
+	(XSTATE_SSE_SIZE): Likewise.
+	(XSTATE_AVX_SIZE): Likewise.
+	(XSTATE_MAX_SIZE): Likewise.
+	(XSTATE_SSE_SIZE_STRING): Likewise.
+	(XSTATE_AVX_SIZE_STRING): Likewise.
+	(XSTATE_MAX_SIZE_STRING): Likewise.
+
+	* i386-tdep.c (i386_gdbarch_init): Use XSTATE_MAX_SIZE_STRING
+	and XSTATE_MAX_MASK_STRING on set_gdbarch_qsupported.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdbarch.c (gdbarch): Add qsupported_process_ack.
+	(startup_gdbarch): Likewise.
+	(gdbarch_alloc): Likewise.
+	(verify_gdbarch): Likewise.
+	(gdbarch_dump): Likewise.
+	(gdbarch_qsupported_process_ack): New.
+	(set_gdbarch_qsupported_process_ack): Likewise.
+
+	* gdbarch.h (gdbarch_qsupported_process_ack_ftype): New.
+	(gdbarch_qsupported_process_ack): Likewise.
+	(set_gdbarch_qsupported_process_ack): Likewise.
+
+	* i386-tdep.c (i386_gdbarch_init): Update call to
+	set_gdbarch_qsupported.
+
+	* remote.c (remote_state): Replace qsupported with gdbarch.
+	(init_remote_state): Set gdbarch instead of  qsupported.
+	(remote_query_supported): Replace qsupported with
+	gdbarch_qsupported.  Call gdbarch_qsupported_process_ack on
+	unprocessed ACKs.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (i387_supply_xsave): Apply XCR0 mask to clear_bv.
+	(i387_collect_xsave): Likewise.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_gregset64_reg_offset): Remove
+	xcr0 offset.
+	(amd64_linux_gregset32_reg_offset): Likewise.
+
+	* amd64-tdep.c (amd64_sse_register_names): Remove xcr0.
+	(amd64_avx_register_names): Likewise.
+	(amd64_register_name): Remove AMD64_XCR0_REGNUM.
+	(amd64_register_type): Remove AMD64_XCR0_REGNUM.  Update
+	AMD64_XSTATE_BV_REGNUM.
+
+	* amd64-tdep.h (AMD64_XCR0_REGNUM): Removed.
+
+	* i386-linux-nat.c (regmap): Remove xcr0.
+
+	* i386-tdep.c (i386_sse_register_names): Remove xcr0.
+	(i386_avx_register_names): Likewise.
+	(i386_xstate_regnum_p): Removed.
+	(i386_register_name): Remove I387_XCR0_REGNUM.
+	(i386_xcr0_type): Removed.
+	(i386_register_type): Remove I387_XCR0_REGNUM and
+	I387_XSTATE_BV_REGNUM.
+	(i386_register_reggroup_p): Remove i386_xstate_regnum_p.
+
+	* i386-tdep.h (gdbarch_tdep): Remove i386_xcr0_type.
+	(I386_SSE_NUM_REGS): Remove xcr0.
+	(i386_xcr0_type): Removed.
+
+	* i387-tdep.c (XSAVE_XCR0_ADDR): Removed.
+	(i387_supply_xsave): Clear part in vector registers if its bit in
+	xstat_bv is zero.  Don't update I387_XCR0_REGNUM nor
+	I387_XSTATE_BV_REGNUM.
+	(i387_collect_xsave): Clear part in vector registers if its bit
+	in xstat_bv is zero.  Update xstat_bv directly.
+
+	* i387-tdep.h (I387_XCR0_REGNUM): Removed.
+
+2010-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdbarch.c (gdbarch): Add qsupported.
+	(startup_gdbarch): Likewise.
+	(gdbarch_alloc): Likewise.
+	(verify_gdbarch): Likewise.
+	(gdbarch_dump): Likewise.
+	(gdbarch_qsupported): New.
+	(set_gdbarch_qsupported): Likewise.
+
+	* gdbarch.h (gdbarch_qsupported): New.
+	(set_gdbarch_qsupported): Likewise.
+
+	* i386-tdep.c (i386_gdbarch_init): Call set_gdbarch_qsupported.
+
+	* remote.c (remote_state): Add qsupported.
+	(init_remote_state): Set qsupported from gdbarch_qsupported.
+	(remote_query_supported): Support qsupported.
+
+2010-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (i387_collect_xsave): Optimize updating single
+	vector register.
+
+2010-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (i387_collect_xsave): Get the original `xstat_bv'.
+
+2010-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_vector_unit_init): Use
+	regcache_cooked_read_unsigned.
+
+	* i387-tdep.c (i387_collect_xsave): Update the bits in
+	`xstate_bv' if any SSE/AVX registers are changed.  Don't change
+	`xcr0'.
+
+2010-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_sse_register_names): Use NULL on xstate_bv.
+	(amd64_avx_register_names): Likewise.
+	(amd64_register_name): Return NULL for AMD64_XSTATE_BV_REGNUM.
+
+	* amd64-tdep. (AMD64_G_PACKET_SIZE_AVX): Don't include xstate_bv.
+
+	* i386-tdep.c (i386_sse_register_names): Use NULL on xstate_bv.
+	(i386_avx_register_names): Likewise.
+	(i386_register_name): Return NULL for I386_XSTATE_BV_REGNUM.
+
+	* i386-tdep. (I386_G_PACKET_SIZE_AVX): Don't include xstate_bv.
+
+	* i387-tdep.c (XSAVE_XSTATE_BV_ADDR): Update comments.
+
+	* regformats/reg-i386-avx-linux.dat: Remove xstate_bv.
+	* regformats/reg-i386-avx.dat: Likewise.
+	* regformats/reg-x86-64-avx-linux.dat: Likewise.
+	* regformats/reg-x86-64-avx.dat: Likewise.
+
+2010-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_vector_unit_init): Correct the
+	XCR0 register number for 64bit.
+
+2010-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_vector_unit_init): Get xcr0 from
+	the remote target.
+
+2010-01-31  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.h (AMD64_G_PACKET_SIZE_AVX): Add sizes for xcr0
+	and xstate_bv.
+	* i386-tdep.h (I386_G_PACKET_SIZE_AVX): Likewise.
+
+	* regformats/reg-i386-avx-linux.dat: Add xcr0 and xstate_bv.
+	* regformats/reg-i386-avx.dat: Likewise.
+	* regformats/reg-x86-64-avx-linux.dat: Likewise.
+	* regformats/reg-x86-64-avx.dat: Likewise.
+
+2010-01-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.c (i386_linux_core_read_description): Read 8
+	bytes for xcr0.
+
+2010-01-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.h (XSAVE_XCR0_OFFSET): Update comments.
+
+2010-01-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_register_name): Return NULL for xcr0
+	and xstate_bv if XSAVE extended state isn't supported.
+	* i386-tdep.c (i386_register_name): Likewise.
+	(i386_xstate_regnum_p): Return 0 of XSAVE extended state isn't
+	supported.
+
+2010-01-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_xstate_regnum_p): New.
+	(i386_register_reggroup_p): Use it.
+
+2010-01-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.c: Include i387-tdep.h and xstate-nat.h.
+	(i386_linux_core_read_description): Read xcr0 from core file.
+
+	* i387-tdep.c (XSAVE_XCR0_ADDR): New.
+	(XSAVE_XSTATE_BV_ADDR): Likewise.
+
+	* i387-tdep.h (XSAVE_XCR0_OFFSET): New.
+	(XSAVE_XCR0_ADDR): Removed.
+	(XSAVE_XSTATE_BV_ADDR): Likewise.
+
+2010-01-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_gregset64_reg_offset): Add
+	entries of -1 for xcr0 and xstate_bv.
+	(amd64_linux_gregset32_reg_offset): Likewise.
+	* i386-linux-nat.c (regmap): Likewise.
+
+	* amd64-linux-tdep.h (AMD64_LINUX_ORIG_RAX_REGNUM): Replace
+	AMD64_MXCSR_REGNUM with AMD64_XSTATE_BV_REGNUM.
+
+	* amd64-tdep.c (amd64_sse_register_names): Add xcr0 and xstate_bv.
+	(amd64_avx_register_names): Likewise.
+	(amd64_register_type): Handle AMD64_XCR0_REGNUM and
+	AMD64_XSTATE_BV_REGNUM.
+
+	* amd64-tdep.h (amd64_regnum): Add AMD64_XCR0_REGNUM and
+	AMD64_XSTATE_BV_REGNUM.
+
+	* i386-tdep.c (i386_sse_register_names): Add xcr0 and xstate_bv.
+	(i386_avx_register_names): Likewise.
+	(i386_xcr0_type): New.
+	(i386_register_type): Handle AMD64_XCR0_REGNUM and
+	AMD64_XSTATE_BV_REGNUM.
+	(i386_gdbarch_vector_unit_init): Set the xcr0 field.
+
+	* i386-tdep.h (gdbarch_tdep): Add xcr0 and i386_xcr0_type.
+	(I386_SSE_NUM_REGS): Increase by 2.
+	(i386_xcr0_type): New.
+
+	* i387-tdep.c (i387_supply_xsave): Handle I387_XCR0_REGNUM
+	and I387_XSTATE_BV_REGNUM.
+	(i387_collect_xsave): Likewise.
+
+	* i387-tdep.h (I387_XCR0_REGNUM): New.
+	(I387_XSTATE_BV_REGNUM): Likewise.
+	(XSAVE_XCR0_ADDR): Likewise.
+	(XSAVE_XSTATE_BV_ADDR): Likewise.
+
+2010-01-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Fall
+	back after PTRACE_GETXSTATEREGS if have_ptrace_getxstateregs == 1.
+	(amd64_linux_store_inferior_registers): Likewise.
+	(_initialize_amd64_linux_nat): Initialize have_ptrace_getxstateregs
+	to 2 for AVX.
+
+	* i386-linux-nat.c (fetch_xstateregs): Fall back after
+	PTRACE_GETXSTATEREGS if have_ptrace_getxstateregs == 1.
+	(store_xstateregs): Likewise.
+	(_initialize_i386_linux_nat): Initialize have_ptrace_getxstateregs
+	to 2 for AVX.
+
+	* i386-tdep.c (i386_gdbarch_vector_unit_init): Updated.
+
+	* common/xstate-nat.h (xstate): Removed.
+	(xstate_status): New.
+	(bit_XSTATE_X87): Likewise.
+	(bit_XSTATE_SSE): Likewise.
+	(bit_XSTATE_AVX): Likewise.
+	(i386_xstate_type): Remove state.  Add status and xcr0.
+
+	* common/xstate-nat.c (i386_xstate_init): Updated.
--- ./gdb/ChangeLog.xml	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/ChangeLog.xml	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,464 @@
+2010-03-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* remote.c (register_remote_support_xml): Use strtok.
+
+2010-03-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* NEWS: Mention xmlRegisters= in qSupported packet.
+
+2010-03-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Move
+	register_remote_support_xml call to ...
+	(_initialize_i386_tdep): Here.
+
+2010-03-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Pass "i386" instead of "x86"
+	to register_remote_support_xml.
+
+2010-03-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* remote.c (register_remote_support_xml): Do nothing if
+	HAVE_LIBEXPAT is undefined.
+
+2010-03-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* remote.c (register_remote_support_xml): Add "xmlRegisters="
+	prefix.  Free the unused old memory.
+	(remote_query_supported_append): New.
+	(remote_query_supported): Call remote_query_supported_append.
+
+2010-03-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c: Include "remote.h".
+	(i386_gdbarch_init): Call register_remote_support_xml.
+
+	* remote.c (remote_support_xml): New.
+	(register_remote_support_xml): Likewise.
+	(remote_query_supported): Support remote_support_xml.
+
+	* remote.h (register_remote_support_xml): New.
+
+2010-02-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c (amd64_linux_core_read_description): Don't
+	check .reg section size.
+	* i386-linux-tdep.c (i386_linux_core_read_description): Likewise.
+
+2010-02-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (AMD64_LINUX_USER64_CS): New.
+	(amd64_linux_read_description): Use it.
+
+2010-02-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c (amd64_linux_init_abi): Check orig_rax
+	right after amd64_init_abi.
+
+	* i386-linux-tdep.c (i386_linux_init_abi): Check orig_eax
+	right after i386_elf_init_abi.
+
+2010-02-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_read_description): Read CS
+	register to check process address space.
+
+2010-02-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_validate_tdesc_p): New.
+	(i386_gdbarch_init): Use it.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_read_description): Return
+	tdesc_i386_linux for 32bit.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_init_abi): Set num_core_regs and
+	register_names after tdesc.
+	* i386-tdep.c (i386_gdbarch_init): Don't check bfd_arch_i386.  Set 
+	num_core_regs and register_names after tdesc.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c (amd64_linux_init_abi): Remove a strayed
+	comment.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c: Don't include "i387-tdep.h".
+	* amd64-linux-tdep.c: Likewise.
+	* i386-linux-tdep.c: Likewise.
+
+	* i386-tdep.h (i386_regnum): Add I386_MXCSR_REGNUM.
+	(I386_SSE_NUM_REGS): Defined with I386_MXCSR_REGNUM.
+
+2010-02-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.h (tdesc_i386): Removed.
+
+2010-02-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c: Include "i387-tdep.h".
+	(amd64_linux_read_description): Just return tdesc_amd64_linux.
+
+	* amd64-linux-tdep.c: Don't include "i386-linux-tdep.h".
+	Include "i387-tdep.h".
+	(amd64_linux_register_name): Removed.
+	(amd64_linux_register_type): Likewise.
+	(amd64_linux_core_read_description): Just return
+	tdesc_amd64_linux.
+	(amd64_linux_init_abi): Set target description to
+	tdesc_amd64_linux if needed.  Support orig_rax.  Set
+	register_reggroup_p.
+
+	* amd64-tdep.c (amd64_register_names): Make it static.
+	(amd64_core_read_description): Removed.
+	(amd64_init_abi): Set num_core_regs and register_names.  Set
+	target description to tdesc_amd64 if needed.  Call
+	set_gdbarch_num_regs. 
+
+	* amd64-tdep.h (amd64_register_names): Removed.
+	(tdesc_amd64): Likewise.
+
+	* i386-linux-tdep.c: Include "i387-tdep.h".
+	(i386_linux_register_name): Removed.
+	(i386_linux_register_type): Likewise.
+	(amd64_linux_init_abi): Set target description to
+	tdesc_i386_linux if needed.  Support orig_eax.  Set
+	register_reggroup_p.
+
+	* i386-nto-tdep.c (i386nto_regset_id): Replace I386_NUM_FREGS
+	with I387_NUM_REGS.
+
+	* i386-tdep.c: Don't include "amd64-tdep.h".
+	(i386_go32_init_abi): Replace I386_NUM_FREGS with I387_NUM_REGS.
+	(i386_core_read_description): Removed.
+	(i386_gdbarch_init): Set target description to tdesc_i386 if
+	needed.  Set gregset_num_regs to I386_NUM_GREGS.  Set
+	num_core_regs and register_names.  Set register_reggroup_p.
+
+2010-02-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Move tdesc_use_registers
+	more toward the end of the function.  Call tdesc_use_registers
+	after gdbarch_init_osabi.  Update
+	set_gdbarch_register_reggroup_p.
+
+	* i386-tdep.h (gdbarch_tdep): Add num_core_regs,
+	register_names, tdesc and register_reggroup_p.
+	(I386_NUM_FREGS): Removed.
+	(I386_SSE_NUM_REGS): Replace I386_NUM_FREGS with I387_NUM_REGS.
+
+	* i387-tdep.h (I387_NUM_REGS): New.
+
+2010-02-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Move tdesc_use_registers
+	further toward the end of the function.
+
+2010-02-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Move tdesc_use_registers
+	toward the end of the function.
+
+2010-02-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c: Include "features/i386/amd64.c".
+	(amd64_core_read_description): New.
+	(_initialize_amd64_tdep): Likewise.
+	(amd64_init_abi): Call set_gdbarch_core_read_description.
+
+	* amd64-tdep.h (tdesc_amd64): New.
+
+	* i386-tdep.c: Include i386-tdep.h" instead of "amd64-tdep.h".
+	Include "amd64-tdep.h" instead of "features/i386/amd64.c" when
+	BFD64 is defined.
+	(i386_core_read_description): New.
+	(i386_gdbarch_init): Call set_gdbarch_core_read_description.
+	(_initialize_i386_tdep): Don't Call initialize_tdesc_amd64.
+
+	* i386-tdep.h (tdesc_i386): New.
+
+2010-02-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_read_description): New.
+	(_initialize_amd64_linux_nat): Use it.
+
+	* amd64-linux-tdep.c: Include "i386-linux-tdep.h" and
+	features/i386/amd64-linux.c.
+	(amd64_linux_register_name): New.
+	(amd64_linux_register_type): Likewise.
+	(amd64_linux_core_read_description): Likewise.
+	(amd64_linux_init_abi): Support remote stub without XML target
+	description.  Use amd64_linux_core_read_description instead of
+	i386_linux_core_read_description.
+	(_initialize_amd64_linux_tdep): Call initialize_tdesc_amd64_linux.
+
+	* amd64-linux-tdep.h: Don't include "i386-linux-tdep.h".
+	(tdesc_amd64_linux): New.
+
+	* i386-linux-nat.c (i386_linux_read_description): New.
+
+	* i386-linux-tdep.c: Include "i386-tdep.h/"i386-linux-tdep.h"
+	instead of "amd64-tdep.h"/"amd64-linux-tdep.h".
+	(i386_linux_register_name): Don't check BFD64.
+	(i386_linux_register_type): Likewise.
+	(_initialize_i386_linux_tdep): Likewise.
+	(i386_linux_init_orig_eax): Removed.
+	(i386_linux_core_read_description): Make it static.  Don't
+	check BFD64.
+	(i386_linux_read_description): Removed.
+	(i386_linux_init_abi): Support remote stub without XML target
+	description.
+
+	* i386-linux-tdep.h (i386_linux_core_read_description): Removed.
+	(i386_linux_read_description): Likewise.
+	(i386_linux_init_orig_eax): Likewise.
+	(tdesc_i386_linux): New.
+
+2010-02-10  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Optimize for BFD64.
+
+2010-02-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.c (i386_linux_register_name): Optimized for
+	BFD64.
+	(i386_linux_register_type): Likewise.
+	(i386_linux_init_orig_eax): Likewise.
+	(i386_linux_read_description): Likewise.
+
+2010-02-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* target-descriptions.c (tdesc_gdb_type): Correct i386_eflags
+	type.
+
+2010-02-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Set numbers of different
+	registers separately for 32bit and 64bit.
+
+2010-02-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i387_ext_type): Call tdesc_find_type instead of
+	arch_float_type.
+
+	* target-descriptions.c (tdesc_find_type): New.
+	(tdesc_gdb_type): Use it.
+
+	* target-descriptions.h (tdesc_find_type): New.
+
+2010-02-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.c: Replace x86-64/x86_64 with amd64.
+	* i386-tdep.c: Likewise.
+
+	* features/Makefile: Replace x86-64 with amd64.
+	* features/i386/*: Rename x86-64* to amd64*.
+
+	* regformats/i386/*: Rename x86-64* to amd64*.
+
+2010-02-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* features/Makefile (I386-XMLTOC): Removed. 
+	(I386-CFILES): Likewise.
+	(i386-cfiles): Likewise.
+
+2010-02-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.c (i386_linux_init_orig_eax): Return only
+	if XML target description is available.
+
+2010-02-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.c (i386_linux_init_orig_eax): Check
+	org.gnu.gdb.i386.linux instead of org.gnu.gdb.i386.core.
+
+2010-02-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c (amd64_linux_init_abi): Revert the last
+	change.  Call i386_linux_init_orig_eax.
+
+	* i386-linux-tdep.c (i386_linux_register_name): Make it static.
+	(i386_linux_register_type): Likewise.
+	(i386_linux_init_orig_eax): New.
+	(i386_linux_init_abi): Revert the last change.  Call
+	i386_linux_init_orig_eax.
+
+	* i386-linux-tdep.h (i386_linux_register_name): Removed.
+	(i386_linux_register_type): Likewise.
+	(i386_linux_init_orig_eax): New.
+
+2010-02-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c (amd64_linux_init_abi): Restore
+	set_gdbarch_num_regs.  Call set_gdbarch_register_name,
+	set_gdbarch_register_type and set_gdbarch_remote_register_number.
+
+	* amd64-linux-tdep.h: Include "i386-linux-tdep.h".
+
+	* i386-linux-tdep.c: Include "i386-tdep.h" and
+	"i386-linux-tdep.h" with "amd64-tdep.h" and "amd64-linux-tdep.h".
+	(i386_linux_register_name): Restored and rewote.  Make it global.
+	(i386_linux_register_type): New.
+	(i386_linux_init_abi): Restore set_gdbarch_num_regs and
+	set_gdbarch_register_name.  Call set_gdbarch_register_type and
+	set_gdbarch_remote_register_number.
+
+	* i386-linux-tdep.h (i386_linux_register_name): New.
+	(i386_linux_register_type): Likewise.
+
+2010-02-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.c (i386_linux_core_read_description): Fix a
+	typo in comments.
+
+2010-02-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_init): Optimize target description
+	check.
+
+2010-02-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c: Include "i386-linux-tdep.h"
+	(amd64_linux_init_abi): Call set_gdbarch_core_read_description.
+
+	* i386-linux-tdep.c (i386_linux_core_read_description): Fix a
+	typo.
+
+2010-02-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (_initialize_amd64_linux_nat): Set
+	to_read_description to i386_linux_read_description.
+	* i386-linux-nat.c (_initialize_i386_linux_nat): Likewise.
+
+	* amd64-linux-tdep.c (amd64_linux_register_name): Removed.
+	(amd64_linux_register_type): Likewise.
+	(amd64_linux_init_abi): Don't call set_gdbarch_num_regs,
+	set_gdbarch_register_name nor set_gdbarch_register_type.
+
+	* amd64-tdep.c (amd64_register_names): Make it global.
+	(amd64_register_name): Removed.
+	(amd64_register_type): Likewise.
+	(amd64_init_abi): Don't call set_gdbarch_num_regs,
+	set_gdbarch_register_name nor set_gdbarch_register_type.
+
+	* amd64-tdep.h (amd64_register_names): New.
+
+	* i386-linux-tdep.c: Include features/i386/i386-linux.c and
+	features/i386/x86-64-linux.c.
+	(i386_linux_register_name): Removed.
+	(i386_linux_core_read_description): New.
+	(i386_linux_read_description): Likewise.
+	(i386_linux_init_abi): Don't call set_gdbarch_num_regs nor
+	set_gdbarch_register_name.  Call
+	set_gdbarch_core_read_description.
+	(_initialize_i386_linux_tdep): Call initialize_tdesc_i386_linux
+	and initialize_tdesc_x86_64_linux.
+
+	* i386-linux-tdep.h (i386_linux_core_read_description): New.
+	(i386_linux_read_description): Likewise.
+
+	* i386-tdep.c: Include "amd64-tdep.h" instead of "i386-tdep.h".
+	Include features/i386/i386.c and features/i386/x86-64.c.
+	(i386_num_register_names): Removed.
+	(i386_register_names): Make it const.
+	(i386_mmx_names): Likewise.
+	(i386_num_register_names): Removed.
+	(i386_register_name): Likewise.
+	(i386_eflags_type): Likewise.
+	(i386_mxcsr_type): Likewise.
+	(i386_sse_type): Likewise.
+	(i386_register_type): Likewise.
+	(i386_pseudo_register_name): New.
+	(i386_pseudo_register_type): Likewise.
+	(i386_mmx_type): Make it static.
+	(i386_gdbarch_init): Don't call set_gdbarch_register_name
+	nor set_gdbarch_register_type.  Call
+	set_tdesc_pseudo_register_type, set_tdesc_pseudo_register_name
+	and tdesc_use_registers.
+	(_initialize_i386_tdep): Call initialize_tdesc_i386 and
+	initialize_tdesc_x86_64.
+
+	* i386-tdep.h (gdbarch_tdep): Remove i386_eflags_type,
+	i386_mxcsr_type and i386_sse_type.
+	(i386_eflags_type): Removed.
+	(i386_mxcsr_type): Likewise.
+	(i386_mmx_type): Likewise.
+	(i386_sse_type): Likewise.
+	(i386_register_name): Likewise.
+
+	* features/Makefile (I386-XMLTOC): New.
+	(I386-CFILES): Likewise.
+	(i386-cfiles): Likewise.
+
+	* features/i386/32bit-sse.xml: Update vec128 type.
+	* features/i386/64bit-sse.xml: Likewise.
+
+	* features/i386/i386-linux.c: Regenerated.
+	* features/i386/i386.c: Likewise.
+	* features/i386/x86-64-linux.c: Likewise.
+	* features/i386/x86-64.c: Likewise.
+
+2010-02-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* target-descriptions.c (tdesc_type): Add TDESC_TYPE_I387_EXT,
+	TDESC_TYPE_I386_EFLAGS and TDESC_TYPE_I386_MXCSR.
+	(tdesc_predefined_types): Add i387_ext, i386_eflags and
+	i386_mxcsr.
+	(tdesc_gdb_type): Handle TDESC_TYPE_I387_EXT,
+	TDESC_TYPE_I386_EFLAGS and TDESC_TYPE_I386_MXCSR.
+	(
+	* features/i386/32bit-core.xml: Replace i386_ext with i387_ext.
+	* features/i386/64bit-core.xml: Likewise.
+
+	* features/i386/i386-linux.c: New.
+	* features/i386/i386.c: Likewise.
+	* features/i386/x86-64-linux.c: Likewise.
+	* features/i386/x86-64.c: Likewise.
+
+2010-02-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* features/i386/32bit-core.xml: New.
+	* features/i386/32bit-linux.xml: Likewise.
+	* features/i386/32bit-sse.xml: Likewise.
+	* features/i386/64bit-core.xml: Likewise.
+	* features/i386/64bit-linux.xml: Likewise.
+	* features/i386/64bit-sse.xml: Likewise.
+	* features/i386/i386-linux.xml: Likewise.
+	* features/i386/i386.xml: Likewise.
+	* features/i386/x86-64-linux.xml: Likewise.
+	* features/i386/x86-64.xml: Likewise.
+
+	* features/Makefile (WHICH): Add i386/i386, i386/i386-linux,
+	i386/x86-64 and i386/x86-64-linux.
+	(i386/i386-expedite): New.
+	(i386/i386-linux-expedite): Likewise.
+	(i386/x86-64-expedite):Likewise.
+	(i386/x86-64-linux-expedite): Likewise.
+	($(outdir)/i386/i386.dat): New dependency.
+	($(outdir)/i386/i386-linux.dat): Likewise.
+	($(outdir)/i386/x86-64.dat): Likewise.
+	($(outdir)/i386/x86-64-linux.dat): Likewise.
+
+	* regformats/i386/i386-linux.dat: Regenerated.
+	* regformats/i386/i386.dat: Likewise.
+	* regformats/i386/x86-64-linux.dat: Likewise.
+	* regformats/i386/x86-64.dat: Likewise.
+
+2010-02-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* regformats/reg-i386-linux.dat: Moved to ...
+	* regformats/i386/i386-linux.dat: Here.
+
+	* regformats/reg-i386.dat: Moved to ...
+	* regformats/i386/i386.dat: Here.
+
+	* regformats/reg-x86-64-linux.dat: Moved to ...
+	* regformats/i386/x86-64-linux.dat: Here.
+
+	* regformats/reg-x86-64.dat: Moved to ...
+	* regformats/i386/x86-64.dat: Here.
--- ./gdb/ChangeLog.xstate	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/ChangeLog.xstate	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,384 @@
+2010-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-tdep.c (i386_gdbarch_vector_unit_init): Updated.
+
+2010-01-31  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_init_abi): Updated.
+	* i386-tdep.c (i386_gdbarch_init): Likewise.
+
+	* i386-tdep.c (i386_gdbarch_vector_unit_init): Change function
+	arguments.
+	* i386-tdep.h (i386_gdbarch_vector_unit_init): Likeise.
+
+2010-01-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* common/xstate-nat.c (i386_xstate_init): Use enabled size.
+
+2010-01-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (i387_supply_fxsave): Check vector_unit.
+	(i387_collect_fxsave): Likewise.
+
+2010-01-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* regcache.c (regcache_raw_supply_part): Group it with ...
+	(regcache_raw_collect_part): This.
+
+2010-01-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-tdep.c (i386_linux_core_read_description): Set
+	vector_unit to sse if there is no .reg-xstate section.
+
+2010-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (_initialize_amd64_linux_nat): Assert
+	i386_xstate.state != XSTATE_UNKNOWN instead of calling i386_xstate_init.
+	* i386-linux-nat.c (_initialize_i386_linux_nat): Likewise.
+
+2010-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c (_initialize_amd64_linux_tdep): Call
+	i386_xstate_init and update the XSAVE extended state size on
+	Linux/x86 host.
+	* i386-linux-tdep.c (_initialize_i386_linux_tdep): Likewise.
+
+2010-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-tdep.c: Include "i386-linux-tdep.h" and "regset.h".
+	(amd64_linux_regset_sections): New.
+	(amd64_linux_init_abi): Call set_gdbarch_core_regset_sections
+	with amd64_linux_regset_sections.  Call
+	set_gdbarch_core_read_description with
+	i386_linux_core_read_description.
+
+	* amd64-tdep.c (amd64_supply_xstateregset): New.
+	(amd64_collect_xstateregset): Likewise.
+	(amd64_regset_from_core_section): Check .reg-xstate section.
+
+	* i386-linux-tdep.c (i386_linux_regset_sections): Add
+	.reg-xstate section.
+	(i386_linux_core_read_description): New.
+	(i386_linux_init_abi): Call set_gdbarch_core_read_description
+	with i386_linux_core_read_description.
+
+	* i386-linux-tdep.h (i386_linux_core_read_description): New.
+
+	* i386-tdep.c (i386_supply_xstateregset): New.
+	(i386_collect_xstateregset): Likewise.
+	(i386_regset_from_core_section): Check .reg-xstate section.
+	(i386_gdbarch_init): Initialize xstateregset to NULL.
+
+	* i386-tdep.h (gdbarch_tdep): Add xstateregset.
+
+2010-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_init_abi): Set sizeof_xstateregset to 0.
+
+	* i386-tdep.c (i386_gdbarch_vector_unit_init): Set
+	sizeof_xstateregset if XSAVE extended state is supported.
+	(i386_gdbarch_init): Set sizeof_xstateregset to 0.
+
+	* i386-tdep.h (gdbarch_tdep): Add sizeof_xstateregset.
+
+	* common/xstate-nat.c (i386_xstate_init): Set i386_xstate.size.
+
+	* common/xstate-nat.h (i386_xstate_type): Add size.
+
+2010-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-tdep.c (amd64_register_names): Renamed to ...
+	(amd64_sse_register_names): This.  Remove AVX registers.
+	(amd64_avx_register_names): New.
+	(AMD64_NUM_REGS): Updated.
+	(amd64_register_name): Handle vector_unit.
+	(amd64_register_type): Replace i386_sse_type with
+	i386_vector_type.
+
+	* defs.h (MAX_REGISTER_SIZE): Increase to 32.
+
+	* i386-tdep.c: (i386_register_names): Renamed to ...
+	(i386_sse_register_names): This.
+	(i386_avx_register_names): New.
+	(i386_vec128_type): Likewise.
+	(i386_vec256_type): Likewise.
+	(i386_num_register_names): Updated.
+	(i386_gdbarch_sse_unit_init): Likewise.
+	(i386_register_name): Handle vector_unit.
+	(i386_sse_type): Renamed to ...
+	(i386_vector_type): This.  Handle vector_unit.
+	(amd64_register_type): Replace i386_sse_type with
+	i386_vector_type.
+
+	* i386-tdep.h (gdbarch_tdep): Replace i386_sse_type with
+	i386_vector_type.
+	(I386_MAX_REGISTER_SIZE): Increase to 32.
+	(i386_sse_type): Renamed to ...
+	(i386_vector_type): This.
+
+2010-01-25  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Makefile.in (xsave-nat.o): Renamed to ...
+	(xstate-nat.o): This.
+
+	* common/xsave-nat.c: Moved to ...
+	* common/xstate-nat.c: This.
+
+	* common/xsave-nat.h: Moved to ...
+	* common/xstate-nat.h: This.
+
+	* config/i386/linux.mh (NATDEPFILES): Replace xsave-nat.o with
+	xstate-nat.o.
+	* config/i386/linux64.mh (NATDEPFILES): Likewise.
+
+	* config/i386/nm-linux.h: Include "xstate-nat.h" instead of
+	"xsave-nat.h".
+	* config/i386/nm-linux64.h: Likewise.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers):
+	Issue an error if PTRACE_GETXSTATEREGS failed and XSAVE
+	extended state is higher than SSE.
+	(amd64_linux_store_inferior_registers): Likewise.
+	* i386-linux-nat.c (fetch_xstateregs): Likewise.
+	(store_xstateregs): Likewise.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* common/xsave-nat.c: Include "i386-cpuid.h" instead of
+	"config/i386/i386-cpuid.h".
+
+	* config/i386/i386-cpuid.h: Moved to ...
+	* common/i386-cpuid.h: Here.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Makefile.in (xsave-nat.o): New.
+
+	* xsave-nat.c: Moved to ...
+	* common/xsave-nat.c: Here.
+
+	* xsave-nat.h: Moved to ...
+	* common/xsave-nat.h: Here.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i386-linux-nat.c (have_ptrace_getxstateregs): New.
+	(PTRACE_GETXSTATEREGS): Likewise.
+	(PTRACE_SETXSTATEREGS): Likewise.
+	(fetch_xstateregs): Likewise.
+	(store_xstateregs): Likewise.
+	(i386_linux_fetch_inferior_registers): Support XSAVE extended
+	state.
+	(i386_linux_store_inferior_registers): Likewise.
+	(_initialize_i386_linux_nat): Call i386_xstate_init and set
+	have_ptrace_getxstateregs.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (xsave_avxh_offset): New.
+	(XSAVE_AVXH_ADDR): Likewise.
+	(i387_supply_xsave): Use XSAVE_SSE_ADDR and XSAVE_AVXH_ADDR for
+	AVX vector unit.
+	(i387_collect_xsave): Likewise.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (xsave_sse_offset): New.
+	(XSAVE_SSE_ADDR): Likewise.
+	(i387_supply_xsave): Use XSAVE_SSE_ADDR.
+	(i387_collect_xsave): Likewise.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-tdep.c (i387_supply_xsave): Check vector unit.
+	(i387_collect_xsave): Likewise.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gregset.h (GDB_XSTATE_SSE_REGSET_T): Removed.
+	(GDB_XSTATE_AVX_REGSET_T): Likewise.
+	(gdb_xstate_sse_regset_t): Likewise.
+	(gdb_xstate_avx_regset_t): Likewise.
+	(supply_xstate_sse_regset): Likewise.
+	(supply_xstate_avx_regset): Likewise.
+	(fill_xstate_sse_regset): Likewise.
+	(fill_xstate_avx_regset): Likewise.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* regcache.c (regcache_raw_supply_part): New.
+	(regcache_raw_collect_part): Likewise.
+	* regcache.h (regcache_raw_supply_part): Likewise.
+	(regcache_raw_collect_part): Likewise.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_init_abi): Call
+	i386_gdbarch_vector_unit_init.
+
+	* i386-tdep.c (i386_gdbarch_vector_unit_init): New.
+	(i386_gdbarch_init): Call i386_gdbarch_vector_unit_init.
+
+	* i386-tdep.h (x86_vector_unit): New.
+	(gdbarch_tdep): Add vector_unit.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (_initialize_amd64_linux_nat): Always call
+	i386_xstate_init ().
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (have_ptrace_getxstateregs): New.
+	(PTRACE_GETXSTATEREGS): Likewise.
+	(PTRACE_SETXSTATEREGS): Likewise.
+	(amd64_linux_fetch_inferior_registers): Support XSAVE extended
+	state.
+	(amd64_linux_store_inferior_registers): Likewise.
+	(amd64_linux_fetch_inferior_registers_with_xsave): Removed.
+	(amd64_linux_store_inferior_registers_with_xsave): Likewise.
+	(_initialize_amd64_linux_nat): Updated.
+
+	* configure.ac: Remove check for PTRACE_GETXSTATEREGS.
+	* config.in: Regenerated.
+	* configure: Likewise.
+
+	* config/i386/nm-linux.h (USE_XSAVE): Changed to ...
+	(FILL_XSTATEREGSET): This.
+	* onfig/i386/nm-linux64.h: Likewise.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* xsave-nat.c (i386_xstate_init): Properly set state.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c: Don't include "xsave-nat.h".
+	(amd64_linux_fetch_inferior_registers_with_xstate): Renamed to ...
+	(amd64_linux_fetch_inferior_registers_with_xsave): This.
+	(amd64_linux_store_inferior_registers_with_xstate): Renamed to ...
+	(amd64_linux_store_inferior_registers_with_xsave): This.
+
+	* config/i386/nm-linux.h: Include "xsave-nat.h".
+	* config/i386/nm-linux64.h: Likewise.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/linux64.mh (NAT_FILE): Set to nm-linux64.h.
+
+	* config/i386/nm-linux.h (USE_XSAVE): New.
+
+	* config/i386/nm-linux64.h: New.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* xsave-nat.c: Include "config/i386/i386-cpuid.h" if <cpuid.h>
+	isn't available.
+
+	* config/i386/i386-cpuid.h: New. Taken from gcc 4.4.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c: Include "xsave-nat.h"
+	(_initialize_amd64_linux_nat): Check HAVE_PTRACE_GETXSTATEREGS
+	instead of HAVE_SYS_XSTATE_H.
+
+	* configure.ac: Add check for cpuid.h.  Remove check for
+	sys/xstate.h, __get_xstate and __get_xstate_size.
+	* config.in: Regenerated.
+	* configure: Likewise.
+
+	* i386-nat.c (i386_xstate): Removed.
+	(i386_xstate_init): Likewise.
+
+	* i386-nat.h (i386_xstate_type): Removed.
+	(i386_xstate): Likewise.
+	(i386_xstate_init): Likewise.
+
+	* xsave-nat.c: New.
+	* xsave-nat.h: Likewise.
+
+	* config/i386/linux.mh (NATDEPFILES): Add xsave-nat.o.
+	* config/i386/linux64.mh (NATDEPFILES): Likewise.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers_with_xstate):
+	Call amd64_supply_xsave instead of amd64_supply_fxsave.
+	(amd64_linux_store_inferior_registers_with_xstate): Call
+	amd64_collect_fxsave instead of amd64_collect_xsave.
+
+	* amd64-tdep.c (amd64_supply_xsave): New.
+	(amd64_collect_xsave): Likewise.
+	* amd64-tdep.h (amd64_supply_xsave): Likewise.
+	(amd64_collect_xsave): Likewise.
+	* i387-tdep.c (i387_supply_xsave): Likewise.
+	(i387_collect_xsave): Likewise.
+	* i387-tdep.h (i387_supply_xsave): Likewise.
+	(i387_collect_xsave): Likewise.
+
+	* i386-nat.h: Update comments.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Revert
+	the last change,
+	(amd64_linux_store_inferior_registers): Likewise.
+	(amd64_linux_fetch_inferior_registers_with_xstate): New.
+	(amd64_linux_store_inferior_registers_with_xstate): Likewise.
+	(_initialize_amd64_linux_nat): Use
+	amd64_linux_fetch_inferior_registers_with_xstate and
+	amd64_linux_store_inferior_registers_with_xstate if possible.
+
+	* i386-nat.h (i386_xstate_type): Rename size to n_of_int64.
+	* i386-nat.c (i386_xstate): Updated.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers):
+	Use PTRACE_GETXSTATEREGS/PTRACE_SETXSTATEREGS if posssible.
+	(amd64_linux_store_inferior_registers): Likewise.
+	(_initialize_amd64_linux_nat): Call i386_xstate_init.
+
+	* i386-nat.c (i386_xstate): New.
+	(i386_xstate_init): Likewise.
+
+	* i386-nat.h (i386_xstate_type): New.
+	(i386_xstate): Likewise.
+	(i386_xstate_init): Likewise.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c: Revert the change change.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* configure.ac: Add check for __get_xstate_size.
+	* config.in: Regenerated.
+	* configure: Likewise.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* amd64-linux-nat.c: Include <sys/xstate.h> if HAVE_SYS_XSTATE_H
+	is defined.
+	(have_ptrace_getxstateregs): New.
+	(_initialize_amd64_linux_nat): Clear have_ptrace_getxstateregs
+	if needed.
+
+	* gregset.h (GDB_XSTATE_SSE_REGSET_T): New.
+	(GDB_XSTATE_AVX_REGSET_T): Likewise.
+	(gdb_xstate_sse_regset_t): Likewise.
+	(gdb_xstate_avx_regset_t): Likewise.
+	(supply_xstate_sse_regset): Likewise.
+	(supply_xstate_avx_regset): Likewise.
+	(fill_xstate_sse_regset): Likewise.
+	(fill_xstate_avx_regset): Likewise.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* configure.ac: Add check for sys/xstate.h, __get_xstate and
+	PTRACE_GETXSTATEREGS.
+	* config.in: Regenerated.
+	* configure: Likewise.
--- ./gdb/amd64-linux-nat.c	2010-04-03 20:59:52.000000000 +0200
+++ ./gdb/amd64-linux-nat.c	2010-04-03 21:15:08.000000000 +0200
@@ -23,11 +23,14 @@
 #include "inferior.h"
 #include "gdbcore.h"
 #include "regcache.h"
+#include "regset.h"
 #include "linux-nat.h"
 #include "amd64-linux-tdep.h"
 
 #include "gdb_assert.h"
 #include "gdb_string.h"
+#include "elf/common.h"
+#include <sys/uio.h>
 #include <sys/ptrace.h>
 #include <sys/debugreg.h>
 #include <sys/syscall.h>
@@ -54,6 +57,18 @@
 #include "i387-tdep.h"
 #include "elf-bfd.h"
 #include "gdb_procfs32.h"
+#include "i386-xstate.h"
+
+#ifndef PTRACE_GETREGSET
+#define PTRACE_GETREGSET	0x4204
+#endif
+
+#ifndef PTRACE_SETREGSET
+#define PTRACE_SETREGSET	0x4205
+#endif
+
+/* Does the current host support PTRACE_GETREGSET?  */
+static int have_ptrace_getregset = -1;
 
 /* Mapping between the general-purpose registers in GNU/Linux x86-64
    `struct user' format and GDB's register cache layout.  */
@@ -76,6 +91,8 @@ static int amd64_linux_gregset64_reg_off
   -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,
   ORIG_RAX * 8
 };
 
@@ -131,6 +148,7 @@ static int amd64_linux_gregset32_reg_off
   -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,
   ORIG_RAX * 8			/* "orig_eax" */
 };
 
@@ -312,10 +330,26 @@ amd64_linux_fetch_inferior_registers (st
     {
       elf_fpregset_t fpregs;
 
-      if (ptrace (PTRACE_GETFPREGS, tid, 0, (long) &fpregs) < 0)
-	perror_with_name (_("Couldn't get floating point status"));
+      if (have_ptrace_getregset)
+	{
+	  char xstateregs[I386_XSTATE_MAX_SIZE];
+	  struct iovec iov;
+
+	  iov.iov_base = xstateregs;
+	  iov.iov_len = sizeof (xstateregs);
+	  if (ptrace (PTRACE_GETREGSET, tid,
+		      (unsigned int) NT_X86_XSTATE, (long) &iov) < 0)
+	    perror_with_name (_("Couldn't get extended state status"));
 
-      amd64_supply_fxsave (regcache, -1, &fpregs);
+	  amd64_supply_xsave (regcache, -1, xstateregs);
+	}
+      else
+	{
+	  if (ptrace (PTRACE_GETFPREGS, tid, 0, (long) &fpregs) < 0)
+	    perror_with_name (_("Couldn't get floating point status"));
+
+	  amd64_supply_fxsave (regcache, -1, &fpregs);
+	}
     }
 }
 
@@ -355,15 +389,33 @@ amd64_linux_store_inferior_registers (st
     {
       elf_fpregset_t fpregs;
 
-      if (ptrace (PTRACE_GETFPREGS, tid, 0, (long) &fpregs) < 0)
-	perror_with_name (_("Couldn't get floating point status"));
+      if (have_ptrace_getregset)
+	{
+	  char xstateregs[I386_XSTATE_MAX_SIZE];
+	  struct iovec iov;
 
-      amd64_collect_fxsave (regcache, regnum, &fpregs);
+	  iov.iov_base = xstateregs;
+	  iov.iov_len = sizeof (xstateregs);
+	  if (ptrace (PTRACE_GETREGSET, tid,
+		      (unsigned int) NT_X86_XSTATE, (long) &iov) < 0)
+	    perror_with_name (_("Couldn't get extended state status"));
+
+	  amd64_collect_xsave (regcache, regnum, xstateregs, 0);
+
+	  if (ptrace (PTRACE_SETREGSET, tid,
+		      (unsigned int) NT_X86_XSTATE, (long) &iov) < 0)
+	    perror_with_name (_("Couldn't write extended state status"));
+	}
+      else
+	{
+	  if (ptrace (PTRACE_GETFPREGS, tid, 0, (long) &fpregs) < 0)
+	    perror_with_name (_("Couldn't get floating point status"));
 
-      if (ptrace (PTRACE_SETFPREGS, tid, 0, (long) &fpregs) < 0)
-	perror_with_name (_("Couldn't write floating point status"));
+	  amd64_collect_fxsave (regcache, regnum, &fpregs);
 
-      return;
+	  if (ptrace (PTRACE_SETFPREGS, tid, 0, (long) &fpregs) < 0)
+	    perror_with_name (_("Couldn't write floating point status"));
+	}
     }
 }
 
@@ -831,6 +883,8 @@ amd64_linux_read_description (struct tar
 {
   unsigned long cs;
   int tid;
+  int is_64bit;
+  static uint64_t xcr0;
 
   /* GNU/Linux LWP ID's are process ID's.  */
   tid = TIDGET (inferior_ptid);
@@ -844,10 +898,55 @@ amd64_linux_read_description (struct tar
   if (errno != 0)
     perror_with_name (_("Couldn't get CS register"));
 
-  if (cs == AMD64_LINUX_USER64_CS)
-    return tdesc_amd64_linux;
+  is_64bit = cs == AMD64_LINUX_USER64_CS;
+
+  if (have_ptrace_getregset == -1)
+    {
+      uint64_t xstateregs[(I386_XSTATE_SSE_SIZE / sizeof (uint64_t))];
+      struct iovec iov;
+      unsigned int xstate_size;
+
+      iov.iov_base = xstateregs;
+      iov.iov_len = sizeof (xstateregs);
+
+      /* Check if PTRACE_GETREGSET works.  */
+      if (ptrace (PTRACE_GETREGSET, tid,
+		  (unsigned int) NT_X86_XSTATE, (long) &iov) < 0)
+	{
+	  have_ptrace_getregset = 0;
+	  xstate_size = 0;
+	}
+      else
+	{
+	  have_ptrace_getregset = 1;
+
+	  /* Get XCR0 from XSAVE extended state.  */
+	  xcr0 = xstateregs[(I386_LINUX_XSAVE_XCR0_OFFSET
+			     / sizeof (uint64_t))];
+
+	  xstate_size = I386_XSTATE_SIZE (xcr0);
+	}
+
+      i386_linux_update_xstateregset (xstate_size);
+      amd64_linux_update_xstateregset (xstate_size);
+    }
+
+  /* Check the native XCR0 only if PTRACE_GETREGSET is available.  */
+  if (have_ptrace_getregset
+      && (xcr0 & I386_XSTATE_AVX_MASK) == I386_XSTATE_AVX_MASK)
+    {
+      if (is_64bit)
+	return tdesc_amd64_avx_linux;
+      else
+	return tdesc_i386_avx_linux;
+    }
   else
-    return tdesc_i386_linux;
+    {
+      if (is_64bit)
+	return tdesc_amd64_linux;
+      else
+	return tdesc_i386_linux;
+    }
 }
 
 /* Provide a prototype to silence -Wmissing-prototypes.  */
--- ./gdb/amd64-linux-tdep.c	2010-04-03 20:59:52.000000000 +0200
+++ ./gdb/amd64-linux-tdep.c	2010-04-03 21:12:32.000000000 +0200
@@ -28,8 +28,11 @@
 #include "symtab.h"
 #include "gdbtypes.h"
 #include "reggroups.h"
+#include "regset.h"
 #include "amd64-linux-tdep.h"
+#include "i386-linux-tdep.h"
 #include "linux-tdep.h"
+#include "i386-xstate.h"
 
 #include "gdb_string.h"
 
@@ -38,6 +41,7 @@
 #include "xml-syscall.h"
 
 #include "features/i386/amd64-linux.c"
+#include "features/i386/amd64-avx-linux.c"
 
 /* The syscall's XML filename for i386.  */
 #define XML_SYSCALL_FILENAME_AMD64 "syscalls/amd64-linux.xml"
@@ -45,6 +49,15 @@
 #include "record.h"
 #include "linux-record.h"
 
+/* Supported register note sections.  */
+static struct core_regset_section amd64_linux_regset_sections[] =
+{
+  { ".reg", 144, "general-purpose" },
+  { ".reg2", 512, "floating-point" },
+  { ".reg-xstate", 0, "XSAVE extended state" },
+  { NULL, 0 }
+};
+
 /* Mapping between the general-purpose registers in `struct user'
    format and GDB's register cache layout.  */
 
@@ -1316,6 +1329,22 @@ amd64_linux_record_signal (struct gdbarc
   return 0;
 }
 
+/* Update XSAVE extended state register note section.  */
+
+void
+amd64_linux_update_xstateregset (unsigned int xstate_size)
+{
+  struct core_regset_section *xstate = &amd64_linux_regset_sections[2];
+
+  /* Update the XSAVE extended state register note section for "gcore".
+     Disable it if its size is 0.  */
+  gdb_assert (strcmp (xstate->sect_name, ".reg-xstate") == 0);
+  if (xstate_size)
+    xstate->size = xstate_size;
+  else
+    xstate->sect_name = NULL;
+}
+
 /* Get Linux/x86 target description from core dump.  */
 
 static const struct target_desc *
@@ -1324,12 +1353,17 @@ amd64_linux_core_read_description (struc
 				  bfd *abfd)
 {
   asection *section = bfd_get_section_by_name (abfd, ".reg2");
+  uint64_t xcr0;
 
   if (section == NULL)
     return NULL;
 
   /* Linux/x86-64.  */
-  return tdesc_amd64_linux;
+  xcr0 = i386_linux_core_read_xcr0 (gdbarch, target, abfd);
+  if ((xcr0 & I386_XSTATE_AVX_MASK) == I386_XSTATE_AVX_MASK)
+    return tdesc_amd64_avx_linux;
+  else
+    return tdesc_amd64_linux;
 }
 
 static void
@@ -1373,6 +1407,8 @@ amd64_linux_init_abi (struct gdbarch_inf
 
   tdep->outermost_frame_p = amd64_linux_outermost_frame;
 
+  tdep->xsave_xcr0_offset = I386_LINUX_XSAVE_XCR0_OFFSET;
+
   /* GNU/Linux uses SVR4-style shared libraries.  */
   set_solib_svr4_fetch_link_map_offsets
     (gdbarch, svr4_lp64_fetch_link_map_offsets);
@@ -1394,6 +1430,9 @@ amd64_linux_init_abi (struct gdbarch_inf
   /* GNU/Linux uses SVR4-style shared libraries.  */
   set_gdbarch_skip_trampoline_code (gdbarch, find_solib_trampoline_target);
 
+  /* Install supported register note sections.  */
+  set_gdbarch_core_regset_sections (gdbarch, amd64_linux_regset_sections);
+
   set_gdbarch_core_read_description (gdbarch,
 				     amd64_linux_core_read_description);
 
@@ -1596,4 +1635,5 @@ _initialize_amd64_linux_tdep (void)
 
   /* Initialize the Linux target description  */
   initialize_tdesc_amd64_linux ();
+  initialize_tdesc_amd64_avx_linux ();
 }
--- ./gdb/amd64-linux-tdep.h	2010-04-03 20:59:52.000000000 +0200
+++ ./gdb/amd64-linux-tdep.h	2010-04-03 21:12:32.000000000 +0200
@@ -26,13 +26,17 @@
 /* Register number for the "orig_rax" register.  If this register
    contains a value >= 0 it is interpreted as the system call number
    that the kernel is supposed to restart.  */
-#define AMD64_LINUX_ORIG_RAX_REGNUM (AMD64_MXCSR_REGNUM + 1)
+#define AMD64_LINUX_ORIG_RAX_REGNUM (AMD64_YMM15H_REGNUM + 1)
 
 /* Total number of registers for GNU/Linux.  */
 #define AMD64_LINUX_NUM_REGS (AMD64_LINUX_ORIG_RAX_REGNUM + 1)
 
 /* Linux target description.  */
 extern struct target_desc *tdesc_amd64_linux;
+extern struct target_desc *tdesc_amd64_avx_linux;
+
+/* Update XSAVE extended state register note section.  */
+extern void amd64_linux_update_xstateregset (unsigned int xstate_size);
 
 /* Enum that defines the syscall identifiers for amd64 linux.
    Used for process record/replay, these will be translated into
--- ./gdb/amd64-tdep.c	2010-04-03 21:11:41.000000000 +0200
+++ ./gdb/amd64-tdep.c	2010-04-03 21:12:32.000000000 +0200
@@ -43,6 +43,7 @@
 #include "i387-tdep.h"
 
 #include "features/i386/amd64.c"
+#include "features/i386/amd64-avx.c"
 
 /* Note that the AMD64 architecture was previously known as x86-64.
    The latter is (forever) engraved into the canonical system name as
@@ -71,8 +72,21 @@ static const char *amd64_register_names[
   "mxcsr",
 };
 
-/* Total number of registers.  */
-#define AMD64_NUM_REGS	ARRAY_SIZE (amd64_register_names)
+static const char *amd64_ymm_names[] = 
+{
+  "ymm0", "ymm1", "ymm2", "ymm3",
+  "ymm4", "ymm5", "ymm6", "ymm7",
+  "ymm8", "ymm9", "ymm10", "ymm11",
+  "ymm12", "ymm13", "ymm14", "ymm15"
+};
+
+static const char *amd64_ymmh_names[] = 
+{
+  "ymm0h", "ymm1h", "ymm2h", "ymm3h",
+  "ymm4h", "ymm5h", "ymm6h", "ymm7h",
+  "ymm8h", "ymm9h", "ymm10h", "ymm11h",
+  "ymm12h", "ymm13h", "ymm14h", "ymm15h"
+};
 
 /* The registers used to pass integer arguments during a function call.  */
 static int amd64_dummy_call_integer_regs[] =
@@ -163,6 +177,8 @@ static const int amd64_dwarf_regmap_len 
 static int
 amd64_dwarf_reg_to_regnum (struct gdbarch *gdbarch, int reg)
 {
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  int ymm0_regnum = tdep->ymm0_regnum;
   int regnum = -1;
 
   if (reg >= 0 && reg < amd64_dwarf_regmap_len)
@@ -170,6 +186,9 @@ amd64_dwarf_reg_to_regnum (struct gdbarc
 
   if (regnum == -1)
     warning (_("Unmapped DWARF Register #%d encountered."), reg);
+  else if (ymm0_regnum >= 0
+	   && i386_xmm_regnum_p (gdbarch, regnum))
+    regnum += ymm0_regnum - I387_XMM0_REGNUM (tdep);
 
   return regnum;
 }
@@ -238,6 +257,19 @@ static const char *amd64_dword_names[] =
   "r8d", "r9d", "r10d", "r11d", "r12d", "r13d", "r14d", "r15d"
 };
 
+/* Return the name of register REGNUM, or the empty string if it is
+   an anonymous register. */
+
+static const char *
+amd64_register_name (struct gdbarch *gdbarch, int regnum)
+{
+  /* Hide the upper YMM registers.  */
+  if (i386_ymmh_regnum_p (gdbarch, regnum))
+    return "";
+
+  return tdesc_register_name (gdbarch, regnum);
+}
+
 /* Return the name of register REGNUM.  */
 
 static const char *
@@ -246,6 +278,8 @@ amd64_pseudo_register_name (struct gdbar
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
   if (i386_byte_regnum_p (gdbarch, regnum))
     return amd64_byte_names[regnum - tdep->al_regnum];
+  else if (i386_ymm_regnum_p (gdbarch, regnum))
+    return amd64_ymm_names[regnum - tdep->ymm0_regnum];
   else if (i386_word_regnum_p (gdbarch, regnum))
     return amd64_word_names[regnum - tdep->ax_regnum];
   else if (i386_dword_regnum_p (gdbarch, regnum))
@@ -2181,6 +2215,28 @@ amd64_collect_fpregset (const struct reg
   amd64_collect_fxsave (regcache, regnum, fpregs);
 }
 
+/* Similar to amd64_supply_fpregset, but use XSAVE extended state.  */
+
+static void
+amd64_supply_xstateregset (const struct regset *regset,
+			   struct regcache *regcache, int regnum,
+			   const void *xstateregs, size_t len)
+{
+  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
+  amd64_supply_xsave (regcache, regnum, xstateregs);
+}
+
+/* Similar to amd64_collect_fpregset, but use XSAVE extended state.  */
+
+static void
+amd64_collect_xstateregset (const struct regset *regset,
+			    const struct regcache *regcache,
+			    int regnum, void *xstateregs, size_t len)
+{
+  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
+  amd64_collect_xsave (regcache, regnum, xstateregs, 1);
+}
+
 /* Return the appropriate register set for the core section identified
    by SECT_NAME and SECT_SIZE.  */
 
@@ -2199,6 +2255,16 @@ amd64_regset_from_core_section (struct g
       return tdep->fpregset;
     }
 
+  if (strcmp (sect_name, ".reg-xstate") == 0)
+    {
+      if (tdep->xstateregset == NULL)
+	tdep->xstateregset = regset_alloc (gdbarch,
+					   amd64_supply_xstateregset,
+					   amd64_collect_xstateregset);
+
+      return tdep->xstateregset;
+    }
+
   return i386_regset_from_core_section (gdbarch, sect_name, sect_size);
 }
 
@@ -2261,6 +2327,13 @@ amd64_init_abi (struct gdbarch_info info
   tdep->num_core_regs = AMD64_NUM_GREGS + I387_NUM_REGS;
   tdep->register_names = amd64_register_names;
 
+  if (tdesc_find_feature (tdesc, "org.gnu.gdb.i386.avx") != NULL)
+    {
+      tdep->ymmh_register_names = amd64_ymmh_names;
+      tdep->num_ymm_regs = 16;
+      tdep->ymm0h_regnum = AMD64_YMM0H_REGNUM;
+    }
+
   tdep->num_byte_regs = 20;
   tdep->num_word_regs = 16;
   tdep->num_dword_regs = 16;
@@ -2274,6 +2347,8 @@ amd64_init_abi (struct gdbarch_info info
 
   set_tdesc_pseudo_register_name (gdbarch, amd64_pseudo_register_name);
 
+  set_gdbarch_register_name (gdbarch, amd64_register_name);
+
   /* AMD64 has an FPU and 16 SSE registers.  */
   tdep->st0_regnum = AMD64_ST0_REGNUM;
   tdep->num_xmm_regs = 16;
@@ -2354,6 +2429,7 @@ void
 _initialize_amd64_tdep (void)
 {
   initialize_tdesc_amd64 ();
+  initialize_tdesc_amd64_avx ();
 }
 
 
@@ -2389,6 +2465,30 @@ amd64_supply_fxsave (struct regcache *re
     }
 }
 
+/* Similar to amd64_supply_fxsave, but use XSAVE extended state.  */
+
+void
+amd64_supply_xsave (struct regcache *regcache, int regnum,
+		    const void *xsave)
+{
+  struct gdbarch *gdbarch = get_regcache_arch (regcache);
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  i387_supply_xsave (regcache, regnum, xsave);
+
+  if (xsave && gdbarch_ptr_bit (gdbarch) == 64)
+    {
+      const gdb_byte *regs = xsave;
+
+      if (regnum == -1 || regnum == I387_FISEG_REGNUM (tdep))
+	regcache_raw_supply (regcache, I387_FISEG_REGNUM (tdep),
+			     regs + 12);
+      if (regnum == -1 || regnum == I387_FOSEG_REGNUM (tdep))
+	regcache_raw_supply (regcache, I387_FOSEG_REGNUM (tdep),
+			     regs + 20);
+    }
+}
+
 /* Fill register REGNUM (if it is a floating-point or SSE register) in
    *FXSAVE with the value from REGCACHE.  If REGNUM is -1, do this for
    all registers.  This function doesn't touch any of the reserved
@@ -2412,3 +2512,26 @@ amd64_collect_fxsave (const struct regca
 	regcache_raw_collect (regcache, I387_FOSEG_REGNUM (tdep), regs + 20);
     }
 }
+
+/* Similar to amd64_collect_fxsave, but but use XSAVE extended state.  */
+
+void
+amd64_collect_xsave (const struct regcache *regcache, int regnum,
+		     void *xsave, int gcore)
+{
+  struct gdbarch *gdbarch = get_regcache_arch (regcache);
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  gdb_byte *regs = xsave;
+
+  i387_collect_xsave (regcache, regnum, xsave, gcore);
+
+  if (gdbarch_ptr_bit (gdbarch) == 64)
+    {
+      if (regnum == -1 || regnum == I387_FISEG_REGNUM (tdep))
+	regcache_raw_collect (regcache, I387_FISEG_REGNUM (tdep),
+			      regs + 12);
+      if (regnum == -1 || regnum == I387_FOSEG_REGNUM (tdep))
+	regcache_raw_collect (regcache, I387_FOSEG_REGNUM (tdep),
+			      regs + 20);
+    }
+}
--- ./gdb/amd64-tdep.h	2010-01-29 06:19:22.000000000 +0100
+++ ./gdb/amd64-tdep.h	2010-04-03 21:12:32.000000000 +0200
@@ -61,12 +61,16 @@ enum amd64_regnum
   AMD64_FSTAT_REGNUM = AMD64_ST0_REGNUM + 9,
   AMD64_XMM0_REGNUM = 40,	/* %xmm0 */
   AMD64_XMM1_REGNUM,		/* %xmm1 */
-  AMD64_MXCSR_REGNUM = AMD64_XMM0_REGNUM + 16
+  AMD64_MXCSR_REGNUM = AMD64_XMM0_REGNUM + 16,
+  AMD64_YMM0H_REGNUM,		/* %ymm0h */
+  AMD64_YMM15H_REGNUM = AMD64_YMM0H_REGNUM + 15
 };
 
 /* Number of general purpose registers.  */
 #define AMD64_NUM_GREGS		24
 
+#define AMD64_NUM_REGS		(AMD64_YMM15H_REGNUM + 1)
+
 extern struct displaced_step_closure *amd64_displaced_step_copy_insn
   (struct gdbarch *gdbarch, CORE_ADDR from, CORE_ADDR to,
    struct regcache *regs);
@@ -77,12 +81,6 @@ extern void amd64_displaced_step_fixup (
 
 extern void amd64_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch);
 
-/* Functions from amd64-tdep.c which may be needed on architectures
-   with extra registers.  */
-
-extern const char *amd64_register_name (struct gdbarch *gdbarch, int regnum);
-extern struct type *amd64_register_type (struct gdbarch *gdbarch, int regnum);
-
 /* Fill register REGNUM in REGCACHE with the appropriate
    floating-point or SSE register value from *FXSAVE.  If REGNUM is
    -1, do this for all registers.  This function masks off any of the
@@ -91,6 +89,10 @@ extern struct type *amd64_register_type 
 extern void amd64_supply_fxsave (struct regcache *regcache, int regnum,
 				 const void *fxsave);
 
+/* Similar to amd64_supply_fxsave, but use XSAVE extended state.  */
+extern void amd64_supply_xsave (struct regcache *regcache, int regnum,
+				const void *xsave);
+
 /* Fill register REGNUM (if it is a floating-point or SSE register) in
    *FXSAVE with the value from REGCACHE.  If REGNUM is -1, do this for
    all registers.  This function doesn't touch any of the reserved
@@ -99,6 +101,10 @@ extern void amd64_supply_fxsave (struct 
 extern void amd64_collect_fxsave (const struct regcache *regcache, int regnum,
 				  void *fxsave);
 
+/* Similar to amd64_collect_fxsave, but but use XSAVE extended state.  */
+extern void amd64_collect_xsave (const struct regcache *regcache,
+				 int regnum, void *xsave, int gcore);
+
 void amd64_classify (struct type *type, enum amd64_reg_class class[2]);
 
 
--- ./gdb/common/i386-xstate.h	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/common/i386-xstate.h	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,41 @@
+/* Common code for i386 XSAVE extended state.
+
+   Copyright (C) 2010 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef I386_XSTATE_H
+#define I386_XSTATE_H 1
+
+/* The extended state feature bits.  */
+#define I386_XSTATE_X87		(1ULL << 0)
+#define I386_XSTATE_SSE		(1ULL << 1)
+#define I386_XSTATE_AVX		(1ULL << 2)
+
+/* Supported mask and size of the extended state.  */
+#define I386_XSTATE_SSE_MASK	(I386_XSTATE_X87 | I386_XSTATE_SSE)
+#define I386_XSTATE_AVX_MASK	(I386_XSTATE_SSE_MASK | I386_XSTATE_AVX)
+
+#define I386_XSTATE_SSE_SIZE	576
+#define I386_XSTATE_AVX_SIZE	832
+#define I386_XSTATE_MAX_SIZE	832
+
+/* Get I386 XSAVE extended state size.  */
+#define I386_XSTATE_SIZE(XCR0)	\
+  (((XCR0) & I386_XSTATE_AVX) != 0 \
+   ? I386_XSTATE_AVX_SIZE : I386_XSTATE_SSE_SIZE)
+
+#endif /* I386_XSTATE_H */
--- ./gdb/config/djgpp/fnchange.lst	2010-02-01 20:27:55.000000000 +0100
+++ ./gdb/config/djgpp/fnchange.lst	2010-04-03 21:12:32.000000000 +0200
@@ -228,6 +228,14 @@
 @V@/gdb/features/rs6000/powerpc-vsx64l.xml @V@/gdb/features/rs6000/ppc-v64l.xml
 @V@/gdb/features/rs6000/powerpc-cell32l.xml @V@/gdb/features/rs6000/ppc-c32l.xml
 @V@/gdb/features/rs6000/powerpc-cell64l.xml @V@/gdb/features/rs6000/ppc-c64l.xml
+@V@/gdb/features/i386/amd64-avx-linux.c @V@/gdb/features/i386/a64-al.c
+@V@/gdb/features/i386/amd64-avx.c @V@/gdb/features/i386/a64-a.c
+@V@/gdb/features/i386/amd64-avx-linux.xml @V@/gdb/features/i386/a64-al.xml
+@V@/gdb/features/i386/amd64-avx.xml @V@/gdb/features/i386/a64-a.xml
+@V@/gdb/features/i386/i386-avx-linux.c @V@/features/i386/i32-al.c
+@V@/gdb/features/i386/i386-avx.c @V@/gdb/features/i386/i32-a.c
+@V@/gdb/features/i386/i386-avx-linux.xml @V@/gdb/features/i386/i32-al.xml
+@V@/gdb/features/i386/i386-avx.xml @V@/gdb/features/i386/i32-a.xml
 @V@/gdb/f-exp.tab.c @V@/gdb/f-exp_tab.c
 @V@/gdb/gdbserver/linux-cris-low.c @V@/gdb/gdbserver/lx-cris.c
 @V@/gdb/gdbserver/linux-crisv32-low.c @V@/gdb/gdbserver/lx-cris32.c
--- ./gdb/doc/ChangeLog.xcr	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/doc/ChangeLog.xcr	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,31 @@
+2010-03-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.texinfo (General Query Packets): Replace "x86=xml" with
+	"xmlRegisters+".
+
+2010-03-12  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.texinfo (General Query Packets): Updated.
+	(i386 Features): Likewise.
+
+2010-03-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.texinfo (i386 Features): Make org.gnu.gdb.i386.avx optional.
+
+2010-03-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.texinfo (General Query Packets): Remove x86:xstate extension.
+	Document x86=xml extension in gdb remote protocol.
+
+2010-02-11  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.texinfo (i386 Features): Add org.gnu.gdb.i386.avx.
+
+2010-02-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.texinfo: Remove x86:xstate from stub reply.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.texinfo: Document x86:xstate extension in gdb remote
+	protocol.
--- ./gdb/doc/ChangeLog.xml	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/doc/ChangeLog.xml	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,28 @@
+2010-03-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.texinfo (General Query Packets): Updated.
+
+2010-03-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.texinfo (General Query Packets): Updated.
+
+2010-03-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.texinfo (General Query Packets): Remove extra supports.
+
+2010-03-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.texinfo (General Query Packets): Add xmlRegisters.
+
+2010-02-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.texinfo (Predefined Target Types): Add i387_ext,
+	i386_eflags and i386_mxcsr.
+
+2010-02-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.texinfo: Update i386 target features.
+
+2010-02-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.texinfo: Document i386 target features.
--- ./gdb/features/Makefile	2010-02-08 06:08:46.000000000 +0100
+++ ./gdb/features/Makefile	2010-04-03 21:12:32.000000000 +0200
@@ -33,6 +33,8 @@
 WHICH = arm-with-iwmmxt arm-with-vfpv2 arm-with-vfpv3 arm-with-neon \
 	i386/i386 i386/i386-linux \
 	i386/amd64 i386/amd64-linux \
+	i386/i386-avx i386/i386-avx-linux \
+	i386/amd64-avx i386/amd64-avx-linux \
 	mips-linux mips64-linux \
 	rs6000/powerpc-32l rs6000/powerpc-altivec32l rs6000/powerpc-e500l \
 	rs6000/powerpc-64l rs6000/powerpc-altivec64l rs6000/powerpc-vsx32l \
@@ -45,6 +47,10 @@ i386/i386-expedite = ebp,esp,eip
 i386/i386-linux-expedite = ebp,esp,eip
 i386/amd64-expedite = rbp,rsp,rip
 i386/amd64-linux-expedite = rbp,rsp,rip
+i386/i386-avx-expedite = ebp,esp,eip
+i386/i386-avx-linux-expedite = ebp,esp,eip
+i386/amd64-avx-expedite = rbp,rsp,rip
+i386/amd64-avx-linux-expedite = rbp,rsp,rip
 mips-expedite = r29,pc
 mips64-expedite = r29,pc
 powerpc-expedite = r1,pc
@@ -90,3 +96,9 @@ $(outdir)/i386/i386-linux.dat: i386/32bi
 $(outdir)/i386/amd64.dat: i386/64bit-core.xml i386/64bit-sse.xml
 $(outdir)/i386/amd64-linux.dat: i386/64bit-core.xml i386/64bit-sse.xml \
 			        i386/64bit-linux.xml
+$(outdir)/i386/i386-avx.dat: i386/32bit-core.xml i386/32bit-avx.xml
+$(outdir)/i386/i386-avx-linux.dat: i386/32bit-core.xml i386/32bit-avx.xml \
+			       i386/32bit-linux.xml
+$(outdir)/i386/amd64-avx.dat: i386/64bit-core.xml i386/64bit-avx.xml
+$(outdir)/i386/amd64-avx-linux.dat: i386/64bit-core.xml i386/64bit-avx.xml \
+				    i386/64bit-linux.xml
--- ./gdb/features/i386/32bit-avx.xml	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/features/i386/32bit-avx.xml	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,18 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2010 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<feature name="org.gnu.gdb.i386.avx">
+  <reg name="ymm0h" bitsize="128" type="uint128"/>
+  <reg name="ymm1h" bitsize="128" type="uint128"/>
+  <reg name="ymm2h" bitsize="128" type="uint128"/>
+  <reg name="ymm3h" bitsize="128" type="uint128"/>
+  <reg name="ymm4h" bitsize="128" type="uint128"/>
+  <reg name="ymm5h" bitsize="128" type="uint128"/>
+  <reg name="ymm6h" bitsize="128" type="uint128"/>
+  <reg name="ymm7h" bitsize="128" type="uint128"/>
+</feature>
--- ./gdb/features/i386/64bit-avx.xml	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/features/i386/64bit-avx.xml	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,26 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2010 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<feature name="org.gnu.gdb.i386.avx">
+  <reg name="ymm0h" bitsize="128" type="uint128"/>
+  <reg name="ymm1h" bitsize="128" type="uint128"/>
+  <reg name="ymm2h" bitsize="128" type="uint128"/>
+  <reg name="ymm3h" bitsize="128" type="uint128"/>
+  <reg name="ymm4h" bitsize="128" type="uint128"/>
+  <reg name="ymm5h" bitsize="128" type="uint128"/>
+  <reg name="ymm6h" bitsize="128" type="uint128"/>
+  <reg name="ymm7h" bitsize="128" type="uint128"/>
+  <reg name="ymm8h" bitsize="128" type="uint128"/>
+  <reg name="ymm9h" bitsize="128" type="uint128"/>
+  <reg name="ymm10h" bitsize="128" type="uint128"/>
+  <reg name="ymm11h" bitsize="128" type="uint128"/>
+  <reg name="ymm12h" bitsize="128" type="uint128"/>
+  <reg name="ymm13h" bitsize="128" type="uint128"/>
+  <reg name="ymm14h" bitsize="128" type="uint128"/>
+  <reg name="ymm15h" bitsize="128" type="uint128"/>
+</feature>
--- ./gdb/features/i386/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/features/i386/Makefile	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,5 @@
+include Makefile
+
+XMLTOC = $(addsuffix .xml, $(filter i386/%, $(WHICH)))
+CFILES = $(patsubst %.xml,%.c,$(XMLTOC))
+cfiles: $(CFILES)
--- ./gdb/features/i386/amd64-avx-linux.c	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/features/i386/amd64-avx-linux.c	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,171 @@
+/* THIS FILE IS GENERATED.  Original: amd64-avx-linux.xml */
+
+#include "defs.h"
+#include "osabi.h"
+#include "target-descriptions.h"
+
+struct target_desc *tdesc_amd64_avx_linux;
+static void
+initialize_tdesc_amd64_avx_linux (void)
+{
+  struct target_desc *result = allocate_target_description ();
+  struct tdesc_feature *feature;
+  struct tdesc_type *field_type, *type;
+
+  set_tdesc_architecture (result, bfd_scan_arch ("i386:x86-64"));
+
+  set_tdesc_osabi (result, osabi_from_tdesc_string ("GNU/Linux"));
+
+  feature = tdesc_create_feature (result, "org.gnu.gdb.i386.core");
+  field_type = tdesc_create_flags (feature, "i386_eflags", 4);
+  tdesc_add_flag (field_type, 0, "CF");
+  tdesc_add_flag (field_type, 1, "");
+  tdesc_add_flag (field_type, 2, "PF");
+  tdesc_add_flag (field_type, 4, "AF");
+  tdesc_add_flag (field_type, 6, "ZF");
+  tdesc_add_flag (field_type, 7, "SF");
+  tdesc_add_flag (field_type, 8, "TF");
+  tdesc_add_flag (field_type, 9, "IF");
+  tdesc_add_flag (field_type, 10, "DF");
+  tdesc_add_flag (field_type, 11, "OF");
+  tdesc_add_flag (field_type, 14, "NT");
+  tdesc_add_flag (field_type, 16, "RF");
+  tdesc_add_flag (field_type, 17, "VM");
+  tdesc_add_flag (field_type, 18, "AC");
+  tdesc_add_flag (field_type, 19, "VIF");
+  tdesc_add_flag (field_type, 20, "VIP");
+  tdesc_add_flag (field_type, 21, "ID");
+
+  tdesc_create_reg (feature, "rax", 0, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "rbx", 1, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "rcx", 2, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "rdx", 3, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "rsi", 4, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "rdi", 5, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "rbp", 6, 1, NULL, 64, "data_ptr");
+  tdesc_create_reg (feature, "rsp", 7, 1, NULL, 64, "data_ptr");
+  tdesc_create_reg (feature, "r8", 8, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "r9", 9, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "r10", 10, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "r11", 11, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "r12", 12, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "r13", 13, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "r14", 14, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "r15", 15, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "rip", 16, 1, NULL, 64, "code_ptr");
+  tdesc_create_reg (feature, "eflags", 17, 1, NULL, 32, "i386_eflags");
+  tdesc_create_reg (feature, "cs", 18, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "ss", 19, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "ds", 20, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "es", 21, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "fs", 22, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "gs", 23, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "st0", 24, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st1", 25, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st2", 26, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st3", 27, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st4", 28, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st5", 29, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st6", 30, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st7", 31, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "fctrl", 32, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fstat", 33, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "ftag", 34, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fiseg", 35, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fioff", 36, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "foseg", 37, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fooff", 38, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fop", 39, 1, "float", 32, "int");
+
+  feature = tdesc_create_feature (result, "org.gnu.gdb.i386.sse");
+  field_type = tdesc_named_type (feature, "ieee_single");
+  tdesc_create_vector (feature, "v4f", field_type, 4);
+
+  field_type = tdesc_named_type (feature, "ieee_double");
+  tdesc_create_vector (feature, "v2d", field_type, 2);
+
+  field_type = tdesc_named_type (feature, "int8");
+  tdesc_create_vector (feature, "v16i8", field_type, 16);
+
+  field_type = tdesc_named_type (feature, "int16");
+  tdesc_create_vector (feature, "v8i16", field_type, 8);
+
+  field_type = tdesc_named_type (feature, "int32");
+  tdesc_create_vector (feature, "v4i32", field_type, 4);
+
+  field_type = tdesc_named_type (feature, "int64");
+  tdesc_create_vector (feature, "v2i64", field_type, 2);
+
+  type = tdesc_create_union (feature, "vec128");
+  field_type = tdesc_named_type (feature, "v4f");
+  tdesc_add_field (type, "v4_float", field_type);
+  field_type = tdesc_named_type (feature, "v2d");
+  tdesc_add_field (type, "v2_double", field_type);
+  field_type = tdesc_named_type (feature, "v16i8");
+  tdesc_add_field (type, "v16_int8", field_type);
+  field_type = tdesc_named_type (feature, "v8i16");
+  tdesc_add_field (type, "v8_int16", field_type);
+  field_type = tdesc_named_type (feature, "v4i32");
+  tdesc_add_field (type, "v4_int32", field_type);
+  field_type = tdesc_named_type (feature, "v2i64");
+  tdesc_add_field (type, "v2_int64", field_type);
+  field_type = tdesc_named_type (feature, "uint128");
+  tdesc_add_field (type, "uint128", field_type);
+
+  field_type = tdesc_create_flags (feature, "i386_mxcsr", 4);
+  tdesc_add_flag (field_type, 0, "IE");
+  tdesc_add_flag (field_type, 1, "DE");
+  tdesc_add_flag (field_type, 2, "ZE");
+  tdesc_add_flag (field_type, 3, "OE");
+  tdesc_add_flag (field_type, 4, "UE");
+  tdesc_add_flag (field_type, 5, "PE");
+  tdesc_add_flag (field_type, 6, "DAZ");
+  tdesc_add_flag (field_type, 7, "IM");
+  tdesc_add_flag (field_type, 8, "DM");
+  tdesc_add_flag (field_type, 9, "ZM");
+  tdesc_add_flag (field_type, 10, "OM");
+  tdesc_add_flag (field_type, 11, "UM");
+  tdesc_add_flag (field_type, 12, "PM");
+  tdesc_add_flag (field_type, 15, "FZ");
+
+  tdesc_create_reg (feature, "xmm0", 40, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm1", 41, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm2", 42, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm3", 43, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm4", 44, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm5", 45, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm6", 46, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm7", 47, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm8", 48, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm9", 49, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm10", 50, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm11", 51, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm12", 52, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm13", 53, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm14", 54, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm15", 55, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "mxcsr", 56, 1, "vector", 32, "i386_mxcsr");
+
+  feature = tdesc_create_feature (result, "org.gnu.gdb.i386.linux");
+  tdesc_create_reg (feature, "orig_rax", 57, 1, NULL, 64, "int");
+
+  feature = tdesc_create_feature (result, "org.gnu.gdb.i386.avx");
+  tdesc_create_reg (feature, "ymm0h", 58, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm1h", 59, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm2h", 60, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm3h", 61, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm4h", 62, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm5h", 63, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm6h", 64, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm7h", 65, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm8h", 66, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm9h", 67, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm10h", 68, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm11h", 69, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm12h", 70, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm13h", 71, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm14h", 72, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm15h", 73, 1, NULL, 128, "uint128");
+
+  tdesc_amd64_avx_linux = result;
+}
--- ./gdb/features/i386/amd64-avx-linux.xml	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/features/i386/amd64-avx-linux.xml	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,18 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2010 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!-- AMD64 with AVX - Includes Linux-only special "register".  -->
+
+<!DOCTYPE target SYSTEM "gdb-target.dtd">
+<target>
+  <architecture>i386:x86-64</architecture>
+  <osabi>GNU/Linux</osabi>
+  <xi:include href="64bit-core.xml"/>
+  <xi:include href="64bit-sse.xml"/>
+  <xi:include href="64bit-linux.xml"/>
+  <xi:include href="64bit-avx.xml"/>
+</target>
--- ./gdb/features/i386/amd64-avx.c	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/features/i386/amd64-avx.c	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,166 @@
+/* THIS FILE IS GENERATED.  Original: amd64-avx.xml */
+
+#include "defs.h"
+#include "osabi.h"
+#include "target-descriptions.h"
+
+struct target_desc *tdesc_amd64_avx;
+static void
+initialize_tdesc_amd64_avx (void)
+{
+  struct target_desc *result = allocate_target_description ();
+  struct tdesc_feature *feature;
+  struct tdesc_type *field_type, *type;
+
+  set_tdesc_architecture (result, bfd_scan_arch ("i386:x86-64"));
+
+  feature = tdesc_create_feature (result, "org.gnu.gdb.i386.core");
+  field_type = tdesc_create_flags (feature, "i386_eflags", 4);
+  tdesc_add_flag (field_type, 0, "CF");
+  tdesc_add_flag (field_type, 1, "");
+  tdesc_add_flag (field_type, 2, "PF");
+  tdesc_add_flag (field_type, 4, "AF");
+  tdesc_add_flag (field_type, 6, "ZF");
+  tdesc_add_flag (field_type, 7, "SF");
+  tdesc_add_flag (field_type, 8, "TF");
+  tdesc_add_flag (field_type, 9, "IF");
+  tdesc_add_flag (field_type, 10, "DF");
+  tdesc_add_flag (field_type, 11, "OF");
+  tdesc_add_flag (field_type, 14, "NT");
+  tdesc_add_flag (field_type, 16, "RF");
+  tdesc_add_flag (field_type, 17, "VM");
+  tdesc_add_flag (field_type, 18, "AC");
+  tdesc_add_flag (field_type, 19, "VIF");
+  tdesc_add_flag (field_type, 20, "VIP");
+  tdesc_add_flag (field_type, 21, "ID");
+
+  tdesc_create_reg (feature, "rax", 0, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "rbx", 1, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "rcx", 2, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "rdx", 3, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "rsi", 4, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "rdi", 5, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "rbp", 6, 1, NULL, 64, "data_ptr");
+  tdesc_create_reg (feature, "rsp", 7, 1, NULL, 64, "data_ptr");
+  tdesc_create_reg (feature, "r8", 8, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "r9", 9, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "r10", 10, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "r11", 11, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "r12", 12, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "r13", 13, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "r14", 14, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "r15", 15, 1, NULL, 64, "int64");
+  tdesc_create_reg (feature, "rip", 16, 1, NULL, 64, "code_ptr");
+  tdesc_create_reg (feature, "eflags", 17, 1, NULL, 32, "i386_eflags");
+  tdesc_create_reg (feature, "cs", 18, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "ss", 19, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "ds", 20, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "es", 21, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "fs", 22, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "gs", 23, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "st0", 24, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st1", 25, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st2", 26, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st3", 27, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st4", 28, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st5", 29, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st6", 30, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st7", 31, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "fctrl", 32, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fstat", 33, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "ftag", 34, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fiseg", 35, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fioff", 36, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "foseg", 37, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fooff", 38, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fop", 39, 1, "float", 32, "int");
+
+  feature = tdesc_create_feature (result, "org.gnu.gdb.i386.sse");
+  field_type = tdesc_named_type (feature, "ieee_single");
+  tdesc_create_vector (feature, "v4f", field_type, 4);
+
+  field_type = tdesc_named_type (feature, "ieee_double");
+  tdesc_create_vector (feature, "v2d", field_type, 2);
+
+  field_type = tdesc_named_type (feature, "int8");
+  tdesc_create_vector (feature, "v16i8", field_type, 16);
+
+  field_type = tdesc_named_type (feature, "int16");
+  tdesc_create_vector (feature, "v8i16", field_type, 8);
+
+  field_type = tdesc_named_type (feature, "int32");
+  tdesc_create_vector (feature, "v4i32", field_type, 4);
+
+  field_type = tdesc_named_type (feature, "int64");
+  tdesc_create_vector (feature, "v2i64", field_type, 2);
+
+  type = tdesc_create_union (feature, "vec128");
+  field_type = tdesc_named_type (feature, "v4f");
+  tdesc_add_field (type, "v4_float", field_type);
+  field_type = tdesc_named_type (feature, "v2d");
+  tdesc_add_field (type, "v2_double", field_type);
+  field_type = tdesc_named_type (feature, "v16i8");
+  tdesc_add_field (type, "v16_int8", field_type);
+  field_type = tdesc_named_type (feature, "v8i16");
+  tdesc_add_field (type, "v8_int16", field_type);
+  field_type = tdesc_named_type (feature, "v4i32");
+  tdesc_add_field (type, "v4_int32", field_type);
+  field_type = tdesc_named_type (feature, "v2i64");
+  tdesc_add_field (type, "v2_int64", field_type);
+  field_type = tdesc_named_type (feature, "uint128");
+  tdesc_add_field (type, "uint128", field_type);
+
+  field_type = tdesc_create_flags (feature, "i386_mxcsr", 4);
+  tdesc_add_flag (field_type, 0, "IE");
+  tdesc_add_flag (field_type, 1, "DE");
+  tdesc_add_flag (field_type, 2, "ZE");
+  tdesc_add_flag (field_type, 3, "OE");
+  tdesc_add_flag (field_type, 4, "UE");
+  tdesc_add_flag (field_type, 5, "PE");
+  tdesc_add_flag (field_type, 6, "DAZ");
+  tdesc_add_flag (field_type, 7, "IM");
+  tdesc_add_flag (field_type, 8, "DM");
+  tdesc_add_flag (field_type, 9, "ZM");
+  tdesc_add_flag (field_type, 10, "OM");
+  tdesc_add_flag (field_type, 11, "UM");
+  tdesc_add_flag (field_type, 12, "PM");
+  tdesc_add_flag (field_type, 15, "FZ");
+
+  tdesc_create_reg (feature, "xmm0", 40, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm1", 41, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm2", 42, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm3", 43, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm4", 44, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm5", 45, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm6", 46, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm7", 47, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm8", 48, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm9", 49, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm10", 50, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm11", 51, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm12", 52, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm13", 53, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm14", 54, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm15", 55, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "mxcsr", 56, 1, "vector", 32, "i386_mxcsr");
+
+  feature = tdesc_create_feature (result, "org.gnu.gdb.i386.avx");
+  tdesc_create_reg (feature, "ymm0h", 57, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm1h", 58, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm2h", 59, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm3h", 60, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm4h", 61, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm5h", 62, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm6h", 63, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm7h", 64, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm8h", 65, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm9h", 66, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm10h", 67, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm11h", 68, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm12h", 69, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm13h", 70, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm14h", 71, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm15h", 72, 1, NULL, 128, "uint128");
+
+  tdesc_amd64_avx = result;
+}
--- ./gdb/features/i386/amd64-avx.xml	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/features/i386/amd64-avx.xml	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,16 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2010 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!-- AMD64 with AVX -->
+
+<!DOCTYPE target SYSTEM "gdb-target.dtd">
+<target>
+  <architecture>i386:x86-64</architecture>
+  <xi:include href="64bit-core.xml"/>
+  <xi:include href="64bit-sse.xml"/>
+  <xi:include href="64bit-avx.xml"/>
+</target>
--- ./gdb/features/i386/i386-avx-linux.c	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/features/i386/i386-avx-linux.c	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,147 @@
+/* THIS FILE IS GENERATED.  Original: i386-avx-linux.xml */
+
+#include "defs.h"
+#include "osabi.h"
+#include "target-descriptions.h"
+
+struct target_desc *tdesc_i386_avx_linux;
+static void
+initialize_tdesc_i386_avx_linux (void)
+{
+  struct target_desc *result = allocate_target_description ();
+  struct tdesc_feature *feature;
+  struct tdesc_type *field_type, *type;
+
+  set_tdesc_architecture (result, bfd_scan_arch ("i386"));
+
+  set_tdesc_osabi (result, osabi_from_tdesc_string ("GNU/Linux"));
+
+  feature = tdesc_create_feature (result, "org.gnu.gdb.i386.core");
+  field_type = tdesc_create_flags (feature, "i386_eflags", 4);
+  tdesc_add_flag (field_type, 0, "CF");
+  tdesc_add_flag (field_type, 1, "");
+  tdesc_add_flag (field_type, 2, "PF");
+  tdesc_add_flag (field_type, 4, "AF");
+  tdesc_add_flag (field_type, 6, "ZF");
+  tdesc_add_flag (field_type, 7, "SF");
+  tdesc_add_flag (field_type, 8, "TF");
+  tdesc_add_flag (field_type, 9, "IF");
+  tdesc_add_flag (field_type, 10, "DF");
+  tdesc_add_flag (field_type, 11, "OF");
+  tdesc_add_flag (field_type, 14, "NT");
+  tdesc_add_flag (field_type, 16, "RF");
+  tdesc_add_flag (field_type, 17, "VM");
+  tdesc_add_flag (field_type, 18, "AC");
+  tdesc_add_flag (field_type, 19, "VIF");
+  tdesc_add_flag (field_type, 20, "VIP");
+  tdesc_add_flag (field_type, 21, "ID");
+
+  tdesc_create_reg (feature, "eax", 0, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "ecx", 1, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "edx", 2, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "ebx", 3, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "esp", 4, 1, NULL, 32, "data_ptr");
+  tdesc_create_reg (feature, "ebp", 5, 1, NULL, 32, "data_ptr");
+  tdesc_create_reg (feature, "esi", 6, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "edi", 7, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "eip", 8, 1, NULL, 32, "code_ptr");
+  tdesc_create_reg (feature, "eflags", 9, 1, NULL, 32, "i386_eflags");
+  tdesc_create_reg (feature, "cs", 10, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "ss", 11, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "ds", 12, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "es", 13, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "fs", 14, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "gs", 15, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "st0", 16, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st1", 17, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st2", 18, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st3", 19, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st4", 20, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st5", 21, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st6", 22, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st7", 23, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "fctrl", 24, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fstat", 25, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "ftag", 26, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fiseg", 27, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fioff", 28, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "foseg", 29, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fooff", 30, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fop", 31, 1, "float", 32, "int");
+
+  feature = tdesc_create_feature (result, "org.gnu.gdb.i386.sse");
+  field_type = tdesc_named_type (feature, "ieee_single");
+  tdesc_create_vector (feature, "v4f", field_type, 4);
+
+  field_type = tdesc_named_type (feature, "ieee_double");
+  tdesc_create_vector (feature, "v2d", field_type, 2);
+
+  field_type = tdesc_named_type (feature, "int8");
+  tdesc_create_vector (feature, "v16i8", field_type, 16);
+
+  field_type = tdesc_named_type (feature, "int16");
+  tdesc_create_vector (feature, "v8i16", field_type, 8);
+
+  field_type = tdesc_named_type (feature, "int32");
+  tdesc_create_vector (feature, "v4i32", field_type, 4);
+
+  field_type = tdesc_named_type (feature, "int64");
+  tdesc_create_vector (feature, "v2i64", field_type, 2);
+
+  type = tdesc_create_union (feature, "vec128");
+  field_type = tdesc_named_type (feature, "v4f");
+  tdesc_add_field (type, "v4_float", field_type);
+  field_type = tdesc_named_type (feature, "v2d");
+  tdesc_add_field (type, "v2_double", field_type);
+  field_type = tdesc_named_type (feature, "v16i8");
+  tdesc_add_field (type, "v16_int8", field_type);
+  field_type = tdesc_named_type (feature, "v8i16");
+  tdesc_add_field (type, "v8_int16", field_type);
+  field_type = tdesc_named_type (feature, "v4i32");
+  tdesc_add_field (type, "v4_int32", field_type);
+  field_type = tdesc_named_type (feature, "v2i64");
+  tdesc_add_field (type, "v2_int64", field_type);
+  field_type = tdesc_named_type (feature, "uint128");
+  tdesc_add_field (type, "uint128", field_type);
+
+  field_type = tdesc_create_flags (feature, "i386_mxcsr", 4);
+  tdesc_add_flag (field_type, 0, "IE");
+  tdesc_add_flag (field_type, 1, "DE");
+  tdesc_add_flag (field_type, 2, "ZE");
+  tdesc_add_flag (field_type, 3, "OE");
+  tdesc_add_flag (field_type, 4, "UE");
+  tdesc_add_flag (field_type, 5, "PE");
+  tdesc_add_flag (field_type, 6, "DAZ");
+  tdesc_add_flag (field_type, 7, "IM");
+  tdesc_add_flag (field_type, 8, "DM");
+  tdesc_add_flag (field_type, 9, "ZM");
+  tdesc_add_flag (field_type, 10, "OM");
+  tdesc_add_flag (field_type, 11, "UM");
+  tdesc_add_flag (field_type, 12, "PM");
+  tdesc_add_flag (field_type, 15, "FZ");
+
+  tdesc_create_reg (feature, "xmm0", 32, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm1", 33, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm2", 34, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm3", 35, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm4", 36, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm5", 37, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm6", 38, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm7", 39, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "mxcsr", 40, 1, "vector", 32, "i386_mxcsr");
+
+  feature = tdesc_create_feature (result, "org.gnu.gdb.i386.linux");
+  tdesc_create_reg (feature, "orig_eax", 41, 1, NULL, 32, "int");
+
+  feature = tdesc_create_feature (result, "org.gnu.gdb.i386.avx");
+  tdesc_create_reg (feature, "ymm0h", 42, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm1h", 43, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm2h", 44, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm3h", 45, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm4h", 46, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm5h", 47, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm6h", 48, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm7h", 49, 1, NULL, 128, "uint128");
+
+  tdesc_i386_avx_linux = result;
+}
--- ./gdb/features/i386/i386-avx-linux.xml	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/features/i386/i386-avx-linux.xml	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,18 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2010 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!-- I386 with AVX- Includes Linux-only special "register".  -->
+
+<!DOCTYPE target SYSTEM "gdb-target.dtd">
+<target>
+  <architecture>i386</architecture>
+  <osabi>GNU/Linux</osabi>
+  <xi:include href="32bit-core.xml"/>
+  <xi:include href="32bit-sse.xml"/>
+  <xi:include href="32bit-linux.xml"/>
+  <xi:include href="32bit-avx.xml"/>
+</target>
--- ./gdb/features/i386/i386-avx.c	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/features/i386/i386-avx.c	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,142 @@
+/* THIS FILE IS GENERATED.  Original: i386-avx.xml */
+
+#include "defs.h"
+#include "osabi.h"
+#include "target-descriptions.h"
+
+struct target_desc *tdesc_i386_avx;
+static void
+initialize_tdesc_i386_avx (void)
+{
+  struct target_desc *result = allocate_target_description ();
+  struct tdesc_feature *feature;
+  struct tdesc_type *field_type, *type;
+
+  set_tdesc_architecture (result, bfd_scan_arch ("i386"));
+
+  feature = tdesc_create_feature (result, "org.gnu.gdb.i386.core");
+  field_type = tdesc_create_flags (feature, "i386_eflags", 4);
+  tdesc_add_flag (field_type, 0, "CF");
+  tdesc_add_flag (field_type, 1, "");
+  tdesc_add_flag (field_type, 2, "PF");
+  tdesc_add_flag (field_type, 4, "AF");
+  tdesc_add_flag (field_type, 6, "ZF");
+  tdesc_add_flag (field_type, 7, "SF");
+  tdesc_add_flag (field_type, 8, "TF");
+  tdesc_add_flag (field_type, 9, "IF");
+  tdesc_add_flag (field_type, 10, "DF");
+  tdesc_add_flag (field_type, 11, "OF");
+  tdesc_add_flag (field_type, 14, "NT");
+  tdesc_add_flag (field_type, 16, "RF");
+  tdesc_add_flag (field_type, 17, "VM");
+  tdesc_add_flag (field_type, 18, "AC");
+  tdesc_add_flag (field_type, 19, "VIF");
+  tdesc_add_flag (field_type, 20, "VIP");
+  tdesc_add_flag (field_type, 21, "ID");
+
+  tdesc_create_reg (feature, "eax", 0, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "ecx", 1, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "edx", 2, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "ebx", 3, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "esp", 4, 1, NULL, 32, "data_ptr");
+  tdesc_create_reg (feature, "ebp", 5, 1, NULL, 32, "data_ptr");
+  tdesc_create_reg (feature, "esi", 6, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "edi", 7, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "eip", 8, 1, NULL, 32, "code_ptr");
+  tdesc_create_reg (feature, "eflags", 9, 1, NULL, 32, "i386_eflags");
+  tdesc_create_reg (feature, "cs", 10, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "ss", 11, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "ds", 12, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "es", 13, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "fs", 14, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "gs", 15, 1, NULL, 32, "int32");
+  tdesc_create_reg (feature, "st0", 16, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st1", 17, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st2", 18, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st3", 19, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st4", 20, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st5", 21, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st6", 22, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st7", 23, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "fctrl", 24, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fstat", 25, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "ftag", 26, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fiseg", 27, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fioff", 28, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "foseg", 29, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fooff", 30, 1, "float", 32, "int");
+  tdesc_create_reg (feature, "fop", 31, 1, "float", 32, "int");
+
+  feature = tdesc_create_feature (result, "org.gnu.gdb.i386.sse");
+  field_type = tdesc_named_type (feature, "ieee_single");
+  tdesc_create_vector (feature, "v4f", field_type, 4);
+
+  field_type = tdesc_named_type (feature, "ieee_double");
+  tdesc_create_vector (feature, "v2d", field_type, 2);
+
+  field_type = tdesc_named_type (feature, "int8");
+  tdesc_create_vector (feature, "v16i8", field_type, 16);
+
+  field_type = tdesc_named_type (feature, "int16");
+  tdesc_create_vector (feature, "v8i16", field_type, 8);
+
+  field_type = tdesc_named_type (feature, "int32");
+  tdesc_create_vector (feature, "v4i32", field_type, 4);
+
+  field_type = tdesc_named_type (feature, "int64");
+  tdesc_create_vector (feature, "v2i64", field_type, 2);
+
+  type = tdesc_create_union (feature, "vec128");
+  field_type = tdesc_named_type (feature, "v4f");
+  tdesc_add_field (type, "v4_float", field_type);
+  field_type = tdesc_named_type (feature, "v2d");
+  tdesc_add_field (type, "v2_double", field_type);
+  field_type = tdesc_named_type (feature, "v16i8");
+  tdesc_add_field (type, "v16_int8", field_type);
+  field_type = tdesc_named_type (feature, "v8i16");
+  tdesc_add_field (type, "v8_int16", field_type);
+  field_type = tdesc_named_type (feature, "v4i32");
+  tdesc_add_field (type, "v4_int32", field_type);
+  field_type = tdesc_named_type (feature, "v2i64");
+  tdesc_add_field (type, "v2_int64", field_type);
+  field_type = tdesc_named_type (feature, "uint128");
+  tdesc_add_field (type, "uint128", field_type);
+
+  field_type = tdesc_create_flags (feature, "i386_mxcsr", 4);
+  tdesc_add_flag (field_type, 0, "IE");
+  tdesc_add_flag (field_type, 1, "DE");
+  tdesc_add_flag (field_type, 2, "ZE");
+  tdesc_add_flag (field_type, 3, "OE");
+  tdesc_add_flag (field_type, 4, "UE");
+  tdesc_add_flag (field_type, 5, "PE");
+  tdesc_add_flag (field_type, 6, "DAZ");
+  tdesc_add_flag (field_type, 7, "IM");
+  tdesc_add_flag (field_type, 8, "DM");
+  tdesc_add_flag (field_type, 9, "ZM");
+  tdesc_add_flag (field_type, 10, "OM");
+  tdesc_add_flag (field_type, 11, "UM");
+  tdesc_add_flag (field_type, 12, "PM");
+  tdesc_add_flag (field_type, 15, "FZ");
+
+  tdesc_create_reg (feature, "xmm0", 32, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm1", 33, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm2", 34, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm3", 35, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm4", 36, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm5", 37, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm6", 38, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "xmm7", 39, 1, NULL, 128, "vec128");
+  tdesc_create_reg (feature, "mxcsr", 40, 1, "vector", 32, "i386_mxcsr");
+
+  feature = tdesc_create_feature (result, "org.gnu.gdb.i386.avx");
+  tdesc_create_reg (feature, "ymm0h", 41, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm1h", 42, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm2h", 43, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm3h", 44, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm4h", 45, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm5h", 46, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm6h", 47, 1, NULL, 128, "uint128");
+  tdesc_create_reg (feature, "ymm7h", 48, 1, NULL, 128, "uint128");
+
+  tdesc_i386_avx = result;
+}
--- ./gdb/features/i386/i386-avx.xml	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/features/i386/i386-avx.xml	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,16 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2010 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!-- I386 with AVX -->
+
+<!DOCTYPE target SYSTEM "gdb-target.dtd">
+<target>
+  <architecture>i386</architecture>
+  <xi:include href="32bit-core.xml"/>
+  <xi:include href="32bit-sse.xml"/>
+  <xi:include href="32bit-avx.xml"/>
+</target>
--- ./gdb/gdbserver/ChangeLog.avx	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/gdbserver/ChangeLog.avx	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,84 @@
+2010-03-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (x86_linux_process_qsupported): Use
+	I386_XSTATE_SSE_SIZE instead of I386_XSTATE_MAX_SIZE.  Use
+	I386_XSTATE_SIZE.
+
+2010-03-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Updated.
+	(i387_xsave_to_cache): Likewise.
+	(x86_xcr0): Likewise.
+	* linux-x86-low.c (x86_linux_process_qsupported): Likewise.
+
+2010-03-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Makefile.in (i386-xstate.o): Removed.
+
+	* configure.srv (srv_tgtobj): Remove i386-xstate.o for
+	i[34567]86-*-linux* and x86_64-*-linux*.
+
+	* i387-fp.c (x86_xcr0): Initialized to XSTATE_SSE_MASK.
+	(x86_xcr0_init): Removed.
+
+	* i387-fp.h (x86_xcr0_init): Removed.
+
+	* linux-x86-low.c (x86_linux_process_qsupported): Use
+	XSTATE_MAX_SIZE_N_OF_INT64 and XSTATE_MAX_SIZE.  Get xcr0
+	from XSAVE extended state.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Makefile.in (clean): Replace reg-i386-linux-avx.c with
+	reg-i386-avx-linux.c.
+	(reg-x86-64-avx.c): Fixed.
+	(reg-x86-64-avx-linux.c): Likewise.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* configure.srv (srv_tgtobj): Add xsave-nat.o for
+	i[34567]86-*-linux* and x86_64-*-linux*.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (x86_sse_unit): Renamed to ...
+	(x86_vector_unit): This.
+	(x86_get_sse_unit): Renamed to ...
+	(x86_get_vector_unit): This.
+	(i387_cache_to_fxsave): Updated.
+	* linux-x86-low.c (x86_arch_setup): Likewise.
+
+2010-01-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.h (x86_sse_unit): Renamed to ...
+	(x86_vector_unit): This.
+
+2009-10-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Makefile.in (clean): Also remove reg-i386-avx.c,
+	reg-i386-avx-linux.c, reg-x86-64-avx.c and reg-x86-64-avx-linux.c.
+	(reg-i386-avx.o): New target.
+	(reg-i386-avx.c): Likewise.
+	(reg-i386-avx-linux.o): Likewise.
+	(reg-i386-avx-linux.c): Likewise.
+	(reg-x86-64-avx.o): Likewise.
+	(reg-x86-64-avx.c): Likewise.
+	(reg-x86-64-avx-linux.o): Likewise.
+	(reg-x86-64-avx-linux.c): Likewise.
+
+	* gdbserver/configure.srv (srv_regobj): Add reg-i386-avx-linux.o
+	for i[34567]86-*-linux*.  Add reg-x86-64-avx-linux.o and
+	reg-i386-avx-linux.o for x86_64-*-linux*.
+
+	* i387-fp.c (x86_sse_unit): New.
+	(x86_get_sse_unit): Likewise.
+	(i387_cache_to_fxsave): Handle x86_sse_unit. Support fake
+	AVX registers.
+	(i387_fxsave_to_cache): Likewise.
+
+	* i387-fp.h (x86_sse_unit): New.
+	(x86_get_sse_unit): Likewise.
+
+	* linux-x86-low.c (init_registers_i386_avx_linux): New.
+	(init_registers_x86_64_avx_linux): Likewise.
+	(x86_arch_setup): Call x86_get_sse_unit () to handle x86_sse_unit.
--- ./gdb/gdbserver/ChangeLog.xcr	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/gdbserver/ChangeLog.xcr	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,373 @@
+2010-03-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c: Don't include <unistd.h>.
+
+2010-03-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (x86_linux_update_xmltarget): Call ptrace
+	only once.
+
+2010-03-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (use_xml): New.
+	(x86_linux_update_xmltarget): Likewise.
+	(x86_linux_process_qsupported): Use x86_linux_update_xmltarget.
+	(x86_arch_setup): Don't call init_registers_amd64_linux,
+	init_registers_i386_linux.  Don't set gdbserver_xmltarget.  Use
+	x86_linux_update_xmltarget.
+
+	* server.c (handle_query): Call target_process_qsupported with
+	NULL query first.
+
+2010-03-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (x86_linux_process_qsupported): Replace
+	uint64_t with unsigned long long.
+
+2010-03-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (x86_linux_process_qsupported): Check
+	"xmlRegisters=" instead of "xmlRegisters+".
+
+2010-03-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (target_regsets): Always use EXTENDED_REGS
+	with NT_X86_XSTATE.
+
+2010-03-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (xmltarget_amd64_linux_no_xml): New.
+	(xmltarget_i386_linux_no_xml): Likewise.
+	(x86_linux_process_qsupported): Remove use_xml.  Update
+	gdbserver_xmltarget.
+	(x86_arch_setup): Set gdbserver_xmltarget to
+	xmltarget_amd64_linux_no_xml/xmltarget_i386_linux_no_xml.
+
+	* server.c (use_xml): Removed.
+	(get_features_xml): Updated.
+	(handle_query): Don't call target_process_qsupported with NULL.
+
+	* server.h (use_xml): Removed.
+
+2010-03-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c: Include <unistd.h>.
+	(x86_linux_process_qsupported): Use getpid.
+
+2010-03-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (x86_linux_process_qsupported): Replace
+	unsigned long long with uint64_t.
+
+2010-03-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (x86_linux_process_qsupported): Set use_xml
+	to 1 if XML is supported.
+
+2010-03-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* server.c (handle_query): Don't check "x86:xstate=".
+
+2010-03-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (x86_linux_process_qsupported): Check
+	xmlRegisters+ instead of x86=xml.
+
+	* server.c (USE_XML): Default to 0.
+	(use_xml): Initialize to USE_XML.
+
+2010-03-12  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Replace bit_I386_XSTATE_XXX
+	with I386_XSTATE_XXX.
+	(i387_xsave_to_cache): Likewise.
+
+2010-03-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Check bit_I386_XSTATE_X87.
+	(i387_xsave_to_cache): Likewise.
+
+2010-03-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Optimized.
+
+2010-03-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Handle upper YMM registers.
+	(i387_xsave_to_cache): Likewise.
+
+	* linux-x86-low.c (x86_linux_process_qsupported): Check x86=xml.
+
+2010-02-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Also check x87 registers.
+	(i387_xsave_to_cache): Likewise.
+
+	* linux-x86-low.c: Include <sys/uio.h>.
+	(x86_linux_process_qsupported): Support AVX only if
+	PTRACE_GETREGSET works.
+
+2010-02-13  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Check x86_xcr0 instead of
+	x86_vector_unit.
+	(i387_xsave_to_cache): Likewise.
+	(x86_vector_unit): Removed.
+	(x86_vector_unit_init): Likewise.
+	(x86_xcr0): New.
+	(x86_xcr0_init): Likewise.
+
+	* i387-fp.h (x86_vector_unit): Removed.
+	(x86_vector_unit_init): Likewise.
+	(x86_xcr0): New.
+	(x86_xcr0_init): Likewise.
+
+	* linux-x86-low.c (x86_linux_process_qsupported): Check x86_xcr0
+	instead of x86_vector_unit.
+
+2010-02-11  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-arm-low.c (target_regsets): Initialize nt_type to 0.
+	* linux-crisv32-low.c (target_regsets): Likewise.
+	* linux-m68k-low.c (target_regsets): Likewise.
+	* linux-mips-low.c (target_regsets): Likewise.
+	* linux-ppc-low.c (target_regsets): Likewise.
+	* linux-s390-low.c (target_regsets): Likewise.
+	* linux-sh-low.c (target_regsets): Likewise.
+	* linux-sparc-low.c (target_regsets): Likewise.
+	* linux-xtensa-low.c (target_regsets): Likewise.
+
+2010-02-11  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-low.c (regsets_fetch_inferior_registers): Simplify
+	nt_type.
+	(regsets_store_inferior_registers): Likewise.
+
+2010-02-10  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-low.c: Include <sys/uio.h>.
+	(regsets_fetch_inferior_registers): Support nt_type.
+	(regsets_store_inferior_registers): Likewise.
+
+	* linux-low.h (regset_info): Add nt_type.
+
+	* linux-x86-low.c: Include "elf/common.h".  Don't include
+	"../config/i386/nm-linux-xstate.h".
+	(PTRACE_GETREGSET): New.
+	(PTRACE_SETREGSET): Likewise.
+	(target_regsets): Initialize nt_type.
+
+2010-02-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c: Replace PTRACE_GETXSTATEREGS with
+	PTRACE_GETREGSET in comments.
+
+2010-02-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c: Include "../config/i386/nm-linux-xstate.h".
+	(PTRACE_SETXSTATEREGS): Removed.
+	(PTRACE_SETXSTATEREGS): Likewise.
+	(target_regsets): Use PTRACE_GETREGSET/PTRACE_SETREGSET instead
+	of PTRACE_GETXSTATEREGS/PTRACE_SETXSTATEREGS.
+	(x86_linux_process_qsupported): Check PTRACE_GETREGSET instead
+	of PTRACE_GETXSTATEREGS.
+
+2010-02-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (x86_vector_unit_init): Properly check xcr0.
+
+	* linux-x86-low.c (x86_linux_process_qsupported): Set use_xml
+	to 0 and return for NULL query.  Set use_xml to 1 if there is
+	"x86:xstate=" in qSupported packet.
+
+	* server.c (get_features_xml): Optimized.
+	(handle_query): Call target_process_qsupported with NULL
+	query first.
+
+2010-02-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Remove unsigned from raw.
+	(i387_xsave_to_cache): Remove unsigned from raw and xmm.  Fix
+	a typo.
+
+2010-02-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (x86_linux_process_qsupported): Set use_xml
+	to 0 if there is no "x86:xstate=" in qSupported packet.
+
+	* server.c (use_xml): New.
+	(get_features_xml): Don't use XML file if use_xml is 0.
+	(handle_query): Always call target_process_qsupported.
+
+	* server.h (use_xml): New.
+
+2010-02-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Makefile.in (clean): Updated.
+	(i386-avx.o): New.
+	(i386-avx.c): Likewise.
+	(i386-avx-linux.o): Likewise.
+	(i386-avx-linux.c): Likewise.
+	(x86-64-avx.o): Likewise.
+	(x86-64-avx.c): Likewise.
+	(x86-64-avx-linux.o): Likewise.
+	(x86-64-avx-linux.c): Likewise.
+
+	* configure.srv (srv_i386_regobj): Add i386-avx.o.
+	(srv_i386_linux_regobj): Add i386-avx-linux.o.
+	(srv_x86_64_regobj): Add x86-64-avx.o.
+	(srv_x86_64_linux_regobj): Add x86-64-avx-linux.o.
+
+2010-02-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* configure.srv (srv_i386_32bit_xmlfiles): Add
+	i386/32bit-avx.xml.
+	(srv_i386_64bit_xmlfiles): Add i386/64bit-avx.xml.
+	(srv_i386_xmlfiles): Add i386/i386-avx.xml.
+	(srv_x86_64_xmlfiles): Add i386/x86-64-avx.xml.
+	(srv_i386_linux_xmlfiles): Add i386/i386-avx-linux.xml.
+	(srv_x86_64_linux_xmlfiles): Add i386/x86-64-avx-linux.xml.
+
+2010-02-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-low.c (linux_process_qsupported): Make it void.
+	* linux-x86-low.c (x86_linux_process_qsupported): Likewise.
+
+	* linux-low.h (linux_target_ops): Make process_qsupported void.
+
+	* server.c (handle_query): Make target_process_qsupported void.
+
+	* target.h (target_ops): Make process_qsupported void.
+	(target_process_qsupported): Make it void.
+
+2010-02-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Replace xmm[32] with raw[32].
+	(i387_xsave_to_cache): Optimize xstate_bv == 0.
+
+2010-02-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Remove collect_register_part.
+	(i387_xsave_to_cache): Remove supply_register_part.
+
+	* regcache.c (supply_register_part): Removed.
+	(collect_register_part): Likewise.
+	* regcache.h (supply_register_part): Likewise.
+	(collect_register_part): Likewise.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Makefile.in (xstate-nat.o): Renamed to ...
+	(i386-xstate.o): This.
+
+	* configure.srv (srv_tgtobj): Add i386-xstate.o instead of
+	xstate-nat.o for i[34567]86-*-linux* and x86_64-*-linux*.
+
+	* i387-fp.c: Include "i386-xstate.h" instead of "xstate-nat.h".
+	* linux-x86-low.c: Likewise.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Add another missing break.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Add the missing break.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* regcache.c (supply_register_part): Clear regcache if buf is
+	NULL.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (x86_linux_process_qsupported): Always
+	initialize size and xcr0.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (x86_vector_unit_init): Support only what both gdb
+	and host support.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Clear part in vector registers
+	if its bit in xstat_bv is zero.  Update xstat_bv if needed.
+	(i387_xsave_to_cache): Clear part in vector registers if its bit
+	in xstat_bv is zero.
+
+	* regcache.c (supply_register): Clear regcache if buf is NULL.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Remove xcr0.
+	(i387_xsave_to_cache): Likewise.
+
+2010-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (x86_vector_unit_init): Updated.
+	* i387-fp.h (x86_vector_unit_init): Likewise.
+
+	* linux-low.c (linux_update_x86_xstate_size): Renamed to ...
+	(linux_process_qsupported): This.  Updated.
+	(linux_target_ops): Updated.
+
+	* linux-low.h (linux_target_ops): Replace update_x86_xstate_size
+	with process_qsupported.
+
+	* linux-x86-low.c (x86_linux_update_x86_xstate_size): Renamed
+	to ...
+	(x86_linux_process_qsupported): This.  Assemble qSupported ACK.
+
+	* server.c (handle_query): Call target_process_qsupported
+	for unhandled query.
+
+	* target.h (target_ops): Replace update_x86_xstate_size with
+	process_qsupported.
+	(target_update_x86_xstate_size): Removed.
+	(target_process_qsupported): New.
+
+2010-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Remove xstate_bv.
+	(i387_xsave_to_cache): Likewise.
+
+2010-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (x86_vector_unit_init): Add and check size argument.
+
+	* i387-fp.h (x86_vector_unit): Remove unknown.
+	(x86_vector_unit_init): Add size argument.
+
+	* linux-low.c (linux_update_x86_xstate_size): New.
+	(linux_target_ops): Add linux_update_x86_xstate_size.
+
+	* linux-low.h (linux_target_ops): Add update_x86_xstate_size.
+
+	* linux-x86-low.c (x86_update_xstateregset_size): Renamed to
+	...
+	(x86_linux_update_x86_xstate_size): This.  Updated.
+	(x86_arch_setup): Don't call x86_update_xstateregset_size.
+	(the_low_target): Add x86_linux_update_x86_xstate_size.
+
+	* server.c (handle_query): Handle "x86:xstate:SIZE".
+
+	* target.h (target_ops): Add update_x86_xstate_size.
+	(target_update_x86_xstate_size): New.
+
+2010-01-31  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Handle xcr0 and xstate_bv
+	only for AVX and above.
+	(i387_xsave_to_cache): Likewise.
+
+2010-01-31  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_xsave): Add xcr0 and xstate_bv.
+	(i387_cache_to_xsave): Handle xcr0 and xstate_bv.
+	(i387_xsave_to_cache): Likewise.
+
+2010-01-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (x86_vector_unit_init): Updated.
+	* linux-x86-low.c (x86_update_xstateregset_size): Likewise.
--- ./gdb/gdbserver/ChangeLog.xml	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/gdbserver/ChangeLog.xml	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,68 @@
+2010-02-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (init_registers_i386_linux): Update comments.
+	(init_registers_amd64_linux): Likewise.
+
+2010-02-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Makefile.in: Replace x86-64 with amd64.
+
+	* configure.srv: Replace x86-64/x86_64 with amd64.
+
+	* linux-x86-low.c: Replace x86_64 with amd64.
+
+2010-02-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* configure.srv (srv_i386_regobj): New.
+	(srv_i386_linux_regobj): Likewise.
+	(srv_x86_64_regobj): Likewise.
+	(srv_x86_64_linux_regobj): Likewise.
+	(i[34567]86-*-cygwin*): Set srv_regobj to $srv_i386_regobj.
+	(i[34567]86-*-mingw32ce*): Likewise.
+	(i[34567]86-*-mingw*): Likewise.
+	(i[34567]86-*-nto*): Likewise.
+	(i[34567]86-*-linux*): Set srv_regobj to $srv_i386_linux_regobj
+	and $srv_x86_64_linux_regobj.
+	(x86_64-*-linux*): Likewise.
+
+2010-02-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* configure.srv (srv_i386_32bit_xmlfiles): New.
+	(srv_i386_64bit_xmlfiles): Likewise.
+	(srv_i386_xmlfiles): Likewise.
+	(srv_x86_64_xmlfiles): Likewise.
+	(srv_i386_linux_xmlfiles): Likewise.
+	(srv_x86_64_linux_xmlfiles): Likewise.
+	(i[34567]86-*-cygwin*): Set srv_xmlfiles to $srv_i386_xmlfiles.
+	(i[34567]86-*-mingw32ce*): Likewise.
+	(i[34567]86-*-mingw*): Likewise.
+	(i[34567]86-*-nto*): Likewise.
+	(i[34567]86-*-linux*): Set srv_xmlfiles to
+	$srv_i386_linux_xmlfiles and $srv_x86_64_linux_xmlfiles.
+	(x86_64-*-linux*): Likewise.
+
+2010-02-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Makefile.in (clean): Replace reg-i386.c, reg-x86-64.c,
+	reg-i386-linux.c and reg-x86-64-linux.c with i386.c, x86-64.c,
+	i386-linux.c and x86-64-linux.c.
+	(reg-i386.o): Removed.
+	(reg-i386.c): Likewise.
+	(reg-i386-linux.o): Likewise.
+	(reg-i386-linux.c): Likewise.
+	(reg-x86-64.o): Likewise.
+	(reg-x86-64.c): Likewise.
+	(reg-x86-64-linux.o): Likewise.
+	(reg-x86-64-linux.c): Likewise.
+	(i386.o): New.
+	(i386.c): Likewise.
+	(i386-linux.o): Likewise.
+	(i386-linux.c): Likewise.
+	(x86-64.o): Likewise.
+	(x86-64.c): Likewise.
+	(x86-64-linux.o): Likewise.
+	(x86-64-linux.c): Likewise.
+
+	* configure.srv: Replace reg-i386.o, reg-x86-64.o,
+	reg-i386-linux.o and reg-x86-64-linux.o with i386.o, x86-64.o,
+	i386-linux.o and x86-64-linux.o.
--- ./gdb/gdbserver/ChangeLog.xstate	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/gdbserver/ChangeLog.xstate	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,89 @@
+2010-01-31  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_xsave): Correct layout.
+
+2010-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (x86_update_xstateregset_size): Use
+	i386_xstate.size.
+
+2010-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (x86_update_xstateregset_size): Call
+	x86_vector_unit_init here. Turn off other FP PTRACE requests
+	only on AVX host.
+	(x86_arch_setup): Don't call x86_vector_unit_init here.
+
+2010-01-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (x86_update_xstateregset_size): Update
+	size for PTRACE_GETXSTATEREGS only if it is supported.
+
+2010-01-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (x86_update_xstateregset_size): Use only
+	PTRACE_GETXSTATEREGS if it is supported.
+
+2010-01-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c (x86_update_xstateregset_size): For AVX,
+	only use PTRACE_GETXSTATEREGS.
+
+2010-01-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* i387-fp.c (i387_cache_to_xsave): Find ymm0 for AVX.
+	(i387_xsave_to_cache): Likewise.
+
+2010-01-25  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Makefile.in (xsave-nat.o): Renamed to ...
+	(xstate-nat.o): This.
+
+	* configure.srv (srv_tgtobj): Add xstate-nat.o instead of
+	xsave-nat.o for i[34567]86-*-linux* and x86_64-*-linux*.
+
+	* i387-fp.c: Include "xstate-nat.h" instead of "xsave-nat.h".
+	* linux-x86-low.c: Likewise.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* regcache.c (supply_register_part): Change size to unsigned int.
+	(collect_register_part): Likewise.
+	* regcache.h (supply_register_part): Likewise.
+	(collect_register_part): Likewise.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* linux-x86-low.c: Include "xsave-nat.h"
+	(PTRACE_GETXSTATEREGS): New.
+	(PTRACE_SETXSTATEREGS): Likewise.
+	(x86_fill_xstateregset): Likewise.
+	(x86_store_xstateregset): Likewise.
+	(x86_update_xstateregset_size): Likewise.
+	(target_regsets): Add PTRACE_GETXSTATEREGS entry.
+	(x86_arch_setup): Call x86_update_xstateregset_size.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* configure.srv (srv_tgtobj): Add xsave-nat.o for
+	i[34567]86-*-linux* and x86_64-*-linux*.
+
+	* i387-fp.c (i387_xsave): New.
+	(i387_cache_to_xsave): Likewise.
+	(i387_xsave_to_cache): Likewise.
+	(x86_vector_unit): Likewise.
+	(x86_vector_unit_init): Likewise.
+	* 387-fp.h (i387_cache_to_xsave): Likewise.
+	(i387_xsave_to_cache): Likewise.
+	(x86_vector_unit): Likewise.
+	(x86_vector_unit_init): Likewise.
+	* regcache.c (supply_register_part): Likewise.
+	(collect_register_part): Likewise.
+	* regcache.h (supply_register_part): Likewise.
+	(collect_register_part): Likewise.
+
+	* linux-x86-low.c (x86_arch_setup): Call x86_vector_unit_init.
+
+2010-01-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Makefile.in (xsave-nat.o): New.
--- ./gdb/gdbserver/Makefile.in	2010-04-03 20:59:52.000000000 +0200
+++ ./gdb/gdbserver/Makefile.in	2010-04-03 21:12:32.000000000 +0200
@@ -217,6 +217,8 @@ clean:
 	rm -f powerpc-isa205-vsx64l.c
 	rm -f s390-linux32.c s390-linux64.c s390x-linux64.c
 	rm -f xml-builtin.c stamp-xml
+	rm -f i386-avx.c i386-avx-linux.c
+	rm -f amd64-avx.c amd64-avx-linux.c
 
 maintainer-clean realclean distclean: clean
 	rm -f nm.h tm.h xm.h config.status config.h stamp-h config.log
@@ -351,6 +353,12 @@ i386.c : $(srcdir)/../regformats/i386/i3
 i386-linux.o : i386-linux.c $(regdef_h)
 i386-linux.c : $(srcdir)/../regformats/i386/i386-linux.dat $(regdat_sh)
 	$(SHELL) $(regdat_sh) $(srcdir)/../regformats/i386/i386-linux.dat i386-linux.c
+i386-avx.o : i386-avx.c $(regdef_h)
+i386-avx.c : $(srcdir)/../regformats/i386/i386-avx.dat $(regdat_sh)
+	$(SHELL) $(regdat_sh) $(srcdir)/../regformats/i386/i386-avx.dat i386-avx.c
+i386-avx-linux.o : i386-avx-linux.c $(regdef_h)
+i386-avx-linux.c : $(srcdir)/../regformats/i386/i386-avx-linux.dat $(regdat_sh)
+	$(SHELL) $(regdat_sh) $(srcdir)/../regformats/i386/i386-avx-linux.dat i386-avx-linux.c
 reg-ia64.o : reg-ia64.c $(regdef_h)
 reg-ia64.c : $(srcdir)/../regformats/reg-ia64.dat $(regdat_sh)
 	$(SHELL) $(regdat_sh) $(srcdir)/../regformats/reg-ia64.dat reg-ia64.c
@@ -438,6 +446,12 @@ amd64.c : $(srcdir)/../regformats/i386/a
 amd64-linux.o : amd64-linux.c $(regdef_h)
 amd64-linux.c : $(srcdir)/../regformats/i386/amd64-linux.dat $(regdat_sh)
 	$(SHELL) $(regdat_sh) $(srcdir)/../regformats/i386/amd64-linux.dat amd64-linux.c
+amd64-avx.o : amd64-avx.c $(regdef_h)
+amd64-avx.c : $(srcdir)/../regformats/i386/amd64-avx.dat $(regdat_sh)
+	$(SHELL) $(regdat_sh) $(srcdir)/../regformats/i386/amd64-avx.dat amd64-avx.c
+amd64-avx-linux.o : amd64-avx-linux.c $(regdef_h)
+amd64-avx-linux.c : $(srcdir)/../regformats/i386/amd64-avx-linux.dat $(regdat_sh)
+	$(SHELL) $(regdat_sh) $(srcdir)/../regformats/i386/amd64-avx-linux.dat amd64-avx-linux.c
 reg-xtensa.o : reg-xtensa.c $(regdef_h)
 reg-xtensa.c : $(srcdir)/../regformats/reg-xtensa.dat $(regdat_sh)
 	$(SHELL) $(regdat_sh) $(srcdir)/../regformats/reg-xtensa.dat reg-xtensa.c
--- ./gdb/gdbserver/configure.srv	2010-04-03 20:59:52.000000000 +0200
+++ ./gdb/gdbserver/configure.srv	2010-04-03 21:12:32.000000000 +0200
@@ -22,17 +22,17 @@
 # Default hostio_last_error implementation
 srv_hostio_err_objs="hostio-errno.o"
 
-srv_i386_regobj=i386.o
-srv_i386_linux_regobj=i386-linux.o
-srv_amd64_regobj=amd64.o
-srv_amd64_linux_regobj=amd64-linux.o
+srv_i386_regobj="i386.o i386-avx.o"
+srv_i386_linux_regobj="i386-linux.o i386-avx-linux.o"
+srv_amd64_regobj="amd64.o x86-64-avx.o"
+srv_amd64_linux_regobj="amd64-linux.o amd64-avx-linux.o"
 
-srv_i386_32bit_xmlfiles="i386/32bit-core.xml i386/32bit-sse.xml"
-srv_i386_64bit_xmlfiles="i386/64bit-core.xml i386/64bit-sse.xml"
-srv_i386_xmlfiles="i386/i386.xml $srv_i386_32bit_xmlfiles"
-srv_amd64_xmlfiles="i386/amd64.xml $srv_i386_64bit_xmlfiles"
-srv_i386_linux_xmlfiles="i386/i386-linux.xml i386/32bit-linux.xml $srv_i386_32bit_xmlfiles"
-srv_amd64_linux_xmlfiles="i386/amd64-linux.xml i386/64bit-linux.xml $srv_i386_64bit_xmlfiles"
+srv_i386_32bit_xmlfiles="i386/32bit-core.xml i386/32bit-sse.xml i386/32bit-avx.xml"
+srv_i386_64bit_xmlfiles="i386/64bit-core.xml i386/64bit-sse.xml i386/64bit-avx.xml"
+srv_i386_xmlfiles="i386/i386.xml i386/i386-avx.xml $srv_i386_32bit_xmlfiles"
+srv_amd64_xmlfiles="i386/amd64.xml i386/amd64-avx.xml $srv_i386_64bit_xmlfiles"
+srv_i386_linux_xmlfiles="i386/i386-linux.xml i386/i386-avx-linux.xml i386/32bit-linux.xml $srv_i386_32bit_xmlfiles"
+srv_amd64_linux_xmlfiles="i386/amd64-linux.xml i386/amd64-avx-linux.xml i386/64bit-linux.xml $srv_i386_64bit_xmlfiles"
 
 # Input is taken from the "${target}" variable.
 
--- ./gdb/gdbserver/i387-fp.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/i387-fp.c	2010-04-03 21:12:32.000000000 +0200
@@ -19,6 +19,7 @@
 
 #include "server.h"
 #include "i387-fp.h"
+#include "i386-xstate.h"
 
 int num_xmm_registers = 8;
 
@@ -72,6 +73,46 @@ struct i387_fxsave {
   unsigned char xmm_space[256];
 };
 
+struct i387_xsave {
+  /* All these are only sixteen bits, plus padding, except for fop (which
+     is only eleven bits), and fooff / fioff (which are 32 bits each).  */
+  unsigned short fctrl;
+  unsigned short fstat;
+  unsigned short ftag;
+  unsigned short fop;
+  unsigned int fioff;
+  unsigned short fiseg;
+  unsigned short pad1;
+  unsigned int fooff;
+  unsigned short foseg;
+  unsigned short pad12;
+
+  unsigned int mxcsr;
+  unsigned int mxcsr_mask;
+
+  /* Space for eight 80-bit FP values in 128-bit spaces.  */
+  unsigned char st_space[128];
+
+  /* Space for eight 128-bit XMM values, or 16 on x86-64.  */
+  unsigned char xmm_space[256];
+
+  unsigned char reserved1[48];
+
+  /* The extended control register 0 (the XFEATURE_ENABLED_MASK
+     register).  */
+  unsigned long long xcr0;
+
+  unsigned char reserved2[40];
+
+  /* The XSTATE_BV bit vector.  */
+  unsigned long long xstate_bv;
+
+  unsigned char reserved3[56];
+
+  /* Space for eight upper 128-bit YMM values, or 16 on x86-64.  */
+  unsigned char ymmh_space[256];
+};
+
 void
 i387_cache_to_fsave (struct regcache *regcache, void *buf)
 {
@@ -199,6 +240,128 @@ i387_cache_to_fxsave (struct regcache *r
   fp->foseg = val;
 }
 
+void
+i387_cache_to_xsave (struct regcache *regcache, void *buf)
+{
+  struct i387_xsave *fp = (struct i387_xsave *) buf;
+  int i;
+  unsigned long val, val2;
+  unsigned int clear_bv;
+  unsigned long long xstate_bv = 0;
+  char raw[16];
+  char *p;
+
+  /* The supported bits in `xstat_bv' are 1 byte.  Clear part in
+     vector registers if its bit in xstat_bv is zero.  */
+  clear_bv = (~fp->xstate_bv) & x86_xcr0;
+
+  /* Clear part in x87 and vector registers if its bit in xstat_bv is
+     zero.  */
+  if (clear_bv)
+    {
+      if ((clear_bv & I386_XSTATE_X87))
+	for (i = 0; i < 8; i++)
+	  memset (((char *) &fp->st_space[0]) + i * 16, 0, 10);
+
+      if ((clear_bv & I386_XSTATE_SSE))
+	for (i = 0; i < num_xmm_registers; i++) 
+	  memset (((char *) &fp->xmm_space[0]) + i * 16, 0, 16);
+
+      if ((clear_bv & I386_XSTATE_AVX))
+	for (i = 0; i < num_xmm_registers; i++) 
+	  memset (((char *) &fp->ymmh_space[0]) + i * 16, 0, 16);
+    }
+
+  /* Check if any x87 registers are changed.  */
+  if ((x86_xcr0 & I386_XSTATE_X87))
+    {
+      int st0_regnum = find_regno ("st0");
+
+      for (i = 0; i < 8; i++)
+	{
+	  collect_register (regcache, i + st0_regnum, raw);
+	  p = ((char *) &fp->st_space[0]) + i * 16;
+	  if (memcmp (raw, p, 10))
+	    {
+	      xstate_bv |= I386_XSTATE_X87;
+	      memcpy (p, raw, 10);
+	    }
+	}
+    }
+
+  /* Check if any SSE registers are changed.  */
+  if ((x86_xcr0 & I386_XSTATE_SSE))
+    {
+      int xmm0_regnum = find_regno ("xmm0");
+
+      for (i = 0; i < num_xmm_registers; i++) 
+	{
+	  collect_register (regcache, i + xmm0_regnum, raw);
+	  p = ((char *) &fp->xmm_space[0]) + i * 16;
+	  if (memcmp (raw, p, 16))
+	    {
+	      xstate_bv |= I386_XSTATE_SSE;
+	      memcpy (p, raw, 16);
+	    }
+	}
+    }
+
+  /* Check if any AVX registers are changed.  */
+  if ((x86_xcr0 & I386_XSTATE_AVX))
+    {
+      int ymm0h_regnum = find_regno ("ymm0h");
+
+      for (i = 0; i < num_xmm_registers; i++) 
+	{
+	  collect_register (regcache, i + ymm0h_regnum, raw);
+	  p = ((char *) &fp->ymmh_space[0]) + i * 16;
+	  if (memcmp (raw, p, 16))
+	    {
+	      xstate_bv |= I386_XSTATE_AVX;
+	      memcpy (p, raw, 16);
+	    }
+	}
+    }
+
+  /* Update the corresponding bits in xstate_bv if any SSE/AVX
+     registers are changed.  */
+  fp->xstate_bv |= xstate_bv;
+
+  collect_register_by_name (regcache, "fioff", &fp->fioff);
+  collect_register_by_name (regcache, "fooff", &fp->fooff);
+  collect_register_by_name (regcache, "mxcsr", &fp->mxcsr);
+
+  /* This one's 11 bits... */
+  collect_register_by_name (regcache, "fop", &val2);
+  fp->fop = (val2 & 0x7FF) | (fp->fop & 0xF800);
+
+  /* Some registers are 16-bit.  */
+  collect_register_by_name (regcache, "fctrl", &val);
+  fp->fctrl = val;
+
+  collect_register_by_name (regcache, "fstat", &val);
+  fp->fstat = val;
+
+  /* Convert to the simplifed tag form stored in fxsave data.  */
+  collect_register_by_name (regcache, "ftag", &val);
+  val &= 0xFFFF;
+  val2 = 0;
+  for (i = 7; i >= 0; i--)
+    {
+      int tag = (val >> (i * 2)) & 3;
+
+      if (tag != 3)
+	val2 |= (1 << i);
+    }
+  fp->ftag = val2;
+
+  collect_register_by_name (regcache, "fiseg", &val);
+  fp->fiseg = val;
+
+  collect_register_by_name (regcache, "foseg", &val);
+  fp->foseg = val;
+}
+
 static int
 i387_ftag (struct i387_fxsave *fp, int regno)
 {
@@ -296,3 +459,107 @@ i387_fxsave_to_cache (struct regcache *r
   val = (fp->fop) & 0x7FF;
   supply_register_by_name (regcache, "fop", &val);
 }
+
+void
+i387_xsave_to_cache (struct regcache *regcache, const void *buf)
+{
+  struct i387_xsave *fp = (struct i387_xsave *) buf;
+  struct i387_fxsave *fxp = (struct i387_fxsave *) buf;
+  int i, top;
+  unsigned long val;
+  unsigned int clear_bv;
+  char *p;
+
+  /* The supported bits in `xstat_bv' are 1 byte.  Clear part in
+     vector registers if its bit in xstat_bv is zero.  */
+  clear_bv = (~fp->xstate_bv) & x86_xcr0;
+
+  /* Check if any x87 registers are changed.  */
+  if ((x86_xcr0 & I386_XSTATE_X87))
+    {
+      int st0_regnum = find_regno ("st0");
+
+      if ((clear_bv & I386_XSTATE_X87))
+	p = NULL;
+      else
+	p = (char *) buf;
+
+      for (i = 0; i < 8; i++)
+	{
+	  if (p)
+	    p = ((char *) &fp->st_space[0]) + i * 16;
+	  supply_register (regcache, i + st0_regnum, p);
+	}
+    }
+
+  if ((x86_xcr0 & I386_XSTATE_SSE))
+    {
+      int xmm0_regnum = find_regno ("xmm0");
+
+      if ((clear_bv & I386_XSTATE_SSE))
+	p = NULL;
+      else
+	p = (char *) buf;
+
+      for (i = 0; i < num_xmm_registers; i++)
+	{
+	  if (p)
+	    p = ((char *) &fp->xmm_space[0]) + i * 16;
+	  supply_register (regcache, i + xmm0_regnum, p);
+	}
+    }
+
+  if ((x86_xcr0 & I386_XSTATE_AVX))
+    {
+      int ymm0h_regnum = find_regno ("ymm0h");
+
+      if ((clear_bv & I386_XSTATE_AVX))
+	p = NULL;
+      else
+	p = (char *) buf;
+
+      for (i = 0; i < num_xmm_registers; i++)
+	{
+	  if (p)
+	    p = ((char *) &fp->ymmh_space[0]) + i * 16;
+	  supply_register (regcache, i + ymm0h_regnum, p);
+	}
+    }
+
+  supply_register_by_name (regcache, "fioff", &fp->fioff);
+  supply_register_by_name (regcache, "fooff", &fp->fooff);
+  supply_register_by_name (regcache, "mxcsr", &fp->mxcsr);
+
+  /* Some registers are 16-bit.  */
+  val = fp->fctrl & 0xFFFF;
+  supply_register_by_name (regcache, "fctrl", &val);
+
+  val = fp->fstat & 0xFFFF;
+  supply_register_by_name (regcache, "fstat", &val);
+
+  /* Generate the form of ftag data that GDB expects.  */
+  top = (fp->fstat >> 11) & 0x7;
+  val = 0;
+  for (i = 7; i >= 0; i--)
+    {
+      int tag;
+      if (fp->ftag & (1 << i))
+	tag = i387_ftag (fxp, (i + 8 - top) % 8);
+      else
+	tag = 3;
+      val |= tag << (2 * i);
+    }
+  supply_register_by_name (regcache, "ftag", &val);
+
+  val = fp->fiseg & 0xFFFF;
+  supply_register_by_name (regcache, "fiseg", &val);
+
+  val = fp->foseg & 0xFFFF;
+  supply_register_by_name (regcache, "foseg", &val);
+
+  val = (fp->fop) & 0x7FF;
+  supply_register_by_name (regcache, "fop", &val);
+}
+
+/* Default to SSE.  */
+unsigned long long x86_xcr0 = I386_XSTATE_SSE_MASK;
--- ./gdb/gdbserver/i387-fp.h	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/i387-fp.h	2010-04-03 21:12:32.000000000 +0200
@@ -26,6 +26,11 @@ void i387_fsave_to_cache (struct regcach
 void i387_cache_to_fxsave (struct regcache *regcache, void *buf);
 void i387_fxsave_to_cache (struct regcache *regcache, const void *buf);
 
+void i387_cache_to_xsave (struct regcache *regcache, void *buf);
+void i387_xsave_to_cache (struct regcache *regcache, const void *buf);
+
+extern unsigned long long x86_xcr0;
+
 extern int num_xmm_registers;
 
 #endif /* I387_FP_H */
--- ./gdb/gdbserver/linux-arm-low.c	2010-02-01 17:13:16.000000000 +0100
+++ ./gdb/gdbserver/linux-arm-low.c	2010-04-03 21:12:32.000000000 +0200
@@ -354,16 +354,16 @@ arm_arch_setup (void)
 }
 
 struct regset_info target_regsets[] = {
-  { PTRACE_GETREGS, PTRACE_SETREGS, 18 * 4,
+  { PTRACE_GETREGS, PTRACE_SETREGS, 0, 18 * 4,
     GENERAL_REGS,
     arm_fill_gregset, arm_store_gregset },
-  { PTRACE_GETWMMXREGS, PTRACE_SETWMMXREGS, 16 * 8 + 6 * 4,
+  { PTRACE_GETWMMXREGS, PTRACE_SETWMMXREGS, 0, 16 * 8 + 6 * 4,
     EXTENDED_REGS,
     arm_fill_wmmxregset, arm_store_wmmxregset },
-  { PTRACE_GETVFPREGS, PTRACE_SETVFPREGS, 32 * 8 + 4,
+  { PTRACE_GETVFPREGS, PTRACE_SETVFPREGS, 0, 32 * 8 + 4,
     EXTENDED_REGS,
     arm_fill_vfpregset, arm_store_vfpregset },
-  { 0, 0, -1, -1, NULL, NULL }
+  { 0, 0, 0, -1, -1, NULL, NULL }
 };
 
 struct linux_target_ops the_low_target = {
--- ./gdb/gdbserver/linux-crisv32-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-crisv32-low.c	2010-04-03 21:12:32.000000000 +0200
@@ -365,9 +365,9 @@ cris_store_gregset (const void *buf)
 typedef unsigned long elf_gregset_t[cris_num_regs];
 
 struct regset_info target_regsets[] = {
-  { PTRACE_GETREGS, PTRACE_SETREGS, sizeof (elf_gregset_t),
+  { PTRACE_GETREGS, PTRACE_SETREGS, 0, sizeof (elf_gregset_t),
     GENERAL_REGS, cris_fill_gregset, cris_store_gregset },
-  { 0, 0, -1, -1, NULL, NULL }
+  { 0, 0, 0, -1, -1, NULL, NULL }
 };
 
 struct linux_target_ops the_low_target = {
--- ./gdb/gdbserver/linux-low.c	2010-03-06 01:12:57.000000000 +0100
+++ ./gdb/gdbserver/linux-low.c	2010-04-03 21:19:14.000000000 +0200
@@ -39,6 +39,7 @@
 #include <dirent.h>
 #include <sys/stat.h>
 #include <sys/vfs.h>
+#include <sys/uio.h>
 #ifndef ELFMAG0
 /* Don't include <linux/elf.h> here.  If it got included by gdb_proc_service.h
    then ELFMAG0 will have been defined.  If it didn't get included by
@@ -2281,14 +2282,15 @@ regsets_fetch_inferior_registers (struct
   struct regset_info *regset;
   int saw_general_regs = 0;
   int pid;
+  struct iovec iov;
 
   regset = target_regsets;
 
   pid = lwpid_of (get_thread_lwp (current_inferior));
   while (regset->size >= 0)
     {
-      void *buf;
-      int res;
+      void *buf, *data;
+      int nt_type, res;
 
       if (regset->size == 0 || disabled_regsets[regset - target_regsets])
 	{
@@ -2297,10 +2299,21 @@ regsets_fetch_inferior_registers (struct
 	}
 
       buf = xmalloc (regset->size);
+
+      nt_type = regset->nt_type;
+      if (nt_type)
+	{
+	  iov.iov_base = buf;
+	  iov.iov_len = regset->size;
+	  data = (void *) &iov;
+	}
+      else
+	data = buf;
+
 #ifndef __sparc__
-      res = ptrace (regset->get_request, pid, 0, buf);
+      res = ptrace (regset->get_request, pid, nt_type, data);
 #else
-      res = ptrace (regset->get_request, pid, buf, 0);
+      res = ptrace (regset->get_request, pid, data, nt_type);
 #endif
       if (res < 0)
 	{
@@ -2338,14 +2351,15 @@ regsets_store_inferior_registers (struct
   struct regset_info *regset;
   int saw_general_regs = 0;
   int pid;
+  struct iovec iov;
 
   regset = target_regsets;
 
   pid = lwpid_of (get_thread_lwp (current_inferior));
   while (regset->size >= 0)
     {
-      void *buf;
-      int res;
+      void *buf, *data;
+      int nt_type, res;
 
       if (regset->size == 0 || disabled_regsets[regset - target_regsets])
 	{
@@ -2358,10 +2372,21 @@ regsets_store_inferior_registers (struct
       /* First fill the buffer with the current register set contents,
 	 in case there are any items in the kernel's regset that are
 	 not in gdbserver's regcache.  */
+
+      nt_type = regset->nt_type;
+      if (nt_type)
+	{
+	  iov.iov_base = buf;
+	  iov.iov_len = regset->size;
+	  data = (void *) &iov;
+	}
+      else
+	data = buf;
+
 #ifndef __sparc__
-      res = ptrace (regset->get_request, pid, 0, buf);
+      res = ptrace (regset->get_request, pid, nt_type, data);
 #else
-      res = ptrace (regset->get_request, pid, buf, 0);
+      res = ptrace (regset->get_request, pid, &iov, data);
 #endif
 
       if (res == 0)
@@ -2371,9 +2396,9 @@ regsets_store_inferior_registers (struct
 
 	  /* Only now do we write the register set.  */
 #ifndef __sparc__
-	  res = ptrace (regset->set_request, pid, 0, buf);
+	  res = ptrace (regset->set_request, pid, nt_type, data);
 #else
-	  res = ptrace (regset->set_request, pid, buf, 0);
+	  res = ptrace (regset->set_request, pid, data, nt_type);
 #endif
 	}
 
@@ -3434,6 +3459,13 @@ linux_core_of_thread (ptid_t ptid)
   return core;
 }
 
+static void
+linux_process_qsupported (const char *query)
+{
+  if (the_low_target.process_qsupported != NULL)
+    the_low_target.process_qsupported (query);
+}
+
 static struct target_ops linux_target_ops = {
   linux_create_inferior,
   linux_attach,
@@ -3477,7 +3509,8 @@ static struct target_ops linux_target_op
 #else
   NULL,
 #endif
-  linux_core_of_thread
+  linux_core_of_thread,
+  linux_process_qsupported
 };
 
 static void
--- ./gdb/gdbserver/linux-low.h	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-low.h	2010-04-03 21:12:32.000000000 +0200
@@ -35,6 +35,9 @@ enum regset_type {
 struct regset_info
 {
   int get_request, set_request;
+  /* If NT_TYPE isn't 0, it will be passed to ptrace as the 3rd
+     argument and the 4th argument should be "const struct iovec *".  */
+  int nt_type;
   int size;
   enum regset_type type;
   regset_fill_func fill_function;
@@ -111,6 +114,9 @@ struct linux_target_ops
 
   /* Hook to call prior to resuming a thread.  */
   void (*prepare_to_resume) (struct lwp_info *);
+
+  /* Hook to support target specific qSupported.  */
+  void (*process_qsupported) (const char *);
 };
 
 extern struct linux_target_ops the_low_target;
--- ./gdb/gdbserver/linux-m68k-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-m68k-low.c	2010-04-03 21:12:32.000000000 +0200
@@ -112,14 +112,14 @@ m68k_store_fpregset (struct regcache *re
 
 struct regset_info target_regsets[] = {
 #ifdef HAVE_PTRACE_GETREGS
-  { PTRACE_GETREGS, PTRACE_SETREGS, sizeof (elf_gregset_t),
+  { PTRACE_GETREGS, PTRACE_SETREGS, 0, sizeof (elf_gregset_t),
     GENERAL_REGS,
     m68k_fill_gregset, m68k_store_gregset },
-  { PTRACE_GETFPREGS, PTRACE_SETFPREGS, sizeof (elf_fpregset_t),
+  { PTRACE_GETFPREGS, PTRACE_SETFPREGS, 0, sizeof (elf_fpregset_t),
     FP_REGS,
     m68k_fill_fpregset, m68k_store_fpregset },
 #endif /* HAVE_PTRACE_GETREGS */
-  { 0, 0, -1, -1, NULL, NULL }
+  { 0, 0, 0, -1, -1, NULL, NULL }
 };
 
 static const unsigned char m68k_breakpoint[] = { 0x4E, 0x4F };
--- ./gdb/gdbserver/linux-mips-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-mips-low.c	2010-04-03 21:12:32.000000000 +0200
@@ -343,12 +343,12 @@ mips_store_fpregset (struct regcache *re
 
 struct regset_info target_regsets[] = {
 #ifdef HAVE_PTRACE_GETREGS
-  { PTRACE_GETREGS, PTRACE_SETREGS, 38 * 8, GENERAL_REGS,
+  { PTRACE_GETREGS, PTRACE_SETREGS, 0, 38 * 8, GENERAL_REGS,
     mips_fill_gregset, mips_store_gregset },
-  { PTRACE_GETFPREGS, PTRACE_SETFPREGS, 33 * 8, FP_REGS,
+  { PTRACE_GETFPREGS, PTRACE_SETFPREGS, 0, 33 * 8, FP_REGS,
     mips_fill_fpregset, mips_store_fpregset },
 #endif /* HAVE_PTRACE_GETREGS */
-  { 0, 0, -1, -1, NULL, NULL }
+  { 0, 0, 0, -1, -1, NULL, NULL }
 };
 
 struct linux_target_ops the_low_target = {
--- ./gdb/gdbserver/linux-ppc-low.c	2010-01-21 23:10:18.000000000 +0100
+++ ./gdb/gdbserver/linux-ppc-low.c	2010-04-03 21:12:32.000000000 +0200
@@ -593,14 +593,14 @@ struct regset_info target_regsets[] = {
      fetch them every time, but still fall back to PTRACE_PEEKUSER for the
      general registers.  Some kernels support these, but not the newer
      PPC_PTRACE_GETREGS.  */
-  { PTRACE_GETVSXREGS, PTRACE_SETVSXREGS, SIZEOF_VSXREGS, EXTENDED_REGS,
+  { PTRACE_GETVSXREGS, PTRACE_SETVSXREGS, 0, SIZEOF_VSXREGS, EXTENDED_REGS,
   ppc_fill_vsxregset, ppc_store_vsxregset },
   { PTRACE_GETVRREGS, PTRACE_SETVRREGS, SIZEOF_VRREGS, EXTENDED_REGS,
     ppc_fill_vrregset, ppc_store_vrregset },
-  { PTRACE_GETEVRREGS, PTRACE_SETEVRREGS, 32 * 4 + 8 + 4, EXTENDED_REGS,
+  { PTRACE_GETEVRREGS, PTRACE_SETEVRREGS, 0, 32 * 4 + 8 + 4, EXTENDED_REGS,
     ppc_fill_evrregset, ppc_store_evrregset },
-  { 0, 0, 0, GENERAL_REGS, ppc_fill_gregset, NULL },
-  { 0, 0, -1, -1, NULL, NULL }
+  { 0, 0, 0, 0, GENERAL_REGS, ppc_fill_gregset, NULL },
+  { 0, 0, 0, -1, -1, NULL, NULL }
 };
 
 struct linux_target_ops the_low_target = {
--- ./gdb/gdbserver/linux-s390-low.c	2010-01-21 20:26:49.000000000 +0100
+++ ./gdb/gdbserver/linux-s390-low.c	2010-04-03 21:12:32.000000000 +0200
@@ -181,8 +181,8 @@ static void s390_fill_gregset (struct re
 }
 
 struct regset_info target_regsets[] = {
-  { 0, 0, 0, GENERAL_REGS, s390_fill_gregset, NULL },
-  { 0, 0, -1, -1, NULL, NULL }
+  { 0, 0, 0, 0, GENERAL_REGS, s390_fill_gregset, NULL },
+  { 0, 0, 0, -1, -1, NULL, NULL }
 };
 
 
--- ./gdb/gdbserver/linux-sh-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-sh-low.c	2010-04-03 21:12:32.000000000 +0200
@@ -104,8 +104,8 @@ static void sh_fill_gregset (struct regc
 }
 
 struct regset_info target_regsets[] = {
-  { 0, 0, 0, GENERAL_REGS, sh_fill_gregset, NULL },
-  { 0, 0, -1, -1, NULL, NULL }
+  { 0, 0, 0, 0, GENERAL_REGS, sh_fill_gregset, NULL },
+  { 0, 0, 0, -1, -1, NULL, NULL }
 };
 
 struct linux_target_ops the_low_target = {
--- ./gdb/gdbserver/linux-sparc-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-sparc-low.c	2010-04-03 21:12:32.000000000 +0200
@@ -260,13 +260,13 @@ sparc_reinsert_addr (void)
 
 
 struct regset_info target_regsets[] = {
-  { PTRACE_GETREGS, PTRACE_SETREGS, sizeof (elf_gregset_t),
+  { PTRACE_GETREGS, PTRACE_SETREGS, 0, sizeof (elf_gregset_t),
     GENERAL_REGS,
     sparc_fill_gregset, sparc_store_gregset },
-  { PTRACE_GETFPREGS, PTRACE_SETFPREGS, sizeof (fpregset_t),
+  { PTRACE_GETFPREGS, PTRACE_SETFPREGS, 0, sizeof (fpregset_t),
     FP_REGS,
     sparc_fill_fpregset, sparc_store_fpregset },
-  { 0, 0, -1, -1, NULL, NULL }
+  { 0, 0, 0, -1, -1, NULL, NULL }
 };
 
 struct linux_target_ops the_low_target = {
--- ./gdb/gdbserver/linux-x86-low.c	2010-04-03 20:59:52.000000000 +0200
+++ ./gdb/gdbserver/linux-x86-low.c	2010-04-03 21:12:32.000000000 +0200
@@ -24,6 +24,8 @@
 #include "linux-low.h"
 #include "i387-fp.h"
 #include "i386-low.h"
+#include "i386-xstate.h"
+#include "elf/common.h"
 
 #include "gdb_proc_service.h"
 
@@ -31,10 +33,35 @@
 void init_registers_i386_linux (void);
 /* Defined in auto-generated file amd64-linux.c.  */
 void init_registers_amd64_linux (void);
+/* Defined in auto-generated file i386-avx-linux.c.  */
+void init_registers_i386_avx_linux (void);
+/* Defined in auto-generated file amd64-avx-linux.c.  */
+void init_registers_amd64_avx_linux (void);
+
+/* Backward compatibility for gdb without XML support.  */
+
+static const char *xmltarget_i386_linux_no_xml = "@<target>\
+<architecture>i386</architecture>\
+<osabi>GNU/Linux</osabi>\
+</target>";
+static const char *xmltarget_amd64_linux_no_xml = "@<target>\
+<architecture>i386:x86-64</architecture>\
+<osabi>GNU/Linux</osabi>\
+</target>";
 
 #include <sys/reg.h>
 #include <sys/procfs.h>
 #include <sys/ptrace.h>
+#include <sys/uio.h>
+
+#ifndef PTRACE_GETREGSET
+#define PTRACE_GETREGSET	0x4204
+#endif
+
+#ifndef PTRACE_SETREGSET
+#define PTRACE_SETREGSET	0x4205
+#endif
+
 
 #ifndef PTRACE_GET_THREAD_AREA
 #define PTRACE_GET_THREAD_AREA 25
@@ -252,6 +279,18 @@ x86_store_fpxregset (struct regcache *re
 
 #endif
 
+static void
+x86_fill_xstateregset (struct regcache *regcache, void *buf)
+{
+  i387_cache_to_xsave (regcache, buf);
+}
+
+static void
+x86_store_xstateregset (struct regcache *regcache, const void *buf)
+{
+  i387_xsave_to_cache (regcache, buf);
+}
+
 /* ??? The non-biarch i386 case stores all the i387 regs twice.
    Once in i387_.*fsave.* and once in i387_.*fxsave.*.
    This is, presumably, to handle the case where PTRACE_[GS]ETFPXREGS
@@ -264,21 +303,23 @@ x86_store_fpxregset (struct regcache *re
 struct regset_info target_regsets[] =
 {
 #ifdef HAVE_PTRACE_GETREGS
-  { PTRACE_GETREGS, PTRACE_SETREGS, sizeof (elf_gregset_t),
+  { PTRACE_GETREGS, PTRACE_SETREGS, 0, sizeof (elf_gregset_t),
     GENERAL_REGS,
     x86_fill_gregset, x86_store_gregset },
+  { PTRACE_GETREGSET, PTRACE_SETREGSET, NT_X86_XSTATE, 0,
+    EXTENDED_REGS, x86_fill_xstateregset, x86_store_xstateregset },
 # ifndef __x86_64__
 #  ifdef HAVE_PTRACE_GETFPXREGS
-  { PTRACE_GETFPXREGS, PTRACE_SETFPXREGS, sizeof (elf_fpxregset_t),
+  { PTRACE_GETFPXREGS, PTRACE_SETFPXREGS, 0, sizeof (elf_fpxregset_t),
     EXTENDED_REGS,
     x86_fill_fpxregset, x86_store_fpxregset },
 #  endif
 # endif
-  { PTRACE_GETFPREGS, PTRACE_SETFPREGS, sizeof (elf_fpregset_t),
+  { PTRACE_GETFPREGS, PTRACE_SETFPREGS, 0, sizeof (elf_fpregset_t),
     FP_REGS,
     x86_fill_fpregset, x86_store_fpregset },
 #endif /* HAVE_PTRACE_GETREGS */
-  { 0, 0, -1, -1, NULL, NULL }
+  { 0, 0, 0, -1, -1, NULL, NULL }
 };
 
 static CORE_ADDR
@@ -772,6 +813,121 @@ x86_siginfo_fixup (struct siginfo *nativ
   return 0;
 }
 
+static int use_xml;
+
+/* Update gdbserver_xmltarget.  */
+
+static void
+x86_linux_update_xmltarget (void)
+{
+  static unsigned long long xcr0;
+  static int have_ptrace_getregset = -1;
+
+  if (!current_inferior)
+    return;
+
+#ifdef __x86_64__
+  if (num_xmm_registers == 8)
+    init_registers_i386_linux ();
+  else
+    init_registers_amd64_linux ();
+#else
+  init_registers_i386_linux ();
+#endif
+
+  if (!use_xml)
+    {
+      /* Don't use XML.  */
+#ifdef __x86_64__
+      if (num_xmm_registers == 8)
+	gdbserver_xmltarget = xmltarget_i386_linux_no_xml;
+      else
+	gdbserver_xmltarget = xmltarget_amd64_linux_no_xml;
+#else
+      gdbserver_xmltarget = xmltarget_i386_linux_no_xml;
+#endif
+
+      x86_xcr0 = I386_XSTATE_SSE_MASK;
+
+      return;
+    }
+
+  /* Update gdbserver_xmltarget with XML support.  */
+#ifdef __x86_64__
+  if (num_xmm_registers == 8)
+    gdbserver_xmltarget = "i386-linux.xml";
+  else
+    gdbserver_xmltarget = "amd64-linux.xml";
+#else
+  gdbserver_xmltarget = "i386-linux.xml";
+#endif
+
+  /* Check if XSAVE extended state is supported.  */
+  if (have_ptrace_getregset == -1)
+    {
+      int pid = pid_of (get_thread_lwp (current_inferior));
+      unsigned long long xstateregs[I386_XSTATE_SSE_SIZE / sizeof (long long)];
+      struct iovec iov;
+      struct regset_info *regset;
+
+      iov.iov_base = xstateregs;
+      iov.iov_len = sizeof (xstateregs);
+
+      /* Check if PTRACE_GETREGSET works.  */
+      if (ptrace (PTRACE_GETREGSET, pid, (unsigned int) NT_X86_XSTATE,
+		  &iov) < 0)
+	{
+	  have_ptrace_getregset = 0;
+	  return;
+	}
+      else
+	have_ptrace_getregset = 1;
+
+      /* Get XCR0 from XSAVE extended state at byte 464.  */
+      xcr0 = xstateregs[464 / sizeof (long long)];
+
+      /* Use PTRACE_GETREGSET if it is available.  */
+      for (regset = target_regsets;
+	   regset->fill_function != NULL; regset++)
+	if (regset->get_request == PTRACE_GETREGSET)
+	  regset->size = I386_XSTATE_SIZE (xcr0);
+	else if (regset->type != GENERAL_REGS)
+	  regset->size = 0;
+    }
+
+  if (have_ptrace_getregset)
+    {
+      /* AVX is the highest feature we support.  */
+      if ((xcr0 & I386_XSTATE_AVX_MASK) == I386_XSTATE_AVX_MASK)
+	{
+	  x86_xcr0 = xcr0;
+
+#ifdef __x86_64__
+	  /* I386 has 8 xmm regs.  */
+	  if (num_xmm_registers == 8)
+	    init_registers_i386_avx_linux ();
+	  else
+	    init_registers_amd64_avx_linux ();
+#else
+	  init_registers_i386_avx_linux ();
+#endif
+	}
+    }
+}
+
+/* Process qSupported query, "xmlRegisters=".  Update the buffer size for
+   PTRACE_GETREGSET.  */
+
+static void
+x86_linux_process_qsupported (const char *query)
+{
+  /* Return if gdb doesn't support XML.  If gdb sends "xmlRegisters="
+     in qSupported query, it supports x86 XML target descriptions.  */
+  use_xml = query != NULL && strncmp (query, "xmlRegisters=", 13) == 0;
+
+  x86_linux_update_xmltarget ();
+}
+
 /* Initialize gdbserver for the architecture of the inferior.  */
 
 static void
@@ -792,8 +948,6 @@ x86_arch_setup (void)
     }
   else if (use_64bit)
     {
-      init_registers_amd64_linux ();
-
       /* Amd64 doesn't have HAVE_LINUX_USRREGS.  */
       the_low_target.num_regs = -1;
       the_low_target.regmap = NULL;
@@ -803,14 +957,13 @@ x86_arch_setup (void)
       /* Amd64 has 16 xmm regs.  */
       num_xmm_registers = 16;
 
+      x86_linux_update_xmltarget ();
       return;
     }
 #endif
 
   /* Ok we have a 32-bit inferior.  */
 
-  init_registers_i386_linux ();
-
   the_low_target.num_regs = I386_NUM_REGS;
   the_low_target.regmap = i386_regmap;
   the_low_target.cannot_fetch_register = i386_cannot_fetch_register;
@@ -818,6 +971,8 @@ x86_arch_setup (void)
 
   /* I386 has 8 xmm regs.  */
   num_xmm_registers = 8;
+
+  x86_linux_update_xmltarget ();
 }
 
 /* This is initialized assuming an amd64 target.
@@ -850,5 +1005,6 @@ struct linux_target_ops the_low_target =
   x86_siginfo_fixup,
   x86_linux_new_process,
   x86_linux_new_thread,
-  x86_linux_prepare_to_resume
+  x86_linux_prepare_to_resume,
+  x86_linux_process_qsupported 
 };
--- ./gdb/gdbserver/linux-xtensa-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-xtensa-low.c	2010-04-03 21:12:32.000000000 +0200
@@ -131,13 +131,13 @@ xtensa_store_xtregset (struct regcache *
 }
 
 struct regset_info target_regsets[] = {
-  { PTRACE_GETREGS, PTRACE_SETREGS, sizeof (elf_gregset_t),
+  { PTRACE_GETREGS, PTRACE_SETREGS, 0, sizeof (elf_gregset_t),
     GENERAL_REGS,
     xtensa_fill_gregset, xtensa_store_gregset },
-  { PTRACE_GETXTREGS, PTRACE_SETXTREGS, XTENSA_ELF_XTREG_SIZE,
+  { PTRACE_GETXTREGS, PTRACE_SETXTREGS, 0, XTENSA_ELF_XTREG_SIZE,
     EXTENDED_REGS,
     xtensa_fill_xtregset, xtensa_store_xtregset },
-  { 0, 0, -1, -1, NULL, NULL }
+  { 0, 0, 0, -1, -1, NULL, NULL }
 };
 
 #if XCHAL_HAVE_BE
--- ./gdb/gdbserver/server.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/server.c	2010-04-03 21:12:32.000000000 +0200
@@ -1236,6 +1236,9 @@ handle_query (char *own_buf, int packet_
     {
       char *p = &own_buf[10];
 
+      /* Start processing qSupported packet.  */
+      target_process_qsupported (NULL);
+
       /* Process each feature being provided by GDB.  The first
 	 feature will follow a ':', and latter features will follow
 	 ';'.  */
@@ -1251,6 +1254,8 @@ handle_query (char *own_buf, int packet_
 		if (target_supports_multi_process ())
 		  multi_process = 1;
 	      }
+	    else
+	      target_process_qsupported (p);
 	  }
 
       sprintf (own_buf, "PacketSize=%x;QPassSignals+", PBUFSIZ - 1);
--- ./gdb/gdbserver/target.h	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/target.h	2010-04-03 21:12:32.000000000 +0200
@@ -286,6 +286,9 @@ struct target_ops
 
   /* Returns the core given a thread, or -1 if not known.  */
   int (*core_of_thread) (ptid_t);
+
+  /* Target specific qSupported support.  */
+  void (*process_qsupported) (const char *);
 };
 
 extern struct target_ops *the_target;
@@ -326,6 +329,10 @@ void set_target_ops (struct target_ops *
   (the_target->supports_multi_process ? \
    (*the_target->supports_multi_process) () : 0)
 
+#define target_process_qsupported(query) \
+  if (the_target->process_qsupported) \
+    the_target->process_qsupported (query)
+
 /* Start non-stop mode, returns 0 on success, -1 on failure.   */
 
 int start_non_stop (int nonstop);
--- ./gdb/i386-linux-nat.c	2010-04-03 20:59:52.000000000 +0200
+++ ./gdb/i386-linux-nat.c	2010-04-03 21:12:32.000000000 +0200
@@ -23,11 +23,14 @@
 #include "inferior.h"
 #include "gdbcore.h"
 #include "regcache.h"
+#include "regset.h"
 #include "target.h"
 #include "linux-nat.h"
 
 #include "gdb_assert.h"
 #include "gdb_string.h"
+#include "elf/common.h"
+#include <sys/uio.h>
 #include <sys/ptrace.h>
 #include <sys/user.h>
 #include <sys/procfs.h>
@@ -69,6 +72,19 @@
 
 /* Defines ps_err_e, struct ps_prochandle.  */
 #include "gdb_proc_service.h"
+
+#include "i386-xstate.h"
+
+#ifndef PTRACE_GETREGSET
+#define PTRACE_GETREGSET	0x4204
+#endif
+
+#ifndef PTRACE_SETREGSET
+#define PTRACE_SETREGSET	0x4205
+#endif
+
+/* Does the current host support PTRACE_GETREGSET?  */
+static int have_ptrace_getregset = -1;
 
 
 /* The register sets used in GNU/Linux ELF core-dumps are identical to
@@ -98,6 +114,8 @@ static int regmap[] = 
   -1, -1, -1, -1,		/* xmm0, xmm1, xmm2, xmm3 */
   -1, -1, -1, -1,		/* xmm4, xmm5, xmm6, xmm6 */
   -1,				/* mxcsr */
+  -1, -1, -1, -1,		/* ymm0h, ymm1h, ymm2h, ymm3h */
+  -1, -1, -1, -1,		/* ymm4h, ymm5h, ymm6h, ymm6h */
   ORIG_EAX
 };
 
@@ -110,6 +128,9 @@ static int regmap[] = 
 #define GETFPXREGS_SUPPLIES(regno) \
   (I386_ST0_REGNUM <= (regno) && (regno) < I386_SSE_NUM_REGS)
 
+#define GETXSTATEREGS_SUPPLIES(regno) \
+  (I386_ST0_REGNUM <= (regno) && (regno) < I386_AVX_NUM_REGS)
+
 /* Does the current host support the GETREGS request?  */
 int have_ptrace_getregs =
 #ifdef HAVE_PTRACE_GETREGS
@@ -355,6 +376,57 @@ static void store_fpregs (const struct r
 
 /* Transfering floating-point and SSE registers to and from GDB.  */
 
+/* Fetch all registers covered by the PTRACE_GETREGSET request from
+   process/thread TID and store their values in GDB's register array.
+   Return non-zero if successful, zero otherwise.  */
+
+static int
+fetch_xstateregs (struct regcache *regcache, int tid)
+{
+  char xstateregs[I386_XSTATE_MAX_SIZE];
+  struct iovec iov;
+
+  if (!have_ptrace_getregset)
+    return 0;
+
+  iov.iov_base = xstateregs;
+  iov.iov_len = sizeof(xstateregs);
+  if (ptrace (PTRACE_GETREGSET, tid, (unsigned int) NT_X86_XSTATE,
+	      &iov) < 0)
+    perror_with_name (_("Couldn't read extended state status"));
+
+  i387_supply_xsave (regcache, -1, xstateregs);
+  return 1;
+}
+
+/* Store all valid registers in GDB's register array covered by the
+   PTRACE_SETREGSET request into the process/thread specified by TID.
+   Return non-zero if successful, zero otherwise.  */
+
+static int
+store_xstateregs (const struct regcache *regcache, int tid, int regno)
+{
+  char xstateregs[I386_XSTATE_MAX_SIZE];
+  struct iovec iov;
+
+  if (!have_ptrace_getregset)
+    return 0;
+  
+  iov.iov_base = xstateregs;
+  iov.iov_len = sizeof(xstateregs);
+  if (ptrace (PTRACE_GETREGSET, tid, (unsigned int) NT_X86_XSTATE,
+	      &iov) < 0)
+    perror_with_name (_("Couldn't read extended state status"));
+
+  i387_collect_xsave (regcache, regno, xstateregs, 0);
+
+  if (ptrace (PTRACE_SETREGSET, tid, (unsigned int) NT_X86_XSTATE,
+	      (int) &iov) < 0)
+    perror_with_name (_("Couldn't write extended state status"));
+
+  return 1;
+}
+
 #ifdef HAVE_PTRACE_GETFPXREGS
 
 /* Fill GDB's register array with the floating-point and SSE register
@@ -489,6 +561,8 @@ i386_linux_fetch_inferior_registers (str
 	  return;
 	}
 
+      if (fetch_xstateregs (regcache, tid))
+	return;
       if (fetch_fpxregs (regcache, tid))
 	return;
       fetch_fpregs (regcache, tid);
@@ -501,6 +575,12 @@ i386_linux_fetch_inferior_registers (str
       return;
     }
 
+  if (GETXSTATEREGS_SUPPLIES (regno))
+    {
+      if (fetch_xstateregs (regcache, tid))
+	return;
+    }
+
   if (GETFPXREGS_SUPPLIES (regno))
     {
       if (fetch_fpxregs (regcache, tid))
@@ -553,6 +633,8 @@ i386_linux_store_inferior_registers (str
   if (regno == -1)
     {
       store_regs (regcache, tid, regno);
+      if (store_xstateregs (regcache, tid, regno))
+	return;
       if (store_fpxregs (regcache, tid, regno))
 	return;
       store_fpregs (regcache, tid, regno);
@@ -565,6 +647,12 @@ i386_linux_store_inferior_registers (str
       return;
     }
 
+  if (GETXSTATEREGS_SUPPLIES (regno))
+    {
+      if (store_xstateregs (regcache, tid, regno))
+	return;
+    }
+
   if (GETFPXREGS_SUPPLIES (regno))
     {
       if (store_fpxregs (regcache, tid, regno))
@@ -873,7 +961,50 @@ i386_linux_child_post_startup_inferior (
 static const struct target_desc *
 i386_linux_read_description (struct target_ops *ops)
 {
-  return tdesc_i386_linux;
+  static uint64_t xcr0;
+
+  if (have_ptrace_getregset == -1)
+    {
+      int tid;
+      uint64_t xstateregs[(I386_XSTATE_SSE_SIZE / sizeof (uint64_t))];
+      struct iovec iov;
+      unsigned int xstate_size;
+
+      /* GNU/Linux LWP ID's are process ID's.  */
+      tid = TIDGET (inferior_ptid);
+      if (tid == 0)
+	tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
+
+      iov.iov_base = xstateregs;
+      iov.iov_len = sizeof (xstateregs);
+
+      /* Check if PTRACE_GETREGSET works.  */
+      if (ptrace (PTRACE_GETREGSET, tid, (unsigned int) NT_X86_XSTATE,
+		  &iov) < 0)
+	{
+	  have_ptrace_getregset = 0;
+	  xstate_size = 0;
+	}
+      else
+	{
+	  have_ptrace_getregset = 1;
+
+	  /* Get XCR0 from XSAVE extended state.  */
+	  xcr0 = xstateregs[(I386_LINUX_XSAVE_XCR0_OFFSET
+			     / sizeof (long long))];
+
+	  xstate_size = I386_XSTATE_SIZE (xcr0);
+	}
+
+      i386_linux_update_xstateregset (xstate_size);
+    }
+
+  /* Check the native XCR0 only if PTRACE_GETREGSET is available.  */
+  if (have_ptrace_getregset
+      && (xcr0 & I386_XSTATE_AVX_MASK) == I386_XSTATE_AVX_MASK)
+    return tdesc_i386_avx_linux;
+  else
+    return tdesc_i386_linux;
 }
 
 void
--- ./gdb/i386-linux-tdep.c	2010-04-03 20:59:52.000000000 +0200
+++ ./gdb/i386-linux-tdep.c	2010-04-03 21:12:32.000000000 +0200
@@ -23,6 +23,7 @@
 #include "frame.h"
 #include "value.h"
 #include "regcache.h"
+#include "regset.h"
 #include "inferior.h"
 #include "osabi.h"
 #include "reggroups.h"
@@ -36,9 +37,11 @@
 #include "solib-svr4.h"
 #include "symtab.h"
 #include "arch-utils.h"
-#include "regset.h"
 #include "xml-syscall.h"
 
+#include "i387-tdep.h"
+#include "i386-xstate.h"
+
 /* The syscall's XML filename for i386.  */
 #define XML_SYSCALL_FILENAME_I386 "syscalls/i386-linux.xml"
 
@@ -47,6 +50,7 @@
 #include <stdint.h>
 
 #include "features/i386/i386-linux.c"
+#include "features/i386/i386-avx-linux.c"
 
 /* Supported register note sections.  */
 static struct core_regset_section i386_linux_regset_sections[] =
@@ -54,6 +58,7 @@ static struct core_regset_section i386_l
   { ".reg", 144, "general-purpose" },
   { ".reg2", 108, "floating-point" },
   { ".reg-xfp", 512, "extended floating-point" },
+  { ".reg-xstate", 0, "XSAVE extended state" },
   { NULL, 0 }
 };
 
@@ -533,6 +538,7 @@ static int i386_linux_gregset_reg_offset
   -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1,
   -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,
   11 * 4			/* "orig_eax" */
 };
 
@@ -560,6 +566,59 @@ static int i386_linux_sc_reg_offset[] =
   0 * 4				/* %gs */
 };
 
+/* Update XSAVE extended state register note section.  */
+
+void
+i386_linux_update_xstateregset (unsigned int xstate_size)
+{
+  struct core_regset_section *xstate = &i386_linux_regset_sections[3];
+
+  /* Update the XSAVE extended state register note section for "gcore".
+     Disable it if its size is 0.  */
+  gdb_assert (strcmp (xstate->sect_name, ".reg-xstate") == 0);
+  if (xstate_size)
+    xstate->size = xstate_size;
+  else
+    xstate->sect_name = NULL;
+}
+
+/* Get XSAVE extended state xcr0 from core dump.  */
+
+uint64_t
+i386_linux_core_read_xcr0 (struct gdbarch *gdbarch,
+			   struct target_ops *target, bfd *abfd)
+{
+  asection *xstate = bfd_get_section_by_name (abfd, ".reg-xstate");
+  uint64_t xcr0;
+
+  if (xstate)
+    {
+      size_t size = bfd_section_size (abfd, xstate);
+
+      /* Check extended state size.  */
+      if (size < I386_XSTATE_AVX_SIZE)
+	xcr0 = I386_XSTATE_SSE_MASK;
+      else
+	{
+	  char contents[8];
+
+	  if (! bfd_get_section_contents (abfd, xstate, contents,
+					  I386_LINUX_XSAVE_XCR0_OFFSET,
+					  8))
+	    {
+	      warning (_("Couldn't read `xcr0' bytes from `.reg-xstate' section in core file."));
+	      return 0;
+	    }
+
+	  xcr0 = bfd_get_64 (abfd, contents);
+	}
+    }
+  else
+    xcr0 = I386_XSTATE_SSE_MASK;
+
+  return xcr0;
+}
+
 /* Get Linux/x86 target description from core dump.  */
 
 static const struct target_desc *
@@ -568,12 +627,17 @@ i386_linux_core_read_description (struct
 				  bfd *abfd)
 {
   asection *section = bfd_get_section_by_name (abfd, ".reg2");
+  uint64_t xcr0;
 
   if (section == NULL)
     return NULL;
 
   /* Linux/i386.  */
-  return tdesc_i386_linux;
+  xcr0 = i386_linux_core_read_xcr0 (gdbarch, target, abfd);
+  if ((xcr0 & I386_XSTATE_AVX_MASK) == I386_XSTATE_AVX_MASK)
+    return tdesc_i386_avx_linux;
+  else
+    return tdesc_i386_linux;
 }
 
 static void
@@ -623,6 +687,8 @@ i386_linux_init_abi (struct gdbarch_info
   tdep->sc_reg_offset = i386_linux_sc_reg_offset;
   tdep->sc_num_regs = ARRAY_SIZE (i386_linux_sc_reg_offset);
 
+  tdep->xsave_xcr0_offset = I386_LINUX_XSAVE_XCR0_OFFSET;
+
   set_gdbarch_process_record (gdbarch, i386_process_record);
   set_gdbarch_process_record_signal (gdbarch, i386_linux_record_signal);
 
@@ -843,4 +909,5 @@ _initialize_i386_linux_tdep (void)
 
   /* Initialize the Linux target description  */
   initialize_tdesc_i386_linux ();
+  initialize_tdesc_i386_avx_linux ();
 }
--- ./gdb/i386-linux-tdep.h	2010-04-03 20:59:52.000000000 +0200
+++ ./gdb/i386-linux-tdep.h	2010-04-03 21:12:32.000000000 +0200
@@ -30,12 +30,41 @@
 /* Register number for the "orig_eax" pseudo-register.  If this
    pseudo-register contains a value >= 0 it is interpreted as the
    system call number that the kernel is supposed to restart.  */
-#define I386_LINUX_ORIG_EAX_REGNUM I386_SSE_NUM_REGS
+#define I386_LINUX_ORIG_EAX_REGNUM I386_AVX_NUM_REGS
 
 /* Total number of registers for GNU/Linux.  */
 #define I386_LINUX_NUM_REGS (I386_LINUX_ORIG_EAX_REGNUM + 1)
 
+/* Get XSAVE extended state xcr0 from core dump.  */
+extern uint64_t i386_linux_core_read_xcr0
+  (struct gdbarch *gdbarch, struct target_ops *target, bfd *abfd);
+
 /* Linux target description.  */
 extern struct target_desc *tdesc_i386_linux;
+extern struct target_desc *tdesc_i386_avx_linux;
+
+/* Update XSAVE extended state register note section.  */
+extern void i386_linux_update_xstateregset (unsigned int xstate_size);
+
+/* Format of XSAVE extended state is:
+ 	struct
+	{
+	  fxsave_bytes[0..463]
+	  sw_usable_bytes[464..511]
+	  xstate_hdr_bytes[512..575]
+	  avx_bytes[576..831]
+	  future_state etc
+	};
+
+  Same memory layout will be used for the coredump NT_X86_XSTATE
+  representing the XSAVE extended state registers.
+
+  The first 8 bytes of the sw_usable_bytes[464..467] is the OS enabled
+  extended state mask, which is the same as the extended control register
+  0 (the XFEATURE_ENABLED_MASK register), XCR0.  We can use this mask
+  together with the mask saved in the xstate_hdr_bytes to determine what
+  states the processor/OS supports and what state, used or initialized,
+  the process/thread is in.  */ 
+#define I386_LINUX_XSAVE_XCR0_OFFSET 464
 
 #endif /* i386-linux-tdep.h */
--- ./gdb/i386-tdep.c	2010-04-03 21:09:29.000000000 +0200
+++ ./gdb/i386-tdep.c	2010-04-03 21:12:32.000000000 +0200
@@ -51,11 +51,13 @@
 
 #include "i386-tdep.h"
 #include "i387-tdep.h"
+#include "i386-xstate.h"
 
 #include "record.h"
 #include <stdint.h>
 
 #include "features/i386/i386.c"
+#include "features/i386/i386-avx.c"
 
 /* Register names.  */
 
@@ -74,6 +76,18 @@ static const char *i386_register_names[]
   "mxcsr"
 };
 
+static const char *i386_ymm_names[] =
+{
+  "ymm0",  "ymm1",   "ymm2",  "ymm3",
+  "ymm4",  "ymm5",   "ymm6",  "ymm7",
+};
+
+static const char *i386_ymmh_names[] =
+{
+  "ymm0h",  "ymm1h",   "ymm2h",  "ymm3h",
+  "ymm4h",  "ymm5h",   "ymm6h",  "ymm7h",
+};
+
 /* Register names for MMX pseudo-registers.  */
 
 static const char *i386_mmx_names[] =
@@ -150,18 +164,47 @@ i386_dword_regnum_p (struct gdbarch *gdb
   return regnum >= 0 && regnum < tdep->num_dword_regs;
 }
 
+int
+i386_ymmh_regnum_p (struct gdbarch *gdbarch, int regnum)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  int ymm0h_regnum = tdep->ymm0h_regnum;
+
+  if (ymm0h_regnum < 0)
+    return 0;
+
+  regnum -= ymm0h_regnum;
+  return regnum >= 0 && regnum < tdep->num_ymm_regs;
+}
+
+/* AVX register?  */
+
+int
+i386_ymm_regnum_p (struct gdbarch *gdbarch, int regnum)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  int ymm0_regnum = tdep->ymm0_regnum;
+
+  if (ymm0_regnum < 0)
+    return 0;
+
+  regnum -= ymm0_regnum;
+  return regnum >= 0 && regnum < tdep->num_ymm_regs;
+}
+
 /* SSE register?  */
 
-static int
-i386_sse_regnum_p (struct gdbarch *gdbarch, int regnum)
+int
+i386_xmm_regnum_p (struct gdbarch *gdbarch, int regnum)
 {
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  int num_xmm_regs = I387_NUM_XMM_REGS (tdep);
 
-  if (I387_NUM_XMM_REGS (tdep) == 0)
+  if (num_xmm_regs == 0)
     return 0;
 
-  return (I387_XMM0_REGNUM (tdep) <= regnum
-	  && regnum < I387_MXCSR_REGNUM (tdep));
+  regnum -= I387_XMM0_REGNUM (tdep);
+  return regnum >= 0 && regnum < num_xmm_regs;
 }
 
 static int
@@ -201,6 +244,19 @@ i386_fpc_regnum_p (struct gdbarch *gdbar
 	  && regnum < I387_XMM0_REGNUM (tdep));
 }
 
+/* Return the name of register REGNUM, or the empty string if it is
+   an anonymous register.  */
+
+static const char *
+i386_register_name (struct gdbarch *gdbarch, int regnum)
+{
+  /* Hide the upper YMM registers.  */
+  if (i386_ymmh_regnum_p (gdbarch, regnum))
+    return "";
+
+  return tdesc_register_name (gdbarch, regnum);
+}
+
 /* Return the name of register REGNUM.  */
 
 const char *
@@ -209,6 +265,8 @@ i386_pseudo_register_name (struct gdbarc
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
   if (i386_mmx_regnum_p (gdbarch, regnum))
     return i386_mmx_names[regnum - I387_MM0_REGNUM (tdep)];
+  else if (i386_ymm_regnum_p (gdbarch, regnum))
+    return i386_ymm_names[regnum - tdep->ymm0_regnum];
   else if (i386_byte_regnum_p (gdbarch, regnum))
     return i386_byte_names[regnum - tdep->al_regnum];
   else if (i386_word_regnum_p (gdbarch, regnum))
@@ -246,7 +304,13 @@ i386_dbx_reg_to_regnum (struct gdbarch *
   else if (reg >= 21 && reg <= 28)
     {
       /* SSE registers.  */
-      return reg - 21 + I387_XMM0_REGNUM (tdep);
+      int ymm0_regnum = tdep->ymm0_regnum;
+
+      if (ymm0_regnum >= 0
+	  && i386_xmm_regnum_p (gdbarch, reg))
+	return reg - 21 + ymm0_regnum;
+      else
+	return reg - 21 + I387_XMM0_REGNUM (tdep);
     }
   else if (reg >= 29 && reg <= 36)
     {
@@ -2184,6 +2248,59 @@ i387_ext_type (struct gdbarch *gdbarch)
   return tdep->i387_ext_type;
 }
 
+/* Construct vector type for pseudo YMM registers.  We can't use
+   tdesc_find_type since YMM isn't described in target description.  */
+
+static struct type *
+i386_ymm_type (struct gdbarch *gdbarch)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  if (!tdep->i386_ymm_type)
+    {
+      const struct builtin_type *bt = builtin_type (gdbarch);
+
+      /* The type we're building is this: */
+#if 0
+      union __gdb_builtin_type_vec256i
+      {
+        int128_t uint128[2];
+        int64_t v2_int64[4];
+        int32_t v4_int32[8];
+        int16_t v8_int16[16];
+        int8_t v16_int8[32];
+        double v2_double[4];
+        float v4_float[8];
+      };
+#endif
+
+      struct type *t;
+
+      t = arch_composite_type (gdbarch,
+			       "__gdb_builtin_type_vec256i", TYPE_CODE_UNION);
+      append_composite_type_field (t, "v8_float",
+				   init_vector_type (bt->builtin_float, 8));
+      append_composite_type_field (t, "v4_double",
+				   init_vector_type (bt->builtin_double, 4));
+      append_composite_type_field (t, "v32_int8",
+				   init_vector_type (bt->builtin_int8, 32));
+      append_composite_type_field (t, "v16_int16",
+				   init_vector_type (bt->builtin_int16, 16));
+      append_composite_type_field (t, "v8_int32",
+				   init_vector_type (bt->builtin_int32, 8));
+      append_composite_type_field (t, "v4_int64",
+				   init_vector_type (bt->builtin_int64, 4));
+      append_composite_type_field (t, "v2_int128",
+				   init_vector_type (bt->builtin_int128, 2));
+
+      TYPE_VECTOR (t) = 1;
+      TYPE_NAME (t) = "builtin_type_vec128i";
+      tdep->i386_ymm_type = t;
+    }
+
+  return tdep->i386_ymm_type;
+}
+
 /* Construct vector type for MMX registers.  */
 static struct type *
 i386_mmx_type (struct gdbarch *gdbarch)
@@ -2234,6 +2351,8 @@ i386_pseudo_register_type (struct gdbarc
 {
   if (i386_mmx_regnum_p (gdbarch, regnum))
     return i386_mmx_type (gdbarch);
+  else if (i386_ymm_regnum_p (gdbarch, regnum))
+    return i386_ymm_type (gdbarch);
   else
     {
       const struct builtin_type *bt = builtin_type (gdbarch);
@@ -2285,7 +2404,22 @@ i386_pseudo_register_read (struct gdbarc
     {
       struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
 
-      if (i386_word_regnum_p (gdbarch, regnum))
+      if (i386_ymm_regnum_p (gdbarch, regnum))
+	{
+	  regnum -= tdep->ymm0_regnum;
+
+	  /* Extract (always little endian).  Read lower 128bits. */
+	  regcache_raw_read (regcache,
+			     I387_XMM0_REGNUM (tdep) + regnum,
+			     raw_buf);
+	  memcpy (buf, raw_buf, 16);
+	  /* Read upper 128bits.  */
+	  regcache_raw_read (regcache,
+			     tdep->ymm0h_regnum + regnum,
+			     raw_buf);
+	  memcpy (buf + 16, raw_buf, 16);
+	}
+      else if (i386_word_regnum_p (gdbarch, regnum))
 	{
 	  int gpnum = regnum - tdep->ax_regnum;
 
@@ -2334,7 +2468,20 @@ i386_pseudo_register_write (struct gdbar
     {
       struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
 
-      if (i386_word_regnum_p (gdbarch, regnum))
+      if (i386_ymm_regnum_p (gdbarch, regnum))
+	{
+	  regnum -= tdep->ymm0_regnum;
+
+	  /* ... Write lower 128bits.  */
+	  regcache_raw_write (regcache,
+			     I387_XMM0_REGNUM (tdep) + regnum,
+			     buf);
+	  /* ... Write upper 128bits.  */
+	  regcache_raw_write (regcache,
+			     tdep->ymm0h_regnum + regnum,
+			     buf + 16);
+	}
+      else if (i386_word_regnum_p (gdbarch, regnum))
 	{
 	  int gpnum = regnum - tdep->ax_regnum;
 
@@ -2581,6 +2728,28 @@ i386_collect_fpregset (const struct regs
   i387_collect_fsave (regcache, regnum, fpregs);
 }
 
+/* Similar to i386_supply_fpregset, but use XSAVE extended state.  */
+
+static void
+i386_supply_xstateregset (const struct regset *regset,
+			  struct regcache *regcache, int regnum,
+			  const void *xstateregs, size_t len)
+{
+  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
+  i387_supply_xsave (regcache, regnum, xstateregs);
+}
+
+/* Similar to i386_collect_fpregset , but use XSAVE extended state.  */
+
+static void
+i386_collect_xstateregset (const struct regset *regset,
+			   const struct regcache *regcache,
+			   int regnum, void *xstateregs, size_t len)
+{
+  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
+  i387_collect_xsave (regcache, regnum, xstateregs, 1);
+}
+
 /* Return the appropriate register set for the core section identified
    by SECT_NAME and SECT_SIZE.  */
 
@@ -2608,6 +2777,16 @@ i386_regset_from_core_section (struct gd
       return tdep->fpregset;
     }
 
+  if (strcmp (sect_name, ".reg-xstate") == 0)
+    {
+      if (tdep->xstateregset == NULL)
+	tdep->xstateregset = regset_alloc (gdbarch,
+					   i386_supply_xstateregset,
+					   i386_collect_xstateregset);
+
+      return tdep->xstateregset;
+    }
+
   return NULL;
 }
 
@@ -2801,46 +2980,60 @@ int
 i386_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
 			  struct reggroup *group)
 {
-  int sse_regnum_p, fp_regnum_p, mmx_regnum_p, byte_regnum_p,
-      word_regnum_p, dword_regnum_p;
+  const struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  int fp_regnum_p, mmx_regnum_p, xmm_regnum_p, mxcsr_regnum_p,
+      ymm_regnum_p, ymmh_regnum_p;
 
   /* Don't include pseudo registers, except for MMX, in any register
      groups.  */
-  byte_regnum_p = i386_byte_regnum_p (gdbarch, regnum);
-  if (byte_regnum_p)
+  if (i386_byte_regnum_p (gdbarch, regnum))
     return 0;
 
-  word_regnum_p = i386_word_regnum_p (gdbarch, regnum);
-  if (word_regnum_p)
+  if (i386_word_regnum_p (gdbarch, regnum))
     return 0;
 
-  dword_regnum_p = i386_dword_regnum_p (gdbarch, regnum);
-  if (dword_regnum_p)
+  if (i386_dword_regnum_p (gdbarch, regnum))
     return 0;
 
   mmx_regnum_p = i386_mmx_regnum_p (gdbarch, regnum);
   if (group == i386_mmx_reggroup)
     return mmx_regnum_p;
 
-  sse_regnum_p = (i386_sse_regnum_p (gdbarch, regnum)
-		  || i386_mxcsr_regnum_p (gdbarch, regnum));
+  xmm_regnum_p = i386_xmm_regnum_p (gdbarch, regnum);
+  mxcsr_regnum_p = i386_mxcsr_regnum_p (gdbarch, regnum);
   if (group == i386_sse_reggroup)
-    return sse_regnum_p;
+    return xmm_regnum_p || mxcsr_regnum_p;
+
+  ymm_regnum_p = i386_ymm_regnum_p (gdbarch, regnum);
   if (group == vector_reggroup)
-    return mmx_regnum_p || sse_regnum_p;
+    return (mmx_regnum_p
+	    || ymm_regnum_p
+	    || mxcsr_regnum_p
+	    || (xmm_regnum_p
+		&& ((tdep->xcr0 & I386_XSTATE_AVX_MASK)
+		    == I386_XSTATE_SSE_MASK)));
 
   fp_regnum_p = (i386_fp_regnum_p (gdbarch, regnum)
 		 || i386_fpc_regnum_p (gdbarch, regnum));
   if (group == float_reggroup)
     return fp_regnum_p;
 
+  /* For "info reg all", don't include upper YMM registers nor XMM
+     registers when AVX is supported.  */
+  ymmh_regnum_p = i386_ymmh_regnum_p (gdbarch, regnum);
+  if (group == all_reggroup
+      && ((xmm_regnum_p
+	   && (tdep->xcr0 & I386_XSTATE_AVX))
+	  || ymmh_regnum_p))
+    return 0;
+
   if (group == general_reggroup)
     return (!fp_regnum_p
 	    && !mmx_regnum_p
-	    && !sse_regnum_p
-	    && !byte_regnum_p
-	    && !word_regnum_p
-	    && !dword_regnum_p);
+	    && !mxcsr_regnum_p
+	    && !xmm_regnum_p
+	    && !ymm_regnum_p
+	    && !ymmh_regnum_p);
 
   return default_register_reggroup_p (gdbarch, regnum, group);
 }
@@ -5650,7 +5843,8 @@ i386_validate_tdesc_p (struct gdbarch_td
 		       struct tdesc_arch_data *tdesc_data)
 {
   const struct target_desc *tdesc = tdep->tdesc;
-  const struct tdesc_feature *feature_core, *feature_vector;
+  const struct tdesc_feature *feature_core;
+  const struct tdesc_feature *feature_sse, *feature_avx;
   int i, num_regs, valid_p;
 
   if (! tdesc_has_registers (tdesc))
@@ -5660,13 +5854,37 @@ i386_validate_tdesc_p (struct gdbarch_td
   feature_core = tdesc_find_feature (tdesc, "org.gnu.gdb.i386.core");
 
   /* Get SSE registers.  */
-  feature_vector = tdesc_find_feature (tdesc, "org.gnu.gdb.i386.sse");
+  feature_sse = tdesc_find_feature (tdesc, "org.gnu.gdb.i386.sse");
 
-  if (feature_core == NULL || feature_vector == NULL)
+  if (feature_core == NULL || feature_sse == NULL)
     return 0;
 
+  /* Try AVX registers.  */
+  feature_avx = tdesc_find_feature (tdesc, "org.gnu.gdb.i386.avx");
+
   valid_p = 1;
 
+  /* The XCR0 bits.  */
+  if (feature_avx)
+    {
+      tdep->xcr0 = I386_XSTATE_AVX_MASK;
+
+      /* It may have been set by OSABI initialization function.  */
+      if (tdep->num_ymm_regs == 0)
+	{
+	  tdep->ymmh_register_names = i386_ymmh_names;
+	  tdep->num_ymm_regs = 8;
+	  tdep->ymm0h_regnum = I386_YMM0H_REGNUM;
+	}
+
+      for (i = 0; i < tdep->num_ymm_regs; i++)
+	valid_p &= tdesc_numbered_register (feature_avx, tdesc_data,
+					    tdep->ymm0h_regnum + i,
+					    tdep->ymmh_register_names[i]);
+    }
+  else
+    tdep->xcr0 = I386_XSTATE_SSE_MASK;
+
   num_regs = tdep->num_core_regs;
   for (i = 0; i < num_regs; i++)
     valid_p &= tdesc_numbered_register (feature_core, tdesc_data, i,
@@ -5675,7 +5893,7 @@ i386_validate_tdesc_p (struct gdbarch_td
   /* Need to include %mxcsr, so add one.  */
   num_regs += tdep->num_xmm_regs + 1;
   for (; i < num_regs; i++)
-    valid_p &= tdesc_numbered_register (feature_vector, tdesc_data, i,
+    valid_p &= tdesc_numbered_register (feature_sse, tdesc_data, i,
 					tdep->register_names[i]);
 
   return valid_p;
@@ -5690,6 +5908,7 @@ i386_gdbarch_init (struct gdbarch_info i
   struct tdesc_arch_data *tdesc_data;
   const struct target_desc *tdesc;
   int mm0_regnum;
+  int ymm0_regnum;
 
   /* If there is already a candidate, use it.  */
   arches = gdbarch_list_lookup_by_info (arches, &info);
@@ -5710,6 +5929,8 @@ i386_gdbarch_init (struct gdbarch_info i
   tdep->fpregset = NULL;
   tdep->sizeof_fpregset = I387_SIZEOF_FSAVE;
 
+  tdep->xstateregset = NULL;
+
   /* The default settings include the FPU registers, the MMX registers
      and the SSE registers.  This can be overridden for a specific ABI
      by adjusting the members `st0_regnum', `mm0_regnum' and
@@ -5742,6 +5963,8 @@ i386_gdbarch_init (struct gdbarch_info i
   /* Unwinding stops on i386 automatically.  */
   tdep->outermost_frame_p = NULL;
 
+  tdep->xsave_xcr0_offset = -1;
+
   tdep->record_regmap = i386_record_regmap;
 
   /* The format used for `long double' on almost all i386 targets is
@@ -5858,9 +6081,14 @@ i386_gdbarch_init (struct gdbarch_info i
   set_tdesc_pseudo_register_type (gdbarch, i386_pseudo_register_type);
   set_tdesc_pseudo_register_name (gdbarch, i386_pseudo_register_name);
 
-  /* The default ABI includes general-purpose registers, 
-     floating-point registers, and the SSE registers.  */
-  set_gdbarch_num_regs (gdbarch, I386_SSE_NUM_REGS);
+  /* Override the normal target description method to make the AVX
+     upper halves anonymous.  */
+  set_gdbarch_register_name (gdbarch, i386_register_name);
+
+  /* Even though the default ABI only includes general-purpose registers,
+     floating-point registers and the SSE registers, we have to leave a
+     gap for the upper AVX registers.  */
+  set_gdbarch_num_regs (gdbarch, I386_AVX_NUM_REGS);
 
   /* Get the x86 target description from INFO.  */
   tdesc = info.target_desc;
@@ -5871,10 +6099,15 @@ i386_gdbarch_init (struct gdbarch_info i
   tdep->num_core_regs = I386_NUM_GREGS + I387_NUM_REGS;
   tdep->register_names = i386_register_names;
 
+  /* No upper YMM registers.  */
+  tdep->ymmh_register_names = NULL;
+  tdep->ymm0h_regnum = -1;
+
   tdep->num_byte_regs = 8;
   tdep->num_word_regs = 8;
   tdep->num_dword_regs = 0;
   tdep->num_mmx_regs = 8;
+  tdep->num_ymm_regs = 0;
 
   tdesc_data = tdesc_data_alloc ();
 
@@ -5882,24 +6115,25 @@ i386_gdbarch_init (struct gdbarch_info i
   info.tdep_info = (void *) tdesc_data;
   gdbarch_init_osabi (info, gdbarch);
 
+  if (!i386_validate_tdesc_p (tdep, tdesc_data))
+    {
+      tdesc_data_cleanup (tdesc_data);
+      xfree (tdep);
+      gdbarch_free (gdbarch);
+      return NULL;
+    }
+
   /* Wire in pseudo registers.  Number of pseudo registers may be
      changed.  */
   set_gdbarch_num_pseudo_regs (gdbarch, (tdep->num_byte_regs
 					 + tdep->num_word_regs
 					 + tdep->num_dword_regs
-					 + tdep->num_mmx_regs));
+					 + tdep->num_mmx_regs
+					 + tdep->num_ymm_regs));
 
   /* Target description may be changed.  */
   tdesc = tdep->tdesc;
 
-  if (!i386_validate_tdesc_p (tdep, tdesc_data))
-    {
-      tdesc_data_cleanup (tdesc_data);
-      xfree (tdep);
-      gdbarch_free (gdbarch);
-      return NULL;
-    }
-
   tdesc_use_registers (gdbarch, tdesc, tdesc_data);
 
   /* Override gdbarch_register_reggroup_p set in tdesc_use_registers.  */
@@ -5909,16 +6143,26 @@ i386_gdbarch_init (struct gdbarch_info i
   tdep->al_regnum = gdbarch_num_regs (gdbarch);
   tdep->ax_regnum = tdep->al_regnum + tdep->num_byte_regs;
 
-  mm0_regnum = tdep->ax_regnum + tdep->num_word_regs;
+  ymm0_regnum = tdep->ax_regnum + tdep->num_word_regs;
   if (tdep->num_dword_regs)
     {
       /* Support dword pseudo-registesr if it hasn't been disabled,  */
-      tdep->eax_regnum = mm0_regnum;
-      mm0_regnum = tdep->eax_regnum + tdep->num_dword_regs;
+      tdep->eax_regnum = ymm0_regnum;
+      ymm0_regnum += tdep->num_dword_regs;
     }
   else
     tdep->eax_regnum = -1;
 
+  mm0_regnum = ymm0_regnum;
+  if (tdep->num_ymm_regs)
+    {
+      /* Support YMM pseudo-registesr if it is available,  */
+      tdep->ymm0_regnum = ymm0_regnum;
+      mm0_regnum += tdep->num_ymm_regs;
+    }
+  else
+    tdep->ymm0_regnum = -1;
+
   if (tdep->num_mmx_regs != 0)
     {
       /* Support MMX pseudo-registesr if MMX hasn't been disabled,  */
@@ -6001,6 +6245,7 @@ is \"default\"."),
 
   /* Initialize the standard target descriptions.  */
   initialize_tdesc_i386 ();
+  initialize_tdesc_i386_avx ();
 
   /* Tell remote stub that we support XML target description.  */
   register_remote_support_xml ("i386");
--- ./gdb/i386-tdep.h	2010-04-03 21:06:52.000000000 +0200
+++ ./gdb/i386-tdep.h	2010-04-03 21:12:32.000000000 +0200
@@ -109,6 +109,9 @@ struct gdbarch_tdep
   struct regset *fpregset;
   size_t sizeof_fpregset;
 
+  /* XSAVE extended state.  */
+  struct regset *xstateregset;
+
   /* Register number for %st(0).  The register numbers for the other
      registers follow from this one.  Set this to -1 to indicate the
      absence of an FPU.  */
@@ -121,6 +124,13 @@ struct gdbarch_tdep
      of MMX support.  */
   int mm0_regnum;
 
+  /* Number of pseudo YMM registers.  */
+  int num_ymm_regs;
+
+  /* Register number for %ymm0.  Set this to -1 to indicate the absence
+     of pseudo YMM register support.  */
+  int ymm0_regnum;
+
   /* Number of byte registers.  */
   int num_byte_regs;
 
@@ -146,9 +156,24 @@ struct gdbarch_tdep
   /* Number of SSE registers.  */
   int num_xmm_regs;
 
+  /* Bits of the extended control register 0 (the XFEATURE_ENABLED_MASK
+     register), excluding the x87 bit, which are supported by this GDB.
+   */
+  uint64_t xcr0;
+
+  /* Offset of XCR0 in XSAVE extended state.  */
+  int xsave_xcr0_offset;
+
   /* Register names.  */
   const char **register_names;
 
+  /* Register number for %ymm0h.  Set this to -1 to indicate the absence
+     of upper YMM register support.  */
+  int ymm0h_regnum;
+
+  /* Upper YMM register names.  Only used for tdesc_numbered_register.  */
+  const char **ymmh_register_names;
+
   /* Target description.  */
   const struct target_desc *tdesc;
 
@@ -182,6 +207,7 @@ struct gdbarch_tdep
 
   /* ISA-specific data types.  */
   struct type *i386_mmx_type;
+  struct type *i386_ymm_type;
   struct type *i387_ext_type;
 
   /* Process record/replay target.  */
@@ -231,7 +257,9 @@ enum i386_regnum
   I386_FS_REGNUM,		/* %fs */
   I386_GS_REGNUM,		/* %gs */
   I386_ST0_REGNUM,		/* %st(0) */
-  I386_MXCSR_REGNUM = 40	/* %mxcsr */ 
+  I386_MXCSR_REGNUM = 40,	/* %mxcsr */ 
+  I386_YMM0H_REGNUM,		/* %ymm0h */
+  I386_YMM7H_REGNUM = I386_YMM0H_REGNUM + 7
 };
 
 /* Register numbers of RECORD_REGMAP.  */
@@ -268,6 +296,7 @@ enum record_i386_regnum
 #define I386_NUM_XREGS  9
 
 #define I386_SSE_NUM_REGS	(I386_MXCSR_REGNUM + 1)
+#define I386_AVX_NUM_REGS	(I386_YMM7H_REGNUM + 1)
 
 /* Size of the largest register.  */
 #define I386_MAX_REGISTER_SIZE	16
@@ -279,6 +308,9 @@ extern struct type *i387_ext_type (struc
 extern int i386_byte_regnum_p (struct gdbarch *gdbarch, int regnum);
 extern int i386_word_regnum_p (struct gdbarch *gdbarch, int regnum);
 extern int i386_dword_regnum_p (struct gdbarch *gdbarch, int regnum);
+extern int i386_xmm_regnum_p (struct gdbarch *gdbarch, int regnum);
+extern int i386_ymm_regnum_p (struct gdbarch *gdbarch, int regnum);
+extern int i386_ymmh_regnum_p (struct gdbarch *gdbarch, int regnum);
 
 extern const char *i386_pseudo_register_name (struct gdbarch *gdbarch,
 					      int regnum);
--- ./gdb/i387-tdep.c	2010-01-01 08:31:36.000000000 +0100
+++ ./gdb/i387-tdep.c	2010-04-03 21:12:32.000000000 +0200
@@ -34,6 +34,7 @@
 
 #include "i386-tdep.h"
 #include "i387-tdep.h"
+#include "i386-xstate.h"
 
 /* Print the floating point number specified by RAW.  */
 
@@ -677,6 +678,518 @@ i387_collect_fxsave (const struct regcac
 			  FXSAVE_MXCSR_ADDR (regs));
 }
 
+/* `xstate_bv' is at byte offset 512.  */
+#define XSAVE_XSTATE_BV_ADDR(xsave) (xsave + 512)
+
+/* At xsave_avxh_offset[REGNUM] you'll find the offset to the location in
+   the upper 128bit of AVX register data structure used by the "xsave"
+   instruction where GDB register REGNUM is stored.  */
+
+static int xsave_avxh_offset[] =
+{
+  576 + 0 * 16,		/* Upper 128bit of %ymm0 through ...  */
+  576 + 1 * 16,
+  576 + 2 * 16,
+  576 + 3 * 16,
+  576 + 4 * 16,
+  576 + 5 * 16,
+  576 + 6 * 16,
+  576 + 7 * 16,
+  576 + 8 * 16,
+  576 + 9 * 16,
+  576 + 10 * 16,
+  576 + 11 * 16,
+  576 + 12 * 16,
+  576 + 13 * 16,
+  576 + 14 * 16,
+  576 + 15 * 16		/* Upper 128bit of ... %ymm15 (128 bits each).  */
+};
+
+#define XSAVE_AVXH_ADDR(tdep, xsave, regnum) \
+  (xsave + xsave_avxh_offset[regnum - I387_YMM0H_REGNUM (tdep)])
+
+/* Similar to i387_supply_fxsave, but use XSAVE extended state.  */
+
+void
+i387_supply_xsave (struct regcache *regcache, int regnum,
+		   const void *xsave)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
+  const gdb_byte *regs = xsave;
+  int i;
+  unsigned int clear_bv;
+  const gdb_byte *p;
+  enum
+    {
+      none = 0x0,
+      x87 = 0x1,
+      sse = 0x2,
+      avxh = 0x4,
+      all = x87 | sse | avxh
+    } regclass;
+
+  gdb_assert (tdep->st0_regnum >= I386_ST0_REGNUM);
+  gdb_assert (tdep->num_xmm_regs > 0);
+
+  if (regnum == -1)
+    regclass = all;
+  else if (regnum >= I387_YMM0H_REGNUM (tdep)
+	   && regnum < I387_YMMENDH_REGNUM (tdep))
+    regclass = avxh;
+  else if (regnum >= I387_XMM0_REGNUM(tdep)
+	   && regnum < I387_MXCSR_REGNUM (tdep))
+    regclass = sse;
+  else if (regnum >= I387_ST0_REGNUM (tdep)
+	   && regnum < I387_FCTRL_REGNUM (tdep))
+    regclass = x87;
+  else
+    regclass = none;
+
+  if (regs != NULL && regclass != none)
+    {
+      /* Get `xstat_bv'.  */
+      const gdb_byte *xstate_bv_p = XSAVE_XSTATE_BV_ADDR (regs);
+
+      /* The supported bits in `xstat_bv' are 1 byte.  Clear part in
+	 vector registers if its bit in xstat_bv is zero.  */
+      clear_bv = (~(*xstate_bv_p)) & tdep->xcr0;
+    }
+  else
+    clear_bv = I386_XSTATE_AVX_MASK;
+
+  switch (regclass)
+    {
+    case none:
+      break;
+
+    case avxh:
+      if ((clear_bv & I386_XSTATE_AVX))
+	p = NULL;
+      else
+	p = XSAVE_AVXH_ADDR (tdep, regs, regnum);
+      regcache_raw_supply (regcache, regnum, p);
+      return;
+
+    case sse:
+      if ((clear_bv & I386_XSTATE_SSE))
+	p = NULL;
+      else
+	p = FXSAVE_ADDR (tdep, regs, regnum);
+      regcache_raw_supply (regcache, regnum, p);
+      return;
+
+    case x87:
+      if ((clear_bv & I386_XSTATE_X87))
+	p = NULL;
+      else
+	p = FXSAVE_ADDR (tdep, regs, regnum);
+      regcache_raw_supply (regcache, regnum, p);
+      return;
+
+    case all:
+      /* Hanle the upper YMM registers.  */
+      if ((tdep->xcr0 & I386_XSTATE_AVX))
+	{
+	  if ((clear_bv & I386_XSTATE_AVX))
+	    p = NULL;
+	  else
+	    p = regs;
+
+	  for (i = I387_YMM0H_REGNUM (tdep);
+	       i < I387_YMMENDH_REGNUM (tdep); i++)
+	    {
+	      if (p != NULL)
+		p = XSAVE_AVXH_ADDR (tdep, regs, i);
+	      regcache_raw_supply (regcache, i, p);
+	    }
+	}
+
+      /* Handle the XMM registers.  */
+      if ((tdep->xcr0 & I386_XSTATE_SSE))
+	{
+	  if ((clear_bv & I386_XSTATE_SSE))
+	    p = NULL;
+	  else
+	    p = regs;
+
+	  for (i = I387_XMM0_REGNUM (tdep);
+	       i < I387_MXCSR_REGNUM (tdep); i++)
+	    {
+	      if (p != NULL)
+		p = FXSAVE_ADDR (tdep, regs, i);
+	      regcache_raw_supply (regcache, i, p);
+	    }
+	}
+
+      /* Handle the x87 registers.  */
+      if ((tdep->xcr0 & I386_XSTATE_X87))
+	{
+	  if ((clear_bv & I386_XSTATE_X87))
+	    p = NULL;
+	  else
+	    p = regs;
+
+	  for (i = I387_ST0_REGNUM (tdep);
+	       i < I387_FCTRL_REGNUM (tdep); i++)
+	    {
+	      if (p != NULL)
+		p = FXSAVE_ADDR (tdep, regs, i);
+	      regcache_raw_supply (regcache, i, p);
+	    }
+	}
+      break;
+    }
+
+  /* Only handle x87 control registers.  */
+  for (i = I387_FCTRL_REGNUM (tdep); i < I387_XMM0_REGNUM (tdep); i++)
+    if (regnum == -1 || regnum == i)
+      {
+	if (regs == NULL)
+	  {
+	    regcache_raw_supply (regcache, i, NULL);
+	    continue;
+	  }
+
+	/* Most of the FPU control registers occupy only 16 bits in
+	   the xsave extended state.  Give those a special treatment.  */
+	if (i != I387_FIOFF_REGNUM (tdep)
+	    && i != I387_FOOFF_REGNUM (tdep))
+	  {
+	    gdb_byte val[4];
+
+	    memcpy (val, FXSAVE_ADDR (tdep, regs, i), 2);
+	    val[2] = val[3] = 0;
+	    if (i == I387_FOP_REGNUM (tdep))
+	      val[1] &= ((1 << 3) - 1);
+	    else if (i== I387_FTAG_REGNUM (tdep))
+	      {
+		/* The fxsave area contains a simplified version of
+		   the tag word.  We have to look at the actual 80-bit
+		   FP data to recreate the traditional i387 tag word.  */
+
+		unsigned long ftag = 0;
+		int fpreg;
+		int top;
+
+		top = ((FXSAVE_ADDR (tdep, regs,
+				     I387_FSTAT_REGNUM (tdep)))[1] >> 3);
+		top &= 0x7;
+
+		for (fpreg = 7; fpreg >= 0; fpreg--)
+		  {
+		    int tag;
+
+		    if (val[0] & (1 << fpreg))
+		      {
+			int regnum = (fpreg + 8 - top) % 8 
+				       + I387_ST0_REGNUM (tdep);
+			tag = i387_tag (FXSAVE_ADDR (tdep, regs, regnum));
+		      }
+		    else
+		      tag = 3;		/* Empty */
+
+		    ftag |= tag << (2 * fpreg);
+		  }
+		val[0] = ftag & 0xff;
+		val[1] = (ftag >> 8) & 0xff;
+	      }
+	    regcache_raw_supply (regcache, i, val);
+	  }
+	else 
+	  regcache_raw_supply (regcache, i, FXSAVE_ADDR (tdep, regs, i));
+      }
+
+  if (regnum == I387_MXCSR_REGNUM (tdep) || regnum == -1)
+    {
+      p = regs == NULL ? NULL : FXSAVE_MXCSR_ADDR (regs);
+      regcache_raw_supply (regcache, I387_MXCSR_REGNUM (tdep), p);
+    }
+}
+
+/* Similar to i387_collect_fxsave, but use XSAVE extended state.  */
+
+void
+i387_collect_xsave (const struct regcache *regcache, int regnum,
+		    void *xsave, int gcore)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
+  gdb_byte *regs = xsave;
+  int i;
+  enum
+    {
+      none = 0x0,
+      check = 0x1,
+      x87 = 0x2 | check,
+      sse = 0x4 | check,
+      avxh = 0x8 | check,
+      all = x87 | sse | avxh
+    } regclass;
+
+  gdb_assert (tdep->st0_regnum >= I386_ST0_REGNUM);
+  gdb_assert (tdep->num_xmm_regs > 0);
+
+  if (regnum == -1)
+    regclass = all;
+  else if (regnum >= I387_YMM0H_REGNUM (tdep)
+	   && regnum < I387_YMMENDH_REGNUM (tdep))
+    regclass = avxh;
+  else if (regnum >= I387_XMM0_REGNUM(tdep)
+	   && regnum < I387_MXCSR_REGNUM (tdep))
+    regclass = sse;
+  else if (regnum >= I387_ST0_REGNUM (tdep)
+	   && regnum < I387_FCTRL_REGNUM (tdep))
+    regclass = x87;
+  else
+    regclass = none;
+
+  if (gcore)
+    {
+      /* Update XCR0 and `xstate_bv' with XCR0 for gcore.  */
+      if (tdep->xsave_xcr0_offset != -1)
+	memcpy (regs + tdep->xsave_xcr0_offset, &tdep->xcr0, 8);
+      memcpy (XSAVE_XSTATE_BV_ADDR (regs), &tdep->xcr0, 8);
+
+      switch (regclass)
+	{
+	default:
+	  abort ();
+
+	case all:
+	  /* Handle the upper YMM registers.  */
+	  if ((tdep->xcr0 & I386_XSTATE_AVX))
+	    for (i = I387_YMM0H_REGNUM (tdep);
+		 i < I387_YMMENDH_REGNUM (tdep); i++)
+	      regcache_raw_collect (regcache, i,
+				    XSAVE_AVXH_ADDR (tdep, regs, i));
+
+	  /* Handle the XMM registers.  */
+	  if ((tdep->xcr0 & I386_XSTATE_SSE))
+	    for (i = I387_XMM0_REGNUM (tdep);
+		 i < I387_MXCSR_REGNUM (tdep); i++)
+	      regcache_raw_collect (regcache, i,
+				    FXSAVE_ADDR (tdep, regs, i));
+
+	  /* Handle the x87 registers.  */
+	  if ((tdep->xcr0 & I386_XSTATE_X87))
+	    for (i = I387_ST0_REGNUM (tdep);
+		 i < I387_FCTRL_REGNUM (tdep); i++)
+	      regcache_raw_collect (regcache, i,
+				    FXSAVE_ADDR (tdep, regs, i));
+	  break;
+
+	case x87:
+	  regcache_raw_collect (regcache, regnum,
+				FXSAVE_ADDR (tdep, regs, regnum));
+	  return;
+
+	case sse:
+	  regcache_raw_collect (regcache, regnum,
+				FXSAVE_ADDR (tdep, regs, regnum));
+	  return;
+
+	case avxh:
+	  regcache_raw_collect (regcache, regnum,
+				XSAVE_AVXH_ADDR (tdep, regs, regnum));
+	  return;
+	}
+    }
+  else
+    {
+      if ((regclass & check))
+	{
+	  gdb_byte raw[I386_MAX_REGISTER_SIZE];
+	  gdb_byte *xstate_bv_p = XSAVE_XSTATE_BV_ADDR (regs);
+	  unsigned int xstate_bv = 0;
+	  /* The supported bits in `xstat_bv' are 1 byte. */
+	  unsigned int clear_bv = (~(*xstate_bv_p)) & tdep->xcr0;
+	  gdb_byte *p;
+
+	  /* Clear register set if its bit in xstat_bv is zero.  */
+	  if (clear_bv)
+	    {
+	      if ((clear_bv & I386_XSTATE_AVX))
+		for (i = I387_YMM0H_REGNUM (tdep);
+		     i < I387_YMMENDH_REGNUM (tdep); i++)
+		  memset (XSAVE_AVXH_ADDR (tdep, regs, i), 0, 16);
+
+	      if ((clear_bv & I386_XSTATE_SSE))
+		for (i = I387_XMM0_REGNUM (tdep);
+		     i < I387_MXCSR_REGNUM (tdep); i++)
+		  memset (FXSAVE_ADDR (tdep, regs, i), 0, 16);
+
+	      if ((clear_bv & I386_XSTATE_X87))
+		for (i = I387_ST0_REGNUM (tdep);
+		     i < I387_FCTRL_REGNUM (tdep); i++)
+		  memset (FXSAVE_ADDR (tdep, regs, i), 0, 10);
+	    }
+
+	  if (regclass == all)
+	    {
+	      /* Check if any upper YMM registers are changed.  */
+	      if ((tdep->xcr0 & I386_XSTATE_AVX))
+		for (i = I387_YMM0H_REGNUM (tdep);
+		     i < I387_YMMENDH_REGNUM (tdep); i++)
+		  {
+		    regcache_raw_collect (regcache, i, raw);
+		    p = XSAVE_AVXH_ADDR (tdep, regs, i);
+		    if (memcmp (raw, p, 16))
+		      {
+			xstate_bv |= I386_XSTATE_AVX;
+			memcpy (p, raw, 16);
+		      }
+		  }
+
+	      /* Check if any SSE registers are changed.  */
+	      if ((tdep->xcr0 & I386_XSTATE_SSE))
+		for (i = I387_XMM0_REGNUM (tdep);
+		     i < I387_MXCSR_REGNUM (tdep); i++)
+		  {
+		    regcache_raw_collect (regcache, i, raw);
+		    p = FXSAVE_ADDR (tdep, regs, i);
+		    if (memcmp (raw, p, 16))
+		      {
+			xstate_bv |= I386_XSTATE_SSE;
+			memcpy (p, raw, 16);
+		      }
+		  }
+
+	      /* Check if any X87 registers are changed.  */
+	      if ((tdep->xcr0 & I386_XSTATE_X87))
+		for (i = I387_ST0_REGNUM (tdep);
+		     i < I387_FCTRL_REGNUM (tdep); i++)
+		  {
+		    regcache_raw_collect (regcache, i, raw);
+		    p = FXSAVE_ADDR (tdep, regs, i);
+		    if (memcmp (raw, p, 10))
+		      {
+			xstate_bv |= I386_XSTATE_X87;
+			memcpy (p, raw, 10);
+		      }
+		  }
+	    }
+	  else
+	    {
+	      /* Check if REGNUM is changed.  */
+	      regcache_raw_collect (regcache, regnum, raw);
+
+	      switch (regclass)
+		{
+		default:
+		  abort ();
+
+		case avxh:
+		  /* This is an upper YMM register.  */
+		  p = XSAVE_AVXH_ADDR (tdep, regs, regnum);
+		  if (memcmp (raw, p, 16))
+		    {
+		      xstate_bv |= I386_XSTATE_AVX;
+		      memcpy (p, raw, 16);
+		    }
+		  break;
+
+		case sse:
+		  /* This is an SSE register.  */
+		  p = FXSAVE_ADDR (tdep, regs, regnum);
+		  if (memcmp (raw, p, 16))
+		    {
+		      xstate_bv |= I386_XSTATE_SSE;
+		      memcpy (p, raw, 16);
+		    }
+		  break;
+
+		case x87:
+		  /* This is an x87 register.  */
+		  p = FXSAVE_ADDR (tdep, regs, regnum);
+		  if (memcmp (raw, p, 10))
+		    {
+		      xstate_bv |= I386_XSTATE_X87;
+		      memcpy (p, raw, 10);
+		    }
+		  break;
+		}
+	    }
+
+	  /* Update the corresponding bits in `xstate_bv' if any SSE/AVX
+	     registers are changed.  */
+	  if (xstate_bv)
+	    {
+	      /* The supported bits in `xstat_bv' are 1 byte.  */
+	      *xstate_bv_p |= (gdb_byte) xstate_bv;
+
+	      switch (regclass)
+		{
+		default:
+		  abort ();
+
+		case all:
+		  break;
+
+		case x87:
+		case sse:
+		case avxh:
+		  /* Register REGNUM has been updated.  Return.  */
+		  return;
+		}
+	    }
+	  else
+	    {
+	      /* Return if REGNUM isn't changed.  */
+	      if (regclass != all)
+		return;
+	    }
+	}
+    }
+
+  /* Only handle x87 control registers.  */
+  for (i = I387_FCTRL_REGNUM (tdep); i < I387_XMM0_REGNUM (tdep); i++)
+    if (regnum == -1 || regnum == i)
+      {
+	/* Most of the FPU control registers occupy only 16 bits in
+	   the xsave extended state.  Give those a special treatment.  */
+	if (i != I387_FIOFF_REGNUM (tdep)
+	    && i != I387_FOOFF_REGNUM (tdep))
+	  {
+	    gdb_byte buf[4];
+
+	    regcache_raw_collect (regcache, i, buf);
+
+	    if (i == I387_FOP_REGNUM (tdep))
+	      {
+		/* The opcode occupies only 11 bits.  Make sure we
+                   don't touch the other bits.  */
+		buf[1] &= ((1 << 3) - 1);
+		buf[1] |= ((FXSAVE_ADDR (tdep, regs, i))[1] & ~((1 << 3) - 1));
+	      }
+	    else if (i == I387_FTAG_REGNUM (tdep))
+	      {
+		/* Converting back is much easier.  */
+
+		unsigned short ftag;
+		int fpreg;
+
+		ftag = (buf[1] << 8) | buf[0];
+		buf[0] = 0;
+		buf[1] = 0;
+
+		for (fpreg = 7; fpreg >= 0; fpreg--)
+		  {
+		    int tag = (ftag >> (fpreg * 2)) & 3;
+
+		    if (tag != 3)
+		      buf[0] |= (1 << fpreg);
+		  }
+	      }
+	    memcpy (FXSAVE_ADDR (tdep, regs, i), buf, 2);
+	  }
+	else
+	  regcache_raw_collect (regcache, i, FXSAVE_ADDR (tdep, regs, i));
+      }
+
+  if (regnum == I387_MXCSR_REGNUM (tdep) || regnum == -1)
+    regcache_raw_collect (regcache, I387_MXCSR_REGNUM (tdep),
+			  FXSAVE_MXCSR_ADDR (regs));
+}
+
 /* Recreate the FTW (tag word) valid bits from the 80-bit FP data in
    *RAW.  */
 
--- ./gdb/i387-tdep.h	2010-04-03 20:59:52.000000000 +0200
+++ ./gdb/i387-tdep.h	2010-04-03 21:12:32.000000000 +0200
@@ -33,6 +33,8 @@ struct ui_file;
 #define I387_ST0_REGNUM(tdep) ((tdep)->st0_regnum)
 #define I387_NUM_XMM_REGS(tdep) ((tdep)->num_xmm_regs)
 #define I387_MM0_REGNUM(tdep) ((tdep)->mm0_regnum)
+#define I387_NUM_YMM_REGS(tdep) ((tdep)->num_ymm_regs)
+#define I387_YMM0H_REGNUM(tdep) ((tdep)->ymm0h_regnum)
 
 #define I387_FCTRL_REGNUM(tdep) (I387_ST0_REGNUM (tdep) + 8)
 #define I387_FSTAT_REGNUM(tdep) (I387_FCTRL_REGNUM (tdep) + 1)
@@ -45,6 +47,8 @@ struct ui_file;
 #define I387_XMM0_REGNUM(tdep) (I387_ST0_REGNUM (tdep) + 16)
 #define I387_MXCSR_REGNUM(tdep) \
   (I387_XMM0_REGNUM (tdep) + I387_NUM_XMM_REGS (tdep))
+#define I387_YMMENDH_REGNUM(tdep) \
+  (I387_YMM0H_REGNUM (tdep) + I387_NUM_YMM_REGS (tdep))
 
 /* Print out the i387 floating point state.  */
 
@@ -99,6 +103,11 @@ extern void i387_collect_fsave (const st
 extern void i387_supply_fxsave (struct regcache *regcache, int regnum,
 				const void *fxsave);
 
+/* Similar to i387_supply_fxsave, but use XSAVE extended state.  */
+
+extern void i387_supply_xsave (struct regcache *regcache, int regnum,
+			       const void *xsave);
+
 /* Fill register REGNUM (if it is a floating-point or SSE register) in
    *FXSAVE with the value from REGCACHE.  If REGNUM is -1, do this for
    all registers.  This function doesn't touch any of the reserved
@@ -107,6 +116,11 @@ extern void i387_supply_fxsave (struct r
 extern void i387_collect_fxsave (const struct regcache *regcache, int regnum,
 				 void *fxsave);
 
+/* Similar to i387_collect_fxsave, but use XSAVE extended state.  */
+
+extern void i387_collect_xsave (const struct regcache *regcache,
+				int regnum, void *xsave, int gcore);
+
 /* Prepare the FPU stack in REGCACHE for a function return.  */
 
 extern void i387_return_value (struct gdbarch *gdbarch,
--- ./gdb/regformats/i386/amd64-avx-linux.dat	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/regformats/i386/amd64-avx-linux.dat	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,78 @@
+# DO NOT EDIT: generated from i386/amd64-avx-linux.xml
+name:amd64_avx_linux
+xmltarget:amd64-avx-linux.xml
+expedite:rbp,rsp,rip
+64:rax
+64:rbx
+64:rcx
+64:rdx
+64:rsi
+64:rdi
+64:rbp
+64:rsp
+64:r8
+64:r9
+64:r10
+64:r11
+64:r12
+64:r13
+64:r14
+64:r15
+64:rip
+32:eflags
+32:cs
+32:ss
+32:ds
+32:es
+32:fs
+32:gs
+80:st0
+80:st1
+80:st2
+80:st3
+80:st4
+80:st5
+80:st6
+80:st7
+32:fctrl
+32:fstat
+32:ftag
+32:fiseg
+32:fioff
+32:foseg
+32:fooff
+32:fop
+128:xmm0
+128:xmm1
+128:xmm2
+128:xmm3
+128:xmm4
+128:xmm5
+128:xmm6
+128:xmm7
+128:xmm8
+128:xmm9
+128:xmm10
+128:xmm11
+128:xmm12
+128:xmm13
+128:xmm14
+128:xmm15
+32:mxcsr
+64:orig_rax
+128:ymm0h
+128:ymm1h
+128:ymm2h
+128:ymm3h
+128:ymm4h
+128:ymm5h
+128:ymm6h
+128:ymm7h
+128:ymm8h
+128:ymm9h
+128:ymm10h
+128:ymm11h
+128:ymm12h
+128:ymm13h
+128:ymm14h
+128:ymm15h
--- ./gdb/regformats/i386/amd64-avx.dat	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/regformats/i386/amd64-avx.dat	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,77 @@
+# DO NOT EDIT: generated from i386/amd64-avx.xml
+name:amd64_avx
+xmltarget:amd64-avx.xml
+expedite:rbp,rsp,rip
+64:rax
+64:rbx
+64:rcx
+64:rdx
+64:rsi
+64:rdi
+64:rbp
+64:rsp
+64:r8
+64:r9
+64:r10
+64:r11
+64:r12
+64:r13
+64:r14
+64:r15
+64:rip
+32:eflags
+32:cs
+32:ss
+32:ds
+32:es
+32:fs
+32:gs
+80:st0
+80:st1
+80:st2
+80:st3
+80:st4
+80:st5
+80:st6
+80:st7
+32:fctrl
+32:fstat
+32:ftag
+32:fiseg
+32:fioff
+32:foseg
+32:fooff
+32:fop
+128:xmm0
+128:xmm1
+128:xmm2
+128:xmm3
+128:xmm4
+128:xmm5
+128:xmm6
+128:xmm7
+128:xmm8
+128:xmm9
+128:xmm10
+128:xmm11
+128:xmm12
+128:xmm13
+128:xmm14
+128:xmm15
+32:mxcsr
+128:ymm0h
+128:ymm1h
+128:ymm2h
+128:ymm3h
+128:ymm4h
+128:ymm5h
+128:ymm6h
+128:ymm7h
+128:ymm8h
+128:ymm9h
+128:ymm10h
+128:ymm11h
+128:ymm12h
+128:ymm13h
+128:ymm14h
+128:ymm15h
--- ./gdb/regformats/i386/i386-avx-linux.dat	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/regformats/i386/i386-avx-linux.dat	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,54 @@
+# DO NOT EDIT: generated from i386/i386-avx-linux.xml
+name:i386_avx_linux
+xmltarget:i386-avx-linux.xml
+expedite:ebp,esp,eip
+32:eax
+32:ecx
+32:edx
+32:ebx
+32:esp
+32:ebp
+32:esi
+32:edi
+32:eip
+32:eflags
+32:cs
+32:ss
+32:ds
+32:es
+32:fs
+32:gs
+80:st0
+80:st1
+80:st2
+80:st3
+80:st4
+80:st5
+80:st6
+80:st7
+32:fctrl
+32:fstat
+32:ftag
+32:fiseg
+32:fioff
+32:foseg
+32:fooff
+32:fop
+128:xmm0
+128:xmm1
+128:xmm2
+128:xmm3
+128:xmm4
+128:xmm5
+128:xmm6
+128:xmm7
+32:mxcsr
+32:orig_eax
+128:ymm0h
+128:ymm1h
+128:ymm2h
+128:ymm3h
+128:ymm4h
+128:ymm5h
+128:ymm6h
+128:ymm7h
--- ./gdb/regformats/i386/i386-avx.dat	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/regformats/i386/i386-avx.dat	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,53 @@
+# DO NOT EDIT: generated from i386/i386-avx.xml
+name:i386_avx
+xmltarget:i386-avx.xml
+expedite:ebp,esp,eip
+32:eax
+32:ecx
+32:edx
+32:ebx
+32:esp
+32:ebp
+32:esi
+32:edi
+32:eip
+32:eflags
+32:cs
+32:ss
+32:ds
+32:es
+32:fs
+32:gs
+80:st0
+80:st1
+80:st2
+80:st3
+80:st4
+80:st5
+80:st6
+80:st7
+32:fctrl
+32:fstat
+32:ftag
+32:fiseg
+32:fioff
+32:foseg
+32:fooff
+32:fop
+128:xmm0
+128:xmm1
+128:xmm2
+128:xmm3
+128:xmm4
+128:xmm5
+128:xmm6
+128:xmm7
+32:mxcsr
+128:ymm0h
+128:ymm1h
+128:ymm2h
+128:ymm3h
+128:ymm4h
+128:ymm5h
+128:ymm6h
+128:ymm7h
--- ./gdb/testsuite/ChangeLog.pseudo	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/testsuite/ChangeLog.pseudo	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,26 @@
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.arch/amd64-dword.exp: New.
+
+	* gdb.arch/amd64-word.exp: Simplified.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.arch/amd64-word.exp: New.
+	* gdb.arch/i386-word.exp: Likewise.
+
+	* gdb.arch/i386-byte.exp (nr_regs): Removed.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.arch/amd64-pseudo.c: New.
+	* gdb.arch/i386-byte.exp: Likewise.
+
+	* gdb.arch/amd64-byte.exp: Updated.
+
+	* gdb.arch/i386-pseudo.c: Make it 32bit only.
+
+2010-02-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.arch/amd64-byte.exp: New.
+	* gdb.arch/i386-pseudo.c: Likewise.
--- ./gdb/testsuite/ChangeLog.xcr	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/testsuite/ChangeLog.xcr	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,6 @@
+2010-03-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.arch/i386-avx.c: New.
+	* gdb.arch/i386-avx.exp: Likewise.
+
+	* gdb.arch/i386-cpuid.h: Updated from gcc 4.4.
--- ./gdb/testsuite/ChangeLog.xml	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/testsuite/ChangeLog.xml	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,4 @@
+2010-02-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gdb.xml/tdesc-regs.exp (architecture): New.  Set it for x86.
+	(load_description): Set architecture if defined.
--- ./gdb/testsuite/gdb.arch/i386-avx.c	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/testsuite/gdb.arch/i386-avx.c	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,128 @@
+/* Test program for AVX registers.
+
+   Copyright 2010 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include "i386-cpuid.h"
+
+typedef struct {
+  float f[8];
+} v8sf_t;
+
+
+v8sf_t data[] =
+  {
+    { {  0.0,  0.125,  0.25,  0.375,  0.50,  0.625,  0.75,  0.875 } },
+    { {  1.0,  1.125,  1.25,  1.375,  1.50,  1.625,  1.75,  1.875 } },
+    { {  2.0,  2.125,  2.25,  2.375,  2.50,  2.625,  2.75,  2.875 } },
+    { {  3.0,  3.125,  3.25,  3.375,  3.50,  3.625,  3.75,  3.875 } },
+    { {  4.0,  4.125,  4.25,  4.375,  4.50,  4.625,  4.75,  4.875 } },
+    { {  5.0,  5.125,  5.25,  5.375,  5.50,  5.625,  5.75,  5.875 } },
+    { {  6.0,  6.125,  6.25,  6.375,  6.50,  6.625,  6.75,  6.875 } },
+    { {  7.0,  7.125,  7.25,  7.375,  7.50,  7.625,  7.75,  7.875 } },
+#ifdef __x86_64__
+    { {  8.0,  8.125,  8.25,  8.375,  8.50,  8.625,  8.75,  8.875 } },
+    { {  9.0,  9.125,  9.25,  9.375,  9.50,  9.625,  9.75,  9.875 } },
+    { { 10.0, 10.125, 10.25, 10.375, 10.50, 10.625, 10.75, 10.875 } },
+    { { 11.0, 11.125, 11.25, 11.375, 11.50, 11.625, 11.75, 11.875 } },
+    { { 12.0, 12.125, 12.25, 12.375, 12.50, 12.625, 12.75, 12.875 } },
+    { { 13.0, 13.125, 13.25, 13.375, 13.50, 13.625, 13.75, 13.875 } },
+    { { 14.0, 14.125, 14.25, 14.375, 14.50, 14.625, 14.75, 14.875 } },
+    { { 15.0, 15.125, 15.25, 15.375, 15.50, 15.625, 15.75, 15.875 } },
+#endif
+  };
+
+
+int
+have_avx (void)
+{
+  unsigned int eax, ebx, ecx, edx;
+
+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))
+    return 0;
+
+  if ((ecx & (bit_AVX | bit_OSXSAVE)) == (bit_AVX | bit_OSXSAVE))
+    return 1;
+  else
+    return 0;
+}
+
+int
+main (int argc, char **argv)
+{
+  if (have_avx ())
+    {
+      asm ("vmovaps 0(%0), %%ymm0\n\t"
+           "vmovaps 32(%0), %%ymm1\n\t"
+           "vmovaps 64(%0), %%ymm2\n\t"
+           "vmovaps 96(%0), %%ymm3\n\t"
+           "vmovaps 128(%0), %%ymm4\n\t"
+           "vmovaps 160(%0), %%ymm5\n\t"
+           "vmovaps 192(%0), %%ymm6\n\t"
+           "vmovaps 224(%0), %%ymm7\n\t"
+           : /* no output operands */
+           : "r" (data) 
+           : "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6", "xmm7");
+#ifdef __x86_64__
+      asm ("vmovaps 256(%0), %%ymm8\n\t"
+           "vmovaps 288(%0), %%ymm9\n\t"
+           "vmovaps 320(%0), %%ymm10\n\t"
+           "vmovaps 352(%0), %%ymm11\n\t"
+           "vmovaps 384(%0), %%ymm12\n\t"
+           "vmovaps 416(%0), %%ymm13\n\t"
+           "vmovaps 448(%0), %%ymm14\n\t"
+           "vmovaps 480(%0), %%ymm15\n\t"
+           : /* no output operands */
+           : "r" (data) 
+           : "xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14", "xmm15");
+#endif
+
+      asm ("nop"); /* first breakpoint here */
+
+      asm (
+           "vmovaps %%ymm0, 0(%0)\n\t"
+           "vmovaps %%ymm1, 32(%0)\n\t"
+           "vmovaps %%ymm2, 64(%0)\n\t"
+           "vmovaps %%ymm3, 96(%0)\n\t"
+           "vmovaps %%ymm4, 128(%0)\n\t"
+           "vmovaps %%ymm5, 160(%0)\n\t"
+           "vmovaps %%ymm6, 192(%0)\n\t"
+           "vmovaps %%ymm7, 224(%0)\n\t"
+           : /* no output operands */
+           : "r" (data) 
+           : "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6", "xmm7");
+#ifdef __x86_64__
+      asm (
+           "vmovaps %%ymm8, 256(%0)\n\t"
+           "vmovaps %%ymm9, 288(%0)\n\t"
+           "vmovaps %%ymm10, 320(%0)\n\t"
+           "vmovaps %%ymm11, 352(%0)\n\t"
+           "vmovaps %%ymm12, 384(%0)\n\t"
+           "vmovaps %%ymm13, 416(%0)\n\t"
+           "vmovaps %%ymm14, 448(%0)\n\t"
+           "vmovaps %%ymm15, 480(%0)\n\t"
+           : /* no output operands */
+           : "r" (data) 
+           : "xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14", "xmm15");
+#endif
+
+      puts ("Bye!"); /* second breakpoint here */
+    }
+
+  return 0;
+}
--- ./gdb/testsuite/gdb.arch/i386-avx.exp	1970-01-01 01:00:00.000000000 +0100
+++ ./gdb/testsuite/gdb.arch/i386-avx.exp	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,110 @@
+# Copyright 2010 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gdb@gnu.org
+
+# This file is part of the gdb testsuite.
+
+if $tracelevel {
+    strace $tracelevel
+}
+
+set prms_id 0
+set bug_id 0
+
+if { ![istarget i?86-*-*] && ![istarget x86_64-*-* ] } {
+    verbose "Skipping x86 AVX tests."
+    return
+}
+
+set testfile "i386-avx"
+set srcfile ${testfile}.c
+set binfile ${objdir}/${subdir}/${testfile}
+
+if [get_compiler_info ${binfile}] {
+    return -1
+}
+
+set additional_flags ""
+if [test_compiler_info gcc*] {
+    set additional_flags "additional_flags=-mavx"
+}
+
+if { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable [list debug $additional_flags]] != "" } {
+    unsupported "compiler does not support AVX"
+    return
+}
+
+gdb_exit
+gdb_start
+gdb_reinitialize_dir $srcdir/$subdir
+gdb_load ${binfile}
+
+if ![runto_main] then {
+    gdb_suppress_tests
+}
+
+send_gdb "print have_avx ()\r"
+gdb_expect {
+    -re ".. = 1\r\n$gdb_prompt " {
+        pass "check whether processor supports AVX"
+    }
+    -re ".. = 0\r\n$gdb_prompt " {
+        verbose "processor does not support AVX; skipping AVX tests"
+        return
+    }
+    -re ".*$gdb_prompt $" {
+        fail "check whether processor supports AVX"
+    }
+    timeout {
+        fail "check whether processor supports AVX (timeout)"
+    }
+}
+
+gdb_test "break [gdb_get_line_number "first breakpoint here"]" \
+         "Breakpoint .* at .*i386-avx.c.*" \
+         "set first breakpoint in main"
+gdb_continue_to_breakpoint "continue to first breakpoint in main"
+
+if [istarget i?86-*-*] {
+    set nr_regs 8
+} else {
+    set nr_regs 16
+}
+
+for { set r 0 } { $r < $nr_regs } { incr r } {
+    gdb_test "print \$ymm$r.v8_float" \
+        ".. = \\{$r, $r.125, $r.25, $r.375, $r.5, $r.625, $r.75, $r.875\\}.*" \
+        "check float contents of %ymm$r"
+    gdb_test "print \$ymm$r.v32_int8" \
+        ".. = \\{(-?\[0-9\]+, ){31}-?\[0-9\]+\\}.*" \
+        "check int8 contents of %ymm$r"
+}
+
+for { set r 0 } { $r < $nr_regs } { incr r } {
+    gdb_test "set var \$ymm$r.v8_float\[0\] = $r + 10" "" "set %ymm$r"
+}
+
+gdb_test "break [gdb_get_line_number "second breakpoint here"]" \
+         "Breakpoint .* at .*i386-avx.c.*" \
+         "set second breakpoint in main"
+gdb_continue_to_breakpoint "continue to second breakpoint in main"
+
+for { set r 0 } { $r < $nr_regs } { incr r } {
+    gdb_test "print data\[$r\]" \
+        ".. = \\{f = \\{[expr $r + 10], $r.125, $r.25, $r.375, $r.5, $r.625, $r.75, $r.875\\}\\}.*" \
+        "check contents of data\[$r\]"
+}
--- ./gdb/testsuite/gdb.arch/i386-cpuid.h	2010-01-01 08:32:00.000000000 +0100
+++ ./gdb/testsuite/gdb.arch/i386-cpuid.h	2010-04-03 21:12:32.000000000 +0200
@@ -1,30 +1,186 @@
-/* Helper file for i386 platform.  Runtime check for MMX/SSE/SSE2 support.
+/* Helper file for i386 platform.  Runtime check for MMX/SSE/SSE2/AVX
+ * support. Copied from gcc 4.4.
+ *
+ * Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 3, or (at your option) any
+ * later version.
+ * 
+ * This file is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * Under Section 7 of GPL version 3, you are granted additional
+ * permissions described in the GCC Runtime Library Exception, version
+ * 3.1, as published by the Free Software Foundation.
+ * 
+ * You should have received a copy of the GNU General Public License and
+ * a copy of the GCC Runtime Library Exception along with this program;
+ * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+/* %ecx */
+#define bit_SSE3	(1 << 0)
+#define bit_PCLMUL	(1 << 1)
+#define bit_SSSE3	(1 << 9)
+#define bit_FMA		(1 << 12)
+#define bit_CMPXCHG16B	(1 << 13)
+#define bit_SSE4_1	(1 << 19)
+#define bit_SSE4_2	(1 << 20)
+#define bit_MOVBE	(1 << 22)
+#define bit_POPCNT	(1 << 23)
+#define bit_AES		(1 << 25)
+#define bit_XSAVE	(1 << 26)
+#define bit_OSXSAVE	(1 << 27)
+#define bit_AVX		(1 << 28)
+
+/* %edx */
+#define bit_CMPXCHG8B	(1 << 8)
+#define bit_CMOV	(1 << 15)
+#define bit_MMX		(1 << 23)
+#define bit_FXSAVE	(1 << 24)
+#define bit_SSE		(1 << 25)
+#define bit_SSE2	(1 << 26)
+
+/* Extended Features */
+/* %ecx */
+#define bit_LAHF_LM	(1 << 0)
+#define bit_ABM		(1 << 5)
+#define bit_SSE4a	(1 << 6)
+#define bit_XOP         (1 << 11)
+#define bit_LWP 	(1 << 15)
+#define bit_FMA4        (1 << 16)
+
+/* %edx */
+#define bit_LM		(1 << 29)
+#define bit_3DNOWP	(1 << 30)
+#define bit_3DNOW	(1 << 31)
+
+
+#if defined(__i386__) && defined(__PIC__)
+/* %ebx may be the PIC register.  */
+#if __GNUC__ >= 3
+#define __cpuid(level, a, b, c, d)			\
+  __asm__ ("xchg{l}\t{%%}ebx, %1\n\t"			\
+	   "cpuid\n\t"					\
+	   "xchg{l}\t{%%}ebx, %1\n\t"			\
+	   : "=a" (a), "=r" (b), "=c" (c), "=d" (d)	\
+	   : "0" (level))
+
+#define __cpuid_count(level, count, a, b, c, d)		\
+  __asm__ ("xchg{l}\t{%%}ebx, %1\n\t"			\
+	   "cpuid\n\t"					\
+	   "xchg{l}\t{%%}ebx, %1\n\t"			\
+	   : "=a" (a), "=r" (b), "=c" (c), "=d" (d)	\
+	   : "0" (level), "2" (count))
+#else
+/* Host GCCs older than 3.0 weren't supporting Intel asm syntax
+   nor alternatives in i386 code.  */
+#define __cpuid(level, a, b, c, d)			\
+  __asm__ ("xchgl\t%%ebx, %1\n\t"			\
+	   "cpuid\n\t"					\
+	   "xchgl\t%%ebx, %1\n\t"			\
+	   : "=a" (a), "=r" (b), "=c" (c), "=d" (d)	\
+	   : "0" (level))
+
+#define __cpuid_count(level, count, a, b, c, d)		\
+  __asm__ ("xchgl\t%%ebx, %1\n\t"			\
+	   "cpuid\n\t"					\
+	   "xchgl\t%%ebx, %1\n\t"			\
+	   : "=a" (a), "=r" (b), "=c" (c), "=d" (d)	\
+	   : "0" (level), "2" (count))
+#endif
+#else
+#define __cpuid(level, a, b, c, d)			\
+  __asm__ ("cpuid\n\t"					\
+	   : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
+	   : "0" (level))
+
+#define __cpuid_count(level, count, a, b, c, d)		\
+  __asm__ ("cpuid\n\t"					\
+	   : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
+	   : "0" (level), "2" (count))
+#endif
+
+/* Return highest supported input value for cpuid instruction.  ext can
+   be either 0x0 or 0x8000000 to return highest supported value for
+   basic or extended cpuid information.  Function returns 0 if cpuid
+   is not supported or whatever cpuid returns in eax register.  If sig
+   pointer is non-null, then first four bytes of the signature
+   (as found in ebx register) are returned in location pointed by sig.  */
+
+static __inline unsigned int
+__get_cpuid_max (unsigned int __ext, unsigned int *__sig)
+{
+  unsigned int __eax, __ebx, __ecx, __edx;
+
+#ifndef __x86_64__
+#if __GNUC__ >= 3
+  /* See if we can use cpuid.  On AMD64 we always can.  */
+  __asm__ ("pushf{l|d}\n\t"
+	   "pushf{l|d}\n\t"
+	   "pop{l}\t%0\n\t"
+	   "mov{l}\t{%0, %1|%1, %0}\n\t"
+	   "xor{l}\t{%2, %0|%0, %2}\n\t"
+	   "push{l}\t%0\n\t"
+	   "popf{l|d}\n\t"
+	   "pushf{l|d}\n\t"
+	   "pop{l}\t%0\n\t"
+	   "popf{l|d}\n\t"
+	   : "=&r" (__eax), "=&r" (__ebx)
+	   : "i" (0x00200000));
+#else
+/* Host GCCs older than 3.0 weren't supporting Intel asm syntax
+   nor alternatives in i386 code.  */
+  __asm__ ("pushfl\n\t"
+	   "pushfl\n\t"
+	   "popl\t%0\n\t"
+	   "movl\t%0, %1\n\t"
+	   "xorl\t%2, %0\n\t"
+	   "pushl\t%0\n\t"
+	   "popfl\n\t"
+	   "pushfl\n\t"
+	   "popl\t%0\n\t"
+	   "popfl\n\t"
+	   : "=&r" (__eax), "=&r" (__ebx)
+	   : "i" (0x00200000));
+#endif
 
-   Copyright 2004, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
+  if (!((__eax ^ __ebx) & 0x00200000))
+    return 0;
+#endif
 
-   This file is part of GDB.
+  /* Host supports cpuid.  Return highest supported cpuid input value.  */
+  __cpuid (__ext, __eax, __ebx, __ecx, __edx);
 
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
+  if (__sig)
+    *__sig = __ebx;
 
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+  return __eax;
+}
 
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+/* Return cpuid data for requested cpuid level, as found in returned
+   eax, ebx, ecx and edx registers.  The function checks if cpuid is
+   supported and returns 1 for valid cpuid information or 0 for
+   unsupported cpuid level.  All pointers are required to be non-null.  */
+
+static __inline int
+__get_cpuid (unsigned int __level,
+	     unsigned int *__eax, unsigned int *__ebx,
+	     unsigned int *__ecx, unsigned int *__edx)
+{
+  unsigned int __ext = __level & 0x80000000;
 
-/* Used by 20020523-2.c and i386-sse-6.c, and possibly others.  */
-/* Plagarized from 20020523-2.c.  */
-/* Plagarized from gcc.  */
+  if (__get_cpuid_max (__ext, 0) < __level)
+    return 0;
 
-#define bit_CMOV (1 << 15)
-#define bit_MMX (1 << 23)
-#define bit_SSE (1 << 25)
-#define bit_SSE2 (1 << 26)
+  __cpuid (__level, *__eax, *__ebx, *__ecx, *__edx);
+  return 1;
+}
 
 #ifndef NOINLINE
 #define NOINLINE __attribute__ ((noinline))
@@ -35,41 +191,10 @@ unsigned int i386_cpuid (void) NOINLINE;
 unsigned int NOINLINE
 i386_cpuid (void)
 {
-  int fl1, fl2;
-
-#ifndef __x86_64__
-  /* See if we can use cpuid.  On AMD64 we always can.  */
-  __asm__ ("pushfl; pushfl; popl %0; movl %0,%1; xorl %2,%0;"
-	   "pushl %0; popfl; pushfl; popl %0; popfl"
-	   : "=&r" (fl1), "=&r" (fl2)
-	   : "i" (0x00200000));
-  if (((fl1 ^ fl2) & 0x00200000) == 0)
-    return (0);
-#endif
+  unsigned int eax, ebx, ecx, edx;
 
-  /* Host supports cpuid.  See if cpuid gives capabilities, try
-     CPUID(0).  Preserve %ebx and %ecx; cpuid insn clobbers these, we
-     don't need their CPUID values here, and %ebx may be the PIC
-     register.  */
-#ifdef __x86_64__
-  __asm__ ("pushq %%rcx; pushq %%rbx; cpuid; popq %%rbx; popq %%rcx"
-	   : "=a" (fl1) : "0" (0) : "rdx", "cc");
-#else
-  __asm__ ("pushl %%ecx; pushl %%ebx; cpuid; popl %%ebx; popl %%ecx"
-	   : "=a" (fl1) : "0" (0) : "edx", "cc");
-#endif
-  if (fl1 == 0)
-    return (0);
-
-  /* Invoke CPUID(1), return %edx; caller can examine bits to
-     determine what's supported.  */
-#ifdef __x86_64__
-  __asm__ ("pushq %%rcx; pushq %%rbx; cpuid; popq %%rbx; popq %%rcx"
-	   : "=d" (fl2), "=a" (fl1) : "1" (1) : "cc");
-#else
-  __asm__ ("pushl %%ecx; pushl %%ebx; cpuid; popl %%ebx; popl %%ecx"
-	   : "=d" (fl2), "=a" (fl1) : "1" (1) : "cc");
-#endif
+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))
+    return 0;
 
-  return fl2;
+  return edx;
 }
--- ./include/elf/ChangeLog.xstate	1970-01-01 01:00:00.000000000 +0100
+++ ./include/elf/ChangeLog.xstate	2010-04-03 21:12:32.000000000 +0200
@@ -0,0 +1,8 @@
+2010-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* common.h (NT_386_XSTATE): Renamed to ...
+	(NT_X86_XSTATE): This.
+
+2010-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* common.h (NT_386_XSTATE): New.
