Index: stardict-3.0.1/src/sigc++/adaptors/adaptors.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/adaptors.h
+++ /dev/null
@@ -1,32 +0,0 @@
-// -*- c++ -*-
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#ifndef _SIGC_ADAPTOR_HPP_
-#define _SIGC_ADAPTOR_HPP_
-
-#include <sigc++/adaptors/bind.h>
-#include <sigc++/adaptors/bind_return.h>
-#include <sigc++/adaptors/hide.h>
-#include <sigc++/adaptors/retype_return.h>
-#include <sigc++/adaptors/retype.h>
-#include <sigc++/adaptors/compose.h>
-#include <sigc++/adaptors/exception_catch.h>
-#include <sigc++/adaptors/lambda/lambda.h>
-
-#endif /* _SIGC_ADAPTOR_HPP_ */
Index: stardict-3.0.1/src/sigc++/adaptors/adaptor_trait.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/adaptor_trait.h
+++ /dev/null
@@ -1,365 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-#ifndef _SIGC_ADAPTORS_MACROS_ADAPTOR_TRAITHM4_
-#define _SIGC_ADAPTORS_MACROS_ADAPTOR_TRAITHM4_
-#include <sigc++config.h> //To get SIGC_TEMPLATE_KEYWORD_OPERATOR_OVERLOAD
-#include <sigc++/visit_each.h>
-#include <sigc++/functors/functor_trait.h>
-#include <sigc++/functors/ptr_fun.h>
-#include <sigc++/functors/mem_fun.h>
-#include <sigc++/adaptors/deduce_result_type.h>
-
-namespace sigc {
-
-// Call either operator()<>() or sun_forte_workaround<>(),
-// depending on the compiler:
-#ifdef SIGC_GCC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  #define SIGC_WORKAROUND_OPERATOR_PARENTHESES template operator()
-  #define SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-#else
-  #ifdef SIGC_MSVC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-    #define SIGC_WORKAROUND_OPERATOR_PARENTHESES operator()
-    #define SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  #else
-    #define SIGC_WORKAROUND_OPERATOR_PARENTHESES sun_forte_workaround
-  #endif
-#endif
-
-
-template <class T_functor> struct adapts;
-
-/** @defgroup adaptors Adaptors
- * Adaptors are functors that alter the signature of a functor's
- * operator()().
- *
- * The adaptor types libsigc++ provides
- * are created with bind(), bind_return(), hide(), hide_return(),
- * retype_return(), retype(), compose(), exception_catch() and group().
- *
- * You can easily derive your own adaptor type from sigc::adapts.
- */
-
-/** Converts an arbitrary functor into an adaptor type.
- * All adaptor tyes in libsigc++ are unnumbered and have
- * a <tt>template operator()</tt> member of every argument count
- * they support. These functions in turn invoke a stored adaptor's
- * <tt>template operator()</tt> processing the arguments and return
- * value in a characteristic manner. Explicit function template
- * instantiation is used to pass type hints thus saving copy costs.
- *
- * adaptor_functor is a glue between adaptors and arbitrary functors
- * that just passes on the arguments. You won't use this type directly.
- *
- * The template argument @e T_functor determines the type of stored
- * functor.
- *
- * @ingroup adaptors
- */
-template <class T_functor>
-struct adaptor_functor : public adaptor_base
-{
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename sigc::deduce_result_type<T_functor, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type; };
-  typedef typename functor_trait<T_functor>::result_type result_type;
-
-  /** Invokes the wrapped functor passing on the arguments.
-   * @return The return value of the functor invocation.
-   */
-  result_type
-  operator()() const;
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  result_type sun_forte_workaround() const
-    { return operator(); }
-  #endif
-  
-  /** Invokes the wrapped functor passing on the arguments.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator()(T_arg1 _A_arg1) const
-    { return functor_(_A_arg1); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround(T_arg1 _A_arg1) const
-    { //Just calling operator() tries to copy the argument:
-      return functor_(_A_arg1);
-    }
-  #endif
-  
-  /** Invokes the wrapped functor passing on the arguments.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2) const
-    { return functor_(_A_arg1,_A_arg2); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2) const
-    { //Just calling operator() tries to copy the argument:
-      return functor_(_A_arg1,_A_arg2);
-    }
-  #endif
-  
-  /** Invokes the wrapped functor passing on the arguments.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3) const
-    { return functor_(_A_arg1,_A_arg2,_A_arg3); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3) const
-    { //Just calling operator() tries to copy the argument:
-      return functor_(_A_arg1,_A_arg2,_A_arg3);
-    }
-  #endif
-  
-  /** Invokes the wrapped functor passing on the arguments.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4) const
-    { return functor_(_A_arg1,_A_arg2,_A_arg3,_A_arg4); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4) const
-    { //Just calling operator() tries to copy the argument:
-      return functor_(_A_arg1,_A_arg2,_A_arg3,_A_arg4);
-    }
-  #endif
-  
-  /** Invokes the wrapped functor passing on the arguments.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5) const
-    { return functor_(_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5) const
-    { //Just calling operator() tries to copy the argument:
-      return functor_(_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5);
-    }
-  #endif
-  
-  /** Invokes the wrapped functor passing on the arguments.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6) const
-    { return functor_(_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5,_A_arg6); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6) const
-    { //Just calling operator() tries to copy the argument:
-      return functor_(_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5,_A_arg6);
-    }
-  #endif
-  
-  /** Invokes the wrapped functor passing on the arguments.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @param _A_arg7 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6,T_arg7 _A_arg7) const
-    { return functor_(_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5,_A_arg6,_A_arg7); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6,T_arg7 _A_arg7) const
-    { //Just calling operator() tries to copy the argument:
-      return functor_(_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5,_A_arg6,_A_arg7);
-    }
-  #endif
-  
-  /// Constructs an invalid functor.
-  adaptor_functor()
-    {}
-
-  /** Constructs an adaptor_functor object that wraps the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   */
-  explicit adaptor_functor(const T_functor& _A_functor)
-    : functor_(_A_functor)
-    {}
-
-  /** Constructs an adaptor_functor object that wraps the passed (member)
-   * function pointer.
-   * @param _A_type Pointer to function or class method to invoke from operator()().
-   */
-  template <class T_type>
-  explicit adaptor_functor(const T_type& _A_type)
-    : functor_(_A_type)
-    {}
-
-  /// Functor that is invoked from operator()().
-  mutable T_functor functor_;
-};
-
-template <class T_functor>
-typename adaptor_functor<T_functor>::result_type
-adaptor_functor<T_functor>::operator()() const
-  { return functor_(); }
-
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::adaptor_functor performs a functor
- * on the functor stored in the sigc::adaptor_functor object.
- *
- * @ingroup adaptors
- */
-template <class T_action, class T_functor>
-void visit_each(const T_action& _A_action,
-                const adaptor_functor<T_functor>& _A_target)
-{
-  //The extra sigc:: prefix avoids ambiguity in some strange
-  //situations.
-  sigc::visit_each(_A_action, _A_target.functor_);
-}
-
-
-/** Trait that specifies what is the adaptor version of a functor type.
- * Template specializations for sigc::adaptor_base derived functors,
- * for function pointers and for class methods are provided.
- *
- * The template argument @e T_functor is the functor type to convert.
- * @e I_isadaptor indicates whether @e T_functor inherits from sigc::adaptor_base.
- *
- * @ingroup adaptors
- */
-template <class T_functor, bool I_isadaptor = is_base_and_derived<adaptor_base, T_functor>::value> struct adaptor_trait;
-
-/** Trait that specifies what is the adaptor version of a functor type.
- * This template specialization is used for types that inherit from adaptor_base.
- * adaptor_type is equal to @p T_functor in this case.
- */
-template <class T_functor> 
-struct adaptor_trait<T_functor, true>
-{
-  typedef typename T_functor::result_type result_type;
-  typedef T_functor functor_type;
-  typedef T_functor adaptor_type;
-};
-
-/** Trait that specifies what is the adaptor version of a functor type.
- * This template specialization is used for arbitrary functors,
- * for function pointers and for class methods are provided.
- * The latter are converted into @p pointer_functor or @p mem_functor types.
- * adaptor_type is equal to @p adaptor_functor<functor_type>.
- */
-template <class T_functor>
-struct adaptor_trait<T_functor, false>
-{
-  typedef typename functor_trait<T_functor>::result_type result_type;
-  typedef typename functor_trait<T_functor>::functor_type functor_type;
-  typedef adaptor_functor<functor_type> adaptor_type;
-};
-
-
-/** Base type for adaptors.
- * adapts wraps adaptors, functors, function pointers and class methods.
- * It contains a single member functor which is always a sigc::adaptor_base.
- * The typedef adaptor_type defines the exact type that is used
- * to store the adaptor, functor, function pointer or class method passed
- * into the constructor. It differs from @e T_functor unless @e T_functor
- * inherits from sigc::adaptor_base.
- *
- * @par Example of a simple adaptor:
- *   @code
- *   template <T_functor>
- *   struct my_adpator : public sigc::adapts<T_functor>
- *   {
- *     template <class T_arg1=void, class T_arg2=void>
- *     struct deduce_result_type
- *     { typedef typename sigc::deduce_result_type<T_functor, T_arg1, T_arg2>::type type; };
- *     typedef typename sigc::functor_trait<T_functor>::result_type result_type;
- *
- *     result_type
- *     operator()() const;
- *
- *     template <class T_arg1>
- *     typename deduce_result_type<T_arg1>::type
- *     operator()(T_arg1 _A_arg1) const;
- *
- *     template <class T_arg1, class T_arg2>
- *     typename deduce_result_type<T_arg1, T_arg2>::type
- *     operator()(T_arg1 _A_arg1, class T_arg2) const;
- *
- *     explicit adaptor_functor(const T_functor& _A_functor) // Constructs a my_functor object that wraps the passed functor.
- *       : sigc::adapts<T_functor>(_A_functor) {}
- *
- *     mutable T_functor functor_; // Functor that is invoked from operator()().
- *   };
- *   @endcode
- *
- * @ingroup adaptors
- */
-template <class T_functor>
-struct adapts : public adaptor_base
-{
-  typedef typename adaptor_trait<T_functor>::result_type  result_type;
-  typedef typename adaptor_trait<T_functor>::adaptor_type adaptor_type;
-
-  /** Constructs an adaptor that wraps the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   */
-  explicit adapts(const T_functor& _A_functor)
-    : functor_(_A_functor)
-    {}
-
-  /// Adaptor that is invoked from operator()().
-  mutable adaptor_type functor_;
-};
-
-} /* namespace sigc */
-#endif /* _SIGC_ADAPTORS_MACROS_ADAPTOR_TRAITHM4_ */
Index: stardict-3.0.1/src/sigc++/adaptors/bind.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/bind.h
+++ /dev/null
@@ -1,2265 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-#ifndef _SIGC_ADAPTORS_MACROS_BINDHM4_
-#define _SIGC_ADAPTORS_MACROS_BINDHM4_
-#include <sigc++/adaptors/adaptor_trait.h>
-#include <sigc++/adaptors/bound_argument.h>
-
-namespace sigc { 
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-
-namespace internal {
-
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-struct count_void
-  { static const int value=0; };
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-struct count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,void>
-  { static const int value=1; };
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-struct count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,void,void>
-  { static const int value=2; };
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-struct count_void<T_arg1,T_arg2,T_arg3,T_arg4,void,void,void>
-  { static const int value=3; };
-template <class T_arg1,class T_arg2,class T_arg3>
-struct count_void<T_arg1,T_arg2,T_arg3,void,void,void,void>
-  { static const int value=4; };
-template <class T_arg1,class T_arg2>
-struct count_void<T_arg1,T_arg2,void,void,void,void,void>
-  { static const int value=5; };
-template <class T_arg1>
-struct count_void<T_arg1,void,void,void,void,void,void>
-  { static const int value=6; };
-template <>
-struct count_void<void,void,void,void,void,void,void>
-  { static const int value=7; };
-
-} /* namespace internal */
-
-#endif /*DOXYGEN_SHOULD_SKIP_THIS*/
-
-
-/** @defgroup bind bind(), bind_return()
- * sigc::bind() alters an arbitrary functor by fixing arguments to certain values.
- * Up to 7 arguments can be bound at a time.
- * For single argument binding overloads of sigc::bind() are provided that let you
- * specify the zero-based position of the argument to fix with the first template parameter.
- * (A value of @p -1 fixes the last argument so sigc::bind<-1>() gives the same result as sigc::bind().)
- * The types of the arguments can optionally be specified if not deduced.
- *
- * @par Examples:
- *   @code
- *   void foo(int, int, int);
- *   // single argument binding ...
- *   sigc::bind(&foo,1)(2,3);     //fixes the last (third) argument and calls foo(2,3,1)
- *   sigc::bind<-1>(&foo,1)(2,3); //same as bind(&foo,1)(2,3) (calls foo(2,3,1))
- *   sigc::bind<0>(&foo,1)(2,3);  //fixes the first argument and calls foo(1,2,3)
- *   sigc::bind<1>(&foo,1)(2,3);  //fixes the second argument and calls foo(2,1,3)
- *   sigc::bind<2>(&foo,1)(2,3);  //fixes the third argument and calls foo(2,3,1)
- *   // multi argument binding ...
- *   sigc::bind(&foo,1,2)(3);     //fixes the last two arguments and calls foo(3,1,2)
- *   sigc::bind(&foo,1,2,3)();    //fixes all three arguments and calls foo(1,2,3)
- *   @endcode
- *
- * The functor sigc::bind() returns can be passed into
- * sigc::signal::connect() directly.
- *
- * @par Example:
- *   @code
- *   sigc::signal<void> some_signal;
- *   void foo(int);
- *   some_signal.connect(sigc::bind(&foo,1));
- *   @endcode
- *
- * sigc::bind_return() alters an arbitrary functor by
- * fixing its return value to a certain value.
- *
- * @par Example:
- *   @code
- *   void foo();
- *   std::cout << sigc::bind_return(&foo, 5)(); // calls foo() and returns 5
- *   @endcode
- *
- * You can bind references to functors by passing the objects through
- * the sigc::ref() helper function.
- *
- * @par Example:
- *   @code
- *   int some_int;
- *   sigc::signal<void> some_signal;
- *   void foo(int&);
- *   some_signal.connect(sigc::bind(&foo,sigc::ref(some_int)));
- *   @endcode
- *
- * If you bind an object of a sigc::trackable derived type to a functor
- * by reference, a slot assigned to the bind adaptor is cleared automatically
- * when the object goes out of scope.
- *
- * @par Example:
- *   @code
- *   struct bar : public sigc::trackable {} some_bar;
- *   sigc::signal<void> some_signal;
- *   void foo(bar&);
- *   some_signal.connect(sigc::bind(&foo,sigc::ref(some_bar)));
- *     // disconnected automatically if some_bar goes out of scope
- *   @endcode
- *
- * For a more powerful version of this functionality see the lambda
- * library adaptor sigc::group() which can bind, hide and reorder
- * arguments arbitrarily.  Although sigc::group() is more flexible,
- * sigc::bind() provides a means of binding parameters when then total
- * number of parameters called is variable.
- *
- * @ingroup adaptors
- */
-
-/** Adaptor that binds an argument to the wrapped functor.
- * Use the convenience function sigc::bind() to create an instance of sigc::bind_functor.
- *
- * The following template arguments are used:
- * - @e I_location Zero-based position of the argument to fix (@p -1 for the last argument).
-
- * - @e T_type1 Type of the 1st bound argument.
- * - @e T_type2 Type of the 2st bound argument.
- * - @e T_type3 Type of the 3st bound argument.
- * - @e T_type4 Type of the 4st bound argument.
- * - @e T_type5 Type of the 5st bound argument.
- * - @e T_type6 Type of the 6st bound argument.
- * - @e T_type7 Type of the 7st bound argument.
- * - @e T_functor Type of the functor to wrap.
- *
- * @ingroup bind
- */
-template <int I_location, class T_functor, class T_type1=nil,class T_type2=nil,class T_type3=nil,class T_type4=nil,class T_type5=nil,class T_type6=nil,class T_type7=nil>
-struct bind_functor;
-
-/** Adaptor that binds an argument to the wrapped functor.
- * This template specialization fixes the 1th argument of the wrapped functor.
- *
- * @ingroup bind
- */
-template <class T_functor, class T_bound>
-struct bind_functor<0, T_functor, T_bound, nil,nil,nil,nil,nil,nil> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>::type type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor passing on the bound argument only.
-   * @return The return value of the functor invocation.
-   */
-  result_type
-  operator()()
-  {
-    //Note: The AIX compiler sometimes gives linker errors if we do not define this in the class.
-    return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass> (bound_.invoke());
-  }
-
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 1th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator()(T_arg1 _A_arg1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass>
-        (bound_.invoke(), _A_arg1);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround(T_arg1 _A_arg1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass>
-        (bound_.invoke(), _A_arg1);
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 1th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass>
-        (bound_.invoke(), _A_arg1, _A_arg2);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass>
-        (bound_.invoke(), _A_arg1, _A_arg2);
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 1th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass>
-        (bound_.invoke(), _A_arg1, _A_arg2, _A_arg3);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass>
-        (bound_.invoke(), _A_arg1, _A_arg2, _A_arg3);
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 1th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
-        (bound_.invoke(), _A_arg1, _A_arg2, _A_arg3, _A_arg4);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
-        (bound_.invoke(), _A_arg1, _A_arg2, _A_arg3, _A_arg4);
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 1th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (bound_.invoke(), _A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (bound_.invoke(), _A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5);
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 1th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (bound_.invoke(), _A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5, _A_arg6);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (bound_.invoke(), _A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5, _A_arg6);
-    }
-  #endif
-    
-  /** Constructs a bind_functor object that binds an argument to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   * @param _A_bound Argument to bind to the functor.
-   */
-  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_bound>::take _A_bound)
-    : adapts<T_functor>(_A_func), bound_(_A_bound)
-    {}
-
-  /// The argument bound to the functor.
-  bound_argument<T_bound> bound_;
-};
-
-/** Adaptor that binds an argument to the wrapped functor.
- * This template specialization fixes the 2th argument of the wrapped functor.
- *
- * @ingroup bind
- */
-template <class T_functor, class T_bound>
-struct bind_functor<1, T_functor, T_bound, nil,nil,nil,nil,nil,nil> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>::type type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor passing on the bound argument only.
-   * @return The return value of the functor invocation.
-   */
-  result_type
-  operator()()
-  {
-    //Note: The AIX compiler sometimes gives linker errors if we do not define this in the class.
-    return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass> (bound_.invoke());
-  }
-
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 2th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator()(T_arg1 _A_arg1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
-        (_A_arg1, bound_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround(T_arg1 _A_arg1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
-        (_A_arg1, bound_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 2th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass>
-        (_A_arg1, bound_.invoke(), _A_arg2);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass>
-        (_A_arg1, bound_.invoke(), _A_arg2);
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 2th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass>
-        (_A_arg1, bound_.invoke(), _A_arg2, _A_arg3);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass>
-        (_A_arg1, bound_.invoke(), _A_arg2, _A_arg3);
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 2th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
-        (_A_arg1, bound_.invoke(), _A_arg2, _A_arg3, _A_arg4);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
-        (_A_arg1, bound_.invoke(), _A_arg2, _A_arg3, _A_arg4);
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 2th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (_A_arg1, bound_.invoke(), _A_arg2, _A_arg3, _A_arg4, _A_arg5);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (_A_arg1, bound_.invoke(), _A_arg2, _A_arg3, _A_arg4, _A_arg5);
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 2th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_arg1, bound_.invoke(), _A_arg2, _A_arg3, _A_arg4, _A_arg5, _A_arg6);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_arg1, bound_.invoke(), _A_arg2, _A_arg3, _A_arg4, _A_arg5, _A_arg6);
-    }
-  #endif
-    
-  /** Constructs a bind_functor object that binds an argument to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   * @param _A_bound Argument to bind to the functor.
-   */
-  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_bound>::take _A_bound)
-    : adapts<T_functor>(_A_func), bound_(_A_bound)
-    {}
-
-  /// The argument bound to the functor.
-  bound_argument<T_bound> bound_;
-};
-
-/** Adaptor that binds an argument to the wrapped functor.
- * This template specialization fixes the 3th argument of the wrapped functor.
- *
- * @ingroup bind
- */
-template <class T_functor, class T_bound>
-struct bind_functor<2, T_functor, T_bound, nil,nil,nil,nil,nil,nil> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>::type type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor passing on the bound argument only.
-   * @return The return value of the functor invocation.
-   */
-  result_type
-  operator()()
-  {
-    //Note: The AIX compiler sometimes gives linker errors if we do not define this in the class.
-    return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass> (bound_.invoke());
-  }
-
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 3th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
-        (_A_arg1,_A_arg2, bound_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
-        (_A_arg1,_A_arg2, bound_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 3th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg3>::pass>
-        (_A_arg1,_A_arg2, bound_.invoke(), _A_arg3);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg3>::pass>
-        (_A_arg1,_A_arg2, bound_.invoke(), _A_arg3);
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 3th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
-        (_A_arg1,_A_arg2, bound_.invoke(), _A_arg3, _A_arg4);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
-        (_A_arg1,_A_arg2, bound_.invoke(), _A_arg3, _A_arg4);
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 3th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (_A_arg1,_A_arg2, bound_.invoke(), _A_arg3, _A_arg4, _A_arg5);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (_A_arg1,_A_arg2, bound_.invoke(), _A_arg3, _A_arg4, _A_arg5);
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 3th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_arg1,_A_arg2, bound_.invoke(), _A_arg3, _A_arg4, _A_arg5, _A_arg6);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_arg1,_A_arg2, bound_.invoke(), _A_arg3, _A_arg4, _A_arg5, _A_arg6);
-    }
-  #endif
-    
-  /** Constructs a bind_functor object that binds an argument to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   * @param _A_bound Argument to bind to the functor.
-   */
-  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_bound>::take _A_bound)
-    : adapts<T_functor>(_A_func), bound_(_A_bound)
-    {}
-
-  /// The argument bound to the functor.
-  bound_argument<T_bound> bound_;
-};
-
-/** Adaptor that binds an argument to the wrapped functor.
- * This template specialization fixes the 4th argument of the wrapped functor.
- *
- * @ingroup bind
- */
-template <class T_functor, class T_bound>
-struct bind_functor<3, T_functor, T_bound, nil,nil,nil,nil,nil,nil> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>::type type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor passing on the bound argument only.
-   * @return The return value of the functor invocation.
-   */
-  result_type
-  operator()()
-  {
-    //Note: The AIX compiler sometimes gives linker errors if we do not define this in the class.
-    return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass> (bound_.invoke());
-  }
-
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 4th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3, bound_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3, bound_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 4th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg4>::pass>
-        (_A_arg1,_A_arg2,_A_arg3, bound_.invoke(), _A_arg4);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg4>::pass>
-        (_A_arg1,_A_arg2,_A_arg3, bound_.invoke(), _A_arg4);
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 4th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (_A_arg1,_A_arg2,_A_arg3, bound_.invoke(), _A_arg4, _A_arg5);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (_A_arg1,_A_arg2,_A_arg3, bound_.invoke(), _A_arg4, _A_arg5);
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 4th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_arg1,_A_arg2,_A_arg3, bound_.invoke(), _A_arg4, _A_arg5, _A_arg6);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_arg1,_A_arg2,_A_arg3, bound_.invoke(), _A_arg4, _A_arg5, _A_arg6);
-    }
-  #endif
-    
-  /** Constructs a bind_functor object that binds an argument to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   * @param _A_bound Argument to bind to the functor.
-   */
-  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_bound>::take _A_bound)
-    : adapts<T_functor>(_A_func), bound_(_A_bound)
-    {}
-
-  /// The argument bound to the functor.
-  bound_argument<T_bound> bound_;
-};
-
-/** Adaptor that binds an argument to the wrapped functor.
- * This template specialization fixes the 5th argument of the wrapped functor.
- *
- * @ingroup bind
- */
-template <class T_functor, class T_bound>
-struct bind_functor<4, T_functor, T_bound, nil,nil,nil,nil,nil,nil> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>::type type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor passing on the bound argument only.
-   * @return The return value of the functor invocation.
-   */
-  result_type
-  operator()()
-  {
-    //Note: The AIX compiler sometimes gives linker errors if we do not define this in the class.
-    return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass> (bound_.invoke());
-  }
-
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 5th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 5th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg5>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound_.invoke(), _A_arg5);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg5>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound_.invoke(), _A_arg5);
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 5th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound_.invoke(), _A_arg5, _A_arg6);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound_.invoke(), _A_arg5, _A_arg6);
-    }
-  #endif
-    
-  /** Constructs a bind_functor object that binds an argument to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   * @param _A_bound Argument to bind to the functor.
-   */
-  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_bound>::take _A_bound)
-    : adapts<T_functor>(_A_func), bound_(_A_bound)
-    {}
-
-  /// The argument bound to the functor.
-  bound_argument<T_bound> bound_;
-};
-
-/** Adaptor that binds an argument to the wrapped functor.
- * This template specialization fixes the 6th argument of the wrapped functor.
- *
- * @ingroup bind
- */
-template <class T_functor, class T_bound>
-struct bind_functor<5, T_functor, T_bound, nil,nil,nil,nil,nil,nil> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg6>::pass>::type type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor passing on the bound argument only.
-   * @return The return value of the functor invocation.
-   */
-  result_type
-  operator()()
-  {
-    //Note: The AIX compiler sometimes gives linker errors if we do not define this in the class.
-    return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass> (bound_.invoke());
-  }
-
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 6th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5, bound_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5, bound_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 6th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg6>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5, bound_.invoke(), _A_arg6);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg6>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5, bound_.invoke(), _A_arg6);
-    }
-  #endif
-    
-  /** Constructs a bind_functor object that binds an argument to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   * @param _A_bound Argument to bind to the functor.
-   */
-  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_bound>::take _A_bound)
-    : adapts<T_functor>(_A_func), bound_(_A_bound)
-    {}
-
-  /// The argument bound to the functor.
-  bound_argument<T_bound> bound_;
-};
-
-/** Adaptor that binds an argument to the wrapped functor.
- * This template specialization fixes the 7th argument of the wrapped functor.
- *
- * @ingroup bind
- */
-template <class T_functor, class T_bound>
-struct bind_functor<6, T_functor, T_bound, nil,nil,nil,nil,nil,nil> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>::type type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor passing on the bound argument only.
-   * @return The return value of the functor invocation.
-   */
-  result_type
-  operator()()
-  {
-    //Note: The AIX compiler sometimes gives linker errors if we do not define this in the class.
-    return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_bound>::type>::pass> (bound_.invoke());
-  }
-
-  /** Invokes the wrapped functor passing on the arguments.
-   * bound_ is passed as the 7th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5,_A_arg6, bound_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass, typename type_trait<typename unwrap_reference<T_bound>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5,_A_arg6, bound_.invoke());
-    }
-  #endif
-    
-  /** Constructs a bind_functor object that binds an argument to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   * @param _A_bound Argument to bind to the functor.
-   */
-  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_bound>::take _A_bound)
-    : adapts<T_functor>(_A_func), bound_(_A_bound)
-    {}
-
-  /// The argument bound to the functor.
-  bound_argument<T_bound> bound_;
-};
-
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bind_functor performs a functor on the
- * functor and on the object instances stored in the sigc::bind_functor object.
- *
- * @ingroup bind
- */
-template <class T_action, int T_loc, class T_functor, class T_bound>
-void visit_each(const T_action& _A_action,
-                const bind_functor<T_loc, T_functor, T_bound>& _A_target)
-{
-  visit_each(_A_action, _A_target.functor_);
-  visit_each(_A_action, _A_target.bound_);
-}
-
-/** Adaptor that binds 1 argument(s) to the wrapped functor.
- * This template specialization fixes the last 1 argument(s) of the wrapped functor.
- *
- * @ingroup bind
- */
-template <class T_functor, class T_type1>
-struct bind_functor<-1, T_functor, T_type1, nil, nil, nil, nil, nil, nil> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-  template <int count, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>::type type; };
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal<2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>::type type; };
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal<3, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>::type type; };
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal<4, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>::type type; };
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal<5, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>::type type; };
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal<6, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>::type type; };
-#endif /*DOXYGEN_SHOULD_SKIP_THIS*/
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type {
-    typedef typename deduce_result_type_internal<internal::count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::value,
-                                                 T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type;
-  };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor passing on the bound argument only.
-   * @return The return value of the functor invocation.
-   */
-  result_type
-  operator()()
-  {
-    //Note: The AIX compiler sometimes gives linker errors if we do not define this in the class.
-    return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_type1>::type>::pass> (bound1_.invoke());
-  }
-
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 1 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator()(T_arg1 _A_arg1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
-        (_A_arg1, bound1_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround(T_arg1 _A_arg1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
-        (_A_arg1, bound1_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 1 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
-        (_A_arg1,_A_arg2, bound1_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
-        (_A_arg1,_A_arg2, bound1_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 1 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3, bound1_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3, bound1_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 1 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound1_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound1_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 1 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5, bound1_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5, bound1_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 1 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5,_A_arg6, bound1_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5,T_arg6 _A_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5,_A_arg6, bound1_.invoke());
-    }
-  #endif
-    
-  /** Constructs a bind_functor object that binds an argument to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   * @param _A_bound Argument to bind to the functor.
-   */
-  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_bound1)
-    : adapts<T_functor>(_A_func), bound1_(_A_bound1)
-    {}
-
-  /// The argument bound to the functor.
-  bound_argument<T_type1> bound1_;
-};
-
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bind_functor performs a functor on the
- * functor and on the object instances stored in the sigc::bind_functor object.
- *
- * @ingroup bind
- */
-template <class T_action, class T_functor, class T_type1>
-void visit_each(const T_action& _A_action,
-                const bind_functor<-1, T_functor, T_type1>& _A_target)
-{
-  visit_each(_A_action, _A_target.functor_);
-  visit_each(_A_action, _A_target.bound1_);
-}
-
-/** Adaptor that binds 2 argument(s) to the wrapped functor.
- * This template specialization fixes the last 2 argument(s) of the wrapped functor.
- *
- * @ingroup bind
- */
-template <class T_functor, class T_type1,class T_type2>
-struct bind_functor<-1, T_functor, T_type1, T_type2, nil, nil, nil, nil, nil> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-  template <int count, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>::type type; };
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal<3, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>::type type; };
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal<4, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>::type type; };
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal<5, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>::type type; };
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal<6, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>::type type; };
-#endif /*DOXYGEN_SHOULD_SKIP_THIS*/
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type {
-    typedef typename deduce_result_type_internal<internal::count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::value,
-                                                 T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type;
-  };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor passing on the bound argument only.
-   * @return The return value of the functor invocation.
-   */
-  result_type
-  operator()()
-  {
-    //Note: The AIX compiler sometimes gives linker errors if we do not define this in the class.
-    return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass> (bound1_.invoke(),bound2_.invoke());
-  }
-
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 2 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator()(T_arg1 _A_arg1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>
-        (_A_arg1, bound1_.invoke(),bound2_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround(T_arg1 _A_arg1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>
-        (_A_arg1, bound1_.invoke(),bound2_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 2 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>
-        (_A_arg1,_A_arg2, bound1_.invoke(),bound2_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>
-        (_A_arg1,_A_arg2, bound1_.invoke(),bound2_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 2 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3, bound1_.invoke(),bound2_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3, bound1_.invoke(),bound2_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 2 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound1_.invoke(),bound2_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound1_.invoke(),bound2_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 2 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5, bound1_.invoke(),bound2_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4,T_arg5 _A_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4,_A_arg5, bound1_.invoke(),bound2_.invoke());
-    }
-  #endif
-    
-  /** Constructs a bind_functor object that binds an argument to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   * @param _A_bound Argument to bind to the functor.
-   */
-  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_bound1,typename type_trait<T_type2>::take _A_bound2)
-    : adapts<T_functor>(_A_func), bound1_(_A_bound1),bound2_(_A_bound2)
-    {}
-
-  /// The argument bound to the functor.
-  bound_argument<T_type1> bound1_;
-  bound_argument<T_type2> bound2_;
-};
-
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bind_functor performs a functor on the
- * functor and on the object instances stored in the sigc::bind_functor object.
- *
- * @ingroup bind
- */
-template <class T_action, class T_functor, class T_type1,class T_type2>
-void visit_each(const T_action& _A_action,
-                const bind_functor<-1, T_functor, T_type1,T_type2>& _A_target)
-{
-  visit_each(_A_action, _A_target.functor_);
-  visit_each(_A_action, _A_target.bound1_);
-  visit_each(_A_action, _A_target.bound2_);
-}
-
-/** Adaptor that binds 3 argument(s) to the wrapped functor.
- * This template specialization fixes the last 3 argument(s) of the wrapped functor.
- *
- * @ingroup bind
- */
-template <class T_functor, class T_type1,class T_type2,class T_type3>
-struct bind_functor<-1, T_functor, T_type1, T_type2, T_type3, nil, nil, nil, nil> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-  template <int count, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>::type type; };
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal<4, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>::type type; };
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal<5, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>::type type; };
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal<6, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>::type type; };
-#endif /*DOXYGEN_SHOULD_SKIP_THIS*/
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type {
-    typedef typename deduce_result_type_internal<internal::count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::value,
-                                                 T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type;
-  };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor passing on the bound argument only.
-   * @return The return value of the functor invocation.
-   */
-  result_type
-  operator()()
-  {
-    //Note: The AIX compiler sometimes gives linker errors if we do not define this in the class.
-    return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass> (bound1_.invoke(),bound2_.invoke(),bound3_.invoke());
-  }
-
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 3 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator()(T_arg1 _A_arg1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>
-        (_A_arg1, bound1_.invoke(),bound2_.invoke(),bound3_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround(T_arg1 _A_arg1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>
-        (_A_arg1, bound1_.invoke(),bound2_.invoke(),bound3_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 3 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>
-        (_A_arg1,_A_arg2, bound1_.invoke(),bound2_.invoke(),bound3_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>
-        (_A_arg1,_A_arg2, bound1_.invoke(),bound2_.invoke(),bound3_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 3 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3, bound1_.invoke(),bound2_.invoke(),bound3_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3, bound1_.invoke(),bound2_.invoke(),bound3_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 3 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound1_.invoke(),bound2_.invoke(),bound3_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3,T_arg4 _A_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3,_A_arg4, bound1_.invoke(),bound2_.invoke(),bound3_.invoke());
-    }
-  #endif
-    
-  /** Constructs a bind_functor object that binds an argument to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   * @param _A_bound Argument to bind to the functor.
-   */
-  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_bound1,typename type_trait<T_type2>::take _A_bound2,typename type_trait<T_type3>::take _A_bound3)
-    : adapts<T_functor>(_A_func), bound1_(_A_bound1),bound2_(_A_bound2),bound3_(_A_bound3)
-    {}
-
-  /// The argument bound to the functor.
-  bound_argument<T_type1> bound1_;
-  bound_argument<T_type2> bound2_;
-  bound_argument<T_type3> bound3_;
-};
-
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bind_functor performs a functor on the
- * functor and on the object instances stored in the sigc::bind_functor object.
- *
- * @ingroup bind
- */
-template <class T_action, class T_functor, class T_type1,class T_type2,class T_type3>
-void visit_each(const T_action& _A_action,
-                const bind_functor<-1, T_functor, T_type1,T_type2,T_type3>& _A_target)
-{
-  visit_each(_A_action, _A_target.functor_);
-  visit_each(_A_action, _A_target.bound1_);
-  visit_each(_A_action, _A_target.bound2_);
-  visit_each(_A_action, _A_target.bound3_);
-}
-
-/** Adaptor that binds 4 argument(s) to the wrapped functor.
- * This template specialization fixes the last 4 argument(s) of the wrapped functor.
- *
- * @ingroup bind
- */
-template <class T_functor, class T_type1,class T_type2,class T_type3,class T_type4>
-struct bind_functor<-1, T_functor, T_type1, T_type2, T_type3, T_type4, nil, nil, nil> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-  template <int count, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass>::type type; };
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal<5, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass>::type type; };
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal<6, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass>::type type; };
-#endif /*DOXYGEN_SHOULD_SKIP_THIS*/
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type {
-    typedef typename deduce_result_type_internal<internal::count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::value,
-                                                 T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type;
-  };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor passing on the bound argument only.
-   * @return The return value of the functor invocation.
-   */
-  result_type
-  operator()()
-  {
-    //Note: The AIX compiler sometimes gives linker errors if we do not define this in the class.
-    return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass> (bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke());
-  }
-
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 4 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator()(T_arg1 _A_arg1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass>
-        (_A_arg1, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround(T_arg1 _A_arg1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass>
-        (_A_arg1, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 4 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass>
-        (_A_arg1,_A_arg2, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass>
-        (_A_arg1,_A_arg2, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 4 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2,T_arg3 _A_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass>
-        (_A_arg1,_A_arg2,_A_arg3, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke());
-    }
-  #endif
-    
-  /** Constructs a bind_functor object that binds an argument to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   * @param _A_bound Argument to bind to the functor.
-   */
-  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_bound1,typename type_trait<T_type2>::take _A_bound2,typename type_trait<T_type3>::take _A_bound3,typename type_trait<T_type4>::take _A_bound4)
-    : adapts<T_functor>(_A_func), bound1_(_A_bound1),bound2_(_A_bound2),bound3_(_A_bound3),bound4_(_A_bound4)
-    {}
-
-  /// The argument bound to the functor.
-  bound_argument<T_type1> bound1_;
-  bound_argument<T_type2> bound2_;
-  bound_argument<T_type3> bound3_;
-  bound_argument<T_type4> bound4_;
-};
-
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bind_functor performs a functor on the
- * functor and on the object instances stored in the sigc::bind_functor object.
- *
- * @ingroup bind
- */
-template <class T_action, class T_functor, class T_type1,class T_type2,class T_type3,class T_type4>
-void visit_each(const T_action& _A_action,
-                const bind_functor<-1, T_functor, T_type1,T_type2,T_type3,T_type4>& _A_target)
-{
-  visit_each(_A_action, _A_target.functor_);
-  visit_each(_A_action, _A_target.bound1_);
-  visit_each(_A_action, _A_target.bound2_);
-  visit_each(_A_action, _A_target.bound3_);
-  visit_each(_A_action, _A_target.bound4_);
-}
-
-/** Adaptor that binds 5 argument(s) to the wrapped functor.
- * This template specialization fixes the last 5 argument(s) of the wrapped functor.
- *
- * @ingroup bind
- */
-template <class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5>
-struct bind_functor<-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, nil, nil> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-  template <int count, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass>::type type; };
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal<6, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass>::type type; };
-#endif /*DOXYGEN_SHOULD_SKIP_THIS*/
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type {
-    typedef typename deduce_result_type_internal<internal::count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::value,
-                                                 T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type;
-  };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor passing on the bound argument only.
-   * @return The return value of the functor invocation.
-   */
-  result_type
-  operator()()
-  {
-    //Note: The AIX compiler sometimes gives linker errors if we do not define this in the class.
-    return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass> (bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke(),bound5_.invoke());
-  }
-
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 5 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator()(T_arg1 _A_arg1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass>
-        (_A_arg1, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke(),bound5_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround(T_arg1 _A_arg1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass>
-        (_A_arg1, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke(),bound5_.invoke());
-    }
-  #endif
-    
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 5 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1 _A_arg1,T_arg2 _A_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass>
-        (_A_arg1,_A_arg2, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke(),bound5_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1 _A_arg1,T_arg2 _A_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass>
-        (_A_arg1,_A_arg2, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke(),bound5_.invoke());
-    }
-  #endif
-    
-  /** Constructs a bind_functor object that binds an argument to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   * @param _A_bound Argument to bind to the functor.
-   */
-  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_bound1,typename type_trait<T_type2>::take _A_bound2,typename type_trait<T_type3>::take _A_bound3,typename type_trait<T_type4>::take _A_bound4,typename type_trait<T_type5>::take _A_bound5)
-    : adapts<T_functor>(_A_func), bound1_(_A_bound1),bound2_(_A_bound2),bound3_(_A_bound3),bound4_(_A_bound4),bound5_(_A_bound5)
-    {}
-
-  /// The argument bound to the functor.
-  bound_argument<T_type1> bound1_;
-  bound_argument<T_type2> bound2_;
-  bound_argument<T_type3> bound3_;
-  bound_argument<T_type4> bound4_;
-  bound_argument<T_type5> bound5_;
-};
-
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bind_functor performs a functor on the
- * functor and on the object instances stored in the sigc::bind_functor object.
- *
- * @ingroup bind
- */
-template <class T_action, class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5>
-void visit_each(const T_action& _A_action,
-                const bind_functor<-1, T_functor, T_type1,T_type2,T_type3,T_type4,T_type5>& _A_target)
-{
-  visit_each(_A_action, _A_target.functor_);
-  visit_each(_A_action, _A_target.bound1_);
-  visit_each(_A_action, _A_target.bound2_);
-  visit_each(_A_action, _A_target.bound3_);
-  visit_each(_A_action, _A_target.bound4_);
-  visit_each(_A_action, _A_target.bound5_);
-}
-
-/** Adaptor that binds 6 argument(s) to the wrapped functor.
- * This template specialization fixes the last 6 argument(s) of the wrapped functor.
- *
- * @ingroup bind
- */
-template <class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6>
-struct bind_functor<-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, nil> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-  template <int count, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass,typename type_trait<typename unwrap_reference<T_type6>::type>::pass>::type type; };
-#endif /*DOXYGEN_SHOULD_SKIP_THIS*/
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type {
-    typedef typename deduce_result_type_internal<internal::count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::value,
-                                                 T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type;
-  };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor passing on the bound argument only.
-   * @return The return value of the functor invocation.
-   */
-  result_type
-  operator()()
-  {
-    //Note: The AIX compiler sometimes gives linker errors if we do not define this in the class.
-    return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass,typename type_trait<typename unwrap_reference<T_type6>::type>::pass> (bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke(),bound5_.invoke(),bound6_.invoke());
-  }
-
-  /** Invokes the wrapped functor passing on the arguments.
-   * The last 6 argument(s) are fixed.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator()(T_arg1 _A_arg1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass,typename type_trait<typename unwrap_reference<T_type6>::type>::pass>
-        (_A_arg1, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke(),bound5_.invoke(),bound6_.invoke());
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround(T_arg1 _A_arg1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass,typename type_trait<typename unwrap_reference<T_type6>::type>::pass>
-        (_A_arg1, bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke(),bound5_.invoke(),bound6_.invoke());
-    }
-  #endif
-    
-  /** Constructs a bind_functor object that binds an argument to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   * @param _A_bound Argument to bind to the functor.
-   */
-  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_bound1,typename type_trait<T_type2>::take _A_bound2,typename type_trait<T_type3>::take _A_bound3,typename type_trait<T_type4>::take _A_bound4,typename type_trait<T_type5>::take _A_bound5,typename type_trait<T_type6>::take _A_bound6)
-    : adapts<T_functor>(_A_func), bound1_(_A_bound1),bound2_(_A_bound2),bound3_(_A_bound3),bound4_(_A_bound4),bound5_(_A_bound5),bound6_(_A_bound6)
-    {}
-
-  /// The argument bound to the functor.
-  bound_argument<T_type1> bound1_;
-  bound_argument<T_type2> bound2_;
-  bound_argument<T_type3> bound3_;
-  bound_argument<T_type4> bound4_;
-  bound_argument<T_type5> bound5_;
-  bound_argument<T_type6> bound6_;
-};
-
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bind_functor performs a functor on the
- * functor and on the object instances stored in the sigc::bind_functor object.
- *
- * @ingroup bind
- */
-template <class T_action, class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6>
-void visit_each(const T_action& _A_action,
-                const bind_functor<-1, T_functor, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6>& _A_target)
-{
-  visit_each(_A_action, _A_target.functor_);
-  visit_each(_A_action, _A_target.bound1_);
-  visit_each(_A_action, _A_target.bound2_);
-  visit_each(_A_action, _A_target.bound3_);
-  visit_each(_A_action, _A_target.bound4_);
-  visit_each(_A_action, _A_target.bound5_);
-  visit_each(_A_action, _A_target.bound6_);
-}
-
-/** Adaptor that binds 7 argument(s) to the wrapped functor.
- * This template specialization fixes the last 7 argument(s) of the wrapped functor.
- *
- * @ingroup bind
- */
-template <class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6,class T_type7>
-struct bind_functor<-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-  template <int count, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  struct deduce_result_type_internal
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass,typename type_trait<typename unwrap_reference<T_type6>::type>::pass,typename type_trait<typename unwrap_reference<T_type7>::type>::pass>::type type; };
-#endif /*DOXYGEN_SHOULD_SKIP_THIS*/
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type {
-    typedef typename deduce_result_type_internal<internal::count_void<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::value,
-                                                 T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type;
-  };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor passing on the bound argument only.
-   * @return The return value of the functor invocation.
-   */
-  result_type
-  operator()()
-  {
-    //Note: The AIX compiler sometimes gives linker errors if we do not define this in the class.
-    return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<typename unwrap_reference<T_type1>::type>::pass,typename type_trait<typename unwrap_reference<T_type2>::type>::pass,typename type_trait<typename unwrap_reference<T_type3>::type>::pass,typename type_trait<typename unwrap_reference<T_type4>::type>::pass,typename type_trait<typename unwrap_reference<T_type5>::type>::pass,typename type_trait<typename unwrap_reference<T_type6>::type>::pass,typename type_trait<typename unwrap_reference<T_type7>::type>::pass> (bound1_.invoke(),bound2_.invoke(),bound3_.invoke(),bound4_.invoke(),bound5_.invoke(),bound6_.invoke(),bound7_.invoke());
-  }
-
-  /** Constructs a bind_functor object that binds an argument to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   * @param _A_bound Argument to bind to the functor.
-   */
-  bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_bound1,typename type_trait<T_type2>::take _A_bound2,typename type_trait<T_type3>::take _A_bound3,typename type_trait<T_type4>::take _A_bound4,typename type_trait<T_type5>::take _A_bound5,typename type_trait<T_type6>::take _A_bound6,typename type_trait<T_type7>::take _A_bound7)
-    : adapts<T_functor>(_A_func), bound1_(_A_bound1),bound2_(_A_bound2),bound3_(_A_bound3),bound4_(_A_bound4),bound5_(_A_bound5),bound6_(_A_bound6),bound7_(_A_bound7)
-    {}
-
-  /// The argument bound to the functor.
-  bound_argument<T_type1> bound1_;
-  bound_argument<T_type2> bound2_;
-  bound_argument<T_type3> bound3_;
-  bound_argument<T_type4> bound4_;
-  bound_argument<T_type5> bound5_;
-  bound_argument<T_type6> bound6_;
-  bound_argument<T_type7> bound7_;
-};
-
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bind_functor performs a functor on the
- * functor and on the object instances stored in the sigc::bind_functor object.
- *
- * @ingroup bind
- */
-template <class T_action, class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6,class T_type7>
-void visit_each(const T_action& _A_action,
-                const bind_functor<-1, T_functor, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6,T_type7>& _A_target)
-{
-  visit_each(_A_action, _A_target.functor_);
-  visit_each(_A_action, _A_target.bound1_);
-  visit_each(_A_action, _A_target.bound2_);
-  visit_each(_A_action, _A_target.bound3_);
-  visit_each(_A_action, _A_target.bound4_);
-  visit_each(_A_action, _A_target.bound5_);
-  visit_each(_A_action, _A_target.bound6_);
-  visit_each(_A_action, _A_target.bound7_);
-}
-
-
-/** Creates an adaptor of type sigc::bind_functor which binds the passed argument to the passed functor.
- * The optional template argument @e I_location specifies the zero-based
- * position of the argument to be fixed (@p -1 stands for the last argument).
- *
- * @param _A_func Functor that should be wrapped.
- * @param _A_b1 Argument to bind to @e _A_func.
- * @return Adaptor that executes @e _A_func with the bound argument on invokation.
- *
- * @ingroup bind
- */
-template <int I_location, class T_bound1, class T_functor>
-inline bind_functor<I_location, T_functor, T_bound1>
-bind(const T_functor& _A_func, T_bound1 _A_b1)
-{ 
-  return bind_functor<I_location, T_functor, T_bound1>
-           (_A_func, _A_b1);
-}
-
-/** Creates an adaptor of type sigc::bind_functor which fixes the last 1 argument(s) of the passed functor.
- * This function overload fixes the last 1 argument(s) of @e _A_func.
- *
- * @param _A_func Functor that should be wrapped.
- * @param _A_b1 Argument to bind to @e _A_func.
- * @return Adaptor that executes _A_func with the bound argument on invokation.
- *
- * @ingroup bind
- */
-template <class T_type1, class T_functor>
-inline bind_functor<-1, T_functor,
-                    T_type1>
-bind(const T_functor& _A_func, T_type1 _A_b1)
-{ return bind_functor<-1, T_functor,
-                    T_type1>
-                    (_A_func, _A_b1);
-}
-
-/** Creates an adaptor of type sigc::bind_functor which fixes the last 2 argument(s) of the passed functor.
- * This function overload fixes the last 2 argument(s) of @e _A_func.
- *
- * @param _A_func Functor that should be wrapped.
- * @param _A_b1 Argument to bind to @e _A_func.
- * @param _A_b2 Argument to bind to @e _A_func.
- * @return Adaptor that executes _A_func with the bound argument on invokation.
- *
- * @ingroup bind
- */
-template <class T_type1,class T_type2, class T_functor>
-inline bind_functor<-1, T_functor,
-                    T_type1,
-                    T_type2>
-bind(const T_functor& _A_func, T_type1 _A_b1,T_type2 _A_b2)
-{ return bind_functor<-1, T_functor,
-                    T_type1,
-                    T_type2>
-                    (_A_func, _A_b1,_A_b2);
-}
-
-/** Creates an adaptor of type sigc::bind_functor which fixes the last 3 argument(s) of the passed functor.
- * This function overload fixes the last 3 argument(s) of @e _A_func.
- *
- * @param _A_func Functor that should be wrapped.
- * @param _A_b1 Argument to bind to @e _A_func.
- * @param _A_b2 Argument to bind to @e _A_func.
- * @param _A_b3 Argument to bind to @e _A_func.
- * @return Adaptor that executes _A_func with the bound argument on invokation.
- *
- * @ingroup bind
- */
-template <class T_type1,class T_type2,class T_type3, class T_functor>
-inline bind_functor<-1, T_functor,
-                    T_type1,
-                    T_type2,
-                    T_type3>
-bind(const T_functor& _A_func, T_type1 _A_b1,T_type2 _A_b2,T_type3 _A_b3)
-{ return bind_functor<-1, T_functor,
-                    T_type1,
-                    T_type2,
-                    T_type3>
-                    (_A_func, _A_b1,_A_b2,_A_b3);
-}
-
-/** Creates an adaptor of type sigc::bind_functor which fixes the last 4 argument(s) of the passed functor.
- * This function overload fixes the last 4 argument(s) of @e _A_func.
- *
- * @param _A_func Functor that should be wrapped.
- * @param _A_b1 Argument to bind to @e _A_func.
- * @param _A_b2 Argument to bind to @e _A_func.
- * @param _A_b3 Argument to bind to @e _A_func.
- * @param _A_b4 Argument to bind to @e _A_func.
- * @return Adaptor that executes _A_func with the bound argument on invokation.
- *
- * @ingroup bind
- */
-template <class T_type1,class T_type2,class T_type3,class T_type4, class T_functor>
-inline bind_functor<-1, T_functor,
-                    T_type1,
-                    T_type2,
-                    T_type3,
-                    T_type4>
-bind(const T_functor& _A_func, T_type1 _A_b1,T_type2 _A_b2,T_type3 _A_b3,T_type4 _A_b4)
-{ return bind_functor<-1, T_functor,
-                    T_type1,
-                    T_type2,
-                    T_type3,
-                    T_type4>
-                    (_A_func, _A_b1,_A_b2,_A_b3,_A_b4);
-}
-
-/** Creates an adaptor of type sigc::bind_functor which fixes the last 5 argument(s) of the passed functor.
- * This function overload fixes the last 5 argument(s) of @e _A_func.
- *
- * @param _A_func Functor that should be wrapped.
- * @param _A_b1 Argument to bind to @e _A_func.
- * @param _A_b2 Argument to bind to @e _A_func.
- * @param _A_b3 Argument to bind to @e _A_func.
- * @param _A_b4 Argument to bind to @e _A_func.
- * @param _A_b5 Argument to bind to @e _A_func.
- * @return Adaptor that executes _A_func with the bound argument on invokation.
- *
- * @ingroup bind
- */
-template <class T_type1,class T_type2,class T_type3,class T_type4,class T_type5, class T_functor>
-inline bind_functor<-1, T_functor,
-                    T_type1,
-                    T_type2,
-                    T_type3,
-                    T_type4,
-                    T_type5>
-bind(const T_functor& _A_func, T_type1 _A_b1,T_type2 _A_b2,T_type3 _A_b3,T_type4 _A_b4,T_type5 _A_b5)
-{ return bind_functor<-1, T_functor,
-                    T_type1,
-                    T_type2,
-                    T_type3,
-                    T_type4,
-                    T_type5>
-                    (_A_func, _A_b1,_A_b2,_A_b3,_A_b4,_A_b5);
-}
-
-/** Creates an adaptor of type sigc::bind_functor which fixes the last 6 argument(s) of the passed functor.
- * This function overload fixes the last 6 argument(s) of @e _A_func.
- *
- * @param _A_func Functor that should be wrapped.
- * @param _A_b1 Argument to bind to @e _A_func.
- * @param _A_b2 Argument to bind to @e _A_func.
- * @param _A_b3 Argument to bind to @e _A_func.
- * @param _A_b4 Argument to bind to @e _A_func.
- * @param _A_b5 Argument to bind to @e _A_func.
- * @param _A_b6 Argument to bind to @e _A_func.
- * @return Adaptor that executes _A_func with the bound argument on invokation.
- *
- * @ingroup bind
- */
-template <class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6, class T_functor>
-inline bind_functor<-1, T_functor,
-                    T_type1,
-                    T_type2,
-                    T_type3,
-                    T_type4,
-                    T_type5,
-                    T_type6>
-bind(const T_functor& _A_func, T_type1 _A_b1,T_type2 _A_b2,T_type3 _A_b3,T_type4 _A_b4,T_type5 _A_b5,T_type6 _A_b6)
-{ return bind_functor<-1, T_functor,
-                    T_type1,
-                    T_type2,
-                    T_type3,
-                    T_type4,
-                    T_type5,
-                    T_type6>
-                    (_A_func, _A_b1,_A_b2,_A_b3,_A_b4,_A_b5,_A_b6);
-}
-
-/** Creates an adaptor of type sigc::bind_functor which fixes the last 7 argument(s) of the passed functor.
- * This function overload fixes the last 7 argument(s) of @e _A_func.
- *
- * @param _A_func Functor that should be wrapped.
- * @param _A_b1 Argument to bind to @e _A_func.
- * @param _A_b2 Argument to bind to @e _A_func.
- * @param _A_b3 Argument to bind to @e _A_func.
- * @param _A_b4 Argument to bind to @e _A_func.
- * @param _A_b5 Argument to bind to @e _A_func.
- * @param _A_b6 Argument to bind to @e _A_func.
- * @param _A_b7 Argument to bind to @e _A_func.
- * @return Adaptor that executes _A_func with the bound argument on invokation.
- *
- * @ingroup bind
- */
-template <class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6,class T_type7, class T_functor>
-inline bind_functor<-1, T_functor,
-                    T_type1,
-                    T_type2,
-                    T_type3,
-                    T_type4,
-                    T_type5,
-                    T_type6,
-                    T_type7>
-bind(const T_functor& _A_func, T_type1 _A_b1,T_type2 _A_b2,T_type3 _A_b3,T_type4 _A_b4,T_type5 _A_b5,T_type6 _A_b6,T_type7 _A_b7)
-{ return bind_functor<-1, T_functor,
-                    T_type1,
-                    T_type2,
-                    T_type3,
-                    T_type4,
-                    T_type5,
-                    T_type6,
-                    T_type7>
-                    (_A_func, _A_b1,_A_b2,_A_b3,_A_b4,_A_b5,_A_b6,_A_b7);
-}
-
-
-} /* namespace sigc */
-#endif /* _SIGC_ADAPTORS_MACROS_BINDHM4_ */
Index: stardict-3.0.1/src/sigc++/adaptors/bind_return.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/bind_return.h
+++ /dev/null
@@ -1,206 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-#ifndef _SIGC_ADAPTORS_MACROS_BIND_RETURNHM4_
-#define _SIGC_ADAPTORS_MACROS_BIND_RETURNHM4_
-#include <sigc++/adaptors/adaptor_trait.h>
-#include <sigc++/adaptors/bound_argument.h>
-
-namespace sigc {
-
-/** Adaptor that fixes the return value of the wrapped functor.
- * Use the convenience function sigc::bind_return() to create an instance of sigc::bind_return_functor.
- *
- * The following template arguments are used:
- * - @e T_return Type of the fixed return value.
- * - @e T_functor Type of the functor to wrap.
- *
- * @ingroup bind
- */
-template <class T_return, class T_functor>
-struct bind_return_functor : public adapts<T_functor>
-{
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename unwrap_reference<T_return>::type type; };
-  typedef typename unwrap_reference<T_return>::type result_type;
-
-  /** Invokes the wrapped functor dropping its return value.
-   * @return The fixed return value.
-   */
-  typename unwrap_reference<T_return>::type operator()();
-
-  /** Invokes the wrapped functor passing on the arguments.,
-   * @param _A_arg%1 Argument to be passed on to the functor.)
-   * @return The fixed return value.
-   */
-  template <class T_arg1>
-  inline typename unwrap_reference<T_return>::type operator()(T_arg1 _A_a1)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-        (_A_a1); return ret_value_.invoke();
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  inline typename unwrap_reference<T_return>::type sun_forte_workaround(T_arg1 _A_a1)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-        (_A_a1); return ret_value_.invoke();
-    }
-  #endif
-
-  /** Invokes the wrapped functor passing on the arguments.,
-   * @param _A_arg%1 Argument to be passed on to the functor.)
-   * @return The fixed return value.
-   */
-  template <class T_arg1,class T_arg2>
-  inline typename unwrap_reference<T_return>::type operator()(T_arg1 _A_a1,T_arg2 _A_a2)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-        (_A_a1,_A_a2); return ret_value_.invoke();
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  inline typename unwrap_reference<T_return>::type sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-        (_A_a1,_A_a2); return ret_value_.invoke();
-    }
-  #endif
-
-  /** Invokes the wrapped functor passing on the arguments.,
-   * @param _A_arg%1 Argument to be passed on to the functor.)
-   * @return The fixed return value.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3>
-  inline typename unwrap_reference<T_return>::type operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-        (_A_a1,_A_a2,_A_a3); return ret_value_.invoke();
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  inline typename unwrap_reference<T_return>::type sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-        (_A_a1,_A_a2,_A_a3); return ret_value_.invoke();
-    }
-  #endif
-
-  /** Invokes the wrapped functor passing on the arguments.,
-   * @param _A_arg%1 Argument to be passed on to the functor.)
-   * @return The fixed return value.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  inline typename unwrap_reference<T_return>::type operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4); return ret_value_.invoke();
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  inline typename unwrap_reference<T_return>::type sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4); return ret_value_.invoke();
-    }
-  #endif
-
-  /** Invokes the wrapped functor passing on the arguments.,
-   * @param _A_arg%1 Argument to be passed on to the functor.)
-   * @return The fixed return value.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  inline typename unwrap_reference<T_return>::type operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); return ret_value_.invoke();
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  inline typename unwrap_reference<T_return>::type sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); return ret_value_.invoke();
-    }
-  #endif
-
-  /** Invokes the wrapped functor passing on the arguments.,
-   * @param _A_arg%1 Argument to be passed on to the functor.)
-   * @return The fixed return value.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  inline typename unwrap_reference<T_return>::type operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); return ret_value_.invoke();
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  inline typename unwrap_reference<T_return>::type sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); return ret_value_.invoke();
-    }
-  #endif
-
-  /** Invokes the wrapped functor passing on the arguments.,
-   * @param _A_arg%1 Argument to be passed on to the functor.)
-   * @return The fixed return value.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  inline typename unwrap_reference<T_return>::type operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); return ret_value_.invoke();
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  inline typename unwrap_reference<T_return>::type sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); return ret_value_.invoke();
-    }
-  #endif
-
-
-  /** Constructs a bind_return_functor object that fixes the return value to @p _A_ret_value.
-   * @param _A_functor Functor to invoke from operator()().
-   * @param _A_ret_value Value to return from operator()().
-   */
-  bind_return_functor(typename type_trait<T_functor>::take _A_functor, typename type_trait<T_return>::take _A_ret_value)
-    : adapts<T_functor>(_A_functor), ret_value_(_A_ret_value)
-    {}
-
-  /// The fixed return value.
-  bound_argument<T_return> ret_value_; // public, so that visit_each() can access it
-};
-
-template <class T_return, class T_functor>
-typename unwrap_reference<T_return>::type bind_return_functor<T_return, T_functor>::operator()()
-  { this->functor_(); return ret_value_.invoke(); }
-
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bind_return_functor performs a functor on the
- * functor and on the object instance stored in the sigc::bind_return_functor object.
- *
- * @ingroup bind
- */
-template <class T_action, class T_return, class T_functor>
-void visit_each(const T_action& _A_action,
-                const bind_return_functor<T_return, T_functor>& _A_target)
-{
-  visit_each(_A_action, _A_target.ret_value_);
-  visit_each(_A_action, _A_target.functor_);
-}
-
-
-/** Creates an adaptor of type sigc::bind_return_functor which fixes the return value of the passed functor to the passed argument.
- *
- * @param _A_functor Functor that should be wrapped.
- * @param _A_ret_value Argument to fix the return value of @e _A_functor to.
- * @return Adaptor that executes @e _A_functor on invokation and returns @e _A_ret_value.
- *
- * @ingroup bind
- */
-template <class T_return, class T_functor>
-inline bind_return_functor<T_return, T_functor>
-bind_return(const T_functor& _A_functor, T_return _A_ret_value)
-{ return bind_return_functor<T_return, T_functor>(_A_functor, _A_ret_value); }
-
-} /* namespace sigc */
-#endif /* _SIGC_ADAPTORS_MACROS_BIND_RETURNHM4_ */
Index: stardict-3.0.1/src/sigc++/adaptors/bound_argument.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/bound_argument.h
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * Copyright 2005, The libsigc++ Development Team
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#ifndef _SIGC_BOUND_ARGUMENT_H_
-#define _SIGC_BOUND_ARGUMENT_H_
-
-
-#include <sigc++/limit_reference.h>
-#include <sigc++/reference_wrapper.h>
-
-
-namespace sigc {
-
-/** A bound_argument<Foo> object stores a bound (for instance, with sigc::bind(), or sigc::bind_return()) argument.
- *
- * If Foo is a wrapped reference to a class Bar (reference_wrapper<Bar>) then this
- * object is implemented on top of a limit_reference. When the slot is
- * invoked, the limit_reference::invoke() method provides the argument (a Bar&).
- * When the slot is visited (e.g. visit_each<>()), we simply visit the limit_reference,
- * which will visit the derived type, or a sigc::trackable base if necessary.
- *
- * Likewise, If Foo is a wrapped const reference to a class Bar (const_reference_wrapper<Bar>)
- * then this object is implemented on top of a const_limit_reference.
- * 
- * If Foo is something else (such as an argument that is bound by value) bound_argument just
- * stores a cop of that value, and both invoke() and visit() simply return it.
- * 
- * This object is used by the bind_functor<> and bind_return_functor<> objects,
- * depending on whether the argument is bound as a parameter or as a return value.
- *
- * The general template implementation is used for parameters that are passed by value.
- * @e T_type The type of the bound argument.
- */
-template <class T_type>
-class bound_argument
-{
-public:
-  /** Constructor.
-   * @param _A_argument The argument to bind.
-   */
-  bound_argument(const T_type& _A_argument)
-    : visited_(_A_argument)
-    {}
-
-  /** Retrieve the entity to visit in visit_each().
-   * @return The bound argument.
-   */
-  inline const T_type& visit() const
-    { return visited_; }
-
-  /** Retrieve the entity to pass to the bound functor or return.
-   * @return The bound argument.
-   */
-  inline T_type& invoke()
-    { return visited_; }
-
-private:
-  /** The value of the argument.
-   */
-  T_type visited_;
-};
-
-//Template specialization:
-/** bound_argument object for a bound argument that is passed by bind() or
- * returned by bind_return() by reference, specialized for reference_wrapper<> types.
- * @e T_wrapped The type of the bound argument.
- */
-template <class T_wrapped>
-class bound_argument< reference_wrapper<T_wrapped> >
-{
-public:
-  /** Constructor.
-   * @param _A_argument The argument to bind.
-   */
-  bound_argument(const reference_wrapper<T_wrapped>& _A_argument)
-    : visited_(unwrap(_A_argument))
-    {}
-
-  /** Retrieve the entity to visit in visit_each().
-   * @return The limited_reference to the bound argument.
-   */
-  inline const limit_reference<T_wrapped>& visit() const
-    { return visited_; }
-
-  /** Retrieve the entity to pass to the bound functor or return.
-   * @return The bound argument.
-   */
-  inline T_wrapped& invoke()
-    { return visited_.invoke(); }
-
-private:
-  /** The limited_reference to the bound argument.
-   */
-  limit_reference<T_wrapped> visited_;
-};
-
-/** bound_argument object for a bound argument that is passed by bind() or
- * returned by bind_return() by const reference, specialized for const reference_wrapper<> types.
- * - @e T_wrapped The type of the bound argument.
- */
-template <class T_wrapped>
-class bound_argument< const_reference_wrapper<T_wrapped> >
-{
-public:
-  /** Constructor.
-   * @param _A_argument The argument to bind.
-   */
-  bound_argument(const const_reference_wrapper<T_wrapped>& _A_argument)
-    : visited_(unwrap(_A_argument))
-    {}
-
-  /** Retrieve the entity to visit in visit_each().
-   * @return The const_limited_reference to the bound argument.
-   */
-  inline const const_limit_reference<T_wrapped>& visit() const
-    { return visited_; }
-
-  /** Retrieve the entity to pass to the bound functor or return.
-   * @return The bound argument.
-   */
-  inline const T_wrapped& invoke()
-    { return visited_.invoke(); }
-
-private:
-  /** The const_limited_reference to the bound argument.
-   */
-  const_limit_reference<T_wrapped> visited_;
-};
-
-/** Implementation of visit_each() specialized for the bound_argument class.
- * Call visit_each() on the entity returned by the bound_argument's visit()
- * method.
- * @e T_action The type of functor to invoke.
- * @e T_type The type of bound_argument.
- * @param _A_action The functor to invoke.
- * @param _A_argument The visited instance.
- */
-template <class T_action, class T_type>
-void
-visit_each(const T_action& _A_action,
-           const bound_argument<T_type>& _A_argument)
-{
-  visit_each(_A_action, _A_argument.visit());
-}
-
-
-} /* namespace sigc */
-
-
-#endif /* _SIGC_BOUND_ARGUMENT_H_ */
Index: stardict-3.0.1/src/sigc++/adaptors/compose.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/compose.h
+++ /dev/null
@@ -1,314 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-
-#ifndef _SIGC_ADAPTORS_MACROS_COMPOSEHM4_
-#define _SIGC_ADAPTORS_MACROS_COMPOSEHM4_
-#include <sigc++/adaptors/adaptor_trait.h>
-
-namespace sigc {
-
-/** @defgroup compose compose()
- * sigc::compose() combines two or three arbitrary functors.
- * On invokation parameters are passed on to one or two getter functor(s).
- * The return value(s) are then passed on to the setter function.
- *
- * @par Examples:
- *   @code
- *   float square_root(float a)  { return sqrtf(a); }
- *   float sum(float a, float b) { return a+b; }
- *   std::cout << sigc::compose(&square_root, &sum)(9, 16); // calls square_root(sum(3,6))
- *   std::cout << sigc::compose(&sum, &square_root, &square_root)(9); // calls sum(square_root(9), square_root(9))
- *   @endcode
- *
- * The functor sigc::compose() returns can be passed into
- * sigc::signal::connect() directly.
- *
- * @par Example:
- *   @code
- *   sigc::signal<float,float,float> some_signal;
- *   some_signal.connect(sigc::compose(&square_root, &sum));
- *   @endcode
- *
- * For a more powerful version of this functionality see the lambda
- * library adaptor sigc::group() which can bind, hide and reorder
- * arguments arbitrarily.  Although sigc::group() is more flexible,
- * sigc::bind() provides a means of binding parameters when then total
- * number of parameters called is variable.
- *
- * @ingroup adaptors
- */
-
-/** Adaptor that combines two functors.
- * Use the convenience function sigc::compose() to create an instance of sigc::compose1_functor.
- *
- * The following template arguments are used:
- * - @e T_setter Type of the setter functor to wrap.
- * - @e T_getter Type of the getter functor to wrap.
- *
- * @ingroup compose
- */
-template <class T_setter, class T_getter>
-struct compose1_functor : public adapts<T_setter>
-{
-  typedef typename adapts<T_setter>::adaptor_type adaptor_type;
-  typedef T_setter setter_type;
-  typedef T_getter getter_type;
-
-  template <class T_arg1 = void,class T_arg2 = void,class T_arg3 = void,class T_arg4 = void,class T_arg5 = void,class T_arg6 = void,class T_arg7 = void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<
-        typename sigc::deduce_result_type<T_getter, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-          >::type type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  result_type
-  operator()();
-
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator()(T_arg1 _A_a1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename sigc::deduce_result_type<T_getter, T_arg1>::type>
-        (get_(_A_a1));
-    }
-
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename sigc::deduce_result_type<T_getter, T_arg1,T_arg2>::type>
-        (get_(_A_a1,_A_a2));
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename sigc::deduce_result_type<T_getter, T_arg1,T_arg2,T_arg3>::type>
-        (get_(_A_a1,_A_a2,_A_a3));
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename sigc::deduce_result_type<T_getter, T_arg1,T_arg2,T_arg3,T_arg4>::type>
-        (get_(_A_a1,_A_a2,_A_a3,_A_a4));
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename sigc::deduce_result_type<T_getter, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type>
-        (get_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5));
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename sigc::deduce_result_type<T_getter, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type>
-        (get_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6));
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename sigc::deduce_result_type<T_getter, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type>
-        (get_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7));
-    }
-
-
-  /** Constructs a compose1_functor object that combines the passed functors.
-   * @param _A_setter Functor that receives the return values of the invokation of @e _A_getter1 and @e _A_getter2.
-   * @param _A_getter1 Functor to invoke from operator()().
-   * @param _A_getter2 Functor to invoke from operator()().
-   */
-  compose1_functor(const T_setter& _A_setter, const T_getter& _A_getter)
-    : adapts<T_setter>(_A_setter), get_(_A_getter)
-    {}
-
-  getter_type get_; // public, so that visit_each() can access it
-};
-
-template <class T_setter, class T_getter>
-typename compose1_functor<T_setter, T_getter>::result_type
-compose1_functor<T_setter, T_getter>::operator()()
-  { return this->functor_(get_()); }
-
-/** Adaptor that combines three functors.
- * Use the convenience function sigc::compose() to create an instance of sigc::compose2_functor.
- *
- * The following template arguments are used:
- * - @e T_setter Type of the setter functor to wrap.
- * - @e T_getter1 Type of the first getter functor to wrap.
- * - @e T_getter2 Type of the second getter functor to wrap.
- *
- * @ingroup compose
- */
-template <class T_setter, class T_getter1, class T_getter2>
-struct compose2_functor : public adapts<T_setter>
-{
-  typedef typename adapts<T_setter>::adaptor_type adaptor_type;
-  typedef T_setter setter_type;
-  typedef T_getter1 getter1_type;
-  typedef T_getter2 getter2_type;
-  
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<
-        typename sigc::deduce_result_type<T_getter1, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type,
-        typename sigc::deduce_result_type<T_getter2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-          >::type result_type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  result_type
-  operator()();
-
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator()(T_arg1 _A_a1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename sigc::deduce_result_type<T_getter1, T_arg1>::type,
-                                                         typename sigc::deduce_result_type<T_getter2, T_arg1>::type>
-        (get1_(_A_a1), get2_(_A_a1));
-    }
-
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename sigc::deduce_result_type<T_getter1, T_arg1,T_arg2>::type,
-                                                         typename sigc::deduce_result_type<T_getter2, T_arg1,T_arg2>::type>
-        (get1_(_A_a1,_A_a2), get2_(_A_a1,_A_a2));
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename sigc::deduce_result_type<T_getter1, T_arg1,T_arg2,T_arg3>::type,
-                                                         typename sigc::deduce_result_type<T_getter2, T_arg1,T_arg2,T_arg3>::type>
-        (get1_(_A_a1,_A_a2,_A_a3), get2_(_A_a1,_A_a2,_A_a3));
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename sigc::deduce_result_type<T_getter1, T_arg1,T_arg2,T_arg3,T_arg4>::type,
-                                                         typename sigc::deduce_result_type<T_getter2, T_arg1,T_arg2,T_arg3,T_arg4>::type>
-        (get1_(_A_a1,_A_a2,_A_a3,_A_a4), get2_(_A_a1,_A_a2,_A_a3,_A_a4));
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename sigc::deduce_result_type<T_getter1, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type,
-                                                         typename sigc::deduce_result_type<T_getter2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type>
-        (get1_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5), get2_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5));
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename sigc::deduce_result_type<T_getter1, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type,
-                                                         typename sigc::deduce_result_type<T_getter2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type>
-        (get1_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6), get2_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6));
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename sigc::deduce_result_type<T_getter1, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type,
-                                                         typename sigc::deduce_result_type<T_getter2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type>
-        (get1_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7), get2_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7));
-    }
-
-
-  /** Constructs a compose2_functor object that combines the passed functors.
-   * @param _A_setter Functor that receives the return values of the invokation of @e _A_getter1 and @e _A_getter2.
-   * @param _A_getter1 Functor to invoke from operator()().
-   * @param _A_getter2 Functor to invoke from operator()().
-   */
-  compose2_functor(const T_setter& _A_setter,
-                   const T_getter1& _A_getter1,
-                   const T_getter2& _A_getter2)
-    : adapts<T_setter>(_A_setter), get1_(_A_getter1), get2_(_A_getter2)
-    {}
-
-  getter1_type get1_; // public, so that visit_each() can access it
-  getter2_type get2_; // public, so that visit_each() can access it
-};
-
-template <class T_setter, class T_getter1, class T_getter2>
-typename compose2_functor<T_setter, T_getter1, T_getter2>::result_type
-compose2_functor<T_setter, T_getter1, T_getter2>::operator()()
-  { return this->functor_(get1_(), get2_()); }
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::compose1_functor performs a functor on the
- * functors stored in the sigc::compose1_functor object.
- *
- * @ingroup compose
- */
-template <class T_action, class T_setter, class T_getter>
-void visit_each(const T_action& _A_action,
-                const compose1_functor<T_setter, T_getter>& _A_target)
-{
-  typedef compose1_functor<T_setter, T_getter> type_functor;
-  
-  //Note that the AIX compiler needs the actual template types of visit_each to be specified:
-  typedef typename type_functor::setter_type type_functor1;
-  visit_each<T_action, type_functor1>(_A_action, _A_target.functor_);
-  
-  typedef typename type_functor::getter_type type_functor_getter;
-  visit_each<T_action, type_functor_getter>(_A_action, _A_target.get_);
-}
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::compose2_functor performs a functor on the
- * functors stored in the sigc::compose2_functor object.
- *
- * @ingroup compose
- */
-template <class T_action, class T_setter, class T_getter1, class T_getter2>
-void visit_each(const T_action& _A_action,
-                const compose2_functor<T_setter, T_getter1, T_getter2>& _A_target)
-{
-  typedef compose2_functor<T_setter, T_getter1, T_getter2> type_functor;
-  
-  //Note that the AIX compiler needs the actual template types of visit_each to be specified:
-  typedef typename type_functor::setter_type type_functor1;
-  visit_each<T_action, type_functor1>(_A_action, _A_target.functor_);
-  
-  typedef typename type_functor::getter1_type type_functor_getter1;
-  visit_each<T_action, type_functor_getter1>(_A_action, _A_target.get1_);
-  
-  typedef typename type_functor::getter2_type type_functor_getter2;
-  visit_each<T_action, type_functor_getter2>(_A_action, _A_target.get2_);
-}
-
-
-/** Creates an adaptor of type sigc::compose1_functor which combines two functors.
- *
- * @param _A_setter Functor that receives the return value of the invokation of @e _A_getter.
- * @param _A_getter Functor to invoke from operator()().
- * @return Adaptor that executes @e _A_setter with the value returned from invokation of @e _A_getter.
- *
- * @ingroup compose
- */
-template <class T_setter, class T_getter>
-inline compose1_functor<T_setter, T_getter>
-compose(const T_setter& _A_setter, const T_getter& _A_getter)
-  { return compose1_functor<T_setter, T_getter>(_A_setter, _A_getter); }
-
-/** Creates an adaptor of type sigc::compose2_functor which combines three functors.
- *
- * @param _A_setter Functor that receives the return values of the invokation of @e _A_getter1 and @e _A_getter2.
- * @param _A_getter1 Functor to invoke from operator()().
- * @param _A_getter2 Functor to invoke from operator()().
- * @return Adaptor that executes @e _A_setter with the values return from invokation of @e _A_getter1 and @e _A_getter2.
- *
- * @ingroup compose
- */
-template <class T_setter, class T_getter1, class T_getter2>
-inline compose2_functor<T_setter, T_getter1, T_getter2>
-compose(const T_setter& _A_setter, const T_getter1& _A_getter1, const T_getter2& _A_getter2)
-  { return compose2_functor<T_setter, T_getter1, T_getter2>(_A_setter, _A_getter1, _A_getter2); }
-
-} /* namespace sigc */
-#endif /* _SIGC_ADAPTORS_MACROS_COMPOSEHM4_ */
Index: stardict-3.0.1/src/sigc++/adaptors/deduce_result_type.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/deduce_result_type.h
+++ /dev/null
@@ -1,121 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-/*
-*/
-#ifndef _SIGC_ADAPTORS_MACROS_DEDUCE_RESULT_TYPEHM4_
-#define _SIGC_ADAPTORS_MACROS_DEDUCE_RESULT_TYPEHM4_
-#include <sigc++/functors/functor_trait.h>
-
-
-namespace sigc {
-
-/** A hint to the compiler.
- * Functors which have all methods based on templates
- * should publicly inherit from this hint and define 
- * a nested template class @p deduce_result_type that
- * can be used to deduce the methods' return types.
- *
- * adaptor_base inherits from the functor_base hint so
- * derived types should also have a result_type defined.
- *
- * Adaptors don't inherit from this type directly. They use
- * use sigc::adapts as a base type instead. sigc::adaptors
- * wraps arbitrary functor types as well as function pointers
- * and class methods.
- *
- * @ingroup adaptors
- */
-struct adaptor_base : public functor_base {};
-
-
-/** Deduce the return type of a functor.
- * <tt>typename deduce_result_type<functor_type, list of arg_types>::type</tt>
- * deduces a functor's result type if @p functor_type inherits from
- * sigc::functor_base and defines @p result_type or if @p functor_type
- * is actually a (member) function type. Multi-type functors are not
- * supported.
- *
- * sigc++ adaptors use
- * <tt>typename deduce_result_type<functor_type, list of arg_types>::type</tt>
- * to determine the return type of their <tt>templated operator()</tt> overloads.
- *
- * Adaptors in turn define a nested template class @p deduce_result_type
- * that is used by template specializations of the global deduce_result_type
- * template to correctly deduce the return types of the adaptor's suitable
- * <tt>template operator()</tt> overload.
- *
- * @ingroup adaptors
- */
-template <class T_functor,
-          class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void,
-          bool I_derives_adaptor_base=is_base_and_derived<adaptor_base,T_functor>::value>
-struct deduce_result_type
-  { typedef typename functor_trait<T_functor>::result_type type; };
-
-/** Deduce the return type of a functor.
- * This is the template specialization of the sigc::deduce_result_type template
- * for 0 arguments.
- */
-template <class T_functor>
-struct deduce_result_type<T_functor, void,void,void,void,void,void,void, true>
-  { typedef typename T_functor::template deduce_result_type<>::type type; };
-
-/** Deduce the return type of a functor.
- * This is the template specialization of the sigc::deduce_result_type template
- * for 1 arguments.
- */
-template <class T_functor, class T_arg1>
-struct deduce_result_type<T_functor, T_arg1, void,void,void,void,void,void, true>
-  { typedef typename T_functor::template deduce_result_type<T_arg1>::type type; };
-
-/** Deduce the return type of a functor.
- * This is the template specialization of the sigc::deduce_result_type template
- * for 2 arguments.
- */
-template <class T_functor, class T_arg1,class T_arg2>
-struct deduce_result_type<T_functor, T_arg1,T_arg2, void,void,void,void,void, true>
-  { typedef typename T_functor::template deduce_result_type<T_arg1,T_arg2>::type type; };
-
-/** Deduce the return type of a functor.
- * This is the template specialization of the sigc::deduce_result_type template
- * for 3 arguments.
- */
-template <class T_functor, class T_arg1,class T_arg2,class T_arg3>
-struct deduce_result_type<T_functor, T_arg1,T_arg2,T_arg3, void,void,void,void, true>
-  { typedef typename T_functor::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type type; };
-
-/** Deduce the return type of a functor.
- * This is the template specialization of the sigc::deduce_result_type template
- * for 4 arguments.
- */
-template <class T_functor, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-struct deduce_result_type<T_functor, T_arg1,T_arg2,T_arg3,T_arg4, void,void,void, true>
-  { typedef typename T_functor::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type type; };
-
-/** Deduce the return type of a functor.
- * This is the template specialization of the sigc::deduce_result_type template
- * for 5 arguments.
- */
-template <class T_functor, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-struct deduce_result_type<T_functor, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, void,void, true>
-  { typedef typename T_functor::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type type; };
-
-/** Deduce the return type of a functor.
- * This is the template specialization of the sigc::deduce_result_type template
- * for 6 arguments.
- */
-template <class T_functor, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-struct deduce_result_type<T_functor, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, void, true>
-  { typedef typename T_functor::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type type; };
-
-/** Deduce the return type of a functor.
- * This is the template specialization of the sigc::deduce_result_type template
- * for 7 arguments.
- */
-template <class T_functor, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-struct deduce_result_type<T_functor, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, true>
-  { typedef typename T_functor::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type; };
-
-
-} /* namespace sigc */
-#endif /* _SIGC_ADAPTORS_MACROS_DEDUCE_RESULT_TYPEHM4_ */
Index: stardict-3.0.1/src/sigc++/adaptors/exception_catch.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/exception_catch.h
+++ /dev/null
@@ -1,318 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-#ifndef _SIGC_ADAPTORS_MACROS_EXCEPTION_CATCHHM4_
-#define _SIGC_ADAPTORS_MACROS_EXCEPTION_CATCHHM4_
-#include <sigc++/adaptors/adaptor_trait.h>
-
-namespace sigc {
-
-/*
-   functor adaptor:  exception_catch(functor, catcher)
-
-   usage:
-
-
-   Future directions:
-     The catcher should be told what type of return it needs to
-   return for multiple type functors,  to do this the user
-   will need to derive from catcher_base.
-*/
-/** @defgroup exception_catch exception_catch()
- * sigc::exception_catch() catches an exception thrown from within 
- * the wrapped functor and directs it to a catcher functor.
- * This catcher can then rethrow the exception and catch it with the proper type.
- *
- * Note that the catcher is expected to return the same type
- * as the wrapped functor so that normal flow can continue.
- *
- * Catchers can be cascaded to catch multiple types because uncaught
- * rethrown exceptions proceed to the next catcher adaptor.
- *
- * @par Examples:
- *   @code
- *   struct my_catch
- *   {
- *     int operator()()
- *     {
- *       try { throw; }
- *       catch (std::range_error e) // catch what types we know
- *         { std::cerr << "caught " << e.what() << std::endl; }
- *       return 1;
- *     }
- *   }
- *   int foo(); // throws std::range_error
- *   sigc::exception_catch(&foo, my_catch())();
- *   @endcode
- *
- * The functor sigc::execption_catch() returns can be passed into
- * sigc::signal::connect() directly.
- *
- * @par Example:
- *   @code
- *   sigc::signal<int> some_signal;
- *   some_signal.connect(sigc::exception_catch(&foo, my_catch));
- *   @endcode
- *
- * @ingroup adaptors
- */
-
-template <class T_functor, class T_catcher, class T_return = typename adapts<T_functor>::result_type>
-struct exception_catch_functor : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type type; };
-  typedef T_return result_type;
-
-  result_type
-  operator()();
-
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator()(T_arg1 _A_a1)
-    { 
-      try
-        {
-          return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-            (_A_a1);
-        } 
-      catch (...)
-        { return catcher_(); }
-    }
-
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2)
-    { 
-      try
-        {
-          return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-            (_A_a1,_A_a2);
-        } 
-      catch (...)
-        { return catcher_(); }
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
-    { 
-      try
-        {
-          return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-            (_A_a1,_A_a2,_A_a3);
-        } 
-      catch (...)
-        { return catcher_(); }
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
-    { 
-      try
-        {
-          return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-            (_A_a1,_A_a2,_A_a3,_A_a4);
-        } 
-      catch (...)
-        { return catcher_(); }
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
-    { 
-      try
-        {
-          return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-            (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
-        } 
-      catch (...)
-        { return catcher_(); }
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
-    { 
-      try
-        {
-          return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-            (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
-        } 
-      catch (...)
-        { return catcher_(); }
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
-    { 
-      try
-        {
-          return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-            (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
-        } 
-      catch (...)
-        { return catcher_(); }
-    }
-
-  exception_catch_functor(const T_functor& _A_func,
-                          const T_catcher& _A_catcher)
-    : adapts<T_functor>(_A_func), catcher_(_A_catcher)
-    {}
-
-  T_catcher catcher_; 
-};
-
-template <class T_functor, class T_catcher, class T_return>
-typename exception_catch_functor<T_functor, T_catcher, T_return>::result_type
-exception_catch_functor<T_functor, T_catcher, T_return>::operator()()
-  { 
-    try
-      { return this->functor_(); }
-    catch (...)
-      { return catcher_(); }
-  }
-
-// void specialization
-template <class T_functor, class T_catcher>
-struct exception_catch_functor<T_functor, T_catcher, void> : public adapts<T_functor>
-{
-  typedef void result_type;
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  void
-  operator()();
-
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator()(T_arg1 _A_a1)
-    { 
-      try
-        {
-          return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-            (_A_a1);
-        } 
-      catch (...)
-        { return catcher_(); }
-    }
-
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2)
-    { 
-      try
-        {
-          return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-            (_A_a1,_A_a2);
-        } 
-      catch (...)
-        { return catcher_(); }
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
-    { 
-      try
-        {
-          return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-            (_A_a1,_A_a2,_A_a3);
-        } 
-      catch (...)
-        { return catcher_(); }
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
-    { 
-      try
-        {
-          return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-            (_A_a1,_A_a2,_A_a3,_A_a4);
-        } 
-      catch (...)
-        { return catcher_(); }
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
-    { 
-      try
-        {
-          return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-            (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
-        } 
-      catch (...)
-        { return catcher_(); }
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
-    { 
-      try
-        {
-          return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-            (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
-        } 
-      catch (...)
-        { return catcher_(); }
-    }
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
-    { 
-      try
-        {
-          return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-            (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
-        } 
-      catch (...)
-        { return catcher_(); }
-    }
-
-  exception_catch_functor() {}
-  exception_catch_functor(const T_functor& _A_func,
-                          const T_catcher& _A_catcher)
-    : adapts<T_functor>(_A_func), catcher_(_A_catcher)
-    {}
-  ~exception_catch_functor() {}
-
-    T_catcher catcher_; 
-};
-
-template <class T_functor, class T_catcher>
-void exception_catch_functor<T_functor, T_catcher, void>::operator()()
-  { 
-    try
-      { this->functor_(); } // I don't understand why void return doesn't work here (Martin)
-    catch (...)
-      { this->catcher_(); }
-  }
-
-  
-//template specialization of visit_each<>(action, functor):
-template <class T_action, class T_functor, class T_catcher, class T_return>
-void visit_each(const T_action& _A_action,
-                const exception_catch_functor<T_functor, T_catcher, T_return>& _A_target)
-{
-  visit_each(_A_action, _A_target.functor_);
-  visit_each(_A_action, _A_target.catcher_);
-}
-
-
-template <class T_functor, class T_catcher>
-inline exception_catch_functor<T_functor, T_catcher>
-exception_catch(const T_functor& _A_func, const T_catcher& _A_catcher)
-  { return exception_catch_functor<T_functor, T_catcher>(_A_func, _A_catcher); }
-
-} /* namespace sigc */
-#endif /* _SIGC_ADAPTORS_MACROS_EXCEPTION_CATCHHM4_ */
Index: stardict-3.0.1/src/sigc++/adaptors/hide.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/hide.h
+++ /dev/null
@@ -1,1064 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-#ifndef _SIGC_ADAPTORS_MACROS_HIDEHM4_
-#define _SIGC_ADAPTORS_MACROS_HIDEHM4_
-#include <sigc++/adaptors/adaptor_trait.h>
-
-namespace sigc { 
-
-/** @defgroup hide hide(), hide_return()
- * sigc::hide() alters an arbitrary functor in that it adds a parameter
- * whose value is ignored on invocation of the returned functor.
- * Thus you can discard one or more of the arguments of a signal.
- *
- * You may optionally specify the zero-based position of the parameter
- * to ignore as a template argument. The default is to ignore the last
- * parameter.
- * (A value of @p -1 adds a parameter at the end so sigc::hide<-1>() gives the same result as sigc::hide().)
- *
- * The type of the parameter can optionally be specified if not deduced.
- *
- * @par Examples:
- *   @code
- *   void foo(int, int);
- *   // single argument hiding ...
- *   sigc::hide(&foo)(1,2,3);     // adds a dummy parameter at the back and calls foo(1,2)
- *   sigc::hide<-1>(&foo)(1,2,3); // same as sigc::hide(&foo)(1,2,3) (calls foo(1,2))
- *   sigc::hide<0>(&foo)(1,2,3);  // adds a dummy parameter at the beginning and calls foo(2,3)
- *   sigc::hide<1>(&foo)(1,2,3);  // adds a dummy parameter in the middle and calls foo(1,3)
- *   sigc::hide<2>(&foo)(1,2,3);  // adds a dummy parameter at the back and calls foo(1,2)
- *   // multiple argument hiding ...
- *   sigc::hide(sigc::hide(&foo))(1,2,3,4); // adds two dummy parameters at the back and calls foo(1,2)
- *   @endcode
- *
- * The functor sigc::hide() returns can be passed into
- * sigc::signal::connect() directly.
- *
- * @par Example:
- *   @code
- *   sigc::signal<void,int> some_signal;
- *   void foo();
- *   some_signal.connect(sigc::hide(&foo));
- *   @endcode
- *
- * sigc::hide_return() alters an arbitrary functor by
- * dropping its return value, thus converting it to a void functor.
- *
- * For a more powerful version of this functionality see the lambda
- * library adaptor sigc::group() which can bind, hide and reorder
- * arguments arbitrarily.  Although sigc::group() is more flexible,
- * sigc::hide() provides a means of hiding parameters when then total
- * number of parameters called is variable.
- *
- * @ingroup adaptors
- */
-
-/** Adaptor that adds a dummy parameter to the wrapped functor.
- * Use the convenience function sigc::hide() to create an instance of sigc::hide_functor.
- *
- * The following template arguments are used:
- * - @e I_location Zero-based position of the dummy parameter (@p -1 for the last parameter).
- * - @e T_type Type of the dummy parameter.
- * - @e T_functor Type of the functor to wrap.
- *
- * @ingroup hide
- */
-template <int I_location, class T_functor>
-struct hide_functor;
-
-/** Adaptor that adds a dummy parameter to the wrapped functor.
- * This template specialization ignores the value of the last parameter in operator()().
- *
- * @ingroup hide
- */
-template <class T_functor>
-struct hide_functor <-1, T_functor> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>::type type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor ignoring the only argument.
-   * @param _A_arg%1 Argument to be ignored.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator()(T_arg1)
-    { return this->functor_(); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround(T_arg1 _A_a1)
-    { return this->functor_(); }
-  #endif
-
-  /** Invokes the wrapped functor ignoring the last argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be ignored.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1 _A_a1, T_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-        (_A_a1); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-        (_A_a1); }
-  #endif
-
-  /** Invokes the wrapped functor ignoring the last argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be ignored.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2, T_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass>
-        (_A_a1, _A_a2); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2, T_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass>
-        (_A_a1, _A_a2); }
-  #endif
-
-  /** Invokes the wrapped functor ignoring the last argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be ignored.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3, T_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass>
-        (_A_a1, _A_a2, _A_a3); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3, T_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass>
-        (_A_a1, _A_a2, _A_a3); }
-  #endif
-
-  /** Invokes the wrapped functor ignoring the last argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be ignored.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4, T_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4, T_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4); }
-  #endif
-
-  /** Invokes the wrapped functor ignoring the last argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be ignored.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5, T_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a5); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5, T_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a5); }
-  #endif
-
-  /** Invokes the wrapped functor ignoring the last argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @param _A_arg7 Argument to be ignored.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6, T_arg7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6, T_arg7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6); }
-  #endif
-
-
-  /** Constructs a hide_functor object that adds a dummy parameter to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   */
-  explicit hide_functor(const T_functor& _A_func)
-    : adapts<T_functor>(_A_func)
-    {}
-};
-
-/** Adaptor that adds a dummy parameter to the wrapped functor.
- * This template specialization ignores the value of the 0th parameter in operator()().
- *
- * @ingroup hide
- */
-template <class T_functor>
-struct hide_functor <0, T_functor> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>::type type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor ignoring the only argument.
-   * @param _A_arg%1 Argument to be ignored.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator()(T_arg1)
-    { return this->functor_(); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround(T_arg1 _A_a1)
-    { return this->functor_(); }
-  #endif
-
-  /** Invokes the wrapped functor ignoring the 1th argument.
-   * @param _A_arg1 Argument to be ignored.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1, T_arg2 _A_a2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg2>::pass>
-        (_A_a2); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1, T_arg2 _A_a2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg2>::pass>
-        (_A_a2); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 1th argument.
-   * @param _A_arg1 Argument to be ignored.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass>
-        (_A_a2, _A_a3); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass>
-        (_A_a2, _A_a3); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 1th argument.
-   * @param _A_arg1 Argument to be ignored.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
-        (_A_a2, _A_a3, _A_a4); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
-        (_A_a2, _A_a3, _A_a4); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 1th argument.
-   * @param _A_arg1 Argument to be ignored.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (_A_a2, _A_a3, _A_a4, _A_a5); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (_A_a2, _A_a3, _A_a4, _A_a5); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 1th argument.
-   * @param _A_arg1 Argument to be ignored.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_a2, _A_a3, _A_a4, _A_a5, _A_a6); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_a2, _A_a3, _A_a4, _A_a5, _A_a6); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 1th argument.
-   * @param _A_arg1 Argument to be ignored.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @param _A_arg7 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator()(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>
-        (_A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>
-        (_A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7); }
-  #endif
-    
-
-  /** Constructs a hide_functor object that adds a dummy parameter to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   */
-  explicit hide_functor(const T_functor& _A_func)
-    : adapts<T_functor>(_A_func)
-    {}
-};
-
-/** Adaptor that adds a dummy parameter to the wrapped functor.
- * This template specialization ignores the value of the 1th parameter in operator()().
- *
- * @ingroup hide
- */
-template <class T_functor>
-struct hide_functor <1, T_functor> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>::type type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor ignoring the 2th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be ignored.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1 _A_a1, T_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-        (_A_a1); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-        (_A_a1); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 2th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be ignored.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass>
-        (_A_a1, _A_a3); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass>
-        (_A_a1, _A_a3); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 2th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be ignored.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3, T_arg4 _A_a4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
-        (_A_a1, _A_a3, _A_a4); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3, T_arg4 _A_a4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
-        (_A_a1, _A_a3, _A_a4); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 2th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be ignored.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (_A_a1, _A_a3, _A_a4, _A_a5); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (_A_a1, _A_a3, _A_a4, _A_a5); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 2th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be ignored.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_a1, _A_a3, _A_a4, _A_a5, _A_a6); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_a1, _A_a3, _A_a4, _A_a5, _A_a6); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 2th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be ignored.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @param _A_arg7 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator()(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>
-        (_A_a1, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>
-        (_A_a1, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7); }
-  #endif
-    
-
-  /** Constructs a hide_functor object that adds a dummy parameter to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   */
-  explicit hide_functor(const T_functor& _A_func)
-    : adapts<T_functor>(_A_func)
-    {}
-};
-
-/** Adaptor that adds a dummy parameter to the wrapped functor.
- * This template specialization ignores the value of the 2th parameter in operator()().
- *
- * @ingroup hide
- */
-template <class T_functor>
-struct hide_functor <2, T_functor> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>::type type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor ignoring the 3th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be ignored.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass>
-        (_A_a1, _A_a2); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass>
-        (_A_a1, _A_a2); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 3th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be ignored.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3, T_arg4 _A_a4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg4>::pass>
-        (_A_a1, _A_a2, _A_a4); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3, T_arg4 _A_a4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg4>::pass>
-        (_A_a1, _A_a2, _A_a4); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 3th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be ignored.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3, T_arg4 _A_a4, T_arg5 _A_a5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (_A_a1, _A_a2, _A_a4, _A_a5); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3, T_arg4 _A_a4, T_arg5 _A_a5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (_A_a1, _A_a2, _A_a4, _A_a5); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 3th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be ignored.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_a1, _A_a2, _A_a4, _A_a5, _A_a6); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_a1, _A_a2, _A_a4, _A_a5, _A_a6); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 3th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be ignored.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @param _A_arg7 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>
-        (_A_a1, _A_a2, _A_a4, _A_a5, _A_a6, _A_a7); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>
-        (_A_a1, _A_a2, _A_a4, _A_a5, _A_a6, _A_a7); }
-  #endif
-    
-
-  /** Constructs a hide_functor object that adds a dummy parameter to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   */
-  explicit hide_functor(const T_functor& _A_func)
-    : adapts<T_functor>(_A_func)
-    {}
-};
-
-/** Adaptor that adds a dummy parameter to the wrapped functor.
- * This template specialization ignores the value of the 3th parameter in operator()().
- *
- * @ingroup hide
- */
-template <class T_functor>
-struct hide_functor <3, T_functor> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>::type type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor ignoring the 4th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be ignored.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass>
-        (_A_a1, _A_a2, _A_a3); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass>
-        (_A_a1, _A_a2, _A_a3); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 4th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be ignored.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4, T_arg5 _A_a5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg5>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a5); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4, T_arg5 _A_a5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg5>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a5); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 4th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be ignored.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4, T_arg5 _A_a5, T_arg6 _A_a6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a5, _A_a6); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4, T_arg5 _A_a5, T_arg6 _A_a6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a5, _A_a6); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 4th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be ignored.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @param _A_arg7 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a5, _A_a6, _A_a7); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a5, _A_a6, _A_a7); }
-  #endif
-    
-
-  /** Constructs a hide_functor object that adds a dummy parameter to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   */
-  explicit hide_functor(const T_functor& _A_func)
-    : adapts<T_functor>(_A_func)
-    {}
-};
-
-/** Adaptor that adds a dummy parameter to the wrapped functor.
- * This template specialization ignores the value of the 4th parameter in operator()().
- *
- * @ingroup hide
- */
-template <class T_functor>
-struct hide_functor <4, T_functor> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>::type type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor ignoring the 5th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be ignored.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 5th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be ignored.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5, T_arg6 _A_a6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg6>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a6); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5, T_arg6 _A_a6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg6>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a6); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 5th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be ignored.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @param _A_arg7 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5, T_arg6 _A_a6, T_arg7 _A_a7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a6, _A_a7); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5, T_arg6 _A_a6, T_arg7 _A_a7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg6>::pass, typename type_trait<T_arg7>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a6, _A_a7); }
-  #endif
-    
-
-  /** Constructs a hide_functor object that adds a dummy parameter to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   */
-  explicit hide_functor(const T_functor& _A_func)
-    : adapts<T_functor>(_A_func)
-    {}
-};
-
-/** Adaptor that adds a dummy parameter to the wrapped functor.
- * This template specialization ignores the value of the 5th parameter in operator()().
- *
- * @ingroup hide
- */
-template <class T_functor>
-struct hide_functor <5, T_functor> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass, typename type_trait<T_arg7>::pass>::type type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor ignoring the 6th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be ignored.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a5); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a5); }
-  #endif
-    
-  /** Invokes the wrapped functor ignoring the 6th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be ignored.
-   * @param _A_arg7 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6, T_arg7 _A_a7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg7>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a7); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6, T_arg7 _A_a7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg7>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a7); }
-  #endif
-    
-
-  /** Constructs a hide_functor object that adds a dummy parameter to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   */
-  explicit hide_functor(const T_functor& _A_func)
-    : adapts<T_functor>(_A_func)
-    {}
-};
-
-/** Adaptor that adds a dummy parameter to the wrapped functor.
- * This template specialization ignores the value of the 6th parameter in operator()().
- *
- * @ingroup hide
- */
-template <class T_functor>
-struct hide_functor <6, T_functor> : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>::type type; };
-  typedef typename adaptor_type::result_type  result_type;
-
-  /** Invokes the wrapped functor ignoring the 7th argument.
-   * @param _A_arg1 Argument to be passed on to the functor.
-   * @param _A_arg2 Argument to be passed on to the functor.
-   * @param _A_arg3 Argument to be passed on to the functor.
-   * @param _A_arg4 Argument to be passed on to the functor.
-   * @param _A_arg5 Argument to be passed on to the functor.
-   * @param _A_arg6 Argument to be passed on to the functor.
-   * @param _A_arg7 Argument to be ignored.
-   * @return The return value of the functor invocation.
-   */
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>
-        (_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6); }
-  #endif
-    
-
-  /** Constructs a hide_functor object that adds a dummy parameter to the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   */
-  explicit hide_functor(const T_functor& _A_func)
-    : adapts<T_functor>(_A_func)
-    {}
-};
-
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::hide_functor performs a functor on the
- * functor stored in the sigc::hide_functor object.
- *
- * @ingroup hide
- */
-template <class T_action, int I_location, class T_functor>
-void visit_each(const T_action& _A_action,
-                const hide_functor<I_location, T_functor>& _A_target)
-{
-  visit_each(_A_action, _A_target.functor_);
-}
-
-
-/** Creates an adaptor of type sigc::hide_functor which adds a dummy parameter to the passed functor.
- * The optional template argument @e I_location specifies the zero-based
- * position of the dummy parameter in the returned functor (@p -1 stands for the last parameter).
- *
- * @param _A_func Functor that should be wrapped.
- * @return Adaptor that executes @e _A_func ignoring the value of the dummy parameter.
- *
- * @ingroup hide
- */
-template <int I_location, class T_functor>
-inline hide_functor<I_location, T_functor>
-hide(const T_functor& _A_func)
-  { return hide_functor<I_location, T_functor>(_A_func); }
-
-/** Creates an adaptor of type sigc::hide_functor which adds a dummy parameter to the passed functor.
- * This overload adds a dummy parameter at the back of the functor's parameter list.
- *
- * @param _A_func Functor that should be wrapped.
- * @return Adaptor that executes @e _A_func ignoring the value of the last parameter.
- *
- * @ingroup hide
- */
-template <class T_functor>
-inline hide_functor<-1, T_functor>
-hide(const T_functor& _A_func)
-  { return hide_functor<-1, T_functor> (_A_func); }
-
-} /* namespace sigc */
-#endif /* _SIGC_ADAPTORS_MACROS_HIDEHM4_ */
Index: stardict-3.0.1/src/sigc++/adaptors/lambda/base.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/lambda/base.h
+++ /dev/null
@@ -1,415 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-#ifndef _SIGC_LAMBDA_BASE_HPP_
-#define _SIGC_LAMBDA_BASE_HPP_
-#include <sigc++/adaptors/adaptor_trait.h>
-#include <sigc++/reference_wrapper.h>
-
-namespace sigc {
-
-/** @defgroup lambdas Lambdas
- * libsigc++ ships with basic lambda functionality and the sigc::group adaptor that uses lambdas to transform a functor's parameter list.
- *
- * The lambda selectors sigc::_1, sigc::_2, ..., sigc::_9 are used to select the
- * first, second, ..., nineth argument from a list.
- *
- * @par Examples:
- *   @code
- *   std::cout << sigc::_1(10,20,30); // returns 10
- *   std::cout << sigc::_2(10,20,30); // returns 20
- *   ...
- *   @endcode
- *
- * Operators are defined so that lambda selectors can be used e.g. as placeholders in
- * arithmetic expressions.
- *
- * @par Examples:
- *   @code
- *   std::cout << (sigc::_1 + 5)(3); // returns (3 + 5)
- *   std::cout << (sigc::_1 * sigc::_2)(7,10); // returns (7 * 10)
- *   @endcode
- */
-
-/** A hint to the compiler.
- * All lambda types publically inherit from this hint.
- *
- * @ingroup lambdas
- */
-struct lambda_base : public adaptor_base {};
-
-// Forward declaration of lambda.
-template <class T_type> struct lambda;
-
-
-namespace internal {
-
-/** Abstracts lambda functionality.
- * Objects of this type store a value that may be of type lambda itself.
- * In this case, operator()() executes the lambda (a lambda is always a functor at the same time).
- * Otherwise, operator()() simply returns the stored value.
- */
-template <class T_type, bool I_islambda = is_base_and_derived<lambda_base, T_type>::value> struct lambda_core;
-
-/// Abstracts lambda functionality (template specialization for lambda values).
-template <class T_type>
-struct lambda_core<T_type, true> : public lambda_base
-{
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename T_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type type; };
-  typedef typename T_type::result_type result_type;
-  typedef T_type lambda_type;
-
-  result_type
-  operator()() const;
-
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator ()(T_arg1 _A_1) const 
-    { return value_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-             (_A_1); 
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround(T_arg1 _A_1) const
-    { return value_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-             (_A_1); 
-    }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2) const 
-    { return value_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-             (_A_1,_A_2); 
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2) const
-    { return value_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-             (_A_1,_A_2); 
-    }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const 
-    { return value_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-             (_A_1,_A_2,_A_3); 
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
-    { return value_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-             (_A_1,_A_2,_A_3); 
-    }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const 
-    { return value_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-             (_A_1,_A_2,_A_3,_A_4); 
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
-    { return value_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-             (_A_1,_A_2,_A_3,_A_4); 
-    }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const 
-    { return value_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-             (_A_1,_A_2,_A_3,_A_4,_A_5); 
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
-    { return value_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-             (_A_1,_A_2,_A_3,_A_4,_A_5); 
-    }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const 
-    { return value_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-             (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6); 
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
-    { return value_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-             (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6); 
-    }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const 
-    { return value_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-             (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7); 
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
-    { return value_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-             (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7); 
-    }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  lambda_core() {}
-
-  explicit lambda_core(const T_type& v)
-    : value_(v) {}
-
-  T_type value_;
-};
-
-template <class T_type>
-typename lambda_core<T_type, true>::result_type
-lambda_core<T_type, true>::operator()() const
-  { return value_(); }
-
-
-/// Abstracts lambda functionality (template specialization for other value types).
-template <class T_type>
-struct lambda_core<T_type, false> : public lambda_base
-{
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef T_type type; };
-  typedef T_type result_type; // all operator() overloads return T_type.
-  typedef lambda<T_type> lambda_type;
-
-  result_type operator()() const;
-
-  template <class T_arg1>
-  result_type operator ()(T_arg1) const 
-    { return value_; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  result_type sun_forte_workaround(T_arg1) const
-    { return value_; }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2>
-  result_type operator ()(T_arg1,T_arg2) const 
-    { return value_; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  result_type sun_forte_workaround(T_arg1,T_arg2) const
-    { return value_; }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3>
-  result_type operator ()(T_arg1,T_arg2,T_arg3) const 
-    { return value_; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  result_type sun_forte_workaround(T_arg1,T_arg2,T_arg3) const
-    { return value_; }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  result_type operator ()(T_arg1,T_arg2,T_arg3,T_arg4) const 
-    { return value_; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  result_type sun_forte_workaround(T_arg1,T_arg2,T_arg3,T_arg4) const
-    { return value_; }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  result_type operator ()(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const 
-    { return value_; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  result_type sun_forte_workaround(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const
-    { return value_; }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  result_type operator ()(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const 
-    { return value_; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  result_type sun_forte_workaround(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const
-    { return value_; }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  result_type operator ()(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const 
-    { return value_; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  result_type sun_forte_workaround(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const
-    { return value_; }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  explicit lambda_core(typename type_trait<T_type>::take v)
-    : value_(v) {}
-
-  T_type value_;
-};
-
-template <class T_type>
-typename lambda_core<T_type, false>::result_type lambda_core<T_type, false>::operator()() const
-  { return value_; }
-
-} /* namespace internal */
-
-
-//template specialization of visit_each<>(action, functor):
-template <class T_action, class T_functor, bool I_islambda>
-void visit_each(const T_action& _A_action,
-                const internal::lambda_core<T_functor, I_islambda>& _A_target)
-{
-  visit_each(_A_action, _A_target.value_);
-}
-
-
-// forward declarations for lambda operators other<subscript> and other<assign>
-template <class T_type>
-struct other;
-struct subscript;
-struct assign;
-
-template <class T_action, class T_type1, class T_type2>
-struct lambda_operator;
-
-template <class T_type>
-struct unwrap_lambda_type;
-
-
-/** Lambda type.
- * Objects of this type store a value that may be of type lambda itself.
- * In this case, operator()() executes the lambda (a lambda is always a functor at the same time).
- * Otherwise, operator()() simply returns the stored value.
- * The assign and subscript operators are defined to return a lambda operator.
- *
- * @ingroup lambdas
- */
-template <class T_type>
-struct lambda : public internal::lambda_core<T_type>
-{
-  typedef lambda<T_type> self;
-
-  lambda()
-    {}
-
-  lambda(typename type_trait<T_type>::take v)
-    : internal::lambda_core<T_type>(v) 
-    {}
-
-  // operators for other<subscript>
-  template <class T_arg>
-  lambda<lambda_operator<other<subscript>, self, typename unwrap_lambda_type<T_arg>::type> >
-  operator [] (const T_arg& a) const
-    { typedef lambda_operator<other<subscript>, self, typename unwrap_lambda_type<T_arg>::type> lambda_operator_type;
-      return lambda<lambda_operator_type>(lambda_operator_type(this->value_, unwrap_lambda_value(a))); }
-
-  // operators for other<assign>
-  template <class T_arg>
-  lambda<lambda_operator<other<assign>, self, typename unwrap_lambda_type<T_arg>::type> >
-  operator = (const T_arg& a) const
-    { typedef lambda_operator<other<assign>, self, typename unwrap_lambda_type<T_arg>::type> lambda_operator_type;
-      return lambda<lambda_operator_type>(lambda_operator_type(this->value_, unwrap_lambda_value(a))); }
-};
-
-
-//template specialization of visit_each<>(action, functor):
-template <class T_action, class T_type>
-void visit_each(const T_action& _A_action,
-                const lambda<T_type>& _A_target)
-{
-  visit_each(_A_action, _A_target.value_);
-}
-
-
-/** Converts a reference into a lambda object.
- * sigc::var creates a 0-ary functor, returning the value of a referenced variable. 
- *
- * @par Example:
- *   @code
- *   int main(int argc, char* argv)
- *   {
- *     int data;
- *     sigc::signal<int> readValue;
- *
- *     readValue.connect(sigc::var(data));
- *
- *     data = 3;
- *     std::cout << readValue() << std::endl; //Prints 3.
- *
- *    data = 5;
- *    std::cout << readValue() << std::endl; //Prints 5.
- *   }
- *   @endcode
- */
-template <class T_type>
-lambda<T_type&> var(T_type& v)
-{ return lambda<T_type&>(v); }
-
-/** Converts a constant reference into a lambda object.
- */
-template <class T_type>
-lambda<const T_type&> var(const T_type& v)
-{ return lambda<const T_type&>(v); }
-
-
-/** Deduces the type of the object stored in an object of the passed lambda type.
- * If the type passed as template argument is no lambda type,
- * type is defined to unwrap_reference<T_type>::type.
- */
-template <class T_type>
-struct unwrap_lambda_type
-{ typedef typename unwrap_reference<T_type>::type type; };
-
-template <class T_type>
-struct unwrap_lambda_type<lambda<T_type> >
-{ typedef T_type type; };
-
-
-/** Gets the object stored inside a lambda object.
- * Returns the object passed as argument if it is not of type lambda.
- */
-template <class T_type>
-T_type& unwrap_lambda_value(T_type& a)
-{ return a; }
-
-template <class T_type>
-const T_type& unwrap_lambda_value(const T_type& a)
-{ return a; }
-
-template <class T_type>
-const T_type& unwrap_lambda_value(const lambda<T_type>& a)
-{ return a.value_; }
-
-} /* namespace sigc */
-
-#endif /* _SIGC_LAMBDA_BASE_HPP_ */
Index: stardict-3.0.1/src/sigc++/adaptors/lambda/group.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/lambda/group.h
+++ /dev/null
@@ -1,737 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-#ifndef _SIGC_ADAPTORS_LAMBDA_MACROS_GROUPHM4_
-#define _SIGC_ADAPTORS_LAMBDA_MACROS_GROUPHM4_
-#include <sigc++/adaptors/lambda/base.h>
-
-/** @defgroup group_ group()
- * sigc::group() alters an arbitrary functor by rebuilding its arguments from one or more lambda expressions.
- * For each parameter that should be passed to the wrapped functor one lambda expression
- * has to be passed into group(). Lambda selectors can be used as placeholders for the
- * arguments passed into the new functor. Arguments that don't have a placeholder in one
- * of the lambda expressions are dropped.
- *
- * @par Examples:
- *   @code
- *   void foo(int, int);
- *   int bar(int);
- *   // argument binding ...
- *   sigc::group(&foo,10,sigc::_1)(20); //fixes the first argument and calls foo(10,20)
- *   sigc::group(&foo,sigc::_1,30)(40); //fixes the second argument and calls foo(40,30)
- *   // argument reordering ...
- *   sigc::group(&foo,sigc::_2,sigc::_1)(1,2); //calls foo(2,1)
- *   // argument hiding ...
- *   sigc::group(&foo,sigc::_1,sigc::_2)(1,2,3); //calls foo(1,2)
- *   // functor composition ...
- *   sigc::group(&foo,sigc::_1,sigc::group(&bar,sigc::_2))(1,2); //calls foo(1,bar(2))
- *   // algebraic expressions ...
- *   sigc::group(&foo,sigc::_1*sigc::_2,sigc::_1/sigc::_2)(6,3); //calls foo(6*3,6/3)
- *   @endcode
- *
- * The functor sigc::group() returns can be passed into
- * sigc::signal::connect() directly.
- *
- * @par Example:
- *   @code
- *   sigc::signal<void,int,int> some_signal;
- *   void foo(int);
- *   some_signal.connect(sigc::group(&foo,sigc::_2));
- *   @endcode
- *
- * Like in sigc::bind() you can bind references to functors by passing the objects
- * through the sigc::ref() helper function.
- *
- * @par Example:
- *   @code
- *   int some_int;
- *   sigc::signal<void> some_signal;
- *   void foo(int&);
- *   some_signal.connect(sigc::group(&foo,sigc::ref(some_int)));
- *   @endcode
- *
- * If you bind an object of a sigc::trackable derived type to a functor
- * by reference, a slot assigned to the group adaptor is cleared automatically
- * when the object goes out of scope.
- *
- * @par Example:
- *   @code
- *   struct bar : public sigc::trackable {} some_bar;
- *   sigc::signal<void> some_signal;
- *   void foo(bar&);
- *   some_signal.connect(sigc::group(&foo,sigc::ref(some_bar)));
- *     // disconnected automatically if some_bar goes out of scope
- *   @endcode
- *
- * @ingroup adaptors, lambdas
- */
-
-namespace sigc {
-
-template <class T_functor, class T_type1>
-struct lambda_group1 : public lambda_base
-{
-  typedef typename functor_trait<T_functor>::result_type result_type;
-  typedef typename lambda<T_type1>::lambda_type   value1_type;
-  typedef typename adaptor_trait<T_functor>::adaptor_type functor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename functor_type::template deduce_result_type<
-          typename value1_type::template deduce_result_type<
-            typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type
-        >::type type; };
-
-  result_type
-  operator ()() const;
-
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator() (T_arg1 _A_1) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass>(_A_1)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround (T_arg1 _A_1) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass>(_A_1)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  lambda_group1(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_1)
-    : value1_(_A_1), func_(_A_func) {}
-
-  value1_type value1_;
-  mutable functor_type func_;
-};
-
-template <class T_functor, class T_type1>
-typename lambda_group1<T_functor, T_type1>::result_type
-lambda_group1<T_functor, T_type1>::operator ()() const
-  { return func_(value1_()); }
-
-
-//template specialization of visit_each<>(action, functor):
-template <class T_action, class T_functor, class T_type1>
-void visit_each(const T_action& _A_action,
-                const lambda_group1<T_functor, T_type1>& _A_target)
-{
-  visit_each(_A_action, _A_target.value1_);
-  visit_each(_A_action, _A_target.func_);
-}
-
-
-template <class T_functor, class T_type1,class T_type2>
-struct lambda_group2 : public lambda_base
-{
-  typedef typename functor_trait<T_functor>::result_type result_type;
-  typedef typename lambda<T_type1>::lambda_type   value1_type;
-  typedef typename lambda<T_type2>::lambda_type   value2_type;
-  typedef typename adaptor_trait<T_functor>::adaptor_type functor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename functor_type::template deduce_result_type<
-          typename value1_type::template deduce_result_type<
-            typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type,
-          typename value2_type::template deduce_result_type<
-            typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type
-        >::type type; };
-
-  result_type
-  operator ()() const;
-
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator() (T_arg1 _A_1) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1>::type,
-          typename value2_type::template deduce_result_type<T_arg1>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass>(_A_1),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass>(_A_1)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround (T_arg1 _A_1) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1>::type,
-          typename value2_type::template deduce_result_type<T_arg1>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass>(_A_1),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass>(_A_1)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  lambda_group2(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_1,typename type_trait<T_type2>::take _A_2)
-    : value1_(_A_1),value2_(_A_2), func_(_A_func) {}
-
-  value1_type value1_;
-  value2_type value2_;
-  mutable functor_type func_;
-};
-
-template <class T_functor, class T_type1,class T_type2>
-typename lambda_group2<T_functor, T_type1,T_type2>::result_type
-lambda_group2<T_functor, T_type1,T_type2>::operator ()() const
-  { return func_(value1_(),value2_()); }
-
-
-//template specialization of visit_each<>(action, functor):
-template <class T_action, class T_functor, class T_type1,class T_type2>
-void visit_each(const T_action& _A_action,
-                const lambda_group2<T_functor, T_type1,T_type2>& _A_target)
-{
-  visit_each(_A_action, _A_target.value1_);
-  visit_each(_A_action, _A_target.value2_);
-  visit_each(_A_action, _A_target.func_);
-}
-
-
-template <class T_functor, class T_type1,class T_type2,class T_type3>
-struct lambda_group3 : public lambda_base
-{
-  typedef typename functor_trait<T_functor>::result_type result_type;
-  typedef typename lambda<T_type1>::lambda_type   value1_type;
-  typedef typename lambda<T_type2>::lambda_type   value2_type;
-  typedef typename lambda<T_type3>::lambda_type   value3_type;
-  typedef typename adaptor_trait<T_functor>::adaptor_type functor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename functor_type::template deduce_result_type<
-          typename value1_type::template deduce_result_type<
-            typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type,
-          typename value2_type::template deduce_result_type<
-            typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type,
-          typename value3_type::template deduce_result_type<
-            typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type
-        >::type type; };
-
-  result_type
-  operator ()() const;
-
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator() (T_arg1 _A_1) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1>::type,
-          typename value2_type::template deduce_result_type<T_arg1>::type,
-          typename value3_type::template deduce_result_type<T_arg1>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass>(_A_1),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass>(_A_1),
-        this->value3_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass>(_A_1)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround (T_arg1 _A_1) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1>::type,
-          typename value2_type::template deduce_result_type<T_arg1>::type,
-          typename value3_type::template deduce_result_type<T_arg1>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass>(_A_1),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass>(_A_1),
-        this->value3_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass>(_A_1)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2>::type,
-          typename value3_type::template deduce_result_type<T_arg1,T_arg2>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2),
-        this->value3_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2>::type,
-          typename value3_type::template deduce_result_type<T_arg1,T_arg2>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2),
-        this->value3_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>(_A_1,_A_2)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type,
-          typename value3_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3),
-        this->value3_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type,
-          typename value3_type::template deduce_result_type<T_arg1,T_arg2,T_arg3>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3),
-        this->value3_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>(_A_1,_A_2,_A_3)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type,
-          typename value3_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4),
-        this->value3_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type,
-          typename value3_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4),
-        this->value3_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>(_A_1,_A_2,_A_3,_A_4)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type,
-          typename value3_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5),
-        this->value3_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type,
-          typename value3_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5),
-        this->value3_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type,
-          typename value3_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6),
-        this->value3_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type,
-          typename value3_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6),
-        this->value3_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator() (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type,
-          typename value3_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7),
-        this->value3_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7)); }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround (T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
-    { return this->func_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename value1_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type,
-          typename value2_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type,
-          typename value3_type::template deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type>(
-        this->value1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7),
-        this->value2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7),
-        this->value3_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<
-          typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>(_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7)); }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  lambda_group3(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_1,typename type_trait<T_type2>::take _A_2,typename type_trait<T_type3>::take _A_3)
-    : value1_(_A_1),value2_(_A_2),value3_(_A_3), func_(_A_func) {}
-
-  value1_type value1_;
-  value2_type value2_;
-  value3_type value3_;
-  mutable functor_type func_;
-};
-
-template <class T_functor, class T_type1,class T_type2,class T_type3>
-typename lambda_group3<T_functor, T_type1,T_type2,T_type3>::result_type
-lambda_group3<T_functor, T_type1,T_type2,T_type3>::operator ()() const
-  { return func_(value1_(),value2_(),value3_()); }
-
-
-//template specialization of visit_each<>(action, functor):
-template <class T_action, class T_functor, class T_type1,class T_type2,class T_type3>
-void visit_each(const T_action& _A_action,
-                const lambda_group3<T_functor, T_type1,T_type2,T_type3>& _A_target)
-{
-  visit_each(_A_action, _A_target.value1_);
-  visit_each(_A_action, _A_target.value2_);
-  visit_each(_A_action, _A_target.value3_);
-  visit_each(_A_action, _A_target.func_);
-}
-
-
-
-template <class T_functor, class T_type1>
-lambda<lambda_group1<T_functor, typename unwrap_reference<T_type1>::type> >
-group(const T_functor& _A_func, T_type1 _A_1)
-{
-  typedef lambda_group1<T_functor, typename unwrap_reference<T_type1>::type> T_lambda;
-  return lambda<T_lambda>(T_lambda(_A_func, _A_1));
-}
-
-template <class T_functor, class T_type1,class T_type2>
-lambda<lambda_group2<T_functor, typename unwrap_reference<T_type1>::type,typename unwrap_reference<T_type2>::type> >
-group(const T_functor& _A_func, T_type1 _A_1,T_type2 _A_2)
-{
-  typedef lambda_group2<T_functor, typename unwrap_reference<T_type1>::type,typename unwrap_reference<T_type2>::type> T_lambda;
-  return lambda<T_lambda>(T_lambda(_A_func, _A_1,_A_2));
-}
-
-template <class T_functor, class T_type1,class T_type2,class T_type3>
-lambda<lambda_group3<T_functor, typename unwrap_reference<T_type1>::type,typename unwrap_reference<T_type2>::type,typename unwrap_reference<T_type3>::type> >
-group(const T_functor& _A_func, T_type1 _A_1,T_type2 _A_2,T_type3 _A_3)
-{
-  typedef lambda_group3<T_functor, typename unwrap_reference<T_type1>::type,typename unwrap_reference<T_type2>::type,typename unwrap_reference<T_type3>::type> T_lambda;
-  return lambda<T_lambda>(T_lambda(_A_func, _A_1,_A_2,_A_3));
-}
-
-
-
-} /* namespace sigc */
-#endif /* _SIGC_ADAPTORS_LAMBDA_MACROS_GROUPHM4_ */
Index: stardict-3.0.1/src/sigc++/adaptors/lambda/lambda.cc
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/lambda/lambda.cc
+++ /dev/null
@@ -1,15 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-#include <sigc++/adaptors/lambda/select.h>
-
-namespace sigc {
-
-const lambda<internal::lambda_select1> _1;
-const lambda<internal::lambda_select2> _2;
-const lambda<internal::lambda_select3> _3;
-const lambda<internal::lambda_select4> _4;
-const lambda<internal::lambda_select5> _5;
-const lambda<internal::lambda_select6> _6;
-const lambda<internal::lambda_select7> _7;
-
-} /* namespace sigc */
Index: stardict-3.0.1/src/sigc++/adaptors/lambda/lambda.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/lambda/lambda.h
+++ /dev/null
@@ -1,28 +0,0 @@
-// -*- c++ -*-
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#ifndef _SIGC_LAMBDA_HPP_
-#define _SIGC_LAMBDA_HPP_
-
-#include <sigc++/adaptors/lambda/base.h>
-#include <sigc++/adaptors/lambda/select.h>
-#include <sigc++/adaptors/lambda/operator.h>
-#include <sigc++/adaptors/lambda/group.h>
-
-#endif /* _SIGC_LAMBDA_HPP_ */
Index: stardict-3.0.1/src/sigc++/adaptors/lambda/operator.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/lambda/operator.h
+++ /dev/null
@@ -1,1700 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-#ifndef _SIGC_LAMBDA_OPERATOR_HPP_
-#define _SIGC_LAMBDA_OPERATOR_HPP_
-#include <sigc++/adaptors/lambda/base.h>
-
-namespace sigc {
-
-/** Deduces the base type of a reference or a pointer.
- * @ingroup internal
- */
-template <class T_type>
-struct dereference_trait
-  { typedef void type; };
-
-template <class T_type>
-struct dereference_trait<T_type*>
-  { typedef T_type type; };
-
-template <class T_type>
-struct dereference_trait<const T_type*>
-  { typedef const T_type type; };
-
-template <class T_type>
-struct dereference_trait<T_type*&>
-  { typedef T_type type; };
-
-template <class T_type>
-struct dereference_trait<const T_type*&>
-  { typedef const T_type type; };
-
-template <class T_type>
-struct dereference_trait<T_type* const&>
-  { typedef T_type type; };
-
-template <class T_type>
-struct dereference_trait<const T_type* const&>
-  { typedef const T_type type; };
-
-template <class T_type>
-struct arithmetic {};
-
-template <class T_type>
-struct bitwise {};
-
-template <class T_type>
-struct logical {};
-
-template <class T_type>
-struct relational {};
-
-template <class T_type>
-struct arithmetic_assign {};
-
-template <class T_type>
-struct bitwise_assign {};
-
-template <class T_type>
-struct other {};
-
-template <class T_type>
-struct unary_arithmetic {};
-
-template <class T_type>
-struct unary_bitwise {};
-
-template <class T_type>
-struct unary_logical {};
-
-template <class T_type>
-struct unary_other {};
-
-template <class T_type>
-struct cast_ {};
-
-struct plus {};
-struct minus {};
-struct multiplies {};
-struct divides {};
-struct modulus {};
-struct leftshift {};
-struct rightshift {};
-struct and_ {};
-struct or_ {};
-struct xor_ {};
-struct less {};
-struct greater {};
-struct less_equal {};
-struct greater_equal {};
-struct equal_to {};
-struct not_equal_to {};
-struct subscript {};
-struct assign {};
-struct pre_increment {};
-struct pre_decrement {};
-struct negate {};
-struct not_ {};
-struct address {};
-struct dereference {};
-struct reinterpret_ {};
-struct static_ {};
-struct dynamic_ {};
-
-template <class T_action, class T_test1, class T_test2>
-struct lambda_action_deduce_result_type
-  { typedef typename type_trait<T_test1>::type type; }; // TODO: e.g. T_test1=int, T_test2=double yields int but it should yield double !
-
-template <class T_action, class T_test1, class T_test2>
-struct lambda_action_deduce_result_type<logical<T_action>, T_test1, T_test2>
-  { typedef bool type; };
-
-template <class T_action, class T_test1, class T_test2>
-struct lambda_action_deduce_result_type<relational<T_action>, T_test1, T_test2>
-  { typedef bool type; };
-
-template <class T_action, class T_test1, class T_test2>
-struct lambda_action_deduce_result_type<arithmetic_assign<T_action>, T_test1, T_test2>
-  { typedef T_test1 type; };
-
-template <class T_action, class T_test1, class T_test2>
-struct lambda_action_deduce_result_type<bitwise_assign<T_action>, T_test1, T_test2>
-  { typedef T_test1 type; };
-
-template <class T_test1, class T_test2>
-struct lambda_action_deduce_result_type<other<subscript>, T_test1, T_test2>
-  { typedef typename type_trait<typename dereference_trait<T_test1>::type>::pass type; };
-
-template <class T_action, class T_test>
-struct lambda_action_unary_deduce_result_type
-  { typedef typename type_trait<T_test>::type type; };
-
-template <class T_action, class T_type, class T_test>
-struct lambda_action_convert_deduce_result_type
-  { typedef typename type_trait<T_type>::type type; };
-
-template <class T_action, class T_test>
-struct lambda_action_unary_deduce_result_type<unary_logical<T_action>, T_test>
-  { typedef bool type; };
-
-template <class T_test>
-struct lambda_action_unary_deduce_result_type<unary_other<address>, T_test>
-  { typedef typename type_trait<T_test>::pointer type; };
-
-template <class T_test>
-struct lambda_action_unary_deduce_result_type<unary_other<dereference>, T_test>
-  { typedef typename type_trait<typename dereference_trait<T_test>::type>::pass type; };
-
-
-
-template <class T_action>
-struct lambda_action {};
-
-template <class T_action>
-struct lambda_action_unary {};
-
-template <class T_action, class T_type>
-struct lambda_action_convert {};
-
-template <>
-struct lambda_action<arithmetic<plus> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<arithmetic<plus>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 + _A_2; }
-};
-
-template <>
-struct lambda_action<arithmetic<minus> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<arithmetic<minus>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 - _A_2; }
-};
-
-template <>
-struct lambda_action<arithmetic<multiplies> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<arithmetic<multiplies>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 * _A_2; }
-};
-
-template <>
-struct lambda_action<arithmetic<divides> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<arithmetic<divides>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 / _A_2; }
-};
-
-template <>
-struct lambda_action<arithmetic<modulus> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<arithmetic<modulus>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 % _A_2; }
-};
-
-template <>
-struct lambda_action<bitwise<leftshift> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<bitwise<leftshift>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 << _A_2; }
-};
-
-template <>
-struct lambda_action<bitwise<rightshift> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<bitwise<rightshift>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 >> _A_2; }
-};
-
-template <>
-struct lambda_action<bitwise<and_> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<bitwise<and_>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 & _A_2; }
-};
-
-template <>
-struct lambda_action<bitwise<or_> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<bitwise<or_>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 | _A_2; }
-};
-
-template <>
-struct lambda_action<bitwise<xor_> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<bitwise<xor_>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 ^ _A_2; }
-};
-
-template <>
-struct lambda_action<logical<and_> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<logical<and_>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 && _A_2; }
-};
-
-template <>
-struct lambda_action<logical<or_> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<logical<or_>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 || _A_2; }
-};
-
-template <>
-struct lambda_action<relational<less> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<relational<less>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 < _A_2; }
-};
-
-template <>
-struct lambda_action<relational<greater> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<relational<greater>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 > _A_2; }
-};
-
-template <>
-struct lambda_action<relational<less_equal> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<relational<less_equal>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 <= _A_2; }
-};
-
-template <>
-struct lambda_action<relational<greater_equal> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<relational<greater_equal>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 >= _A_2; }
-};
-
-template <>
-struct lambda_action<relational<equal_to> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<relational<equal_to>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 == _A_2; }
-};
-
-template <>
-struct lambda_action<relational<not_equal_to> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<relational<not_equal_to>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 != _A_2; }
-};
-
-template <>
-struct lambda_action<arithmetic_assign<plus> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<arithmetic_assign<plus>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 += _A_2; }
-};
-
-template <>
-struct lambda_action<arithmetic_assign<minus> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<arithmetic_assign<minus>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 -= _A_2; }
-};
-
-template <>
-struct lambda_action<arithmetic_assign<multiplies> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<arithmetic_assign<multiplies>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 *= _A_2; }
-};
-
-template <>
-struct lambda_action<arithmetic_assign<divides> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<arithmetic_assign<divides>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 /= _A_2; }
-};
-
-template <>
-struct lambda_action<arithmetic_assign<modulus> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<arithmetic_assign<modulus>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 %= _A_2; }
-};
-
-template <>
-struct lambda_action<bitwise_assign<leftshift> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<bitwise_assign<leftshift>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 <<= _A_2; }
-};
-
-template <>
-struct lambda_action<bitwise_assign<rightshift> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<bitwise_assign<rightshift>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 >>= _A_2; }
-};
-
-template <>
-struct lambda_action<bitwise_assign<and_> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<bitwise_assign<and_>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 &= _A_2; }
-};
-
-template <>
-struct lambda_action<bitwise_assign<or_> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<bitwise_assign<or_>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 |= _A_2; }
-};
-
-template <>
-struct lambda_action<bitwise_assign<xor_> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<bitwise_assign<xor_>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 ^= _A_2; }
-};
-
-template <>
-struct lambda_action<other<subscript> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<other<subscript>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1[_A_2]; }
-};
-
-template <>
-struct lambda_action<other<assign> >
-{
-  template <class T_arg1, class T_arg2>
-  static typename lambda_action_deduce_result_type<other<assign>, T_arg1, T_arg2>::type
-  do_action(T_arg1 _A_1, T_arg2 _A_2)
-    { return _A_1 = _A_2; }
-};
-
-template <>
-struct lambda_action_unary<unary_arithmetic<pre_increment> >
-{
-  template <class T_arg>
-  static typename lambda_action_unary_deduce_result_type<unary_arithmetic<pre_increment>, T_arg>::type
-  do_action(T_arg _Aa)
-    { return ++_Aa; }
-};
-
-template <>
-struct lambda_action_unary<unary_arithmetic<pre_decrement> >
-{
-  template <class T_arg>
-  static typename lambda_action_unary_deduce_result_type<unary_arithmetic<pre_decrement>, T_arg>::type
-  do_action(T_arg _Aa)
-    { return --_Aa; }
-};
-
-template <>
-struct lambda_action_unary<unary_arithmetic<negate> >
-{
-  template <class T_arg>
-  static typename lambda_action_unary_deduce_result_type<unary_arithmetic<negate>, T_arg>::type
-  do_action(T_arg _Aa)
-    { return -_Aa; }
-};
-
-template <>
-struct lambda_action_unary<unary_bitwise<not_> >
-{
-  template <class T_arg>
-  static typename lambda_action_unary_deduce_result_type<unary_bitwise<not_>, T_arg>::type
-  do_action(T_arg _Aa)
-    { return ~_Aa; }
-};
-
-template <>
-struct lambda_action_unary<unary_logical<not_> >
-{
-  template <class T_arg>
-  static typename lambda_action_unary_deduce_result_type<unary_logical<not_>, T_arg>::type
-  do_action(T_arg _Aa)
-    { return !_Aa; }
-};
-
-template <>
-struct lambda_action_unary<unary_other<address> >
-{
-  template <class T_arg>
-  static typename lambda_action_unary_deduce_result_type<unary_other<address>, T_arg>::type
-  do_action(T_arg _Aa)
-    { return &_Aa; }
-};
-
-template <>
-struct lambda_action_unary<unary_other<dereference> >
-{
-  template <class T_arg>
-  static typename lambda_action_unary_deduce_result_type<unary_other<dereference>, T_arg>::type
-  do_action(T_arg _Aa)
-    { return *_Aa; }
-};
-
-template <class T_type>
-struct lambda_action_convert<cast_<reinterpret_>, T_type>
-{
-  template <class T_arg>
-  static typename lambda_action_convert_deduce_result_type<cast_<reinterpret_>, T_type, T_arg>::type
-  do_action(T_arg _Aa)
-    { return reinterpret_cast<T_type>(_Aa); }
-};
-
-template <class T_type>
-struct lambda_action_convert<cast_<static_>, T_type>
-{
-  template <class T_arg>
-  static typename lambda_action_convert_deduce_result_type<cast_<static_>, T_type, T_arg>::type
-  do_action(T_arg _Aa)
-    { return static_cast<T_type>(_Aa); }
-};
-
-template <class T_type>
-struct lambda_action_convert<cast_<dynamic_>, T_type>
-{
-  template <class T_arg>
-  static typename lambda_action_convert_deduce_result_type<cast_<dynamic_>, T_type, T_arg>::type
-  do_action(T_arg _Aa)
-    { return dynamic_cast<T_type>(_Aa); }
-};
-
-
-
-template <class T_action, class T_type1, class T_type2>
-struct lambda_operator : public lambda_base
-{
-  typedef typename lambda<T_type1>::lambda_type arg1_type;
-  typedef typename lambda<T_type2>::lambda_type arg2_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename arg1_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type left_type;
-      typedef typename arg2_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type right_type;
-      typedef typename lambda_action_deduce_result_type<T_action, left_type, right_type>::type type;
-    };
-  typedef typename lambda_action_deduce_result_type<
-      T_action,
-      typename arg1_type::result_type,
-      typename arg2_type::result_type
-    >::type result_type;
-
-  result_type
-  operator ()() const;
-
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator ()(T_arg1 _A_1) const
-    {
-      return lambda_action<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass>::left_type,
-            typename deduce_result_type<typename type_trait<T_arg1>::pass>::right_type>
-        (arg1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-            (_A_1),
-         arg2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-            (_A_1));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround(T_arg1 _A_1) const
-    {
-      return lambda_action<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass>::left_type,
-            typename deduce_result_type<typename type_trait<T_arg1>::pass>::right_type>
-        (arg1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-            (_A_1),
-         arg2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-            (_A_1));
-    }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2) const
-    {
-      return lambda_action<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>::left_type,
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>::right_type>
-        (arg1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-            (_A_1,_A_2),
-         arg2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-            (_A_1,_A_2));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2) const
-    {
-      return lambda_action<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>::left_type,
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>::right_type>
-        (arg1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-            (_A_1,_A_2),
-         arg2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-            (_A_1,_A_2));
-    }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
-    {
-      return lambda_action<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>::left_type,
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>::right_type>
-        (arg1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-            (_A_1,_A_2,_A_3),
-         arg2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-            (_A_1,_A_2,_A_3));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
-    {
-      return lambda_action<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>::left_type,
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>::right_type>
-        (arg1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-            (_A_1,_A_2,_A_3),
-         arg2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-            (_A_1,_A_2,_A_3));
-    }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
-    {
-      return lambda_action<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>::left_type,
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>::right_type>
-        (arg1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-            (_A_1,_A_2,_A_3,_A_4),
-         arg2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-            (_A_1,_A_2,_A_3,_A_4));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
-    {
-      return lambda_action<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>::left_type,
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>::right_type>
-        (arg1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-            (_A_1,_A_2,_A_3,_A_4),
-         arg2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-            (_A_1,_A_2,_A_3,_A_4));
-    }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
-    {
-      return lambda_action<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>::left_type,
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>::right_type>
-        (arg1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5),
-         arg2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
-    {
-      return lambda_action<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>::left_type,
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>::right_type>
-        (arg1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5),
-         arg2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5));
-    }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
-    {
-      return lambda_action<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>::left_type,
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>::right_type>
-        (arg1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6),
-         arg2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
-    {
-      return lambda_action<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>::left_type,
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>::right_type>
-        (arg1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6),
-         arg2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6));
-    }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
-    {
-      return lambda_action<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::left_type,
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::right_type>
-        (arg1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7),
-         arg2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
-    {
-      return lambda_action<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::left_type,
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::right_type>
-        (arg1_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7),
-         arg2_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7));
-    }
-  #endif //SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-
-  lambda_operator(typename type_trait<T_type1>::take a1, typename type_trait<T_type2>::take a2 )
-    : arg1_(a1), arg2_(a2) {}
-
-  arg1_type arg1_;
-  arg2_type arg2_;
-};
-
-template <class T_action, class T_type1, class T_type2>
-typename lambda_operator<T_action, T_type1, T_type2>::result_type
-lambda_operator<T_action, T_type1, T_type2>::operator ()() const
-  { return lambda_action<T_action>::template do_action<
-      typename arg1_type::result_type,
-      typename arg2_type::result_type>
-      (arg1_(), arg2_()); }
-
-//template specialization of visit_each<>(action, functor):      
-template <class T_action, class T_lambda_action, class T_arg1, class T_arg2>
-void visit_each(const T_action& _A_action,
-                const lambda_operator<T_lambda_action, T_arg1, T_arg2>& _A_target)
-{
-  visit_each(_A_action, _A_target.arg1_);
-  visit_each(_A_action, _A_target.arg2_);
-}
-
-
-template <class T_action, class T_type>
-struct lambda_operator_unary : public lambda_base
-{
-  typedef typename lambda<T_type>::lambda_type arg_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename arg_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type operand_type;
-      typedef typename lambda_action_unary_deduce_result_type<T_action, operand_type>::type type;
-    };
-  typedef typename lambda_action_unary_deduce_result_type<
-      T_action,
-      typename arg_type::result_type
-    >::type result_type;
-
-  result_type
-  operator ()() const;
-
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator ()(T_arg1 _A_1) const
-    {
-      return lambda_action_unary<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-            (_A_1));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround(T_arg1 _A_1) const
-    {
-      return lambda_action_unary<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-            (_A_1));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2) const
-    {
-      return lambda_action_unary<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-            (_A_1,_A_2));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2) const
-    {
-      return lambda_action_unary<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-            (_A_1,_A_2));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
-    {
-      return lambda_action_unary<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-            (_A_1,_A_2,_A_3));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
-    {
-      return lambda_action_unary<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-            (_A_1,_A_2,_A_3));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
-    {
-      return lambda_action_unary<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-            (_A_1,_A_2,_A_3,_A_4));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
-    {
-      return lambda_action_unary<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-            (_A_1,_A_2,_A_3,_A_4));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
-    {
-      return lambda_action_unary<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
-    {
-      return lambda_action_unary<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
-    {
-      return lambda_action_unary<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
-    {
-      return lambda_action_unary<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
-    {
-      return lambda_action_unary<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
-    {
-      return lambda_action_unary<T_action>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7));
-    }
-  #endif
-
-  lambda_operator_unary(typename type_trait<T_type>::take a)
-    : arg_(a) {}
-
-  arg_type arg_;
-};
-
-template <class T_action, class T_type>
-typename lambda_operator_unary<T_action, T_type>::result_type
-lambda_operator_unary<T_action, T_type>::operator ()() const
-  { return lambda_action_unary<T_action>::template do_action<
-      typename arg_type::result_type>
-      (arg_()); }
-
-//template specialization of visit_each<>(action, functor):
-template <class T_action, class T_lambda_action, class T_arg>
-void visit_each(const T_action& _A_action,
-                const lambda_operator_unary<T_lambda_action, T_arg>& _A_target)
-{
-  visit_each(_A_action, _A_target.arg_);
-}
-
-
-template <class T_action, class T_type, class T_arg>
-struct lambda_operator_convert : public lambda_base
-{
-  typedef typename lambda<T_arg>::lambda_type arg_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename arg_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type operand_type;
-      typedef typename lambda_action_convert_deduce_result_type<T_action, T_type, operand_type>::type type;
-    };
-  typedef typename lambda_action_convert_deduce_result_type<
-      T_action, T_type,
-      typename arg_type::result_type
-    >::type result_type;
-
-  result_type
-  operator ()() const;
-
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator ()(T_arg1 _A_1) const
-    {
-      return lambda_action_convert<T_action, T_type>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-            (_A_1));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround(T_arg1 _A_1) const
-    {
-      return lambda_action_convert<T_action, T_type>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-            (_A_1));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2) const
-    {
-      return lambda_action_convert<T_action, T_type>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-            (_A_1,_A_2));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2) const
-    {
-      return lambda_action_convert<T_action, T_type>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-            (_A_1,_A_2));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
-    {
-      return lambda_action_convert<T_action, T_type>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-            (_A_1,_A_2,_A_3));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const
-    {
-      return lambda_action_convert<T_action, T_type>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-            (_A_1,_A_2,_A_3));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
-    {
-      return lambda_action_convert<T_action, T_type>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-            (_A_1,_A_2,_A_3,_A_4));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const
-    {
-      return lambda_action_convert<T_action, T_type>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-            (_A_1,_A_2,_A_3,_A_4));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
-    {
-      return lambda_action_convert<T_action, T_type>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const
-    {
-      return lambda_action_convert<T_action, T_type>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
-    {
-      return lambda_action_convert<T_action, T_type>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const
-    {
-      return lambda_action_convert<T_action, T_type>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator ()(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
-    {
-      return lambda_action_convert<T_action, T_type>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const
-    {
-      return lambda_action_convert<T_action, T_type>::template do_action<
-            typename deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::operand_type>
-        (arg_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-            (_A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7));
-    }
-  #endif
-
-  lambda_operator_convert(typename type_trait<T_arg>::take a)
-    : arg_(a) {}
-
-  arg_type arg_;
-};
-
-template <class T_action, class T_type, class T_arg>
-typename lambda_operator_convert<T_action, T_type, T_arg>::result_type
-lambda_operator_convert<T_action, T_type, T_arg>::operator ()() const
-  { return lambda_action_convert<T_action, T_type>::template do_action<
-      typename arg_type::result_type>
-      (arg_()); }
-
-//template specialization of visit_each<>(action, functor):
-template <class T_action, class T_lambda_action, class T_type, class T_arg>
-void visit_each(const T_action& _A_action,
-                const lambda_operator_convert<T_lambda_action, T_type, T_arg>& _A_target)
-{
-  visit_each(_A_action, _A_target.arg_);
-}
-
-
-// Operators for lambda action arithmetic<plus>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic<plus>, T_arg1, T_arg2> >
-operator + (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic<plus>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic<plus>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator + (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<arithmetic<plus>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic<plus>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator + (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic<plus>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action arithmetic<minus>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic<minus>, T_arg1, T_arg2> >
-operator - (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic<minus>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic<minus>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator - (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<arithmetic<minus>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic<minus>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator - (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic<minus>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action arithmetic<multiplies>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic<multiplies>, T_arg1, T_arg2> >
-operator * (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic<multiplies>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic<multiplies>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator * (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<arithmetic<multiplies>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic<multiplies>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator * (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic<multiplies>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action arithmetic<divides>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic<divides>, T_arg1, T_arg2> >
-operator / (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic<divides>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic<divides>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator / (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<arithmetic<divides>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic<divides>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator / (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic<divides>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action arithmetic<modulus>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic<modulus>, T_arg1, T_arg2> >
-operator % (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic<modulus>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic<modulus>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator % (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<arithmetic<modulus>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic<modulus>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator % (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic<modulus>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action bitwise<leftshift>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise<leftshift>, T_arg1, T_arg2> >
-operator << (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise<leftshift>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise<leftshift>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator << (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<bitwise<leftshift>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise<leftshift>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator << (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise<leftshift>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action bitwise<rightshift>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise<rightshift>, T_arg1, T_arg2> >
-operator >> (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise<rightshift>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise<rightshift>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator >> (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<bitwise<rightshift>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise<rightshift>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator >> (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise<rightshift>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action bitwise<and_>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise<and_>, T_arg1, T_arg2> >
-operator & (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise<and_>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise<and_>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator & (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<bitwise<and_>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise<and_>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator & (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise<and_>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action bitwise<or_>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise<or_>, T_arg1, T_arg2> >
-operator | (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise<or_>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise<or_>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator | (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<bitwise<or_>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise<or_>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator | (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise<or_>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action bitwise<xor_>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise<xor_>, T_arg1, T_arg2> >
-operator ^ (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise<xor_>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise<xor_>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator ^ (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<bitwise<xor_>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise<xor_>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator ^ (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise<xor_>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action logical<and_>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<logical<and_>, T_arg1, T_arg2> >
-operator && (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<logical<and_>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<logical<and_>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator && (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<logical<and_>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<logical<and_>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator && (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<logical<and_>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action logical<or_>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<logical<or_>, T_arg1, T_arg2> >
-operator || (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<logical<or_>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<logical<or_>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator || (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<logical<or_>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<logical<or_>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator || (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<logical<or_>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action relational<less>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<less>, T_arg1, T_arg2> >
-operator < (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<relational<less>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<less>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator < (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<relational<less>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<less>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator < (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<relational<less>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action relational<greater>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<greater>, T_arg1, T_arg2> >
-operator > (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<relational<greater>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<greater>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator > (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<relational<greater>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<greater>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator > (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<relational<greater>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action relational<less_equal>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<less_equal>, T_arg1, T_arg2> >
-operator <= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<relational<less_equal>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<less_equal>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator <= (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<relational<less_equal>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<less_equal>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator <= (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<relational<less_equal>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action relational<greater_equal>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<greater_equal>, T_arg1, T_arg2> >
-operator >= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<relational<greater_equal>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<greater_equal>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator >= (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<relational<greater_equal>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<greater_equal>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator >= (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<relational<greater_equal>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action relational<equal_to>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<equal_to>, T_arg1, T_arg2> >
-operator == (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<relational<equal_to>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<equal_to>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator == (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<relational<equal_to>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<equal_to>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator == (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<relational<equal_to>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action relational<not_equal_to>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<not_equal_to>, T_arg1, T_arg2> >
-operator != (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<relational<not_equal_to>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<not_equal_to>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator != (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<relational<not_equal_to>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<relational<not_equal_to>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator != (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<relational<not_equal_to>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action arithmetic_assign<plus>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic_assign<plus>, T_arg1, T_arg2> >
-operator += (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic_assign<plus>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic_assign<plus>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator += (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<arithmetic_assign<plus>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic_assign<plus>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator += (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic_assign<plus>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action arithmetic_assign<minus>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic_assign<minus>, T_arg1, T_arg2> >
-operator -= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic_assign<minus>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic_assign<minus>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator -= (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<arithmetic_assign<minus>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic_assign<minus>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator -= (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic_assign<minus>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action arithmetic_assign<multiplies>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic_assign<multiplies>, T_arg1, T_arg2> >
-operator *= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic_assign<multiplies>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic_assign<multiplies>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator *= (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<arithmetic_assign<multiplies>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic_assign<multiplies>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator *= (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic_assign<multiplies>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action arithmetic_assign<divides>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic_assign<divides>, T_arg1, T_arg2> >
-operator /= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic_assign<divides>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic_assign<divides>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator /= (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<arithmetic_assign<divides>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic_assign<divides>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator /= (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic_assign<divides>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action arithmetic_assign<modulus>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic_assign<modulus>, T_arg1, T_arg2> >
-operator %= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic_assign<modulus>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic_assign<modulus>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator %= (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<arithmetic_assign<modulus>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<arithmetic_assign<modulus>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator %= (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<arithmetic_assign<modulus>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action bitwise_assign<leftshift>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise_assign<leftshift>, T_arg1, T_arg2> >
-operator <<= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise_assign<leftshift>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise_assign<leftshift>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator <<= (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<bitwise_assign<leftshift>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise_assign<leftshift>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator <<= (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise_assign<leftshift>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action bitwise_assign<rightshift>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise_assign<rightshift>, T_arg1, T_arg2> >
-operator >>= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise_assign<rightshift>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise_assign<rightshift>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator >>= (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<bitwise_assign<rightshift>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise_assign<rightshift>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator >>= (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise_assign<rightshift>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action bitwise_assign<and_>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise_assign<and_>, T_arg1, T_arg2> >
-operator &= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise_assign<and_>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise_assign<and_>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator &= (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<bitwise_assign<and_>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise_assign<and_>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator &= (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise_assign<and_>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action bitwise_assign<or_>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise_assign<or_>, T_arg1, T_arg2> >
-operator |= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise_assign<or_>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise_assign<or_>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator |= (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<bitwise_assign<or_>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise_assign<or_>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator |= (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise_assign<or_>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operators for lambda action bitwise_assign<xor_>. At least one of the arguments needs to be of type lamdba, hence the overloads.
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise_assign<xor_>, T_arg1, T_arg2> >
-operator ^= (const lambda<T_arg1>& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise_assign<xor_>, T_arg1, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2.value_)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise_assign<xor_>, T_arg1, typename unwrap_reference<T_arg2>::type> >
-operator ^= (const lambda<T_arg1>& a1, const T_arg2& a2)
-{ typedef lambda_operator<bitwise_assign<xor_>, T_arg1, typename unwrap_reference<T_arg2>::type> operator_type;
-  return lambda<operator_type>(operator_type(a1.value_,a2)); }
-template <class T_arg1, class T_arg2>
-lambda<lambda_operator<bitwise_assign<xor_>, typename unwrap_reference<T_arg1>::type, T_arg2> >
-operator ^= (const T_arg1& a1, const lambda<T_arg2>& a2)
-{ typedef lambda_operator<bitwise_assign<xor_>, typename unwrap_reference<T_arg1>::type, T_arg2> operator_type;
-  return lambda<operator_type>(operator_type(a1,a2.value_)); }
-
-// Operator for lambda action unary_arithmetic<pre_increment>.
-template <class T_arg>
-lambda<lambda_operator_unary<unary_arithmetic<pre_increment>, T_arg> >
-operator ++ (const lambda<T_arg>& a)
-{ typedef lambda_operator_unary<unary_arithmetic<pre_increment>, T_arg> operator_type;
-  return lambda<operator_type>(operator_type(a.value_)); }
-
-// Operator for lambda action unary_arithmetic<pre_decrement>.
-template <class T_arg>
-lambda<lambda_operator_unary<unary_arithmetic<pre_decrement>, T_arg> >
-operator -- (const lambda<T_arg>& a)
-{ typedef lambda_operator_unary<unary_arithmetic<pre_decrement>, T_arg> operator_type;
-  return lambda<operator_type>(operator_type(a.value_)); }
-
-// Operator for lambda action unary_arithmetic<negate>.
-template <class T_arg>
-lambda<lambda_operator_unary<unary_arithmetic<negate>, T_arg> >
-operator - (const lambda<T_arg>& a)
-{ typedef lambda_operator_unary<unary_arithmetic<negate>, T_arg> operator_type;
-  return lambda<operator_type>(operator_type(a.value_)); }
-
-// Operator for lambda action unary_bitwise<not_>.
-template <class T_arg>
-lambda<lambda_operator_unary<unary_bitwise<not_>, T_arg> >
-operator ~ (const lambda<T_arg>& a)
-{ typedef lambda_operator_unary<unary_bitwise<not_>, T_arg> operator_type;
-  return lambda<operator_type>(operator_type(a.value_)); }
-
-// Operator for lambda action unary_logical<not_>.
-template <class T_arg>
-lambda<lambda_operator_unary<unary_logical<not_>, T_arg> >
-operator ! (const lambda<T_arg>& a)
-{ typedef lambda_operator_unary<unary_logical<not_>, T_arg> operator_type;
-  return lambda<operator_type>(operator_type(a.value_)); }
-
-// Operator for lambda action unary_other<address>.
-template <class T_arg>
-lambda<lambda_operator_unary<unary_other<address>, T_arg> >
-operator & (const lambda<T_arg>& a)
-{ typedef lambda_operator_unary<unary_other<address>, T_arg> operator_type;
-  return lambda<operator_type>(operator_type(a.value_)); }
-
-// Operator for lambda action unary_other<dereference>.
-template <class T_arg>
-lambda<lambda_operator_unary<unary_other<dereference>, T_arg> >
-operator * (const lambda<T_arg>& a)
-{ typedef lambda_operator_unary<unary_other<dereference>, T_arg> operator_type;
-  return lambda<operator_type>(operator_type(a.value_)); }
-
-// Creators for lambda action cast_<reinterpret_>.
-template <class T_type, class T_arg>
-lambda<lambda_operator_convert<cast_<reinterpret_>, T_type, typename unwrap_lambda_type<T_arg>::type> >
-reinterpret_cast_(const T_arg& a)
-{ typedef lambda_operator_convert<cast_<reinterpret_>, T_type, typename unwrap_lambda_type<T_arg>::type> operator_type;
-  return lambda<operator_type>(operator_type(unwrap_lambda_value(a))); }
-
-// Creators for lambda action cast_<static_>.
-template <class T_type, class T_arg>
-lambda<lambda_operator_convert<cast_<static_>, T_type, typename unwrap_lambda_type<T_arg>::type> >
-static_cast_(const T_arg& a)
-{ typedef lambda_operator_convert<cast_<static_>, T_type, typename unwrap_lambda_type<T_arg>::type> operator_type;
-  return lambda<operator_type>(operator_type(unwrap_lambda_value(a))); }
-
-// Creators for lambda action cast_<dynamic_>.
-template <class T_type, class T_arg>
-lambda<lambda_operator_convert<cast_<dynamic_>, T_type, typename unwrap_lambda_type<T_arg>::type> >
-dynamic_cast_(const T_arg& a)
-{ typedef lambda_operator_convert<cast_<dynamic_>, T_type, typename unwrap_lambda_type<T_arg>::type> operator_type;
-  return lambda<operator_type>(operator_type(unwrap_lambda_value(a))); }
-
-
-} /* namespace sigc */
-
-#endif /* _SIGC_LAMBDA_OPERATOR_HPP_ */
Index: stardict-3.0.1/src/sigc++/adaptors/lambda/select.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/lambda/select.h
+++ /dev/null
@@ -1,346 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-#ifndef _SIGC_LAMBDA_SELECT_HPP_
-#define _SIGC_LAMBDA_SELECT_HPP_
-#include <sigc++/adaptors/lambda/base.h>
-
-namespace sigc {
-
-namespace internal {
-struct lambda_select1 : public lambda_base
-{
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef T_arg1 type; };
-  typedef void result_type; // no operator ()() overload
-
-  void operator ()() const; // not implemented
-  template <class T_arg1>
-  T_arg1 operator ()(T_arg1 _A_1) const { return _A_1; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  //Does not work: T_arg1 sun_forte_workaround(T_arg1 _A_1) const { return operator()( _A_1 ); }
-  T_arg1 sun_forte_workaround(T_arg1 _A_1) const { return _A_1; }
-  #endif
-  
-  template <class T_arg1,class T_arg2>
-  T_arg1 operator ()(T_arg1 _A_1, T_arg2) const { return _A_1; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  //Does not work: T_arg1 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2) const { return operator()( _A_1,_A_2 ); }
-  T_arg1 sun_forte_workaround(T_arg1 _A_1, T_arg2) const { return _A_1; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3>
-  T_arg1 operator ()(T_arg1 _A_1, T_arg2, T_arg3) const { return _A_1; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  //Does not work: T_arg1 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const { return operator()( _A_1,_A_2,_A_3 ); }
-  T_arg1 sun_forte_workaround(T_arg1 _A_1, T_arg2, T_arg3) const { return _A_1; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  T_arg1 operator ()(T_arg1 _A_1, T_arg2, T_arg3, T_arg4) const { return _A_1; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  //Does not work: T_arg1 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const { return operator()( _A_1,_A_2,_A_3,_A_4 ); }
-  T_arg1 sun_forte_workaround(T_arg1 _A_1, T_arg2, T_arg3, T_arg4) const { return _A_1; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  T_arg1 operator ()(T_arg1 _A_1, T_arg2, T_arg3, T_arg4, T_arg5) const { return _A_1; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  //Does not work: T_arg1 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5 ); }
-  T_arg1 sun_forte_workaround(T_arg1 _A_1, T_arg2, T_arg3, T_arg4, T_arg5) const { return _A_1; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  T_arg1 operator ()(T_arg1 _A_1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const { return _A_1; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  //Does not work: T_arg1 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5,_A_6 ); }
-  T_arg1 sun_forte_workaround(T_arg1 _A_1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const { return _A_1; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  T_arg1 operator ()(T_arg1 _A_1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const { return _A_1; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  //Does not work: T_arg1 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7 ); }
-  T_arg1 sun_forte_workaround(T_arg1 _A_1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const { return _A_1; }
-  #endif
-  
-};
-
-struct lambda_select2 : public lambda_base
-{
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef T_arg2 type; };
-  typedef void result_type; // no operator ()() overload
-
-  void operator ()() const; // not implemented
-  template <class T_arg1,class T_arg2>
-  T_arg2 operator ()(T_arg1, T_arg2 _A_2) const { return _A_2; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  //Does not work: T_arg2 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2) const { return operator()( _A_1,_A_2 ); }
-  T_arg2 sun_forte_workaround(T_arg1, T_arg2 _A_2) const { return _A_2; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3>
-  T_arg2 operator ()(T_arg1, T_arg2 _A_2, T_arg3) const { return _A_2; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  //Does not work: T_arg2 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const { return operator()( _A_1,_A_2,_A_3 ); }
-  T_arg2 sun_forte_workaround(T_arg1, T_arg2 _A_2, T_arg3) const { return _A_2; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  T_arg2 operator ()(T_arg1, T_arg2 _A_2, T_arg3, T_arg4) const { return _A_2; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  //Does not work: T_arg2 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const { return operator()( _A_1,_A_2,_A_3,_A_4 ); }
-  T_arg2 sun_forte_workaround(T_arg1, T_arg2 _A_2, T_arg3, T_arg4) const { return _A_2; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  T_arg2 operator ()(T_arg1, T_arg2 _A_2, T_arg3, T_arg4, T_arg5) const { return _A_2; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  //Does not work: T_arg2 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5 ); }
-  T_arg2 sun_forte_workaround(T_arg1, T_arg2 _A_2, T_arg3, T_arg4, T_arg5) const { return _A_2; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  T_arg2 operator ()(T_arg1, T_arg2 _A_2, T_arg3, T_arg4, T_arg5, T_arg6) const { return _A_2; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  //Does not work: T_arg2 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5,_A_6 ); }
-  T_arg2 sun_forte_workaround(T_arg1, T_arg2 _A_2, T_arg3, T_arg4, T_arg5, T_arg6) const { return _A_2; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  T_arg2 operator ()(T_arg1, T_arg2 _A_2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const { return _A_2; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  //Does not work: T_arg2 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7 ); }
-  T_arg2 sun_forte_workaround(T_arg1, T_arg2 _A_2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const { return _A_2; }
-  #endif
-  
-};
-
-struct lambda_select3 : public lambda_base
-{
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef T_arg3 type; };
-  typedef void result_type; // no operator ()() overload
-
-  void operator ()() const; // not implemented
-  template <class T_arg1,class T_arg2,class T_arg3>
-  T_arg3 operator ()(T_arg1, T_arg2, T_arg3 _A_3) const { return _A_3; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  //Does not work: T_arg3 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3) const { return operator()( _A_1,_A_2,_A_3 ); }
-  T_arg3 sun_forte_workaround(T_arg1, T_arg2, T_arg3 _A_3) const { return _A_3; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  T_arg3 operator ()(T_arg1, T_arg2, T_arg3 _A_3, T_arg4) const { return _A_3; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  //Does not work: T_arg3 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const { return operator()( _A_1,_A_2,_A_3,_A_4 ); }
-  T_arg3 sun_forte_workaround(T_arg1, T_arg2, T_arg3 _A_3, T_arg4) const { return _A_3; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  T_arg3 operator ()(T_arg1, T_arg2, T_arg3 _A_3, T_arg4, T_arg5) const { return _A_3; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  //Does not work: T_arg3 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5 ); }
-  T_arg3 sun_forte_workaround(T_arg1, T_arg2, T_arg3 _A_3, T_arg4, T_arg5) const { return _A_3; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  T_arg3 operator ()(T_arg1, T_arg2, T_arg3 _A_3, T_arg4, T_arg5, T_arg6) const { return _A_3; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  //Does not work: T_arg3 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5,_A_6 ); }
-  T_arg3 sun_forte_workaround(T_arg1, T_arg2, T_arg3 _A_3, T_arg4, T_arg5, T_arg6) const { return _A_3; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  T_arg3 operator ()(T_arg1, T_arg2, T_arg3 _A_3, T_arg4, T_arg5, T_arg6, T_arg7) const { return _A_3; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  //Does not work: T_arg3 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7 ); }
-  T_arg3 sun_forte_workaround(T_arg1, T_arg2, T_arg3 _A_3, T_arg4, T_arg5, T_arg6, T_arg7) const { return _A_3; }
-  #endif
-  
-};
-
-struct lambda_select4 : public lambda_base
-{
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef T_arg4 type; };
-  typedef void result_type; // no operator ()() overload
-
-  void operator ()() const; // not implemented
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  T_arg4 operator ()(T_arg1, T_arg2, T_arg3, T_arg4 _A_4) const { return _A_4; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  //Does not work: T_arg4 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4) const { return operator()( _A_1,_A_2,_A_3,_A_4 ); }
-  T_arg4 sun_forte_workaround(T_arg1, T_arg2, T_arg3, T_arg4 _A_4) const { return _A_4; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  T_arg4 operator ()(T_arg1, T_arg2, T_arg3, T_arg4 _A_4, T_arg5) const { return _A_4; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  //Does not work: T_arg4 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5 ); }
-  T_arg4 sun_forte_workaround(T_arg1, T_arg2, T_arg3, T_arg4 _A_4, T_arg5) const { return _A_4; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  T_arg4 operator ()(T_arg1, T_arg2, T_arg3, T_arg4 _A_4, T_arg5, T_arg6) const { return _A_4; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  //Does not work: T_arg4 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5,_A_6 ); }
-  T_arg4 sun_forte_workaround(T_arg1, T_arg2, T_arg3, T_arg4 _A_4, T_arg5, T_arg6) const { return _A_4; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  T_arg4 operator ()(T_arg1, T_arg2, T_arg3, T_arg4 _A_4, T_arg5, T_arg6, T_arg7) const { return _A_4; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  //Does not work: T_arg4 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7 ); }
-  T_arg4 sun_forte_workaround(T_arg1, T_arg2, T_arg3, T_arg4 _A_4, T_arg5, T_arg6, T_arg7) const { return _A_4; }
-  #endif
-  
-};
-
-struct lambda_select5 : public lambda_base
-{
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef T_arg5 type; };
-  typedef void result_type; // no operator ()() overload
-
-  void operator ()() const; // not implemented
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  T_arg5 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 _A_5) const { return _A_5; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  //Does not work: T_arg5 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5 ); }
-  T_arg5 sun_forte_workaround(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 _A_5) const { return _A_5; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  T_arg5 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 _A_5, T_arg6) const { return _A_5; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  //Does not work: T_arg5 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5,_A_6 ); }
-  T_arg5 sun_forte_workaround(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 _A_5, T_arg6) const { return _A_5; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  T_arg5 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 _A_5, T_arg6, T_arg7) const { return _A_5; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  //Does not work: T_arg5 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7 ); }
-  T_arg5 sun_forte_workaround(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 _A_5, T_arg6, T_arg7) const { return _A_5; }
-  #endif
-  
-};
-
-struct lambda_select6 : public lambda_base
-{
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef T_arg6 type; };
-  typedef void result_type; // no operator ()() overload
-
-  void operator ()() const; // not implemented
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  T_arg6 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 _A_6) const { return _A_6; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  //Does not work: T_arg6 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5,_A_6 ); }
-  T_arg6 sun_forte_workaround(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 _A_6) const { return _A_6; }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  T_arg6 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 _A_6, T_arg7) const { return _A_6; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  //Does not work: T_arg6 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7 ); }
-  T_arg6 sun_forte_workaround(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 _A_6, T_arg7) const { return _A_6; }
-  #endif
-  
-};
-
-struct lambda_select7 : public lambda_base
-{
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef T_arg7 type; };
-  typedef void result_type; // no operator ()() overload
-
-  void operator ()() const; // not implemented
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  T_arg7 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 _A_7) const { return _A_7; }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  //Does not work: T_arg7 sun_forte_workaround(T_arg1 _A_1,T_arg2 _A_2,T_arg3 _A_3,T_arg4 _A_4,T_arg5 _A_5,T_arg6 _A_6,T_arg7 _A_7) const { return operator()( _A_1,_A_2,_A_3,_A_4,_A_5,_A_6,_A_7 ); }
-  T_arg7 sun_forte_workaround(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 _A_7) const { return _A_7; }
-  #endif
-  
-};
-
-
-} /* namespace internal */
-
-extern SIGC_API const lambda<internal::lambda_select1> _1;
-extern SIGC_API const lambda<internal::lambda_select2> _2;
-extern SIGC_API const lambda<internal::lambda_select3> _3;
-extern SIGC_API const lambda<internal::lambda_select4> _4;
-extern SIGC_API const lambda<internal::lambda_select5> _5;
-extern SIGC_API const lambda<internal::lambda_select6> _6;
-extern SIGC_API const lambda<internal::lambda_select7> _7;
-
-
-} /* namespace sigc */
-
-#endif /* _SIGC_LAMBDA_SELECT_HPP_ */
Index: stardict-3.0.1/src/sigc++/adaptors/retype.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/retype.h
+++ /dev/null
@@ -1,1248 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-#ifndef _SIGC_ADAPTORS_MACROS_RETYPEHM4_
-#define _SIGC_ADAPTORS_MACROS_RETYPEHM4_
-#include <sigc++/adaptors/adaptor_trait.h>
-#include <sigc++/functors/ptr_fun.h>
-#include <sigc++/functors/mem_fun.h>
-#include <sigc++/functors/slot.h>
-
-namespace sigc {
-
-/** @defgroup retype retype(), retype_return()
- * sigc::retype() alters a sigc::pointer_functor, a sigc::mem_functor or a sigc::slot
- * in that it makes C-style casts to the functor's parameter types
- * of all parameters passed through operator()().
- *
- * Use this adaptor for inline conversion between numeric or other simple types.
- * @par Example:
- *   @code
- *   void foo(int);
- *   sigc::retype(sigc::ptr_fun(&foo))(5.7F); // calls foo(5)
- *   @endcode
- *
- * The functor sigc::retype() returns can be passed into
- * sigc::signal::connect() directly.
- *
- * @par Example:
- *   @code
- *   sigc::signal<void,float> some_signal;
- *   void foo(int);
- *   some_signal.connect(sigc::retype(sigc::ptr_fun(&foo)));
- *   @endcode
- *
- * This adaptor builds an exception in that it only works on sig::pointer_functor,
- * sigc::mem_functor and sigc::slot because it needs sophisticated information about
- * the parameter types that cannot be deduced from arbitrary functor types.
- *
- * sigc::retype_return() alters the return type of an arbitrary functor.
- * Like in sigc::retype() a C-style cast is preformed. Usage sigc::retype_return() is
- * not restricted to libsigc++ functor types but you need to
- * specify the new return type as a template parameter.
- *
- * @par Example:
- *   @code
- *   float foo();
- *   std::cout << sigc::retype_return<int>(&foo)(); // converts foo's return value to an integer
- *   @endcode
- *
- * @ingroup adaptors
- */
-
-/** Adaptor that performs C-style casts on the parameters passed on to the functor.
- * Use the convenience function sigc::retype() to create an instance of retype_functor.
- *
- * The following template arguments are used:
- * - @e T_functor Type of the functor to wrap.
- * - @e T_type1 Type of @e T_functor's 1th argument.
- * - @e T_type2 Type of @e T_functor's 2th argument.
- * - @e T_type3 Type of @e T_functor's 3th argument.
- * - @e T_type4 Type of @e T_functor's 4th argument.
- * - @e T_type5 Type of @e T_functor's 5th argument.
- * - @e T_type6 Type of @e T_functor's 6th argument.
- * - @e T_type7 Type of @e T_functor's 7th argument.
- *
- * @ingroup retype
- */
-template <class T_functor, class T_type1=nil,class T_type2=nil,class T_type3=nil,class T_type4=nil,class T_type5=nil,class T_type6=nil,class T_type7=nil>
-struct retype_functor
-  : public adapts<T_functor>
-{
-  typedef typename adapts<T_functor>::adaptor_type adaptor_type;
-
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef typename adaptor_type::template deduce_result_type<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>::type type; };
-  typedef typename adapts<T_functor>::result_type result_type;
-
-  result_type operator()();
-    
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  operator()(T_arg1 _A_a1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_type1>::take>
-        (static_cast<T_type1>(_A_a1));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  typename deduce_result_type<T_arg1>::type
-  sun_forte_workaround(T_arg1 _A_a1)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_type1>::take>
-        (static_cast<T_type1>(_A_a1));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  typename deduce_result_type<T_arg1,T_arg2>::type
-  sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take,typename type_trait<T_type3>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3>::type
-  sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take,typename type_trait<T_type3>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take,typename type_trait<T_type3>::take,typename type_trait<T_type4>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4>::type
-  sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take,typename type_trait<T_type3>::take,typename type_trait<T_type4>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take,typename type_trait<T_type3>::take,typename type_trait<T_type4>::take,typename type_trait<T_type5>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::type
-  sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take,typename type_trait<T_type3>::take,typename type_trait<T_type4>::take,typename type_trait<T_type5>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take,typename type_trait<T_type3>::take,typename type_trait<T_type4>::take,typename type_trait<T_type5>::take,typename type_trait<T_type6>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5),static_cast<T_type6>(_A_a6));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::type
-  sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take,typename type_trait<T_type3>::take,typename type_trait<T_type4>::take,typename type_trait<T_type5>::take,typename type_trait<T_type6>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5),static_cast<T_type6>(_A_a6));
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take,typename type_trait<T_type3>::take,typename type_trait<T_type4>::take,typename type_trait<T_type5>::take,typename type_trait<T_type6>::take,typename type_trait<T_type7>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5),static_cast<T_type6>(_A_a6),static_cast<T_type7>(_A_a7));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  typename deduce_result_type<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type
-  sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
-    { return this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_type1>::take,typename type_trait<T_type2>::take,typename type_trait<T_type3>::take,typename type_trait<T_type4>::take,typename type_trait<T_type5>::take,typename type_trait<T_type6>::take,typename type_trait<T_type7>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5),static_cast<T_type6>(_A_a6),static_cast<T_type7>(_A_a7));
-    }
-  #endif
-
-
-  /** Constructs a retype_functor object that performs C-style casts on the parameters passed on to the functor.
-   * @param _A_functor Functor to invoke from operator()().
-   */
-  explicit retype_functor(typename type_trait<T_functor>::take _A_functor)
-    : adapts<T_functor>(_A_functor)
-    {}
-};
-
-template <class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6,class T_type7>
-typename retype_functor<T_functor, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6,T_type7>::result_type
-retype_functor<T_functor, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6,T_type7>::operator()()
-  { return this->functor_(); }
-
-  
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::retype_functor performs a functor on the
- * functor stored in the sigc::retype_functor object.
- *
- * @ingroup retype
- */
-template <class T_action, class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6,class T_type7>
-void visit_each(const T_action& _A_action,
-                const retype_functor<T_functor, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6,T_type7>& _A_target)
-{
-  visit_each(_A_action, _A_target.functor_);
-}
-
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::slot.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-inline retype_functor<slot<T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-retype(const slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
-{ return retype_functor<slot<T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-    (_A_functor); }
-
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::pointer_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return>
-inline retype_functor<pointer_functor0<T_return> >
-retype(const pointer_functor0<T_return>& _A_functor)
-{ return retype_functor<pointer_functor0<T_return> >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::pointer_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_arg1, class T_return>
-inline retype_functor<pointer_functor1<T_arg1, T_return>, T_arg1 >
-retype(const pointer_functor1<T_arg1, T_return>& _A_functor)
-{ return retype_functor<pointer_functor1<T_arg1, T_return>, T_arg1 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::pointer_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_arg1,class T_arg2, class T_return>
-inline retype_functor<pointer_functor2<T_arg1, T_arg2, T_return>, T_arg1,T_arg2 >
-retype(const pointer_functor2<T_arg1,T_arg2, T_return>& _A_functor)
-{ return retype_functor<pointer_functor2<T_arg1, T_arg2, T_return>, T_arg1,T_arg2 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::pointer_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return>
-inline retype_functor<pointer_functor3<T_arg1, T_arg2, T_arg3, T_return>, T_arg1,T_arg2,T_arg3 >
-retype(const pointer_functor3<T_arg1,T_arg2,T_arg3, T_return>& _A_functor)
-{ return retype_functor<pointer_functor3<T_arg1, T_arg2, T_arg3, T_return>, T_arg1,T_arg2,T_arg3 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::pointer_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return>
-inline retype_functor<pointer_functor4<T_arg1, T_arg2, T_arg3, T_arg4, T_return>, T_arg1,T_arg2,T_arg3,T_arg4 >
-retype(const pointer_functor4<T_arg1,T_arg2,T_arg3,T_arg4, T_return>& _A_functor)
-{ return retype_functor<pointer_functor4<T_arg1, T_arg2, T_arg3, T_arg4, T_return>, T_arg1,T_arg2,T_arg3,T_arg4 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::pointer_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return>
-inline retype_functor<pointer_functor5<T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-retype(const pointer_functor5<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_return>& _A_functor)
-{ return retype_functor<pointer_functor5<T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::pointer_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return>
-inline retype_functor<pointer_functor6<T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-retype(const pointer_functor6<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_return>& _A_functor)
-{ return retype_functor<pointer_functor6<T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::pointer_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return>
-inline retype_functor<pointer_functor7<T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-retype(const pointer_functor7<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_return>& _A_functor)
-{ return retype_functor<pointer_functor7<T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-    (_A_functor); }
-
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj>
-inline retype_functor<mem_functor0<T_return, T_obj> >
-retype(const mem_functor0<T_return, T_obj>& _A_functor)
-{ return retype_functor<mem_functor0<T_return, T_obj> >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1>
-inline retype_functor<mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
-retype(const mem_functor1<T_return, T_obj, T_arg1>& _A_functor)
-{ return retype_functor<mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2>
-inline retype_functor<mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
-retype(const mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_functor)
-{ return retype_functor<mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-inline retype_functor<mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
-retype(const mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_functor)
-{ return retype_functor<mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-inline retype_functor<mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
-retype(const mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_functor)
-{ return retype_functor<mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-inline retype_functor<mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-retype(const mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_functor)
-{ return retype_functor<mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-inline retype_functor<mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-retype(const mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_functor)
-{ return retype_functor<mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-inline retype_functor<mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-retype(const mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
-{ return retype_functor<mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::const_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj>
-inline retype_functor<const_mem_functor0<T_return, T_obj> >
-retype(const const_mem_functor0<T_return, T_obj>& _A_functor)
-{ return retype_functor<const_mem_functor0<T_return, T_obj> >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::const_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1>
-inline retype_functor<const_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
-retype(const const_mem_functor1<T_return, T_obj, T_arg1>& _A_functor)
-{ return retype_functor<const_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::const_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2>
-inline retype_functor<const_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
-retype(const const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_functor)
-{ return retype_functor<const_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::const_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-inline retype_functor<const_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
-retype(const const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_functor)
-{ return retype_functor<const_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::const_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-inline retype_functor<const_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
-retype(const const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_functor)
-{ return retype_functor<const_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::const_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-inline retype_functor<const_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-retype(const const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_functor)
-{ return retype_functor<const_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::const_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-inline retype_functor<const_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-retype(const const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_functor)
-{ return retype_functor<const_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::const_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-inline retype_functor<const_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-retype(const const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
-{ return retype_functor<const_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj>
-inline retype_functor<volatile_mem_functor0<T_return, T_obj> >
-retype(const volatile_mem_functor0<T_return, T_obj>& _A_functor)
-{ return retype_functor<volatile_mem_functor0<T_return, T_obj> >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1>
-inline retype_functor<volatile_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
-retype(const volatile_mem_functor1<T_return, T_obj, T_arg1>& _A_functor)
-{ return retype_functor<volatile_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2>
-inline retype_functor<volatile_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
-retype(const volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_functor)
-{ return retype_functor<volatile_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-inline retype_functor<volatile_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
-retype(const volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_functor)
-{ return retype_functor<volatile_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-inline retype_functor<volatile_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
-retype(const volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_functor)
-{ return retype_functor<volatile_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-inline retype_functor<volatile_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-retype(const volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_functor)
-{ return retype_functor<volatile_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-inline retype_functor<volatile_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-retype(const volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_functor)
-{ return retype_functor<volatile_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-inline retype_functor<volatile_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-retype(const volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
-{ return retype_functor<volatile_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::const_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj>
-inline retype_functor<const_volatile_mem_functor0<T_return, T_obj> >
-retype(const const_volatile_mem_functor0<T_return, T_obj>& _A_functor)
-{ return retype_functor<const_volatile_mem_functor0<T_return, T_obj> >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::const_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1>
-inline retype_functor<const_volatile_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
-retype(const const_volatile_mem_functor1<T_return, T_obj, T_arg1>& _A_functor)
-{ return retype_functor<const_volatile_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::const_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2>
-inline retype_functor<const_volatile_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
-retype(const const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_functor)
-{ return retype_functor<const_volatile_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::const_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-inline retype_functor<const_volatile_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
-retype(const const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_functor)
-{ return retype_functor<const_volatile_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::const_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-inline retype_functor<const_volatile_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
-retype(const const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_functor)
-{ return retype_functor<const_volatile_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::const_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-inline retype_functor<const_volatile_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-retype(const const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_functor)
-{ return retype_functor<const_volatile_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::const_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-inline retype_functor<const_volatile_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-retype(const const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_functor)
-{ return retype_functor<const_volatile_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::const_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-inline retype_functor<const_volatile_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-retype(const const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
-{ return retype_functor<const_volatile_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj>
-inline retype_functor<bound_mem_functor0<T_return, T_obj> >
-retype(const bound_mem_functor0<T_return, T_obj>& _A_functor)
-{ return retype_functor<bound_mem_functor0<T_return, T_obj> >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1>
-inline retype_functor<bound_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
-retype(const bound_mem_functor1<T_return, T_obj, T_arg1>& _A_functor)
-{ return retype_functor<bound_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2>
-inline retype_functor<bound_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
-retype(const bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_functor)
-{ return retype_functor<bound_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-inline retype_functor<bound_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
-retype(const bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_functor)
-{ return retype_functor<bound_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-inline retype_functor<bound_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
-retype(const bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_functor)
-{ return retype_functor<bound_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-inline retype_functor<bound_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-retype(const bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_functor)
-{ return retype_functor<bound_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-inline retype_functor<bound_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-retype(const bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_functor)
-{ return retype_functor<bound_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-inline retype_functor<bound_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-retype(const bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
-{ return retype_functor<bound_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_const_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj>
-inline retype_functor<bound_const_mem_functor0<T_return, T_obj> >
-retype(const bound_const_mem_functor0<T_return, T_obj>& _A_functor)
-{ return retype_functor<bound_const_mem_functor0<T_return, T_obj> >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_const_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1>
-inline retype_functor<bound_const_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
-retype(const bound_const_mem_functor1<T_return, T_obj, T_arg1>& _A_functor)
-{ return retype_functor<bound_const_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_const_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2>
-inline retype_functor<bound_const_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
-retype(const bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_functor)
-{ return retype_functor<bound_const_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_const_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-inline retype_functor<bound_const_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
-retype(const bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_functor)
-{ return retype_functor<bound_const_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_const_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-inline retype_functor<bound_const_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
-retype(const bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_functor)
-{ return retype_functor<bound_const_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_const_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-inline retype_functor<bound_const_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-retype(const bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_functor)
-{ return retype_functor<bound_const_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_const_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-inline retype_functor<bound_const_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-retype(const bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_functor)
-{ return retype_functor<bound_const_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_const_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-inline retype_functor<bound_const_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-retype(const bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
-{ return retype_functor<bound_const_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj>
-inline retype_functor<bound_volatile_mem_functor0<T_return, T_obj> >
-retype(const bound_volatile_mem_functor0<T_return, T_obj>& _A_functor)
-{ return retype_functor<bound_volatile_mem_functor0<T_return, T_obj> >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1>
-inline retype_functor<bound_volatile_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
-retype(const bound_volatile_mem_functor1<T_return, T_obj, T_arg1>& _A_functor)
-{ return retype_functor<bound_volatile_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2>
-inline retype_functor<bound_volatile_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
-retype(const bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_functor)
-{ return retype_functor<bound_volatile_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-inline retype_functor<bound_volatile_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
-retype(const bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_functor)
-{ return retype_functor<bound_volatile_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-inline retype_functor<bound_volatile_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
-retype(const bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_functor)
-{ return retype_functor<bound_volatile_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-inline retype_functor<bound_volatile_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-retype(const bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_functor)
-{ return retype_functor<bound_volatile_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-inline retype_functor<bound_volatile_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-retype(const bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_functor)
-{ return retype_functor<bound_volatile_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-inline retype_functor<bound_volatile_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-retype(const bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
-{ return retype_functor<bound_volatile_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_const_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj>
-inline retype_functor<bound_const_volatile_mem_functor0<T_return, T_obj> >
-retype(const bound_const_volatile_mem_functor0<T_return, T_obj>& _A_functor)
-{ return retype_functor<bound_const_volatile_mem_functor0<T_return, T_obj> >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_const_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1>
-inline retype_functor<bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
-retype(const bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>& _A_functor)
-{ return retype_functor<bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>, T_arg1 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_const_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2>
-inline retype_functor<bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
-retype(const bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_functor)
-{ return retype_functor<bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1, T_arg2>, T_arg1,T_arg2 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_const_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-inline retype_functor<bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
-retype(const bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_functor)
-{ return retype_functor<bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1, T_arg2, T_arg3>, T_arg1,T_arg2,T_arg3 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_const_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-inline retype_functor<bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
-retype(const bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_functor)
-{ return retype_functor<bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4>, T_arg1,T_arg2,T_arg3,T_arg4 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_const_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-inline retype_functor<bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-retype(const bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_functor)
-{ return retype_functor<bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_const_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-inline retype_functor<bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-retype(const bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_functor)
-{ return retype_functor<bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6 >
-    (_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_functor which performs C-style casts on the parameters passed on to the functor.
- * This function template specialization works on sigc::bound_const_volatile_mem_functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing C-style casts on the paramters passed on.
- *
- * @ingroup retype
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-inline retype_functor<bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-retype(const bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_functor)
-{ return retype_functor<bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7>, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7 >
-    (_A_functor); }
-
-
-} /* namespace sigc */
-#endif /* _SIGC_ADAPTORS_MACROS_RETYPEHM4_ */
Index: stardict-3.0.1/src/sigc++/adaptors/retype_return.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/adaptors/retype_return.h
+++ /dev/null
@@ -1,309 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-#ifndef _SIGC_ADAPTORS_MACROS_RETYPE_RETURNHM4_
-#define _SIGC_ADAPTORS_MACROS_RETYPE_RETURNHM4_
-#include <sigc++/adaptors/adaptor_trait.h>
-
-namespace sigc {
-
-/** Adaptor that perform a C-style cast on the return value of a functor.
- * Use the convenience function sigc::retype_return() to create an instance of retype_return_functor.
- *
- * The following template arguments are used:
- * - @e T_return Target type of the C-style cast.
- * - @e T_functor Type of the functor to wrap.
- *
- * @ingroup retype
- */
-template <class T_return, class T_functor>
-struct retype_return_functor : public adapts<T_functor>
-{
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef T_return type; };
-  typedef T_return result_type;
-
-  T_return operator()();
-
-  template <class T_arg1>
-  inline T_return operator()(T_arg1 _A_a1)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-        (_A_a1));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  inline T_return sun_forte_workaround(T_arg1 _A_a1)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-        (_A_a1));
-    }
-  #endif
-    
-  template <class T_arg1,class T_arg2>
-  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-        (_A_a1,_A_a2));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  inline T_return sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-        (_A_a1,_A_a2));
-    }
-  #endif
-    
-  template <class T_arg1,class T_arg2,class T_arg3>
-  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-        (_A_a1,_A_a2,_A_a3));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  inline T_return sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-        (_A_a1,_A_a2,_A_a3));
-    }
-  #endif
-    
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  inline T_return sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4));
-    }
-  #endif
-    
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  inline T_return sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5));
-    }
-  #endif
-    
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  inline T_return sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6));
-    }
-  #endif
-    
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  inline T_return sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7));
-    }
-  #endif
-    
-  retype_return_functor() {}
-
-  /** Constructs a retype_return_functor object that perform a C-style cast on the return value of the passed functor.
-   * @param _A_functor Functor to invoke from operator()().
-   */
-  explicit retype_return_functor(typename type_trait<T_functor>::take _A_functor)
-    : adapts<T_functor>(_A_functor)
-    {}
-};
-
-template <class T_return, class T_functor>
-T_return retype_return_functor<T_return, T_functor>::operator()()
-  { return T_return(this->functor_()); }
-
-
-/** Adaptor that perform a C-style cast on the return value of a functor.
- * This template specialization is for a void return. It drops the return value of the functor it invokes.
- * Use the convenience function sigc::hide_return() to create an instance of sigc::retype_return_functor<void>.
- *
- * @ingroup retype
- */
-/* The void specialization needed because of explicit cast to T_return.
- */
-template <class T_functor>
-struct retype_return_functor<void, T_functor> : public adapts<T_functor>
-{
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef void type; };
-  typedef void result_type;
-
-  void operator()();
-
-  template <class T_arg1>
-  inline void operator()(T_arg1 _A_a1)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-        (_A_a1);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  inline void sun_forte_workaround(T_arg1 _A_a1)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass>
-        (_A_a1);
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2>
-  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-        (_A_a1,_A_a2);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  inline void sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass>
-        (_A_a1,_A_a2);
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3>
-  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-        (_A_a1,_A_a2,_A_a3);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  inline void sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass>
-        (_A_a1,_A_a2,_A_a3);
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  inline void sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4);
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  inline void sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  inline void sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
-    }
-  #endif
-
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  inline void sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
-    { this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::pass,typename type_trait<T_arg2>::pass,typename type_trait<T_arg3>::pass,typename type_trait<T_arg4>::pass,typename type_trait<T_arg5>::pass,typename type_trait<T_arg6>::pass,typename type_trait<T_arg7>::pass>
-        (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
-    }
-  #endif
-
-  retype_return_functor() {}
-  retype_return_functor(typename type_trait<T_functor>::take _A_functor)
-    : adapts<T_functor>(_A_functor)
-    {}
-};
-
-template <class T_functor>
-void retype_return_functor<void, T_functor>::operator()()
-  { this->functor_(); }
-
-  
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::retype_return_functor performs a functor on the
- * functor stored in the sigc::retype_return_functor object.
- *
- * @ingroup retype
- */
-template <class T_action, class T_return, class T_functor>
-void visit_each(const T_action& _A_action,
-                const retype_return_functor<T_return, T_functor>& _A_target)
-{
-  visit_each(_A_action, _A_target.functor_);
-}
-
-
-/** Creates an adaptor of type sigc::retype_return_functor which performs a C-style cast on the return value of the passed functor.
- * The template argument @e T_return specifies the target type of the cast.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor performing a C-style casts on the return value.
- *
- * @ingroup retype
- */
-template <class T_return, class T_functor>
-inline retype_return_functor<T_return, T_functor>
-retype_return(const T_functor& _A_functor)
-  { return retype_return_functor<T_return, T_functor>(_A_functor); }
-
-/** Creates an adaptor of type sigc::retype_return_functor which drops the return value of the passed functor.
- *
- * @param _A_functor Functor that should be wrapped.
- * @return Adaptor that executes @e _A_functor dropping its return value.
- *
- * @ingroup hide
- */
-template <class T_functor>
-inline retype_return_functor<void, T_functor>
-hide_return(const T_functor& _A_functor)
-  { return retype_return_functor<void, T_functor>(_A_functor); }
-
-} /* namespace sigc */
-#endif /* _SIGC_ADAPTORS_MACROS_RETYPE_RETURNHM4_ */
Index: stardict-3.0.1/src/sigc++/bind.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/bind.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#ifndef _SIGC_BIND_HPP_
-#define _SIGC_BIND_HPP_
-
-#include <sigc++/adaptors/bind.h>
-
-#ifndef LIBSIGC_DISABLE_DEPRECATED
-
-namespace SigC {
-
-template <class T_bound1, class T_functor>
-inline ::sigc::bind_functor<-1, T_functor,
-                            typename ::sigc::unwrap_reference<T_bound1>::type>
-bind(const T_functor& _A_functor, T_bound1 _A_b1)
-{ return ::sigc::bind_functor<-1, T_functor,
-                              typename ::sigc::unwrap_reference<T_bound1>::type>
-                              (_A_functor, _A_b1);
-}
-
-template <class T_bound1, class T_bound2, class T_functor>
-inline ::sigc::bind_functor<-1, T_functor,
-                            typename ::sigc::unwrap_reference<T_bound1>::type,
-                            typename ::sigc::unwrap_reference<T_bound2>::type>
-bind(const T_functor& _A_functor, T_bound1 _A_b1, T_bound2 _A_b2)
-{ return ::sigc::bind_functor<-1, T_functor,
-                              typename ::sigc::unwrap_reference<T_bound1>::type,
-                              typename ::sigc::unwrap_reference<T_bound2>::type>
-                              (_A_functor, _A_b1, _A_b2); 
-}
-
-template <class T_bound1, class T_bound2, class T_bound3, class T_functor>
-inline ::sigc::bind_functor<-1, T_functor,
-                            typename ::sigc::unwrap_reference<T_bound1>::type,
-                            typename ::sigc::unwrap_reference<T_bound2>::type,
-                            typename ::sigc::unwrap_reference<T_bound3>::type>
-bind(const T_functor& _A_functor, T_bound1 _A_b1, T_bound2 _A_b2,T_bound3 _A_b3)
-{ return ::sigc::bind_functor<-1, T_functor,
-                              typename ::sigc::unwrap_reference<T_bound1>::type,
-                              typename ::sigc::unwrap_reference<T_bound2>::type,
-                              typename ::sigc::unwrap_reference<T_bound3>::type>
-                              (_A_functor, _A_b1, _A_b2, _A_b3);
-}
-
-}
-
-#endif /* LIBSIGC_DISABLE_DEPRECATED */
-
-#endif /* _SIGC_BIND_HPP_ */
Index: stardict-3.0.1/src/sigc++/bind_return.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/bind_return.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#ifndef _SIGC_BIND_RETURN_HPP_
-#define _SIGC_BIND_RETURN_HPP_
-
-#include <sigc++/adaptors/bind_return.h>
-
-#ifndef LIBSIGC_DISABLE_DEPRECATED
-
-namespace SigC {
-
-using ::sigc::bind_return;
-
-}
-
-#endif /* LIBSIGC_DISABLE_DEPRECATED */
-
-#endif /* _SIGC_BIND_RETURN_HPP_ */
Index: stardict-3.0.1/src/sigc++/class_slot.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/class_slot.h
+++ /dev/null
@@ -1,568 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-
-
-#ifndef _SIGC_MACROS_CLASS_SLOTHM4_
-#define _SIGC_MACROS_CLASS_SLOTHM4_
-
-#include <sigc++/slot.h>
-#include <sigc++/functors/mem_fun.h>
-
-#ifndef LIBSIGC_DISABLE_DEPRECATED
-
-namespace SigC {
-
-// slot_class()
-/** Creates a functor of type SigC::Slot0 that encapsulates a  method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_obj>
-inline Slot0<T_return>
-slot_class( T_obj& _A_obj, T_return (T_obj::*_A_func)() )
-{ return ::sigc::bound_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot1 that encapsulates a  method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1, class T_obj>
-inline Slot1<T_return, T_arg1>
-slot_class( T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1) )
-{ return ::sigc::bound_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot2 that encapsulates a  method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2, class T_obj>
-inline Slot2<T_return, T_arg1,T_arg2>
-slot_class( T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2) )
-{ return ::sigc::bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot3 that encapsulates a  method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_obj>
-inline Slot3<T_return, T_arg1,T_arg2,T_arg3>
-slot_class( T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) )
-{ return ::sigc::bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot4 that encapsulates a  method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_obj>
-inline Slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4>
-slot_class( T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) )
-{ return ::sigc::bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot5 that encapsulates a  method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_obj>
-inline Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-slot_class( T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) )
-{ return ::sigc::bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot6 that encapsulates a  method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_obj>
-inline Slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-slot_class( T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) )
-{ return ::sigc::bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot7 that encapsulates a  method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_obj>
-inline Slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-slot_class( T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) )
-{ return ::sigc::bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-
-/** Creates a functor of type SigC::Slot0 that encapsulates a const method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_obj>
-inline Slot0<T_return>
-slot_class(const T_obj& _A_obj, T_return (T_obj::*_A_func)() const)
-{ return ::sigc::bound_const_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot1 that encapsulates a const method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1, class T_obj>
-inline Slot1<T_return, T_arg1>
-slot_class(const T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1) const)
-{ return ::sigc::bound_const_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot2 that encapsulates a const method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2, class T_obj>
-inline Slot2<T_return, T_arg1,T_arg2>
-slot_class(const T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2) const)
-{ return ::sigc::bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot3 that encapsulates a const method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_obj>
-inline Slot3<T_return, T_arg1,T_arg2,T_arg3>
-slot_class(const T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) const)
-{ return ::sigc::bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot4 that encapsulates a const method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_obj>
-inline Slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4>
-slot_class(const T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const)
-{ return ::sigc::bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot5 that encapsulates a const method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_obj>
-inline Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-slot_class(const T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const)
-{ return ::sigc::bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot6 that encapsulates a const method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_obj>
-inline Slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-slot_class(const T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const)
-{ return ::sigc::bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot7 that encapsulates a const method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_obj>
-inline Slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-slot_class(const T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const)
-{ return ::sigc::bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-
-/** Creates a functor of type SigC::Slot0 that encapsulates a volatile method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_obj>
-inline Slot0<T_return>
-slot_class( T_obj& _A_obj, T_return (T_obj::*_A_func)() volatile)
-{ return ::sigc::bound_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot1 that encapsulates a volatile method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1, class T_obj>
-inline Slot1<T_return, T_arg1>
-slot_class( T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1) volatile)
-{ return ::sigc::bound_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot2 that encapsulates a volatile method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2, class T_obj>
-inline Slot2<T_return, T_arg1,T_arg2>
-slot_class( T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2) volatile)
-{ return ::sigc::bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot3 that encapsulates a volatile method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_obj>
-inline Slot3<T_return, T_arg1,T_arg2,T_arg3>
-slot_class( T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) volatile)
-{ return ::sigc::bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot4 that encapsulates a volatile method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_obj>
-inline Slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4>
-slot_class( T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile)
-{ return ::sigc::bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot5 that encapsulates a volatile method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_obj>
-inline Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-slot_class( T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile)
-{ return ::sigc::bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot6 that encapsulates a volatile method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_obj>
-inline Slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-slot_class( T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile)
-{ return ::sigc::bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot7 that encapsulates a volatile method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_obj>
-inline Slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-slot_class( T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile)
-{ return ::sigc::bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-
-/** Creates a functor of type SigC::Slot0 that encapsulates a const volatile method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_obj>
-inline Slot0<T_return>
-slot_class(const T_obj& _A_obj, T_return (T_obj::*_A_func)() const volatile)
-{ return ::sigc::bound_const_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot1 that encapsulates a const volatile method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1, class T_obj>
-inline Slot1<T_return, T_arg1>
-slot_class(const T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1) const volatile)
-{ return ::sigc::bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot2 that encapsulates a const volatile method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2, class T_obj>
-inline Slot2<T_return, T_arg1,T_arg2>
-slot_class(const T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2) const volatile)
-{ return ::sigc::bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot3 that encapsulates a const volatile method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_obj>
-inline Slot3<T_return, T_arg1,T_arg2,T_arg3>
-slot_class(const T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) const volatile)
-{ return ::sigc::bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot4 that encapsulates a const volatile method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_obj>
-inline Slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4>
-slot_class(const T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile)
-{ return ::sigc::bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot5 that encapsulates a const volatile method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_obj>
-inline Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-slot_class(const T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile)
-{ return ::sigc::bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot6 that encapsulates a const volatile method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_obj>
-inline Slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-slot_class(const T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile)
-{ return ::sigc::bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot7 that encapsulates a const volatile method and an object instance.
- *
- * This function is part of the compatibility module and therefore deprecated.
- * Use sigc::mem_fun() instead.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_obj>
-inline Slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-slot_class(const T_obj& _A_obj, T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const volatile)
-{ return ::sigc::bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-
-
-}
-
-#endif
-#endif /* _SIGC_MACROS_CLASS_SLOTHM4_ */
Index: stardict-3.0.1/src/sigc++/compatibility.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/compatibility.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#ifndef _SIGC_COMPATIBILITY_HPP_
-#define _SIGC_COMPATIBILITY_HPP_
-
-#include <sigc++/signal.h>
-#include <sigc++/connection.h>
-#include <sigc++/object_slot.h>
-
-#ifndef LIBSIGC_DISABLE_DEPRECATED
-
-namespace SigC {
-
-/** @defgroup compat Compatibility module
- * This set of types and functions provides an API that is compatible to
- * libsigc++-1.2. Some internal structures of libsigc++-1.2 are not available.
- *
- * All types and functions that are defined in namespace SigC are deprecated.
- * Use the new libsigc++2 API that is defined in namespace sigc.
- */
-
-}
-
-#endif /* LIBSIGC_DISABLE_DEPRECATED */
-
-#endif /* _SIGC_COMPATIBILITY_HPP_ */
Index: stardict-3.0.1/src/sigc++/connection.cc
===================================================================
--- stardict-3.0.1.orig/src/sigc++/connection.cc
+++ /dev/null
@@ -1,111 +0,0 @@
-// -*- c++ -*-
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-
-#include <sigc++/connection.h>
-using namespace std;
-
-namespace sigc {
-
-connection::connection()
-: slot_(0)
-{}
-
-connection::connection(const connection& c)
-: slot_(c.slot_)
-{
-  //Let the connection forget about the signal handler when the handler object dies:
-  if (slot_)
-    slot_->add_destroy_notify_callback(this, &notify);
-}
-
-connection::connection(slot_base& sl)
-: slot_(&sl)
-{
-  //Let the connection forget about the signal handler when the handler object dies:
-  slot_->add_destroy_notify_callback(this, &notify);
-}
-
-connection& connection::operator=(const connection& c)
-{
-  set_slot(c.slot_);
-  return *this;
-}
-
-connection::~connection()
-{
-  if (slot_)
-    slot_->remove_destroy_notify_callback(this);
-}
-
-bool connection::empty() const
-{
-  return (!slot_ || slot_->empty());
-}
-
-bool connection::connected() const
-{
-  return !empty();
-}
-
-bool connection::blocked() const
-{
-  return (slot_ ? slot_->blocked() : false);
-}
-
-bool connection::block(bool should_block)
-{
-  return (slot_ ? slot_->block(should_block) : false);
-}
-
-bool connection::unblock()
-{
-  return (slot_ ? slot_->unblock() : false);
-}
-
-void connection::disconnect()
-{
-  if (slot_)
-    slot_->disconnect(); // This notifies slot_'s parent.
-} 
-
-connection::operator bool()
-{
-  return !empty();
-}
-    
-void connection::set_slot(slot_base* sl)
-{
-  if (slot_)
-    slot_->remove_destroy_notify_callback(this);
-
-  slot_ = sl;
-
-  if (slot_)
-    slot_->add_destroy_notify_callback(this, &notify);
-}
-
-void* connection::notify(void* data)
-{
-  connection* self = reinterpret_cast<connection*>(data);
-  self->slot_ = 0;
-  return 0;
-}
-
-} /* namespace sigc */
Index: stardict-3.0.1/src/sigc++/connection.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/connection.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#ifndef _SIGC_CONNECTION_HPP_
-#define _SIGC_CONNECTION_HPP_
-#include <sigc++config.h>
-#include <sigc++/signal.h>
-
-namespace sigc {
-
-/** Convinience class for safe disconnection.
- * Iterators must not be used beyond the lifetime of the list
- * they work on. A connection object can be created from a
- * slot list iterator and may safely be used to disconnect
- * the referred slot at any time (disconnect()). If the slot
- * has already been destroyed, disconnect() does nothing. empty() or
- * operator bool() can be used to test whether the connection is
- * still active. The connection can be blocked (block(), unblock()).
- *
- * This is possible because the connection object gets notified
- * when the referred slot dies (notify()).
- *
- * @ingroup signal
- */
-struct SIGC_API connection
-{
-  /** Constructs an empty connection object. */
-  connection();
-
-  /** Constructs a connection object copying an existing one.
-   * @param c The connection object to make a copy from.
-   */
-  connection(const connection& c);
-
-  /** Constructs a connection object from a slot list iterator.
-   * @param it The slot list iterator to take the slot from.
-   */
-  template <typename T_slot>
-  connection(const slot_iterator<T_slot>& it) : slot_(&(*it))
-    { if (slot_) slot_->add_destroy_notify_callback(this, &notify); }
-
-  /** Constructs a connection object from a slot object.
-   * This is only useful if you create your own slot list.
-   * @param sl The slot to operate on.
-   */
-  explicit connection(slot_base& sl);
-
-  /** Overrides this connection object copying another one.
-   * @param c The connection object to make a copy from.
-   */
-  connection& operator=(const connection& c);
-
-  /** Overrides this connection object with another slot list iterator.
-   * @param it The new slot list iterator to take the slot from.
-   */
-  template <typename T_slot>
-  connection& operator=(const slot_iterator<T_slot>& it)
-    { set_slot(&(*it)); return *this; }
-
-  ~connection();
-
-  /** Returns whether the connection is still active.
-   * @return @p false if the connection is still active.
-   */
-  bool empty() const;
-
-  /** Returns whether the connection is still active.
-   * @return @p true if the connection is still active.
-   */
-  bool connected() const;
-
-  /** Returns whether the connection is blocked.
-   * @return @p true if the connection is blocked.
-   */
-  bool blocked() const;
-
-  /** Sets or unsets the blocking state of this connection.
-   * See slot_base::block() for details.
-   * @param should_block Indicates whether the blocking state should be set or unset.
-   * @return @p true if the connection has been in blocking state before.
-   */
-  bool block(bool should_block = true);
-
-  /** Unsets the blocking state of this connection.
-   * @return @p true if the connection has been in blocking state before.
-   */
-  bool unblock();
-
-  /// Disconnects the referred slot.
-  void disconnect();
-
-  /** Returns whether the connection is still active.
-   * @return @p true if the connection is still active.
-   */
-  operator bool();
-
-  /** Callback that is executed when the referred slot is destroyed.
-   * @param d The connection object notified (@p this).
-   */
-  static void* notify(void* data);
-
-private:
-  void set_slot(slot_base* sl);
-
-  /* Referred slot. Set to zero from notify().
-   * A value of zero indicates an "empty" connection.
-   */
-  slot_base* slot_;
-};
-
-} /* namespace sigc */
-
-
-#ifndef LIBSIGC_DISABLE_DEPRECATED
-
-namespace SigC {
-
-/** Convinience class for safe disconnection.
- * Iterators must not be used beyond the lifetime of the list
- * they work on. A connection object can be created from a
- * slot list iterator and may safely be used to disconnect
- * the referred slot at any time (disconnect()). If the slot
- * has already been destroyed, disconnect() does nothing. empty() or
- * operator bool() can be used to test whether the connection is
- * still active. The connection can be blocked (block(), unblock()).
- *
- * This is possible because the connection object gets notified
- * when the referred slot dies (notify()).
- *
- * @deprecated Use sigc::connection instead.
- * @ingroup compat
- */
-typedef ::sigc::connection Connection;
-
-}
-
-#endif /* LIBSIGC_DISABLE_DEPRECATED */
-
-#endif /* _SIGC_TRACKABLE_HPP_ */
Index: stardict-3.0.1/src/sigc++/functors/functors.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/functors/functors.h
+++ /dev/null
@@ -1,27 +0,0 @@
-// -*- c++ -*-
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#ifndef _SIGC_FUNCTOR_HPP_
-#define _SIGC_FUNCTOR_HPP_
-
-#include <sigc++/functors/slot.h>
-#include <sigc++/functors/ptr_fun.h>
-#include <sigc++/functors/mem_fun.h>
-
-#endif /* _SIGC_FUNCTOR_HPP_ */
Index: stardict-3.0.1/src/sigc++/functors/functor_trait.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/functors/functor_trait.h
+++ /dev/null
@@ -1,307 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-/*
-  Trait functor_trait<functor>:
-
-  This trait allows the user to specific what is the return type
-  of any type. It has been overloaded to detect the return type and
-  the functor version of function pointers and class methods as well.
-
-  To populate the return type of user defined and third party functors
-  use the macro SIGC_FUNCTOR_TRAIT(T_functor,T_return) in
-  namespace sigc. Multi-type functors are only partly supported.
-  Try specifying the return type of the functor's operator()() overload.
-
-  Alternatively, you can derive your functors from functor_base and
-  place "typedef T_return result_type;" in the class definition.
-
-  Use SIGC_FUNCTORS_HAVE_RESULT_TYPE if you want sigc++ to assume that
-  result_type is defined in all user defined or 3rd-party functors
-  (except those you specify a return type explicitly with SIGC_FUNCTOR_TRAIT()).
-
-*/
-#ifndef _SIGC_FUNCTORS_MACROS_FUNCTOR_TRAITHM4_
-#define _SIGC_FUNCTORS_MACROS_FUNCTOR_TRAITHM4_
-#include <sigc++/type_traits.h>
-
-
-namespace sigc {
-
-/** nil struct type.
- * The nil struct type is used as default template argument in the
- * unnumbered sigc::signal and sigc::slot templates.
- *
- * @ingroup signal
- * @ingroup slot
- */
-struct nil;
-
-
-/** @defgroup functors Functors
- * Functors are copyable types that define operator()().
- *
- * Types that define operator()() overloads with different return types are referred to
- * as multi-type functors. Multi-type functors are only partly supported in libsigc++.
- *
- * Closures are functors that store all information needed to invoke a callback from operator()().
- *
- * Adaptors are functors that alter the signature of a functor's operator()().
- *
- * libsigc++ defines numerous functors, closures and adaptors.
- * Since libsigc++ is a callback libaray, most functors are also closures.
- * The documentation doesn't distinguish between functors and closures.
- *
- * The basic functor types libsigc++ provides are created with ptr_fun() and mem_fun()
- * and can be converted into slots implicitly.
- * The set of adaptors that ships with libsigc++ is documented in the equally named module. 
- */
-
-/** A hint to the compiler.
- * All functors which define @p result_type should publically inherit from this hint.
- *
- * @ingroup functors
- */
-struct functor_base {};
-
-
-template <class T_functor, bool I_derives_functor_base=is_base_and_derived<functor_base,T_functor>::value>
-struct functor_trait
-{
-  typedef void result_type;
-  typedef T_functor functor_type;
-};
-
-template <class T_functor>
-struct functor_trait<T_functor,true>
-{
-  typedef typename T_functor::result_type result_type;
-  typedef T_functor functor_type;
-};
-
-/** If you want to mix functors from a different library with libsigc++ and
- * these functors define @p result_type simply use this macro inside namespace sigc like so:
- * @code
- * namespace sigc { SIGC_FUNCTORS_HAVE_RESULT_TYPE }
- * @endcode
- *
- * @ingroup functors
- */
-#define SIGC_FUNCTORS_HAVE_RESULT_TYPE                 \
-template <class T_functor>                             \
-struct functor_trait<T_functor,false>                  \
-{                                                      \
-  typedef typename T_functor::result_type result_type; \
-  typedef T_functor functor_type;                      \
-};
-
-/** If you want to mix functors from a different library with libsigc++ and
- * these functors don't define @p result_type use this macro inside namespace sigc
- * to expose the return type of the functors like so:
- * @code
- * namespace sigc {
- *   SIGC_FUNCTOR_TRAIT(first_functor_type, return_type_of_first_functor_type)
- *   SIGC_FUNCTOR_TRAIT(second_functor_type, return_type_of_second_functor_type)
- *   ...
- * }
- * @endcode
- *
- * @ingroup functors
- */
-#define SIGC_FUNCTOR_TRAIT(T_functor,T_return) \
-template <>                                    \
-struct functor_trait<T_functor,false>          \
-{                                              \
-  typedef T_return result_type;                \
-  typedef T_functor functor_type;              \
-};
-
-// detect the return type and the functor version of non-functor types.
-template <class T_return> class pointer_functor0;
-template <class T_return>
-struct functor_trait<T_return (*)(), false>
-{
-  typedef T_return result_type;
-  typedef pointer_functor0<T_return> functor_type;
-};
-
-template <class T_arg1, class T_return> class pointer_functor1;
-template <class T_arg1, class T_return>
-struct functor_trait<T_return (*)(T_arg1), false>
-{
-  typedef T_return result_type;
-  typedef pointer_functor1<T_arg1, T_return> functor_type;
-};
-
-template <class T_arg1,class T_arg2, class T_return> class pointer_functor2;
-template <class T_arg1,class T_arg2, class T_return>
-struct functor_trait<T_return (*)(T_arg1,T_arg2), false>
-{
-  typedef T_return result_type;
-  typedef pointer_functor2<T_arg1,T_arg2, T_return> functor_type;
-};
-
-template <class T_arg1,class T_arg2,class T_arg3, class T_return> class pointer_functor3;
-template <class T_arg1,class T_arg2,class T_arg3, class T_return>
-struct functor_trait<T_return (*)(T_arg1,T_arg2,T_arg3), false>
-{
-  typedef T_return result_type;
-  typedef pointer_functor3<T_arg1,T_arg2,T_arg3, T_return> functor_type;
-};
-
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return> class pointer_functor4;
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return>
-struct functor_trait<T_return (*)(T_arg1,T_arg2,T_arg3,T_arg4), false>
-{
-  typedef T_return result_type;
-  typedef pointer_functor4<T_arg1,T_arg2,T_arg3,T_arg4, T_return> functor_type;
-};
-
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return> class pointer_functor5;
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return>
-struct functor_trait<T_return (*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5), false>
-{
-  typedef T_return result_type;
-  typedef pointer_functor5<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_return> functor_type;
-};
-
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return> class pointer_functor6;
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return>
-struct functor_trait<T_return (*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6), false>
-{
-  typedef T_return result_type;
-  typedef pointer_functor6<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_return> functor_type;
-};
-
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return> class pointer_functor7;
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return>
-struct functor_trait<T_return (*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7), false>
-{
-  typedef T_return result_type;
-  typedef pointer_functor7<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_return> functor_type;
-};
-
-
-template <class T_return, class T_obj> class mem_functor0;
-template <class T_return, class T_obj> class const_mem_functor0;
-template <class T_return, class T_obj>
-struct functor_trait<T_return (T_obj::*)(), false>
-{
-  typedef T_return result_type;
-  typedef mem_functor0<T_return, T_obj> functor_type;
-};
-template <class T_return, class T_obj>
-struct functor_trait<T_return (T_obj::*)() const, false>
-{
-  typedef T_return result_type;
-  typedef const_mem_functor0<T_return, T_obj> functor_type;
-};
-
-template <class T_arg1, class T_return, class T_obj> class mem_functor1;
-template <class T_arg1, class T_return, class T_obj> class const_mem_functor1;
-template <class T_arg1, class T_return, class T_obj>
-struct functor_trait<T_return (T_obj::*)(T_arg1), false>
-{
-  typedef T_return result_type;
-  typedef mem_functor1<T_arg1, T_return, T_obj> functor_type;
-};
-template <class T_arg1, class T_return, class T_obj>
-struct functor_trait<T_return (T_obj::*)(T_arg1) const, false>
-{
-  typedef T_return result_type;
-  typedef const_mem_functor1<T_arg1, T_return, T_obj> functor_type;
-};
-
-template <class T_arg1,class T_arg2, class T_return, class T_obj> class mem_functor2;
-template <class T_arg1,class T_arg2, class T_return, class T_obj> class const_mem_functor2;
-template <class T_arg1,class T_arg2, class T_return, class T_obj>
-struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2), false>
-{
-  typedef T_return result_type;
-  typedef mem_functor2<T_arg1,T_arg2, T_return, T_obj> functor_type;
-};
-template <class T_arg1,class T_arg2, class T_return, class T_obj>
-struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2) const, false>
-{
-  typedef T_return result_type;
-  typedef const_mem_functor2<T_arg1,T_arg2, T_return, T_obj> functor_type;
-};
-
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj> class mem_functor3;
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj> class const_mem_functor3;
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
-struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3), false>
-{
-  typedef T_return result_type;
-  typedef mem_functor3<T_arg1,T_arg2,T_arg3, T_return, T_obj> functor_type;
-};
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
-struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3) const, false>
-{
-  typedef T_return result_type;
-  typedef const_mem_functor3<T_arg1,T_arg2,T_arg3, T_return, T_obj> functor_type;
-};
-
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj> class mem_functor4;
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj> class const_mem_functor4;
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
-struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3,T_arg4), false>
-{
-  typedef T_return result_type;
-  typedef mem_functor4<T_arg1,T_arg2,T_arg3,T_arg4, T_return, T_obj> functor_type;
-};
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
-struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3,T_arg4) const, false>
-{
-  typedef T_return result_type;
-  typedef const_mem_functor4<T_arg1,T_arg2,T_arg3,T_arg4, T_return, T_obj> functor_type;
-};
-
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj> class mem_functor5;
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj> class const_mem_functor5;
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
-struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5), false>
-{
-  typedef T_return result_type;
-  typedef mem_functor5<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_return, T_obj> functor_type;
-};
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
-struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const, false>
-{
-  typedef T_return result_type;
-  typedef const_mem_functor5<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_return, T_obj> functor_type;
-};
-
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj> class mem_functor6;
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj> class const_mem_functor6;
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
-struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6), false>
-{
-  typedef T_return result_type;
-  typedef mem_functor6<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_return, T_obj> functor_type;
-};
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
-struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const, false>
-{
-  typedef T_return result_type;
-  typedef const_mem_functor6<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_return, T_obj> functor_type;
-};
-
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj> class mem_functor7;
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj> class const_mem_functor7;
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
-struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7), false>
-{
-  typedef T_return result_type;
-  typedef mem_functor7<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_return, T_obj> functor_type;
-};
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
-struct functor_trait<T_return (T_obj::*)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const, false>
-{
-  typedef T_return result_type;
-  typedef const_mem_functor7<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_return, T_obj> functor_type;
-};
-
-
-
-} /* namespace sigc */
-#endif /* _SIGC_FUNCTORS_MACROS_FUNCTOR_TRAITHM4_ */
Index: stardict-3.0.1/src/sigc++/functors/mem_fun.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/functors/mem_fun.h
+++ /dev/null
@@ -1,6201 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-
-
-// implementation notes:  
-//  - we do not use bind here, because it would introduce
-//    an extra copy and complicate the header include order if bind is
-//    to have automatic conversion for member pointers.
-#ifndef _SIGC_FUNCTORS_MACROS_MEM_FUNHM4_
-#define _SIGC_FUNCTORS_MACROS_MEM_FUNHM4_
-#include <sigc++/type_traits.h>
-#include <sigc++/functors/functor_trait.h>
-#include <sigc++/limit_reference.h>
-
-namespace sigc {
-
-/** @defgroup mem_fun mem_fun()
- * mem_fun() is used to convert a pointer to a method to a functor.
- *
- * Optionally a reference or pointer to an object can be bound to the functor.
- * Note that only if the object type inherits from sigc::trackable
- * the slot is cleared automatically when the object goes out of scope!
- *
- * If the member function pointer is to an overloaded type, you must specify
- * the types using template arguments starting with the first argument.
- * It is not necessary to supply the return type.
- *
- * @par Example:
- *   @code
- *   struct foo : public sigc::trackable
- *   {
- *     void bar(int) {}
- *   };
- *   foo my_foo;
- *   sigc::slot<void, int> sl = sigc::mem_fun(my_foo, &foo::bar);
- *   @endcode
- *
- * For const methods mem_fun() takes a const reference or pointer to an object.
- *
- * @par Example:
- *   @code
- *   struct foo : public sigc::trackable
- *   {
- *     void bar(int) const {}
- *   };
- *   const foo my_foo;
- *   sigc::slot<void, int> sl = sigc::mem_fun(my_foo, &foo::bar);
- *   @endcode
- *
- * Use mem_fun#() if there is an abiguity as to the number of arguments.
- *
- * @par Example:
- *   @code
- *   struct foo : public sigc::trackable
- *   {
- *     void bar(int) {}
- *     void bar(float) {}
- *     void bar(int, int) {}
- *   };
- *   foo my_foo;
- *   sigc::slot<void, int> sl = sigc::mem_fun1<int>(my_foo, &foo::bar);
- *   @endcode
- *
- * @ingroup functors
- */
-
-/** mem_functor0 wraps  methods with 0 argument(s).
- * Use the convenience function mem_fun() to create an instance of mem_functor0.
- *
- * The following template arguments are used:
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj>
-class mem_functor0 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)() ;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  mem_functor0() : func_ptr_(0) {}
-
-  /** Constructs a mem_functor0 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit mem_functor0(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj* _A_obj) const
-    { return (_A_obj->*(this->func_ptr_))(); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj& _A_obj) const
-    { return (_A_obj.*func_ptr_)(); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** mem_functor1 wraps  methods with 1 argument(s).
- * Use the convenience function mem_fun() to create an instance of mem_functor1.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1>
-class mem_functor1 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1) ;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  mem_functor1() : func_ptr_(0) {}
-
-  /** Constructs a mem_functor1 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit mem_functor1(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1) const
-    { return (_A_obj.*func_ptr_)(_A_a1); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** mem_functor2 wraps  methods with 2 argument(s).
- * Use the convenience function mem_fun() to create an instance of mem_functor2.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2>
-class mem_functor2 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2) ;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  mem_functor2() : func_ptr_(0) {}
-
-  /** Constructs a mem_functor2 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit mem_functor2(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** mem_functor3 wraps  methods with 3 argument(s).
- * Use the convenience function mem_fun() to create an instance of mem_functor3.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-class mem_functor3 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3) ;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  mem_functor3() : func_ptr_(0) {}
-
-  /** Constructs a mem_functor3 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit mem_functor3(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** mem_functor4 wraps  methods with 4 argument(s).
- * Use the convenience function mem_fun() to create an instance of mem_functor4.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-class mem_functor4 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4) ;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  mem_functor4() : func_ptr_(0) {}
-
-  /** Constructs a mem_functor4 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit mem_functor4(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** mem_functor5 wraps  methods with 5 argument(s).
- * Use the convenience function mem_fun() to create an instance of mem_functor5.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-class mem_functor5 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) ;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  mem_functor5() : func_ptr_(0) {}
-
-  /** Constructs a mem_functor5 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit mem_functor5(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** mem_functor6 wraps  methods with 6 argument(s).
- * Use the convenience function mem_fun() to create an instance of mem_functor6.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-class mem_functor6 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) ;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  mem_functor6() : func_ptr_(0) {}
-
-  /** Constructs a mem_functor6 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit mem_functor6(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** mem_functor7 wraps  methods with 7 argument(s).
- * Use the convenience function mem_fun() to create an instance of mem_functor7.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_arg7 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-class mem_functor7 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) ;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  mem_functor7() : func_ptr_(0) {}
-
-  /** Constructs a mem_functor7 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit mem_functor7(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @param _A_a7 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @param _A_a7 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** const_mem_functor0 wraps const methods with 0 argument(s).
- * Use the convenience function mem_fun() to create an instance of const_mem_functor0.
- *
- * The following template arguments are used:
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj>
-class const_mem_functor0 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)() const;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  const_mem_functor0() : func_ptr_(0) {}
-
-  /** Constructs a const_mem_functor0 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit const_mem_functor0(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj* _A_obj) const
-    { return (_A_obj->*(this->func_ptr_))(); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj& _A_obj) const
-    { return (_A_obj.*func_ptr_)(); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** const_mem_functor1 wraps const methods with 1 argument(s).
- * Use the convenience function mem_fun() to create an instance of const_mem_functor1.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1>
-class const_mem_functor1 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1) const;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  const_mem_functor1() : func_ptr_(0) {}
-
-  /** Constructs a const_mem_functor1 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit const_mem_functor1(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1) const
-    { return (_A_obj.*func_ptr_)(_A_a1); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** const_mem_functor2 wraps const methods with 2 argument(s).
- * Use the convenience function mem_fun() to create an instance of const_mem_functor2.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2>
-class const_mem_functor2 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2) const;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  const_mem_functor2() : func_ptr_(0) {}
-
-  /** Constructs a const_mem_functor2 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit const_mem_functor2(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** const_mem_functor3 wraps const methods with 3 argument(s).
- * Use the convenience function mem_fun() to create an instance of const_mem_functor3.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-class const_mem_functor3 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3) const;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  const_mem_functor3() : func_ptr_(0) {}
-
-  /** Constructs a const_mem_functor3 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit const_mem_functor3(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** const_mem_functor4 wraps const methods with 4 argument(s).
- * Use the convenience function mem_fun() to create an instance of const_mem_functor4.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-class const_mem_functor4 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4) const;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  const_mem_functor4() : func_ptr_(0) {}
-
-  /** Constructs a const_mem_functor4 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit const_mem_functor4(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** const_mem_functor5 wraps const methods with 5 argument(s).
- * Use the convenience function mem_fun() to create an instance of const_mem_functor5.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-class const_mem_functor5 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  const_mem_functor5() : func_ptr_(0) {}
-
-  /** Constructs a const_mem_functor5 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit const_mem_functor5(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** const_mem_functor6 wraps const methods with 6 argument(s).
- * Use the convenience function mem_fun() to create an instance of const_mem_functor6.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-class const_mem_functor6 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  const_mem_functor6() : func_ptr_(0) {}
-
-  /** Constructs a const_mem_functor6 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit const_mem_functor6(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** const_mem_functor7 wraps const methods with 7 argument(s).
- * Use the convenience function mem_fun() to create an instance of const_mem_functor7.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_arg7 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-class const_mem_functor7 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  const_mem_functor7() : func_ptr_(0) {}
-
-  /** Constructs a const_mem_functor7 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit const_mem_functor7(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @param _A_a7 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @param _A_a7 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** volatile_mem_functor0 wraps volatile methods with 0 argument(s).
- * Use the convenience function mem_fun() to create an instance of volatile_mem_functor0.
- *
- * The following template arguments are used:
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj>
-class volatile_mem_functor0 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)() volatile;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  volatile_mem_functor0() : func_ptr_(0) {}
-
-  /** Constructs a volatile_mem_functor0 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit volatile_mem_functor0(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj* _A_obj) const
-    { return (_A_obj->*(this->func_ptr_))(); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj& _A_obj) const
-    { return (_A_obj.*func_ptr_)(); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** volatile_mem_functor1 wraps volatile methods with 1 argument(s).
- * Use the convenience function mem_fun() to create an instance of volatile_mem_functor1.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1>
-class volatile_mem_functor1 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1) volatile;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  volatile_mem_functor1() : func_ptr_(0) {}
-
-  /** Constructs a volatile_mem_functor1 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit volatile_mem_functor1(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1) const
-    { return (_A_obj.*func_ptr_)(_A_a1); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** volatile_mem_functor2 wraps volatile methods with 2 argument(s).
- * Use the convenience function mem_fun() to create an instance of volatile_mem_functor2.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2>
-class volatile_mem_functor2 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2) volatile;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  volatile_mem_functor2() : func_ptr_(0) {}
-
-  /** Constructs a volatile_mem_functor2 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit volatile_mem_functor2(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** volatile_mem_functor3 wraps volatile methods with 3 argument(s).
- * Use the convenience function mem_fun() to create an instance of volatile_mem_functor3.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-class volatile_mem_functor3 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3) volatile;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  volatile_mem_functor3() : func_ptr_(0) {}
-
-  /** Constructs a volatile_mem_functor3 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit volatile_mem_functor3(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** volatile_mem_functor4 wraps volatile methods with 4 argument(s).
- * Use the convenience function mem_fun() to create an instance of volatile_mem_functor4.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-class volatile_mem_functor4 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4) volatile;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  volatile_mem_functor4() : func_ptr_(0) {}
-
-  /** Constructs a volatile_mem_functor4 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit volatile_mem_functor4(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** volatile_mem_functor5 wraps volatile methods with 5 argument(s).
- * Use the convenience function mem_fun() to create an instance of volatile_mem_functor5.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-class volatile_mem_functor5 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  volatile_mem_functor5() : func_ptr_(0) {}
-
-  /** Constructs a volatile_mem_functor5 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit volatile_mem_functor5(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** volatile_mem_functor6 wraps volatile methods with 6 argument(s).
- * Use the convenience function mem_fun() to create an instance of volatile_mem_functor6.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-class volatile_mem_functor6 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  volatile_mem_functor6() : func_ptr_(0) {}
-
-  /** Constructs a volatile_mem_functor6 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit volatile_mem_functor6(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** volatile_mem_functor7 wraps volatile methods with 7 argument(s).
- * Use the convenience function mem_fun() to create an instance of volatile_mem_functor7.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_arg7 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-class volatile_mem_functor7 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  volatile_mem_functor7() : func_ptr_(0) {}
-
-  /** Constructs a volatile_mem_functor7 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit volatile_mem_functor7(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @param _A_a7 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @param _A_a7 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** const_volatile_mem_functor0 wraps const volatile methods with 0 argument(s).
- * Use the convenience function mem_fun() to create an instance of const_volatile_mem_functor0.
- *
- * The following template arguments are used:
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj>
-class const_volatile_mem_functor0 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)() const volatile;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  const_volatile_mem_functor0() : func_ptr_(0) {}
-
-  /** Constructs a const_volatile_mem_functor0 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit const_volatile_mem_functor0(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj* _A_obj) const
-    { return (_A_obj->*(this->func_ptr_))(); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj& _A_obj) const
-    { return (_A_obj.*func_ptr_)(); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** const_volatile_mem_functor1 wraps const volatile methods with 1 argument(s).
- * Use the convenience function mem_fun() to create an instance of const_volatile_mem_functor1.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1>
-class const_volatile_mem_functor1 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1) const volatile;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  const_volatile_mem_functor1() : func_ptr_(0) {}
-
-  /** Constructs a const_volatile_mem_functor1 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit const_volatile_mem_functor1(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1) const
-    { return (_A_obj.*func_ptr_)(_A_a1); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** const_volatile_mem_functor2 wraps const volatile methods with 2 argument(s).
- * Use the convenience function mem_fun() to create an instance of const_volatile_mem_functor2.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2>
-class const_volatile_mem_functor2 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2) const volatile;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  const_volatile_mem_functor2() : func_ptr_(0) {}
-
-  /** Constructs a const_volatile_mem_functor2 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit const_volatile_mem_functor2(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** const_volatile_mem_functor3 wraps const volatile methods with 3 argument(s).
- * Use the convenience function mem_fun() to create an instance of const_volatile_mem_functor3.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-class const_volatile_mem_functor3 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3) const volatile;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  const_volatile_mem_functor3() : func_ptr_(0) {}
-
-  /** Constructs a const_volatile_mem_functor3 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit const_volatile_mem_functor3(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** const_volatile_mem_functor4 wraps const volatile methods with 4 argument(s).
- * Use the convenience function mem_fun() to create an instance of const_volatile_mem_functor4.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-class const_volatile_mem_functor4 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  const_volatile_mem_functor4() : func_ptr_(0) {}
-
-  /** Constructs a const_volatile_mem_functor4 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit const_volatile_mem_functor4(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** const_volatile_mem_functor5 wraps const volatile methods with 5 argument(s).
- * Use the convenience function mem_fun() to create an instance of const_volatile_mem_functor5.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-class const_volatile_mem_functor5 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  const_volatile_mem_functor5() : func_ptr_(0) {}
-
-  /** Constructs a const_volatile_mem_functor5 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit const_volatile_mem_functor5(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** const_volatile_mem_functor6 wraps const volatile methods with 6 argument(s).
- * Use the convenience function mem_fun() to create an instance of const_volatile_mem_functor6.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-class const_volatile_mem_functor6 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  const_volatile_mem_functor6() : func_ptr_(0) {}
-
-  /** Constructs a const_volatile_mem_functor6 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit const_volatile_mem_functor6(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
-
-protected:
-  function_type func_ptr_;
-};
-
-/** const_volatile_mem_functor7 wraps const volatile methods with 7 argument(s).
- * Use the convenience function mem_fun() to create an instance of const_volatile_mem_functor7.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_arg7 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-class const_volatile_mem_functor7 : public functor_base
-{
-public:
-  typedef T_return (T_obj::*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const volatile;
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  const_volatile_mem_functor7() : func_ptr_(0) {}
-
-  /** Constructs a const_volatile_mem_functor7 object that wraps the passed method.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  explicit const_volatile_mem_functor7(function_type _A_func) : func_ptr_(_A_func) {}
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Pointer to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @param _A_a7 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj* _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
-    { return (_A_obj->*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
-
-  /** Execute the wrapped method operating on the passed instance.
-   * @param _A_obj Reference to instance the method should operate on.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @param _A_a7 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(const T_obj& _A_obj, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
-    { return (_A_obj.*func_ptr_)(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
-
-protected:
-  function_type func_ptr_;
-};
-
-
-/** bound_mem_functor0 encapsulates a  method with 0 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_mem_functor0.
- *
- * The following template arguments are used:
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj>
-class bound_mem_functor0
-  : public mem_functor0<T_return, T_obj>
-{
-  typedef mem_functor0<T_return, T_obj> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_mem_functor0 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_mem_functor0( T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_mem_functor0 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_mem_functor0( T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()() const
-    { return (obj_.invoke().*(this->func_ptr_))(); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj>
-void visit_each(const T_action& _A_action,
-                const bound_mem_functor0<T_return, T_obj>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_mem_functor1 encapsulates a  method with 1 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_mem_functor1.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1>
-class bound_mem_functor1
-  : public mem_functor1<T_return, T_obj, T_arg1>
-{
-  typedef mem_functor1<T_return, T_obj, T_arg1> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_mem_functor1 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_mem_functor1( T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_mem_functor1 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_mem_functor1( T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1>
-void visit_each(const T_action& _A_action,
-                const bound_mem_functor1<T_return, T_obj, T_arg1>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_mem_functor2 encapsulates a  method with 2 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_mem_functor2.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2>
-class bound_mem_functor2
-  : public mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-{
-  typedef mem_functor2<T_return, T_obj, T_arg1,T_arg2> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_mem_functor2 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_mem_functor2( T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_mem_functor2 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_mem_functor2( T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2>
-void visit_each(const T_action& _A_action,
-                const bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_mem_functor3 encapsulates a  method with 3 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_mem_functor3.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-class bound_mem_functor3
-  : public mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-{
-  typedef mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_mem_functor3 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_mem_functor3( T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_mem_functor3 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_mem_functor3( T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-void visit_each(const T_action& _A_action,
-                const bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_mem_functor4 encapsulates a  method with 4 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_mem_functor4.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-class bound_mem_functor4
-  : public mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-{
-  typedef mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_mem_functor4 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_mem_functor4( T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_mem_functor4 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_mem_functor4( T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-void visit_each(const T_action& _A_action,
-                const bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_mem_functor5 encapsulates a  method with 5 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_mem_functor5.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-class bound_mem_functor5
-  : public mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-{
-  typedef mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_mem_functor5 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_mem_functor5( T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_mem_functor5 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_mem_functor5( T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-void visit_each(const T_action& _A_action,
-                const bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_mem_functor6 encapsulates a  method with 6 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_mem_functor6.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-class bound_mem_functor6
-  : public mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-{
-  typedef mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_mem_functor6 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_mem_functor6( T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_mem_functor6 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_mem_functor6( T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-void visit_each(const T_action& _A_action,
-                const bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_mem_functor7 encapsulates a  method with 7 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_mem_functor7.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_arg7 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-class bound_mem_functor7
-  : public mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-{
-  typedef mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_mem_functor7 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_mem_functor7( T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_mem_functor7 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_mem_functor7( T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @param _A_a7 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-void visit_each(const T_action& _A_action,
-                const bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_const_mem_functor0.
- *
- * The following template arguments are used:
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj>
-class bound_const_mem_functor0
-  : public const_mem_functor0<T_return, T_obj>
-{
-  typedef const_mem_functor0<T_return, T_obj> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_const_mem_functor0 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_mem_functor0(const T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_const_mem_functor0 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_mem_functor0(const T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()() const
-    { return (obj_.invoke().*(this->func_ptr_))(); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  const_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_const_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_const_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj>
-void visit_each(const T_action& _A_action,
-                const bound_const_mem_functor0<T_return, T_obj>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_const_mem_functor1.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1>
-class bound_const_mem_functor1
-  : public const_mem_functor1<T_return, T_obj, T_arg1>
-{
-  typedef const_mem_functor1<T_return, T_obj, T_arg1> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_const_mem_functor1 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_mem_functor1(const T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_const_mem_functor1 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_mem_functor1(const T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  const_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_const_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_const_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1>
-void visit_each(const T_action& _A_action,
-                const bound_const_mem_functor1<T_return, T_obj, T_arg1>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_const_mem_functor2.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2>
-class bound_const_mem_functor2
-  : public const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-{
-  typedef const_mem_functor2<T_return, T_obj, T_arg1,T_arg2> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_const_mem_functor2 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_mem_functor2(const T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_const_mem_functor2 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_mem_functor2(const T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  const_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_const_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_const_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2>
-void visit_each(const T_action& _A_action,
-                const bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_const_mem_functor3.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-class bound_const_mem_functor3
-  : public const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-{
-  typedef const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_const_mem_functor3 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_mem_functor3(const T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_const_mem_functor3 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_mem_functor3(const T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  const_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_const_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_const_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-void visit_each(const T_action& _A_action,
-                const bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_const_mem_functor4.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-class bound_const_mem_functor4
-  : public const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-{
-  typedef const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_const_mem_functor4 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_mem_functor4(const T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_const_mem_functor4 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_mem_functor4(const T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  const_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_const_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_const_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-void visit_each(const T_action& _A_action,
-                const bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_const_mem_functor5.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-class bound_const_mem_functor5
-  : public const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-{
-  typedef const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_const_mem_functor5 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_mem_functor5(const T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_const_mem_functor5 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_mem_functor5(const T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  const_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_const_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_const_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-void visit_each(const T_action& _A_action,
-                const bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_const_mem_functor6.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-class bound_const_mem_functor6
-  : public const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-{
-  typedef const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_const_mem_functor6 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_mem_functor6(const T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_const_mem_functor6 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_mem_functor6(const T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  const_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_const_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_const_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-void visit_each(const T_action& _A_action,
-                const bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_const_mem_functor7.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_arg7 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-class bound_const_mem_functor7
-  : public const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-{
-  typedef const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_const_mem_functor7 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_mem_functor7(const T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_const_mem_functor7 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_mem_functor7(const T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @param _A_a7 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  const_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_const_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_const_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-void visit_each(const T_action& _A_action,
-                const bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_volatile_mem_functor0.
- *
- * The following template arguments are used:
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj>
-class bound_volatile_mem_functor0
-  : public volatile_mem_functor0<T_return, T_obj>
-{
-  typedef volatile_mem_functor0<T_return, T_obj> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_volatile_mem_functor0 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_volatile_mem_functor0( T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_volatile_mem_functor0 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_volatile_mem_functor0( T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()() const
-    { return (obj_.invoke().*(this->func_ptr_))(); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  volatile_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_volatile_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_volatile_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj>
-void visit_each(const T_action& _A_action,
-                const bound_volatile_mem_functor0<T_return, T_obj>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_volatile_mem_functor1.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1>
-class bound_volatile_mem_functor1
-  : public volatile_mem_functor1<T_return, T_obj, T_arg1>
-{
-  typedef volatile_mem_functor1<T_return, T_obj, T_arg1> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_volatile_mem_functor1 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_volatile_mem_functor1( T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_volatile_mem_functor1 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_volatile_mem_functor1( T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  volatile_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_volatile_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_volatile_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1>
-void visit_each(const T_action& _A_action,
-                const bound_volatile_mem_functor1<T_return, T_obj, T_arg1>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_volatile_mem_functor2.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2>
-class bound_volatile_mem_functor2
-  : public volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-{
-  typedef volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_volatile_mem_functor2 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_volatile_mem_functor2( T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_volatile_mem_functor2 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_volatile_mem_functor2( T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  volatile_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_volatile_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_volatile_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2>
-void visit_each(const T_action& _A_action,
-                const bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_volatile_mem_functor3.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-class bound_volatile_mem_functor3
-  : public volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-{
-  typedef volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_volatile_mem_functor3 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_volatile_mem_functor3( T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_volatile_mem_functor3 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_volatile_mem_functor3( T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  volatile_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_volatile_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_volatile_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-void visit_each(const T_action& _A_action,
-                const bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_volatile_mem_functor4.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-class bound_volatile_mem_functor4
-  : public volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-{
-  typedef volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_volatile_mem_functor4 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_volatile_mem_functor4( T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_volatile_mem_functor4 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_volatile_mem_functor4( T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  volatile_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_volatile_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_volatile_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-void visit_each(const T_action& _A_action,
-                const bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_volatile_mem_functor5.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-class bound_volatile_mem_functor5
-  : public volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-{
-  typedef volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_volatile_mem_functor5 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_volatile_mem_functor5( T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_volatile_mem_functor5 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_volatile_mem_functor5( T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  volatile_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_volatile_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_volatile_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-void visit_each(const T_action& _A_action,
-                const bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_volatile_mem_functor6.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-class bound_volatile_mem_functor6
-  : public volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-{
-  typedef volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_volatile_mem_functor6 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_volatile_mem_functor6( T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_volatile_mem_functor6 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_volatile_mem_functor6( T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  volatile_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_volatile_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_volatile_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-void visit_each(const T_action& _A_action,
-                const bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_volatile_mem_functor7.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_arg7 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-class bound_volatile_mem_functor7
-  : public volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-{
-  typedef volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_volatile_mem_functor7 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_volatile_mem_functor7( T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_volatile_mem_functor7 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_volatile_mem_functor7( T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @param _A_a7 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  volatile_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_volatile_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_volatile_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-void visit_each(const T_action& _A_action,
-                const bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_const_volatile_mem_functor0.
- *
- * The following template arguments are used:
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj>
-class bound_const_volatile_mem_functor0
-  : public const_volatile_mem_functor0<T_return, T_obj>
-{
-  typedef const_volatile_mem_functor0<T_return, T_obj> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_const_volatile_mem_functor0 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_volatile_mem_functor0(const T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_const_volatile_mem_functor0 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_volatile_mem_functor0(const T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()() const
-    { return (obj_.invoke().*(this->func_ptr_))(); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  const_volatile_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_const_volatile_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_const_volatile_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj>
-void visit_each(const T_action& _A_action,
-                const bound_const_volatile_mem_functor0<T_return, T_obj>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_const_volatile_mem_functor1.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1>
-class bound_const_volatile_mem_functor1
-  : public const_volatile_mem_functor1<T_return, T_obj, T_arg1>
-{
-  typedef const_volatile_mem_functor1<T_return, T_obj, T_arg1> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_const_volatile_mem_functor1 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_volatile_mem_functor1(const T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_const_volatile_mem_functor1 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_volatile_mem_functor1(const T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  const_volatile_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_const_volatile_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_const_volatile_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1>
-void visit_each(const T_action& _A_action,
-                const bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_const_volatile_mem_functor2.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2>
-class bound_const_volatile_mem_functor2
-  : public const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-{
-  typedef const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_const_volatile_mem_functor2 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_volatile_mem_functor2(const T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_const_volatile_mem_functor2 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_volatile_mem_functor2(const T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  const_volatile_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_const_volatile_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_const_volatile_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2>
-void visit_each(const T_action& _A_action,
-                const bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_const_volatile_mem_functor3.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-class bound_const_volatile_mem_functor3
-  : public const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-{
-  typedef const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_const_volatile_mem_functor3 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_volatile_mem_functor3(const T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_const_volatile_mem_functor3 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_volatile_mem_functor3(const T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  const_volatile_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_const_volatile_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_const_volatile_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3>
-void visit_each(const T_action& _A_action,
-                const bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_const_volatile_mem_functor4.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-class bound_const_volatile_mem_functor4
-  : public const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-{
-  typedef const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_const_volatile_mem_functor4 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_volatile_mem_functor4(const T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_const_volatile_mem_functor4 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_volatile_mem_functor4(const T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  const_volatile_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_const_volatile_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_const_volatile_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-void visit_each(const T_action& _A_action,
-                const bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_const_volatile_mem_functor5.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-class bound_const_volatile_mem_functor5
-  : public const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-{
-  typedef const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_const_volatile_mem_functor5 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_volatile_mem_functor5(const T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_const_volatile_mem_functor5 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_volatile_mem_functor5(const T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  const_volatile_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_const_volatile_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_const_volatile_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-void visit_each(const T_action& _A_action,
-                const bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_const_volatile_mem_functor6.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-class bound_const_volatile_mem_functor6
-  : public const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-{
-  typedef const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_const_volatile_mem_functor6 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_volatile_mem_functor6(const T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_const_volatile_mem_functor6 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_volatile_mem_functor6(const T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  const_volatile_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_const_volatile_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_const_volatile_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-void visit_each(const T_action& _A_action,
-                const bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-/** bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object instance.
- * Use the convenience function mem_fun() to create an instance of bound_const_volatile_mem_functor7.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_arg7 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- * - @e T_obj The object type.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-class bound_const_volatile_mem_functor7
-  : public const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-{
-  typedef const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> base_type_;
-public:
-  typedef typename base_type_::function_type function_type;
-
-  /** Constructs a bound_const_volatile_mem_functor7 object that wraps the passed method.
-   * @param _A_obj Pointer to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_volatile_mem_functor7(const T_obj* _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(*_A_obj)
-    {}
-
-  /** Constructs a bound_const_volatile_mem_functor7 object that wraps the passed method.
-   * @param _A_obj Reference to instance the method will operate on.
-   * @param _A_func Pointer to method will be invoked from operator()().
-   */
-  bound_const_volatile_mem_functor7(const T_obj& _A_obj, function_type _A_func)
-    : base_type_(_A_func),
-      obj_(_A_obj)
-    {}
-
-  /** Execute the wrapped method operating on the stored instance.
-   * @param _A_a1 Argument to be passed on to the method.
-   * @param _A_a2 Argument to be passed on to the method.
-   * @param _A_a3 Argument to be passed on to the method.
-   * @param _A_a4 Argument to be passed on to the method.
-   * @param _A_a5 Argument to be passed on to the method.
-   * @param _A_a6 Argument to be passed on to the method.
-   * @param _A_a7 Argument to be passed on to the method.
-   * @return The return value of the method invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
-    { return (obj_.invoke().*(this->func_ptr_))(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
-
-//protected:
-  // Reference to stored object instance.
-  // This is the handler object, such as TheObject in void TheObject::signal_handler().
-  const_volatile_limit_reference<T_obj> obj_;
-};
-
-//template specialization of visit_each<>(action, functor):
-/** Performs a functor on each of the targets of a functor.
- * The function overload for sigc::bound_const_volatile_mem_functor performs a functor
- * on the object instance stored in the sigc::bound_const_volatile_mem_functor object.
- *
- * @ingroup mem_fun
- */
-template <class T_action, class T_return, class T_obj, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-void visit_each(const T_action& _A_action,
-                const bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>& _A_target)
-{
-  sigc::visit_each(_A_action, _A_target.obj_);
-}
-
-
-// numbered
-/** Creates a functor of type sigc::mem_functor0 which wraps a  method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj>
-inline mem_functor0<T_return, T_obj>
-mem_fun0(T_return (T_obj::*_A_func)() )
-{ return mem_functor0<T_return, T_obj>(_A_func); }
-
-/** Creates a functor of type sigc::mem_functor1 which wraps a  method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj>
-inline mem_functor1<T_return, T_obj, T_arg1>
-mem_fun1(T_return (T_obj::*_A_func)(T_arg1) )
-{ return mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
-
-/** Creates a functor of type sigc::mem_functor2 which wraps a  method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj>
-inline mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun2(T_return (T_obj::*_A_func)(T_arg1,T_arg2) )
-{ return mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
-
-/** Creates a functor of type sigc::mem_functor3 which wraps a  method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
-inline mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun3(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) )
-{ return mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
-
-/** Creates a functor of type sigc::mem_functor4 which wraps a  method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
-inline mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun4(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) )
-{ return mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
-
-/** Creates a functor of type sigc::mem_functor5 which wraps a  method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
-inline mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun5(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) )
-{ return mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
-
-/** Creates a functor of type sigc::mem_functor6 which wraps a  method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
-inline mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun6(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) )
-{ return mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
-
-/** Creates a functor of type sigc::mem_functor7 which wraps a  method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
-inline mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun7(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) )
-{ return mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
-
-/** Creates a functor of type sigc::const_mem_functor0 which wraps a const method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj>
-inline const_mem_functor0<T_return, T_obj>
-mem_fun0(T_return (T_obj::*_A_func)() const)
-{ return const_mem_functor0<T_return, T_obj>(_A_func); }
-
-/** Creates a functor of type sigc::const_mem_functor1 which wraps a const method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj>
-inline const_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun1(T_return (T_obj::*_A_func)(T_arg1) const)
-{ return const_mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
-
-/** Creates a functor of type sigc::const_mem_functor2 which wraps a const method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj>
-inline const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun2(T_return (T_obj::*_A_func)(T_arg1,T_arg2) const)
-{ return const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
-
-/** Creates a functor of type sigc::const_mem_functor3 which wraps a const method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
-inline const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun3(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) const)
-{ return const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
-
-/** Creates a functor of type sigc::const_mem_functor4 which wraps a const method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
-inline const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun4(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const)
-{ return const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
-
-/** Creates a functor of type sigc::const_mem_functor5 which wraps a const method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
-inline const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun5(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const)
-{ return const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
-
-/** Creates a functor of type sigc::const_mem_functor6 which wraps a const method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
-inline const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun6(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const)
-{ return const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
-
-/** Creates a functor of type sigc::const_mem_functor7 which wraps a const method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
-inline const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun7(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const)
-{ return const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
-
-/** Creates a functor of type sigc::volatile_mem_functor0 which wraps a volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj>
-inline volatile_mem_functor0<T_return, T_obj>
-mem_fun0(T_return (T_obj::*_A_func)() volatile)
-{ return volatile_mem_functor0<T_return, T_obj>(_A_func); }
-
-/** Creates a functor of type sigc::volatile_mem_functor1 which wraps a volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj>
-inline volatile_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun1(T_return (T_obj::*_A_func)(T_arg1) volatile)
-{ return volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
-
-/** Creates a functor of type sigc::volatile_mem_functor2 which wraps a volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj>
-inline volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun2(T_return (T_obj::*_A_func)(T_arg1,T_arg2) volatile)
-{ return volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
-
-/** Creates a functor of type sigc::volatile_mem_functor3 which wraps a volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
-inline volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun3(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) volatile)
-{ return volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
-
-/** Creates a functor of type sigc::volatile_mem_functor4 which wraps a volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
-inline volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun4(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile)
-{ return volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
-
-/** Creates a functor of type sigc::volatile_mem_functor5 which wraps a volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
-inline volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun5(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile)
-{ return volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
-
-/** Creates a functor of type sigc::volatile_mem_functor6 which wraps a volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
-inline volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun6(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile)
-{ return volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
-
-/** Creates a functor of type sigc::volatile_mem_functor7 which wraps a volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
-inline volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun7(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile)
-{ return volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
-
-/** Creates a functor of type sigc::const_volatile_mem_functor0 which wraps a const volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj>
-inline const_volatile_mem_functor0<T_return, T_obj>
-mem_fun0(T_return (T_obj::*_A_func)() const volatile)
-{ return const_volatile_mem_functor0<T_return, T_obj>(_A_func); }
-
-/** Creates a functor of type sigc::const_volatile_mem_functor1 which wraps a const volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj>
-inline const_volatile_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun1(T_return (T_obj::*_A_func)(T_arg1) const volatile)
-{ return const_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
-
-/** Creates a functor of type sigc::const_volatile_mem_functor2 which wraps a const volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj>
-inline const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun2(T_return (T_obj::*_A_func)(T_arg1,T_arg2) const volatile)
-{ return const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
-
-/** Creates a functor of type sigc::const_volatile_mem_functor3 which wraps a const volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
-inline const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun3(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) const volatile)
-{ return const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
-
-/** Creates a functor of type sigc::const_volatile_mem_functor4 which wraps a const volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
-inline const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun4(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile)
-{ return const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
-
-/** Creates a functor of type sigc::const_volatile_mem_functor5 which wraps a const volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
-inline const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun5(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile)
-{ return const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
-
-/** Creates a functor of type sigc::const_volatile_mem_functor6 which wraps a const volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
-inline const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun6(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile)
-{ return const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
-
-/** Creates a functor of type sigc::const_volatile_mem_functor7 which wraps a const volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
-inline const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun7(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const volatile)
-{ return const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor0 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor0<T_return, T_obj>
-mem_fun0(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)() )
-{ return bound_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor0 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor0<T_return, T_obj>
-mem_fun0(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)() )
-{ return bound_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor1 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun1(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) )
-{ return bound_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor1 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun1(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) )
-{ return bound_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor2 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun2(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) )
-{ return bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor2 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun2(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) )
-{ return bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor3 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun3(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) )
-{ return bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor3 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun3(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) )
-{ return bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor4 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun4(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) )
-{ return bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor4 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun4(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) )
-{ return bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor5 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun5(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) )
-{ return bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor5 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun5(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) )
-{ return bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor6 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun6(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) )
-{ return bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor6 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun6(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) )
-{ return bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor7 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun7(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) )
-{ return bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor7 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun7(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) )
-{ return bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor0 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor0<T_return, T_obj>
-mem_fun0(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)() const)
-{ return bound_const_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor0 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor0<T_return, T_obj>
-mem_fun0(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)() const)
-{ return bound_const_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor1 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun1(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const)
-{ return bound_const_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor1 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun1(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const)
-{ return bound_const_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor2 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun2(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const)
-{ return bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor2 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun2(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const)
-{ return bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor3 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun3(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const)
-{ return bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor3 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun3(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const)
-{ return bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor4 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun4(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const)
-{ return bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor4 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun4(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const)
-{ return bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor5 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun5(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const)
-{ return bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor5 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun5(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const)
-{ return bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor6 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun6(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const)
-{ return bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor6 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun6(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const)
-{ return bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor7 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun7(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const)
-{ return bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor7 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun7(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const)
-{ return bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor0 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor0<T_return, T_obj>
-mem_fun0(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)() volatile)
-{ return bound_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor0 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor0<T_return, T_obj>
-mem_fun0(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)() volatile)
-{ return bound_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor1 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun1(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) volatile)
-{ return bound_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor1 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun1(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) volatile)
-{ return bound_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor2 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun2(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) volatile)
-{ return bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor2 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun2(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) volatile)
-{ return bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor3 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun3(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) volatile)
-{ return bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor3 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun3(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) volatile)
-{ return bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor4 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun4(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile)
-{ return bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor4 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun4(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile)
-{ return bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor5 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun5(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile)
-{ return bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor5 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun5(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile)
-{ return bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor6 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun6(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile)
-{ return bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor6 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun6(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile)
-{ return bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor7 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun7(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile)
-{ return bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor7 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun7(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile)
-{ return bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor0 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor0<T_return, T_obj>
-mem_fun0(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)() const volatile)
-{ return bound_const_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor0 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor0<T_return, T_obj>
-mem_fun0(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)() const volatile)
-{ return bound_const_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor1 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun1(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const volatile)
-{ return bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor1 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun1(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const volatile)
-{ return bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor2 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun2(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const volatile)
-{ return bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor2 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun2(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const volatile)
-{ return bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor3 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun3(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const volatile)
-{ return bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor3 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun3(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const volatile)
-{ return bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor4 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun4(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile)
-{ return bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor4 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun4(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile)
-{ return bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor5 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun5(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile)
-{ return bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor5 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun5(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile)
-{ return bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor6 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun6(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile)
-{ return bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor6 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun6(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile)
-{ return bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor7 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun7(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const volatile)
-{ return bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor7 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun7(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const volatile)
-{ return bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-
-// unnumbered
-/** Creates a functor of type sigc::mem_functor0 which wraps a  method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj>
-inline mem_functor0<T_return, T_obj>
-mem_fun(T_return (T_obj::*_A_func)() )
-{ return mem_functor0<T_return, T_obj>(_A_func); }
-
-/** Creates a functor of type sigc::mem_functor1 which wraps a  method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj>
-inline mem_functor1<T_return, T_obj, T_arg1>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1) )
-{ return mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
-
-/** Creates a functor of type sigc::mem_functor2 which wraps a  method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj>
-inline mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2) )
-{ return mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
-
-/** Creates a functor of type sigc::mem_functor3 which wraps a  method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
-inline mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) )
-{ return mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
-
-/** Creates a functor of type sigc::mem_functor4 which wraps a  method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
-inline mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) )
-{ return mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
-
-/** Creates a functor of type sigc::mem_functor5 which wraps a  method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
-inline mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) )
-{ return mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
-
-/** Creates a functor of type sigc::mem_functor6 which wraps a  method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
-inline mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) )
-{ return mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
-
-/** Creates a functor of type sigc::mem_functor7 which wraps a  method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
-inline mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) )
-{ return mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
-
-/** Creates a functor of type sigc::const_mem_functor0 which wraps a const method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj>
-inline const_mem_functor0<T_return, T_obj>
-mem_fun(T_return (T_obj::*_A_func)() const)
-{ return const_mem_functor0<T_return, T_obj>(_A_func); }
-
-/** Creates a functor of type sigc::const_mem_functor1 which wraps a const method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj>
-inline const_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1) const)
-{ return const_mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
-
-/** Creates a functor of type sigc::const_mem_functor2 which wraps a const method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj>
-inline const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2) const)
-{ return const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
-
-/** Creates a functor of type sigc::const_mem_functor3 which wraps a const method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
-inline const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) const)
-{ return const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
-
-/** Creates a functor of type sigc::const_mem_functor4 which wraps a const method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
-inline const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const)
-{ return const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
-
-/** Creates a functor of type sigc::const_mem_functor5 which wraps a const method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
-inline const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const)
-{ return const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
-
-/** Creates a functor of type sigc::const_mem_functor6 which wraps a const method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
-inline const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const)
-{ return const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
-
-/** Creates a functor of type sigc::const_mem_functor7 which wraps a const method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
-inline const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const)
-{ return const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
-
-/** Creates a functor of type sigc::volatile_mem_functor0 which wraps a volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj>
-inline volatile_mem_functor0<T_return, T_obj>
-mem_fun(T_return (T_obj::*_A_func)() volatile)
-{ return volatile_mem_functor0<T_return, T_obj>(_A_func); }
-
-/** Creates a functor of type sigc::volatile_mem_functor1 which wraps a volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj>
-inline volatile_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1) volatile)
-{ return volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
-
-/** Creates a functor of type sigc::volatile_mem_functor2 which wraps a volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj>
-inline volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2) volatile)
-{ return volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
-
-/** Creates a functor of type sigc::volatile_mem_functor3 which wraps a volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
-inline volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) volatile)
-{ return volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
-
-/** Creates a functor of type sigc::volatile_mem_functor4 which wraps a volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
-inline volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile)
-{ return volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
-
-/** Creates a functor of type sigc::volatile_mem_functor5 which wraps a volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
-inline volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile)
-{ return volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
-
-/** Creates a functor of type sigc::volatile_mem_functor6 which wraps a volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
-inline volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile)
-{ return volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
-
-/** Creates a functor of type sigc::volatile_mem_functor7 which wraps a volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
-inline volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile)
-{ return volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
-
-/** Creates a functor of type sigc::const_volatile_mem_functor0 which wraps a const volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj>
-inline const_volatile_mem_functor0<T_return, T_obj>
-mem_fun(T_return (T_obj::*_A_func)() const volatile)
-{ return const_volatile_mem_functor0<T_return, T_obj>(_A_func); }
-
-/** Creates a functor of type sigc::const_volatile_mem_functor1 which wraps a const volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj>
-inline const_volatile_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1) const volatile)
-{ return const_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
-
-/** Creates a functor of type sigc::const_volatile_mem_functor2 which wraps a const volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj>
-inline const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2) const volatile)
-{ return const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
-
-/** Creates a functor of type sigc::const_volatile_mem_functor3 which wraps a const volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj>
-inline const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) const volatile)
-{ return const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
-
-/** Creates a functor of type sigc::const_volatile_mem_functor4 which wraps a const volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj>
-inline const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile)
-{ return const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
-
-/** Creates a functor of type sigc::const_volatile_mem_functor5 which wraps a const volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj>
-inline const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile)
-{ return const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
-
-/** Creates a functor of type sigc::const_volatile_mem_functor6 which wraps a const volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj>
-inline const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile)
-{ return const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
-
-/** Creates a functor of type sigc::const_volatile_mem_functor7 which wraps a const volatile method.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj>
-inline const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const volatile)
-{ return const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor0 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor0<T_return, T_obj>
-mem_fun(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)() )
-{ return bound_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor0 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor0<T_return, T_obj>
-mem_fun(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)() )
-{ return bound_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor1 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) )
-{ return bound_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor1 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) )
-{ return bound_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor2 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) )
-{ return bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor2 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) )
-{ return bound_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor3 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) )
-{ return bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor3 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) )
-{ return bound_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor4 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) )
-{ return bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor4 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) )
-{ return bound_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor5 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) )
-{ return bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor5 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) )
-{ return bound_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor6 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) )
-{ return bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor6 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) )
-{ return bound_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor7 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) )
-{ return bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_mem_functor7 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
-inline bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) )
-{ return bound_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor0 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor0<T_return, T_obj>
-mem_fun(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)() const)
-{ return bound_const_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor0 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor0<T_return, T_obj>
-mem_fun(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)() const)
-{ return bound_const_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor1 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const)
-{ return bound_const_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor1 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const)
-{ return bound_const_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor2 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const)
-{ return bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor2 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const)
-{ return bound_const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor3 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const)
-{ return bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor3 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const)
-{ return bound_const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor4 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const)
-{ return bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor4 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const)
-{ return bound_const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor5 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const)
-{ return bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor5 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const)
-{ return bound_const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor6 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const)
-{ return bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor6 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const)
-{ return bound_const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor7 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const)
-{ return bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_mem_functor7 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
-inline bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const)
-{ return bound_const_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor0 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor0<T_return, T_obj>
-mem_fun(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)() volatile)
-{ return bound_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor0 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor0<T_return, T_obj>
-mem_fun(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)() volatile)
-{ return bound_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor1 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) volatile)
-{ return bound_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor1 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) volatile)
-{ return bound_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor2 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) volatile)
-{ return bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor2 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) volatile)
-{ return bound_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor3 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) volatile)
-{ return bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor3 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) volatile)
-{ return bound_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor4 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile)
-{ return bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor4 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile)
-{ return bound_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor5 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile)
-{ return bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor5 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile)
-{ return bound_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor6 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile)
-{ return bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor6 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile)
-{ return bound_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor7 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun(/**/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile)
-{ return bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_volatile_mem_functor7 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
-inline bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun(/**/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile)
-{ return bound_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor0 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor0<T_return, T_obj>
-mem_fun(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)() const volatile)
-{ return bound_const_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor0 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor0<T_return, T_obj>
-mem_fun(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)() const volatile)
-{ return bound_const_volatile_mem_functor0<T_return, T_obj>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor1 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const volatile)
-{ return bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor1 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>
-mem_fun(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const volatile)
-{ return bound_const_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor2 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const volatile)
-{ return bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor2 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>
-mem_fun(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const volatile)
-{ return bound_const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor3 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const volatile)
-{ return bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor3 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>
-mem_fun(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const volatile)
-{ return bound_const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor4 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile)
-{ return bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor4 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>
-mem_fun(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile)
-{ return bound_const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor5 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile)
-{ return bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor5 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-mem_fun(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile)
-{ return bound_const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor6 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile)
-{ return bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor6 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-mem_fun(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile)
-{ return bound_const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor7 which encapsulates a method and an object instance.
- * @param _A_obj Pointer to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun(/*const*/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const volatile)
-{ return bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-/** Creates a functor of type sigc::bound_const_volatile_mem_functor7 which encapsulates a method and an object instance.
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup mem_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2>
-inline bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-mem_fun(/*const*/ T_obj& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const volatile)
-{ return bound_const_volatile_mem_functor7<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-
-} /* namespace sigc */
-#endif /* _SIGC_FUNCTORS_MACROS_MEM_FUNHM4_ */
Index: stardict-3.0.1/src/sigc++/functors/ptr_fun.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/functors/ptr_fun.h
+++ /dev/null
@@ -1,542 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-
-#ifndef _SIGC_FUNCTORS_MACROS_PTR_FUNHM4_
-#define _SIGC_FUNCTORS_MACROS_PTR_FUNHM4_
-#include <sigc++/type_traits.h>
-#include <sigc++/functors/functor_trait.h>
-
-namespace sigc {
-
-/** @defgroup ptr_fun ptr_fun()
- * ptr_fun() is used to convert a pointer to a function to a functor.
- * If the function pointer is to an overloaded type, you must specify
- * the types using template arguments starting with the first argument.
- * It is not necessary to supply the return type.
- *
- * @par Example:
- *   @code
- *   void foo(int) {}
- *   sigc::slot<void, int> sl = sigc::ptr_fun(&foo);
- *   @endcode
- *
- * Use ptr_fun#() if there is an abiguity as to the number of arguments.
- *
- * @par Example:
- *   @code
- *   void foo(int) {}  // choose this one
- *   void foo(float) {}
- *   void foo(int, int) {}
- *   sigc::slot<void, long> sl = sigc::ptr_fun1<int>(&foo);
- *   @endcode
- *
- * ptr_fun() can also be used to convert a pointer to a static member
- * function to a functor, like so:
- *
- * @par Example:
- *   @code
- *   struct foo
- *   {
- *     static void bar(int) {}
- *   };
- *   sigc::slot<void, int> sl = sigc::ptr_fun(&foo::bar);
- *   @endcode
- *
- * @ingroup functors
- */
-
-/** pointer_functor0 wraps existing non-member functions with 0 argument(s).
- * Use the convenience function ptr_fun() to create an instance of pointer_functor0.
- *
- * The following template arguments are used:
- * - @e T_return The return type of operator()().
- *
- * @ingroup ptr_fun
- */
-template <class T_return>
-class pointer_functor0 : public functor_base
-{
-  typedef T_return (*function_type)();
-protected: 
-  function_type func_ptr_;
-public:
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  pointer_functor0() {}
-
-  /** Constructs a pointer_functor0 object that wraps an existing function.
-   * @param _A_func Pointer to function that will be invoked from operator()().
-   */
-  explicit pointer_functor0(function_type _A_func): func_ptr_(_A_func) {}
-
-  /** Execute the wrapped function.
-   * @return The return value of the function invocation.
-   */
-  T_return operator()() const 
-    { return func_ptr_(); }
-};
-
-/** pointer_functor1 wraps existing non-member functions with 1 argument(s).
- * Use the convenience function ptr_fun() to create an instance of pointer_functor1.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1, class T_return>
-class pointer_functor1 : public functor_base
-{
-  typedef T_return (*function_type)(T_arg1);
-protected: 
-  function_type func_ptr_;
-public:
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  pointer_functor1() {}
-
-  /** Constructs a pointer_functor1 object that wraps an existing function.
-   * @param _A_func Pointer to function that will be invoked from operator()().
-   */
-  explicit pointer_functor1(function_type _A_func): func_ptr_(_A_func) {}
-
-  /** Execute the wrapped function.
-   * @param _A_a1 Argument to be passed on to the function.
-   * @return The return value of the function invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1) const 
-    { return func_ptr_(_A_a1); }
-};
-
-/** pointer_functor2 wraps existing non-member functions with 2 argument(s).
- * Use the convenience function ptr_fun() to create an instance of pointer_functor2.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2, class T_return>
-class pointer_functor2 : public functor_base
-{
-  typedef T_return (*function_type)(T_arg1,T_arg2);
-protected: 
-  function_type func_ptr_;
-public:
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  pointer_functor2() {}
-
-  /** Constructs a pointer_functor2 object that wraps an existing function.
-   * @param _A_func Pointer to function that will be invoked from operator()().
-   */
-  explicit pointer_functor2(function_type _A_func): func_ptr_(_A_func) {}
-
-  /** Execute the wrapped function.
-   * @param _A_a1 Argument to be passed on to the function.
-   * @param _A_a2 Argument to be passed on to the function.
-   * @return The return value of the function invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const 
-    { return func_ptr_(_A_a1,_A_a2); }
-};
-
-/** pointer_functor3 wraps existing non-member functions with 3 argument(s).
- * Use the convenience function ptr_fun() to create an instance of pointer_functor3.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return>
-class pointer_functor3 : public functor_base
-{
-  typedef T_return (*function_type)(T_arg1,T_arg2,T_arg3);
-protected: 
-  function_type func_ptr_;
-public:
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  pointer_functor3() {}
-
-  /** Constructs a pointer_functor3 object that wraps an existing function.
-   * @param _A_func Pointer to function that will be invoked from operator()().
-   */
-  explicit pointer_functor3(function_type _A_func): func_ptr_(_A_func) {}
-
-  /** Execute the wrapped function.
-   * @param _A_a1 Argument to be passed on to the function.
-   * @param _A_a2 Argument to be passed on to the function.
-   * @param _A_a3 Argument to be passed on to the function.
-   * @return The return value of the function invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const 
-    { return func_ptr_(_A_a1,_A_a2,_A_a3); }
-};
-
-/** pointer_functor4 wraps existing non-member functions with 4 argument(s).
- * Use the convenience function ptr_fun() to create an instance of pointer_functor4.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return>
-class pointer_functor4 : public functor_base
-{
-  typedef T_return (*function_type)(T_arg1,T_arg2,T_arg3,T_arg4);
-protected: 
-  function_type func_ptr_;
-public:
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  pointer_functor4() {}
-
-  /** Constructs a pointer_functor4 object that wraps an existing function.
-   * @param _A_func Pointer to function that will be invoked from operator()().
-   */
-  explicit pointer_functor4(function_type _A_func): func_ptr_(_A_func) {}
-
-  /** Execute the wrapped function.
-   * @param _A_a1 Argument to be passed on to the function.
-   * @param _A_a2 Argument to be passed on to the function.
-   * @param _A_a3 Argument to be passed on to the function.
-   * @param _A_a4 Argument to be passed on to the function.
-   * @return The return value of the function invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const 
-    { return func_ptr_(_A_a1,_A_a2,_A_a3,_A_a4); }
-};
-
-/** pointer_functor5 wraps existing non-member functions with 5 argument(s).
- * Use the convenience function ptr_fun() to create an instance of pointer_functor5.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return>
-class pointer_functor5 : public functor_base
-{
-  typedef T_return (*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5);
-protected: 
-  function_type func_ptr_;
-public:
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  pointer_functor5() {}
-
-  /** Constructs a pointer_functor5 object that wraps an existing function.
-   * @param _A_func Pointer to function that will be invoked from operator()().
-   */
-  explicit pointer_functor5(function_type _A_func): func_ptr_(_A_func) {}
-
-  /** Execute the wrapped function.
-   * @param _A_a1 Argument to be passed on to the function.
-   * @param _A_a2 Argument to be passed on to the function.
-   * @param _A_a3 Argument to be passed on to the function.
-   * @param _A_a4 Argument to be passed on to the function.
-   * @param _A_a5 Argument to be passed on to the function.
-   * @return The return value of the function invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const 
-    { return func_ptr_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
-};
-
-/** pointer_functor6 wraps existing non-member functions with 6 argument(s).
- * Use the convenience function ptr_fun() to create an instance of pointer_functor6.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return>
-class pointer_functor6 : public functor_base
-{
-  typedef T_return (*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6);
-protected: 
-  function_type func_ptr_;
-public:
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  pointer_functor6() {}
-
-  /** Constructs a pointer_functor6 object that wraps an existing function.
-   * @param _A_func Pointer to function that will be invoked from operator()().
-   */
-  explicit pointer_functor6(function_type _A_func): func_ptr_(_A_func) {}
-
-  /** Execute the wrapped function.
-   * @param _A_a1 Argument to be passed on to the function.
-   * @param _A_a2 Argument to be passed on to the function.
-   * @param _A_a3 Argument to be passed on to the function.
-   * @param _A_a4 Argument to be passed on to the function.
-   * @param _A_a5 Argument to be passed on to the function.
-   * @param _A_a6 Argument to be passed on to the function.
-   * @return The return value of the function invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const 
-    { return func_ptr_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
-};
-
-/** pointer_functor7 wraps existing non-member functions with 7 argument(s).
- * Use the convenience function ptr_fun() to create an instance of pointer_functor7.
- *
- * The following template arguments are used:
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_arg7 Argument type used in the definition of operator()().
- * - @e T_return The return type of operator()().
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return>
-class pointer_functor7 : public functor_base
-{
-  typedef T_return (*function_type)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7);
-protected: 
-  function_type func_ptr_;
-public:
-  typedef T_return result_type;
-
-  /// Constructs an invalid functor.
-  pointer_functor7() {}
-
-  /** Constructs a pointer_functor7 object that wraps an existing function.
-   * @param _A_func Pointer to function that will be invoked from operator()().
-   */
-  explicit pointer_functor7(function_type _A_func): func_ptr_(_A_func) {}
-
-  /** Execute the wrapped function.
-   * @param _A_a1 Argument to be passed on to the function.
-   * @param _A_a2 Argument to be passed on to the function.
-   * @param _A_a3 Argument to be passed on to the function.
-   * @param _A_a4 Argument to be passed on to the function.
-   * @param _A_a5 Argument to be passed on to the function.
-   * @param _A_a6 Argument to be passed on to the function.
-   * @param _A_a7 Argument to be passed on to the function.
-   * @return The return value of the function invocation.
-   */
-  T_return operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const 
-    { return func_ptr_(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
-};
-
-
-// numbered ptr_fun
-/** Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member function.
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup ptr_fun
- */
-template <class T_return>
-inline pointer_functor0<T_return> 
-ptr_fun0(T_return (*_A_func)())
-{ return pointer_functor0<T_return>(_A_func); }
-
-/** Creates a functor of type sigc::pointer_functor1 which wraps an existing non-member function.
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1, class T_return>
-inline pointer_functor1<T_arg1, T_return> 
-ptr_fun1(T_return (*_A_func)(T_arg1))
-{ return pointer_functor1<T_arg1, T_return>(_A_func); }
-
-/** Creates a functor of type sigc::pointer_functor2 which wraps an existing non-member function.
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2, class T_return>
-inline pointer_functor2<T_arg1,T_arg2, T_return> 
-ptr_fun2(T_return (*_A_func)(T_arg1,T_arg2))
-{ return pointer_functor2<T_arg1,T_arg2, T_return>(_A_func); }
-
-/** Creates a functor of type sigc::pointer_functor3 which wraps an existing non-member function.
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return>
-inline pointer_functor3<T_arg1,T_arg2,T_arg3, T_return> 
-ptr_fun3(T_return (*_A_func)(T_arg1,T_arg2,T_arg3))
-{ return pointer_functor3<T_arg1,T_arg2,T_arg3, T_return>(_A_func); }
-
-/** Creates a functor of type sigc::pointer_functor4 which wraps an existing non-member function.
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return>
-inline pointer_functor4<T_arg1,T_arg2,T_arg3,T_arg4, T_return> 
-ptr_fun4(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4))
-{ return pointer_functor4<T_arg1,T_arg2,T_arg3,T_arg4, T_return>(_A_func); }
-
-/** Creates a functor of type sigc::pointer_functor5 which wraps an existing non-member function.
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return>
-inline pointer_functor5<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_return> 
-ptr_fun5(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5))
-{ return pointer_functor5<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_return>(_A_func); }
-
-/** Creates a functor of type sigc::pointer_functor6 which wraps an existing non-member function.
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return>
-inline pointer_functor6<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_return> 
-ptr_fun6(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6))
-{ return pointer_functor6<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_return>(_A_func); }
-
-/** Creates a functor of type sigc::pointer_functor7 which wraps an existing non-member function.
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return>
-inline pointer_functor7<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_return> 
-ptr_fun7(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7))
-{ return pointer_functor7<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_return>(_A_func); }
-
-
-// unnumbered ptr_fun
-/** Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member function.
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup ptr_fun
- */
-template <class T_return>
-inline pointer_functor0<T_return> 
-ptr_fun(T_return (*_A_func)())
-{ return pointer_functor0<T_return>(_A_func); }
-
-/** Creates a functor of type sigc::pointer_functor1 which wraps an existing non-member function.
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1, class T_return>
-inline pointer_functor1<T_arg1, T_return> 
-ptr_fun(T_return (*_A_func)(T_arg1))
-{ return pointer_functor1<T_arg1, T_return>(_A_func); }
-
-/** Creates a functor of type sigc::pointer_functor2 which wraps an existing non-member function.
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2, class T_return>
-inline pointer_functor2<T_arg1,T_arg2, T_return> 
-ptr_fun(T_return (*_A_func)(T_arg1,T_arg2))
-{ return pointer_functor2<T_arg1,T_arg2, T_return>(_A_func); }
-
-/** Creates a functor of type sigc::pointer_functor3 which wraps an existing non-member function.
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3, class T_return>
-inline pointer_functor3<T_arg1,T_arg2,T_arg3, T_return> 
-ptr_fun(T_return (*_A_func)(T_arg1,T_arg2,T_arg3))
-{ return pointer_functor3<T_arg1,T_arg2,T_arg3, T_return>(_A_func); }
-
-/** Creates a functor of type sigc::pointer_functor4 which wraps an existing non-member function.
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return>
-inline pointer_functor4<T_arg1,T_arg2,T_arg3,T_arg4, T_return> 
-ptr_fun(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4))
-{ return pointer_functor4<T_arg1,T_arg2,T_arg3,T_arg4, T_return>(_A_func); }
-
-/** Creates a functor of type sigc::pointer_functor5 which wraps an existing non-member function.
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return>
-inline pointer_functor5<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_return> 
-ptr_fun(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5))
-{ return pointer_functor5<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_return>(_A_func); }
-
-/** Creates a functor of type sigc::pointer_functor6 which wraps an existing non-member function.
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return>
-inline pointer_functor6<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_return> 
-ptr_fun(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6))
-{ return pointer_functor6<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_return>(_A_func); }
-
-/** Creates a functor of type sigc::pointer_functor7 which wraps an existing non-member function.
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes @e _A_func on invokation.
- *
- * @ingroup ptr_fun
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return>
-inline pointer_functor7<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_return> 
-ptr_fun(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7))
-{ return pointer_functor7<T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_return>(_A_func); }
-
-
-} /* namespace sigc */
-#endif /* _SIGC_FUNCTORS_MACROS_PTR_FUNHM4_ */
Index: stardict-3.0.1/src/sigc++/functors/slot_base.cc
===================================================================
--- stardict-3.0.1.orig/src/sigc++/functors/slot_base.cc
+++ /dev/null
@@ -1,179 +0,0 @@
-// -*- c++ -*-
-/*
- * Copyright 2003, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-
-#include <sigc++/functors/slot_base.h>
-
-namespace sigc
-{
-
-namespace internal {
-
-// only MSVC needs this to guarantee that all new/delete are executed from the DLL module
-#ifdef SIGC_NEW_DELETE_IN_LIBRARY_ONLY
-void* slot_rep::operator new(size_t size_)
-{
-  return malloc(size_);
-}
-
-void slot_rep::operator delete(void* p)
-{
-  free(p);
-}
-#endif
-
-void slot_rep::disconnect()
-{
-  if (parent_)
-  {
-    call_ = 0;          // Invalidate the slot.
-                        // _Must_ be done here because parent_ might defer the actual
-                        // destruction of the slot_rep and try to invoke it before that point.
-    void* data_ = parent_;
-    parent_ = 0;        // Just a precaution.
-    (cleanup_)(data_);  // Notify the parent (might lead to destruction of this!).
-  }
-  else
-    call_ = 0;
-}
-
-//static
-void* slot_rep::notify(void* data)
-{
-  slot_rep* self_ = reinterpret_cast<slot_rep*>(data);
-
-  self_->call_ = 0; // Invalidate the slot.
-  self_->destroy(); // Detach the stored functor from the other referred trackables and destroy it.
-  self_->disconnect(); // Disconnect the slot (might lead to deletion of self_!).
-
-  return 0;
-}
-
-} // namespace internal
-  
-slot_base::slot_base()
-: rep_(0),
-  blocked_(false)
-{}
-
-slot_base::slot_base(rep_type* rep)
-: rep_(rep),
-  blocked_(false)
-{}
-
-slot_base::slot_base(const slot_base& src)
-: rep_(0),
-  blocked_(src.blocked_)
-{
-  if (src.rep_)
-  {
-    //Check call_ so we can ignore invalidated slots.
-    //Otherwise, destroyed bound reference parameters (whose destruction caused the slot's invalidation) may be used during dup().
-    //Note: I'd prefer to check somewhere during dup(). murrayc.
-    if (src.rep_->call_)
-      rep_ = src.rep_->dup();
-    else
-    {
-      *this = slot_base(); //Return the default invalid slot.
-    }
-  }
-}
-
-slot_base::~slot_base()
-{
-  if (rep_)
-    delete rep_;
-}
-
-slot_base::operator bool() const
-{
-  return rep_ != 0;
-}
-
-slot_base& slot_base::operator=(const slot_base& src)
-{
-  if (src.rep_ == rep_) return *this;
-
-  if (src.empty())
-  {
-    disconnect();
-    return *this;
-  }
-
-  internal::slot_rep* new_rep_ = src.rep_->dup();
-
-  if (rep_)               // Silently exchange the slot_rep.
-  {
-    new_rep_->set_parent(rep_->parent_, rep_->cleanup_);
-    delete rep_;
-  }
-
-  rep_ = new_rep_;
-
-  return *this;
-}
-
-void slot_base::set_parent(void* parent, void* (*cleanup)(void*)) const
-{
-  if (rep_)
-    rep_->set_parent(parent, cleanup);
-}
-
-void slot_base::add_destroy_notify_callback(void* data, func_destroy_notify func) const
-{
-  if (rep_)
-    rep_->add_destroy_notify_callback(data, func);
-}
-
-void slot_base::remove_destroy_notify_callback(void* data) const
-{
-  if (rep_)
-    rep_->remove_destroy_notify_callback(data);
-}
-
-bool slot_base::block(bool should_block)
-{
-  bool old = blocked_;
-  blocked_ = should_block;
-  return old;
-}
-
-bool slot_base::unblock()
-{
-  return block(false);
-}
-
-void slot_base::disconnect()
-{
-  if (rep_)
-    rep_->disconnect();
-}
-
-
-/*bool slot_base::empty() const // having this function not inline is killing performance !!!
-{
-  if (rep_ && !rep_->call_)
-    {
-      delete rep_;        // This is not strictly necessary here. I'm convinced that it is
-      rep_ = 0;           // safe to wait for the destructor to delete the slot_rep. Martin.
-    }
-  return (rep_ == 0);
-}*/
-
-} //namespace sigc
Index: stardict-3.0.1/src/sigc++/functors/slot_base.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/functors/slot_base.h
+++ /dev/null
@@ -1,321 +0,0 @@
-/*
- * Copyright 2003, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#ifndef _SIGC_SLOT_BASE_HPP_
-#define _SIGC_SLOT_BASE_HPP_
-
-#include <sigc++config.h>
-#include <sigc++/trackable.h>
-#include <sigc++/functors/functor_trait.h>
-
-namespace sigc
-{
-
-namespace internal {
-
-typedef void* (*hook)(void*);
-
-/** Internal representation of a slot.
- * Derivations of this class can be considered as a link
- * between a slot and the functor that the slot should
- * execute in operator(). This link is needed because in
- * libsigc++2 the slot doesn't necessarily have exactly the
- * same function signature as the functor thus allowing for
- * implicit conversions.
- * The base class slot_rep serves the purpose to
- * - form a common pointer type (slot_rep*),
- * - offer the possibility to create duplicates (dup()),
- * - offer a notification callback (notify()),
- * - implement some of slot_base's interface that depends
- *   on the notification callback, i.e.
- *   -# the possibility to set a single parent with a callback
- *      (set_parent()) that is executed from notify(),
- *   -# a generic function pointer, call_, that is simply
- *      set to zero in notify() to invalidate the slot.
- * slot_rep inherits trackable so that connection objects can
- * refer to the slot and are notified when the slot is destroyed.
- */
-struct SIGC_API slot_rep : public trackable
-{
-  /* NB: Instead of slot_rep we could inherit slot_base from trackable.
-   * However, a simple benchmark seems to indicate that this slows
-   * down dereferencing of slot list iterators. Martin. */
-
-  /// Callback that invokes the contained functor.
-  /* This can't be a virtual function since number of arguments
-   * must be flexible. We use function pointers to slot_call::call_it()
-   * instead. call_ is set to zero to indicate that the slot is invalid.
-   */
-  hook call_;
-
-  /// Callback that detaches the slot_rep object from referred trackables and destroys it.
-  /* This could be a replaced by a virtual dtor. However since this struct is
-   * crucual for the efficiency of the whole library we want to avoid this.
-   */
-  hook destroy_;
-
-  /** Callback that makes a deep copy of the slot_rep object.
-   * @return A deep copy of the slot_rep object.
-   */
-  hook dup_;
-
-  /** Callback of parent_. */
-  hook cleanup_;
-
-  /** Parent object whose callback cleanup_ is executed on notification. */
-  void* parent_;
-
-  inline slot_rep(hook call__, hook destroy__, hook dup__)
-    : call_(call__), destroy_(destroy__), dup_(dup__), cleanup_(0), parent_(0) {}
-
-  inline ~slot_rep()
-    { destroy(); }
-
-  // only MSVC needs this to guarantee that all new/delete are executed from the DLL module
-#ifdef SIGC_NEW_DELETE_IN_LIBRARY_ONLY
-  void* operator new(size_t size_);
-  void operator delete(void* p);
-#endif
-
-  /** Destroys the slot_rep object (but doesn't delete it).
-   */
-  inline void destroy()
-    { if (destroy_) (*destroy_)(this); }
-
-  /** Makes a deep copy of the slot_rep object.
-   * @return A deep copy of the slot_rep object.
-   */
-  inline slot_rep* dup() const
-    { return reinterpret_cast<slot_rep*>((*dup_)(const_cast<slot_rep*>(this))); }
-
-  /** Set the parent with a callback.
-   * slots have one parent exclusively.
-   * @param parent The new parent.
-   * @param cleanup The callback to execute from notify().
-   */
-  inline void set_parent(void* parent, hook cleanup)
-    {
-      parent_ = parent;
-      cleanup_ = cleanup;
-    }
-
-  /// Invalidates the slot and executes the parent's cleanup callback.
-  void disconnect();
-
-  /** Callback that invalidates the slot.
-   * This callback is registered in every object of a trackable
-   * inherited type that is referred by this slot_rep object.
-   * It is executed when the slot becomes invalid because of some
-   * referred object dying.
-   * @param data The slot_rep object that is becoming invalid (@p this).
-   */
-  static void* notify(void* data);
-};
-
-/** Functor used to add a dependency to a trackable.
- * Consequently slot_rep::notify() gets executed when the
- * trackable is destroyed or overwritten.
- */
-struct SIGC_API slot_do_bind
-{
-  /** The slot_rep object trackables should notify on destruction. */
-  slot_rep* rep_;
-
-  /** Construct a slot_do_bind functor.
-   * @param rep The slot_rep object trackables should notify on destruction.
-   */
-  inline slot_do_bind(slot_rep* rep) : rep_(rep) {}
-
-  /** Adds a dependency to @p t.
-   * @param t The trackable object to add a callback to.
-   */
-  inline void operator()(const trackable* t) const
-    { t->add_destroy_notify_callback(rep_, &slot_rep::notify); }
-};
-
-/// Functor used to remove a dependency from a trackable.
-struct SIGC_API slot_do_unbind
-{
-  /** The slot_rep object trackables don't need to notify on destruction any more. */
-  slot_rep* rep_;
-
-  /** Construct a slot_do_unbind functor.
-   * @param rep The slot_rep object trackables don't need to notify on destruction any more.
-   */
-  inline slot_do_unbind(slot_rep* rep) : rep_(rep) {}
-
-  /** Removes a dependency from @p t.
-   * @param t The trackable object to remove the callback from.
-   */
-  inline void operator()(const trackable* t) const
-    { t->remove_destroy_notify_callback(rep_); }
-};
-
-} //namespace internal
-
-
-/** @defgroup slot Slots
- * Slots are type-safe representations of callback methods and functions.
- * A Slot can be constructed from any function, regardless of whether it is a global function,
- * a member method, static, or virtual.
- *
- * Use the sigc::mem_fun() and sigc::ptr_fun() template functions to get a sigc::slot, like so:
- *
- * @code
- * sigc::slot<void, int> sl = sigc::mem_fun(someobj,& SomeClass::somemethod);
- * @endcode
- *
- * or
- *
- * @code
- * sigc::slot<void, int> sl = sigc::ptr_fun(&somefunction);
- * @endcode
- *
- * or
- *
- * @code
- * m_Button.signal_clicked().connect( sigc::mem_fun(*this, &MyWindow::on_button_clicked) );
- * @endcode
- *
- * The compiler will complain if SomeClass::somemethod, etc. have the wrong signature.
- *
- * You can also pass slots as method parameters where you might normally pass a function pointer.
- *
- * @ingroup functors
- */
-
-/** Base type for slots.
- * slot_base integrates most of the interface of the derived
- * sigc::slot templates. slots
- * can be connected to signals, be disconnected at some later point
- * (disconnect()) and temporarily be blocked (block(), unblock()).
- * The validity of a slot can be tested with empty().
- *
- * The internal representation of a sigc::internal::slot_rep derived
- * type is built from slot_base's derivations. set_parent() is used to
- * register a notification callback that is executed when the slot gets
- * invalid. add_destroy_notify_callback() is used by connection objects
- * to add a notification callback that is executed on destruction.
- *
- * @ingroup slot
- */
-class SIGC_API slot_base : public functor_base
-{
-  typedef internal::slot_rep rep_type;
-
-public:
-  /// Constructs an empty slot.
-  slot_base();
-
-  /** Constructs a slot from an existing slot_rep object.
-   * @param rep The slot_rep object this slot should contain.
-   */
-  explicit slot_base(rep_type* rep);
-
-  /** Constructs a slot, copying an existing one.
-   * @param src The existing slot to copy.
-   */
-  slot_base(const slot_base& src);
-
-  ~slot_base();
-
-  /** Tests whether a slot is null, because the default constructor was used.
-   * Test a slot for null like so:
-   * @code
-   * if(slot)
-   *  do_something()
-   * @endcode
-   */
-  operator bool() const;
-
-  /** Sets the parent of this slot.
-   * This function is used by signals to register a notification callback.
-   * This notification callback is executed when the slot becomes invalid
-   * because of some referred object dying.
-   * @param parent The new parent.
-   * @param cleanup The notification callback.
-   */
-  void set_parent(void* parent, void* (*cleanup)(void*)) const;
-
-  typedef trackable::func_destroy_notify func_destroy_notify;
-  /** Add a callback that is executed (notified) when the slot is detroyed.
-   * This function is used internally by connection objects.
-   * @param data Passed into func upon notification.
-   * @param func Callback executed upon destruction of the object.
-   */
-  void add_destroy_notify_callback(void* data, func_destroy_notify func) const;
-
-  /** Remove a callback previously installed with add_destroy_notify_callback().
-   * The callback is not executed.
-   * @param data Parameter passed into previous call to add_destroy_notify_callback().
-   */
-  void remove_destroy_notify_callback(void* data) const;
-
-  /** Returns whether the slot is invalid.
-   * @return @p true if the slot is invalid (empty).
-   */
-  inline bool empty() const
-    { return (!rep_ || !rep_->call_); }
-
-  /** Returns whether the slot is blocked.
-   * @return @p true if the slot is blocked.
-   */
-  inline bool blocked() const
-    { return blocked_; }
-    
-  /** Sets the blocking state.
-   * If @e should_block is @p true then the blocking state is set.
-   * Subsequent calls to slot::operator()() don't invoke the functor
-   * contained by this slot until unblock() or block() with
-   * @e should_block = @p false is called.
-   * @param should_block Indicates whether the blocking state should be set or unset.
-   * @return @p true if the slot was in blocking state before.
-   */
-  bool block(bool should_block = true);
-
-  /** Unsets the blocking state.
-   * @return @p true if the slot was in blocking state before.
-   */
-  bool unblock();
-
-  /** Disconnects the slot.
-   * Invalidates the slot and notifies the parent.
-   */
-  void disconnect();
-
-//The Tru64 and Solaris Forte 5.5 compilers needs this operator=() to be public. I'm not sure why, or why it needs to be protected usually. murrayc.
-//See bug #168265. 
-//protected:
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  slot_base& operator=(const slot_base& src);
-
-public: // public to avoid template friend declarations
-  /** Typed slot_rep object that contains a functor. */
-  mutable rep_type *rep_;
-
-  /** Indicates whether the slot is blocked. */
-  bool blocked_;
-};
-
-} //namespace sigc
-
-#endif //_SIGC_SLOT_BASE_HPP_
-
Index: stardict-3.0.1/src/sigc++/functors/slot.cc
===================================================================
--- stardict-3.0.1.orig/src/sigc++/functors/slot.cc
+++ /dev/null
@@ -1,25 +0,0 @@
-// -*- c++ -*-
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#include <sigc++/functors/slot.h>
-
-namespace sigc {
-
-
-} /* namespace sigc */
Index: stardict-3.0.1/src/sigc++/functors/slot.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/functors/slot.h
+++ /dev/null
@@ -1,1301 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-#ifndef _SIGC_FUNCTORS_MACROS_SLOTHM4_
-#define _SIGC_FUNCTORS_MACROS_SLOTHM4_
-#include <sigc++/trackable.h>
-#include <sigc++/visit_each.h>
-#include <sigc++/adaptors/adaptor_trait.h>
-#include <sigc++/functors/slot_base.h>
-
-namespace sigc {
-
-namespace internal {
-
-/** A typed slot_rep.
- * A typed slot_rep holds a functor that can be invoked from
- * slot::operator()(). visit_each() is used to visit the functor's
- * targets that inherit trackable recursively and register the
- * notification callback. Consequently the slot_rep object will be
- * notified when some referred object is destroyed or overwritten.
- */
-template <class T_functor>
-struct typed_slot_rep : public slot_rep
-{
-  typedef typed_slot_rep<T_functor> self;
-
-  /* Use an adaptor type so that arguments can be passed as const references
-   * through explicit template instantiation from slot_call#::call_it() */
-  typedef typename adaptor_trait<T_functor>::adaptor_type adaptor_type;
-
-  /** The functor contained by this slot_rep object. */
-  adaptor_type functor_;
-
-  /** Constructs an invalid typed slot_rep object.
-   * The notification callback is registered using visit_each().
-   * @param functor The functor contained by the new slot_rep object.
-   */
-  inline typed_slot_rep(const T_functor& functor)
-    : slot_rep(0, &destroy, &dup), functor_(functor)
-    { visit_each_type<trackable*>(slot_do_bind(this), functor_); }
-
-  inline typed_slot_rep(const typed_slot_rep& cl)
-    : slot_rep(cl.call_, &destroy, &dup), functor_(cl.functor_)
-    { visit_each_type<trackable*>(slot_do_bind(this), functor_); }
-
-  inline ~typed_slot_rep()
-    {
-      call_ = 0;
-      destroy_ = 0;
-      visit_each_type<trackable*>(slot_do_unbind(this), functor_);
-    }
-
-  /** Detaches the stored functor from the other referred trackables and destroys it.
-   * This does not destroy the base slot_rep object.
-   */
-  static void* destroy(void* data)
-    {
-      self* self_ = static_cast<self*>(reinterpret_cast<slot_rep*>(data));
-      self_->call_ = 0;
-      self_->destroy_ = 0;
-      visit_each_type<trackable*>(slot_do_unbind(self_), self_->functor_);
-      self_->functor_.~adaptor_type();
-      /* don't call disconnect() here: destroy() is either called
-       * a) from the parent itself (in which case disconnect() leads to a segfault) or
-       * b) from a parentless slot (in which case disconnect() does nothing)
-       */
-      return 0;
-    }
-
-  /** Makes a deep copy of the slot_rep object.
-   * Deep copy means that the notification callback of the new
-   * slot_rep object is registered in the referred trackables.
-   * @return A deep copy of the slot_rep object.
-   */
-  static void* dup(void* data)
-    {
-      slot_rep* a_rep = reinterpret_cast<slot_rep*>(data);
-      return static_cast<slot_rep*>(new self(*static_cast<self*>(a_rep)));
-    }
-};
-
-
-/** Abstracts functor execution.
- * call_it() invokes a functor of type @e T_functor with a list of
- * parameters whose types are given by the template arguments.
- * address() forms a function pointer from call_it().
- *
- * The following template arguments are used:
- * - @e T_functor The functor type.
- * - @e T_return The return type of call_it().
- *
- */
-template<class T_functor, class T_return>
-struct slot_call0
-{
-  /** Invokes a functor of type @p T_functor.
-   * @param rep slot_rep object that holds a functor of type @p T_functor.
-   * @return The return values of the functor invocation.
-   */
-  static T_return call_it(slot_rep* rep)
-    {
-      typedef typed_slot_rep<T_functor> typed_slot;
-      typed_slot *typed_rep = static_cast<typed_slot*>(rep);
-      return (typed_rep->functor_)();
-    }
-
-  /** Forms a function pointer from call_it().
-   * @return A function pointer formed from call_it().
-   */
-  static hook address() 
-    { return reinterpret_cast<hook>(&call_it); }
-};
-
-/** Abstracts functor execution.
- * call_it() invokes a functor of type @e T_functor with a list of
- * parameters whose types are given by the template arguments.
- * address() forms a function pointer from call_it().
- *
- * The following template arguments are used:
- * - @e T_functor The functor type.
- * - @e T_return The return type of call_it().
- * - @e T_arg1 Argument type used in the definition of call_it().
- *
- */
-template<class T_functor, class T_return, class T_arg1>
-struct slot_call1
-{
-  /** Invokes a functor of type @p T_functor.
-   * @param rep slot_rep object that holds a functor of type @p T_functor.
-   * @param _A_a1 Argument to be passed on to the functor.
-   * @return The return values of the functor invocation.
-   */
-  static T_return call_it(slot_rep* rep, typename type_trait<T_arg1>::take a_1)
-    {
-      typedef typed_slot_rep<T_functor> typed_slot;
-      typed_slot *typed_rep = static_cast<typed_slot*>(rep);
-      return (typed_rep->functor_).SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::take>
-               (a_1);
-    }
-
-  /** Forms a function pointer from call_it().
-   * @return A function pointer formed from call_it().
-   */
-  static hook address() 
-    { return reinterpret_cast<hook>(&call_it); }
-};
-
-/** Abstracts functor execution.
- * call_it() invokes a functor of type @e T_functor with a list of
- * parameters whose types are given by the template arguments.
- * address() forms a function pointer from call_it().
- *
- * The following template arguments are used:
- * - @e T_functor The functor type.
- * - @e T_return The return type of call_it().
- * - @e T_arg1 Argument type used in the definition of call_it().
- * - @e T_arg2 Argument type used in the definition of call_it().
- *
- */
-template<class T_functor, class T_return, class T_arg1,class T_arg2>
-struct slot_call2
-{
-  /** Invokes a functor of type @p T_functor.
-   * @param rep slot_rep object that holds a functor of type @p T_functor.
-   * @param _A_a1 Argument to be passed on to the functor.
-   * @param _A_a2 Argument to be passed on to the functor.
-   * @return The return values of the functor invocation.
-   */
-  static T_return call_it(slot_rep* rep, typename type_trait<T_arg1>::take a_1,typename type_trait<T_arg2>::take a_2)
-    {
-      typedef typed_slot_rep<T_functor> typed_slot;
-      typed_slot *typed_rep = static_cast<typed_slot*>(rep);
-      return (typed_rep->functor_).SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take>
-               (a_1,a_2);
-    }
-
-  /** Forms a function pointer from call_it().
-   * @return A function pointer formed from call_it().
-   */
-  static hook address() 
-    { return reinterpret_cast<hook>(&call_it); }
-};
-
-/** Abstracts functor execution.
- * call_it() invokes a functor of type @e T_functor with a list of
- * parameters whose types are given by the template arguments.
- * address() forms a function pointer from call_it().
- *
- * The following template arguments are used:
- * - @e T_functor The functor type.
- * - @e T_return The return type of call_it().
- * - @e T_arg1 Argument type used in the definition of call_it().
- * - @e T_arg2 Argument type used in the definition of call_it().
- * - @e T_arg3 Argument type used in the definition of call_it().
- *
- */
-template<class T_functor, class T_return, class T_arg1,class T_arg2,class T_arg3>
-struct slot_call3
-{
-  /** Invokes a functor of type @p T_functor.
-   * @param rep slot_rep object that holds a functor of type @p T_functor.
-   * @param _A_a1 Argument to be passed on to the functor.
-   * @param _A_a2 Argument to be passed on to the functor.
-   * @param _A_a3 Argument to be passed on to the functor.
-   * @return The return values of the functor invocation.
-   */
-  static T_return call_it(slot_rep* rep, typename type_trait<T_arg1>::take a_1,typename type_trait<T_arg2>::take a_2,typename type_trait<T_arg3>::take a_3)
-    {
-      typedef typed_slot_rep<T_functor> typed_slot;
-      typed_slot *typed_rep = static_cast<typed_slot*>(rep);
-      return (typed_rep->functor_).SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take>
-               (a_1,a_2,a_3);
-    }
-
-  /** Forms a function pointer from call_it().
-   * @return A function pointer formed from call_it().
-   */
-  static hook address() 
-    { return reinterpret_cast<hook>(&call_it); }
-};
-
-/** Abstracts functor execution.
- * call_it() invokes a functor of type @e T_functor with a list of
- * parameters whose types are given by the template arguments.
- * address() forms a function pointer from call_it().
- *
- * The following template arguments are used:
- * - @e T_functor The functor type.
- * - @e T_return The return type of call_it().
- * - @e T_arg1 Argument type used in the definition of call_it().
- * - @e T_arg2 Argument type used in the definition of call_it().
- * - @e T_arg3 Argument type used in the definition of call_it().
- * - @e T_arg4 Argument type used in the definition of call_it().
- *
- */
-template<class T_functor, class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-struct slot_call4
-{
-  /** Invokes a functor of type @p T_functor.
-   * @param rep slot_rep object that holds a functor of type @p T_functor.
-   * @param _A_a1 Argument to be passed on to the functor.
-   * @param _A_a2 Argument to be passed on to the functor.
-   * @param _A_a3 Argument to be passed on to the functor.
-   * @param _A_a4 Argument to be passed on to the functor.
-   * @return The return values of the functor invocation.
-   */
-  static T_return call_it(slot_rep* rep, typename type_trait<T_arg1>::take a_1,typename type_trait<T_arg2>::take a_2,typename type_trait<T_arg3>::take a_3,typename type_trait<T_arg4>::take a_4)
-    {
-      typedef typed_slot_rep<T_functor> typed_slot;
-      typed_slot *typed_rep = static_cast<typed_slot*>(rep);
-      return (typed_rep->functor_).SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take>
-               (a_1,a_2,a_3,a_4);
-    }
-
-  /** Forms a function pointer from call_it().
-   * @return A function pointer formed from call_it().
-   */
-  static hook address() 
-    { return reinterpret_cast<hook>(&call_it); }
-};
-
-/** Abstracts functor execution.
- * call_it() invokes a functor of type @e T_functor with a list of
- * parameters whose types are given by the template arguments.
- * address() forms a function pointer from call_it().
- *
- * The following template arguments are used:
- * - @e T_functor The functor type.
- * - @e T_return The return type of call_it().
- * - @e T_arg1 Argument type used in the definition of call_it().
- * - @e T_arg2 Argument type used in the definition of call_it().
- * - @e T_arg3 Argument type used in the definition of call_it().
- * - @e T_arg4 Argument type used in the definition of call_it().
- * - @e T_arg5 Argument type used in the definition of call_it().
- *
- */
-template<class T_functor, class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-struct slot_call5
-{
-  /** Invokes a functor of type @p T_functor.
-   * @param rep slot_rep object that holds a functor of type @p T_functor.
-   * @param _A_a1 Argument to be passed on to the functor.
-   * @param _A_a2 Argument to be passed on to the functor.
-   * @param _A_a3 Argument to be passed on to the functor.
-   * @param _A_a4 Argument to be passed on to the functor.
-   * @param _A_a5 Argument to be passed on to the functor.
-   * @return The return values of the functor invocation.
-   */
-  static T_return call_it(slot_rep* rep, typename type_trait<T_arg1>::take a_1,typename type_trait<T_arg2>::take a_2,typename type_trait<T_arg3>::take a_3,typename type_trait<T_arg4>::take a_4,typename type_trait<T_arg5>::take a_5)
-    {
-      typedef typed_slot_rep<T_functor> typed_slot;
-      typed_slot *typed_rep = static_cast<typed_slot*>(rep);
-      return (typed_rep->functor_).SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take>
-               (a_1,a_2,a_3,a_4,a_5);
-    }
-
-  /** Forms a function pointer from call_it().
-   * @return A function pointer formed from call_it().
-   */
-  static hook address() 
-    { return reinterpret_cast<hook>(&call_it); }
-};
-
-/** Abstracts functor execution.
- * call_it() invokes a functor of type @e T_functor with a list of
- * parameters whose types are given by the template arguments.
- * address() forms a function pointer from call_it().
- *
- * The following template arguments are used:
- * - @e T_functor The functor type.
- * - @e T_return The return type of call_it().
- * - @e T_arg1 Argument type used in the definition of call_it().
- * - @e T_arg2 Argument type used in the definition of call_it().
- * - @e T_arg3 Argument type used in the definition of call_it().
- * - @e T_arg4 Argument type used in the definition of call_it().
- * - @e T_arg5 Argument type used in the definition of call_it().
- * - @e T_arg6 Argument type used in the definition of call_it().
- *
- */
-template<class T_functor, class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-struct slot_call6
-{
-  /** Invokes a functor of type @p T_functor.
-   * @param rep slot_rep object that holds a functor of type @p T_functor.
-   * @param _A_a1 Argument to be passed on to the functor.
-   * @param _A_a2 Argument to be passed on to the functor.
-   * @param _A_a3 Argument to be passed on to the functor.
-   * @param _A_a4 Argument to be passed on to the functor.
-   * @param _A_a5 Argument to be passed on to the functor.
-   * @param _A_a6 Argument to be passed on to the functor.
-   * @return The return values of the functor invocation.
-   */
-  static T_return call_it(slot_rep* rep, typename type_trait<T_arg1>::take a_1,typename type_trait<T_arg2>::take a_2,typename type_trait<T_arg3>::take a_3,typename type_trait<T_arg4>::take a_4,typename type_trait<T_arg5>::take a_5,typename type_trait<T_arg6>::take a_6)
-    {
-      typedef typed_slot_rep<T_functor> typed_slot;
-      typed_slot *typed_rep = static_cast<typed_slot*>(rep);
-      return (typed_rep->functor_).SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take,typename type_trait<T_arg6>::take>
-               (a_1,a_2,a_3,a_4,a_5,a_6);
-    }
-
-  /** Forms a function pointer from call_it().
-   * @return A function pointer formed from call_it().
-   */
-  static hook address() 
-    { return reinterpret_cast<hook>(&call_it); }
-};
-
-/** Abstracts functor execution.
- * call_it() invokes a functor of type @e T_functor with a list of
- * parameters whose types are given by the template arguments.
- * address() forms a function pointer from call_it().
- *
- * The following template arguments are used:
- * - @e T_functor The functor type.
- * - @e T_return The return type of call_it().
- * - @e T_arg1 Argument type used in the definition of call_it().
- * - @e T_arg2 Argument type used in the definition of call_it().
- * - @e T_arg3 Argument type used in the definition of call_it().
- * - @e T_arg4 Argument type used in the definition of call_it().
- * - @e T_arg5 Argument type used in the definition of call_it().
- * - @e T_arg6 Argument type used in the definition of call_it().
- * - @e T_arg7 Argument type used in the definition of call_it().
- *
- */
-template<class T_functor, class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-struct slot_call7
-{
-  /** Invokes a functor of type @p T_functor.
-   * @param rep slot_rep object that holds a functor of type @p T_functor.
-   * @param _A_a1 Argument to be passed on to the functor.
-   * @param _A_a2 Argument to be passed on to the functor.
-   * @param _A_a3 Argument to be passed on to the functor.
-   * @param _A_a4 Argument to be passed on to the functor.
-   * @param _A_a5 Argument to be passed on to the functor.
-   * @param _A_a6 Argument to be passed on to the functor.
-   * @param _A_a7 Argument to be passed on to the functor.
-   * @return The return values of the functor invocation.
-   */
-  static T_return call_it(slot_rep* rep, typename type_trait<T_arg1>::take a_1,typename type_trait<T_arg2>::take a_2,typename type_trait<T_arg3>::take a_3,typename type_trait<T_arg4>::take a_4,typename type_trait<T_arg5>::take a_5,typename type_trait<T_arg6>::take a_6,typename type_trait<T_arg7>::take a_7)
-    {
-      typedef typed_slot_rep<T_functor> typed_slot;
-      typed_slot *typed_rep = static_cast<typed_slot*>(rep);
-      return (typed_rep->functor_).SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take,typename type_trait<T_arg6>::take,typename type_trait<T_arg7>::take>
-               (a_1,a_2,a_3,a_4,a_5,a_6,a_7);
-    }
-
-  /** Forms a function pointer from call_it().
-   * @return A function pointer formed from call_it().
-   */
-  static hook address() 
-    { return reinterpret_cast<hook>(&call_it); }
-};
-
-} /* namespace internal */
-
-
-/** Converts an arbitrary functor to a unified type which is opaque.
- * sigc::slot itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * You should use the more convenient unnumbered sigc::slot template.
- *
- * @ingroup slot
- */
-/* TODO: Where put the following bit of information? I can't make any
- *       sense of the "because", by the way!
- *
- * Because slot is opaque, visit_each() will not visit its internal members.
- */
-template <class T_return>
-class slot0
-  : public slot_base
-{
-public:
-  typedef T_return result_type;
-
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-private:
-  typedef internal::slot_rep rep_type;
-public:
-  typedef T_return (*call_type)(rep_type*);
-#endif
-
-  /** Invoke the contained functor unless slot is in blocking state.
-   * @return The return value of the functor invocation.
-   */
-  inline T_return operator()() const
-    {
-      if (!empty() && !blocked())
-        return (reinterpret_cast<call_type>(slot_base::rep_->call_))(slot_base::rep_);
-      return T_return();
-    }
-
-  inline slot0() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desirer functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  slot0(const T_functor& _A_func)
-    : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))
-    {
-      //The slot_base:: is necessary to stop the HP-UX aCC compiler from being confused. murrayc.
-      slot_base::rep_->call_ = internal::slot_call0<T_functor, T_return>::address();
-    }
-
-  slot0(const slot0& src)
-    : slot_base(src) {}
-
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  slot0& operator=(const slot0& src)
-    { slot_base::operator=(src); return *this; }
-};
-
-/** Converts an arbitrary functor to a unified type which is opaque.
- * sigc::slot itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- * - @e T_arg1 Argument type used in the definition of operator()(). The default @p nil means no argument.
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * You should use the more convenient unnumbered sigc::slot template.
- *
- * @ingroup slot
- */
-/* TODO: Where put the following bit of information? I can't make any
- *       sense of the "because", by the way!
- *
- * Because slot is opaque, visit_each() will not visit its internal members.
- */
-template <class T_return, class T_arg1>
-class slot1
-  : public slot_base
-{
-public:
-  typedef T_return result_type;
-  typedef typename type_trait<T_arg1>::take arg1_type_;
-
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-private:
-  typedef internal::slot_rep rep_type;
-public:
-  typedef T_return (*call_type)(rep_type*, arg1_type_);
-#endif
-
-  /** Invoke the contained functor unless slot is in blocking state.
-   * @param _A_a1 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  inline T_return operator()(arg1_type_ _A_a1) const
-    {
-      if (!empty() && !blocked())
-        return (reinterpret_cast<call_type>(slot_base::rep_->call_))(slot_base::rep_, _A_a1);
-      return T_return();
-    }
-
-  inline slot1() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desirer functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  slot1(const T_functor& _A_func)
-    : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))
-    {
-      //The slot_base:: is necessary to stop the HP-UX aCC compiler from being confused. murrayc.
-      slot_base::rep_->call_ = internal::slot_call1<T_functor, T_return, T_arg1>::address();
-    }
-
-  slot1(const slot1& src)
-    : slot_base(src) {}
-
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  slot1& operator=(const slot1& src)
-    { slot_base::operator=(src); return *this; }
-};
-
-/** Converts an arbitrary functor to a unified type which is opaque.
- * sigc::slot itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- * - @e T_arg1 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg2 Argument type used in the definition of operator()(). The default @p nil means no argument.
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * You should use the more convenient unnumbered sigc::slot template.
- *
- * @ingroup slot
- */
-/* TODO: Where put the following bit of information? I can't make any
- *       sense of the "because", by the way!
- *
- * Because slot is opaque, visit_each() will not visit its internal members.
- */
-template <class T_return, class T_arg1,class T_arg2>
-class slot2
-  : public slot_base
-{
-public:
-  typedef T_return result_type;
-  typedef typename type_trait<T_arg1>::take arg1_type_;
-  typedef typename type_trait<T_arg2>::take arg2_type_;
-
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-private:
-  typedef internal::slot_rep rep_type;
-public:
-  typedef T_return (*call_type)(rep_type*, arg1_type_,arg2_type_);
-#endif
-
-  /** Invoke the contained functor unless slot is in blocking state.
-   * @param _A_a1 Argument to be passed on to the functor.
-   * @param _A_a2 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  inline T_return operator()(arg1_type_ _A_a1,arg2_type_ _A_a2) const
-    {
-      if (!empty() && !blocked())
-        return (reinterpret_cast<call_type>(slot_base::rep_->call_))(slot_base::rep_, _A_a1,_A_a2);
-      return T_return();
-    }
-
-  inline slot2() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desirer functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  slot2(const T_functor& _A_func)
-    : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))
-    {
-      //The slot_base:: is necessary to stop the HP-UX aCC compiler from being confused. murrayc.
-      slot_base::rep_->call_ = internal::slot_call2<T_functor, T_return, T_arg1,T_arg2>::address();
-    }
-
-  slot2(const slot2& src)
-    : slot_base(src) {}
-
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  slot2& operator=(const slot2& src)
-    { slot_base::operator=(src); return *this; }
-};
-
-/** Converts an arbitrary functor to a unified type which is opaque.
- * sigc::slot itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- * - @e T_arg1 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg2 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg3 Argument type used in the definition of operator()(). The default @p nil means no argument.
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * You should use the more convenient unnumbered sigc::slot template.
- *
- * @ingroup slot
- */
-/* TODO: Where put the following bit of information? I can't make any
- *       sense of the "because", by the way!
- *
- * Because slot is opaque, visit_each() will not visit its internal members.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3>
-class slot3
-  : public slot_base
-{
-public:
-  typedef T_return result_type;
-  typedef typename type_trait<T_arg1>::take arg1_type_;
-  typedef typename type_trait<T_arg2>::take arg2_type_;
-  typedef typename type_trait<T_arg3>::take arg3_type_;
-
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-private:
-  typedef internal::slot_rep rep_type;
-public:
-  typedef T_return (*call_type)(rep_type*, arg1_type_,arg2_type_,arg3_type_);
-#endif
-
-  /** Invoke the contained functor unless slot is in blocking state.
-   * @param _A_a1 Argument to be passed on to the functor.
-   * @param _A_a2 Argument to be passed on to the functor.
-   * @param _A_a3 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  inline T_return operator()(arg1_type_ _A_a1,arg2_type_ _A_a2,arg3_type_ _A_a3) const
-    {
-      if (!empty() && !blocked())
-        return (reinterpret_cast<call_type>(slot_base::rep_->call_))(slot_base::rep_, _A_a1,_A_a2,_A_a3);
-      return T_return();
-    }
-
-  inline slot3() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desirer functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  slot3(const T_functor& _A_func)
-    : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))
-    {
-      //The slot_base:: is necessary to stop the HP-UX aCC compiler from being confused. murrayc.
-      slot_base::rep_->call_ = internal::slot_call3<T_functor, T_return, T_arg1,T_arg2,T_arg3>::address();
-    }
-
-  slot3(const slot3& src)
-    : slot_base(src) {}
-
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  slot3& operator=(const slot3& src)
-    { slot_base::operator=(src); return *this; }
-};
-
-/** Converts an arbitrary functor to a unified type which is opaque.
- * sigc::slot itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- * - @e T_arg1 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg2 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg3 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg4 Argument type used in the definition of operator()(). The default @p nil means no argument.
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * You should use the more convenient unnumbered sigc::slot template.
- *
- * @ingroup slot
- */
-/* TODO: Where put the following bit of information? I can't make any
- *       sense of the "because", by the way!
- *
- * Because slot is opaque, visit_each() will not visit its internal members.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-class slot4
-  : public slot_base
-{
-public:
-  typedef T_return result_type;
-  typedef typename type_trait<T_arg1>::take arg1_type_;
-  typedef typename type_trait<T_arg2>::take arg2_type_;
-  typedef typename type_trait<T_arg3>::take arg3_type_;
-  typedef typename type_trait<T_arg4>::take arg4_type_;
-
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-private:
-  typedef internal::slot_rep rep_type;
-public:
-  typedef T_return (*call_type)(rep_type*, arg1_type_,arg2_type_,arg3_type_,arg4_type_);
-#endif
-
-  /** Invoke the contained functor unless slot is in blocking state.
-   * @param _A_a1 Argument to be passed on to the functor.
-   * @param _A_a2 Argument to be passed on to the functor.
-   * @param _A_a3 Argument to be passed on to the functor.
-   * @param _A_a4 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  inline T_return operator()(arg1_type_ _A_a1,arg2_type_ _A_a2,arg3_type_ _A_a3,arg4_type_ _A_a4) const
-    {
-      if (!empty() && !blocked())
-        return (reinterpret_cast<call_type>(slot_base::rep_->call_))(slot_base::rep_, _A_a1,_A_a2,_A_a3,_A_a4);
-      return T_return();
-    }
-
-  inline slot4() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desirer functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  slot4(const T_functor& _A_func)
-    : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))
-    {
-      //The slot_base:: is necessary to stop the HP-UX aCC compiler from being confused. murrayc.
-      slot_base::rep_->call_ = internal::slot_call4<T_functor, T_return, T_arg1,T_arg2,T_arg3,T_arg4>::address();
-    }
-
-  slot4(const slot4& src)
-    : slot_base(src) {}
-
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  slot4& operator=(const slot4& src)
-    { slot_base::operator=(src); return *this; }
-};
-
-/** Converts an arbitrary functor to a unified type which is opaque.
- * sigc::slot itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- * - @e T_arg1 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg2 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg3 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg4 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg5 Argument type used in the definition of operator()(). The default @p nil means no argument.
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * You should use the more convenient unnumbered sigc::slot template.
- *
- * @ingroup slot
- */
-/* TODO: Where put the following bit of information? I can't make any
- *       sense of the "because", by the way!
- *
- * Because slot is opaque, visit_each() will not visit its internal members.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-class slot5
-  : public slot_base
-{
-public:
-  typedef T_return result_type;
-  typedef typename type_trait<T_arg1>::take arg1_type_;
-  typedef typename type_trait<T_arg2>::take arg2_type_;
-  typedef typename type_trait<T_arg3>::take arg3_type_;
-  typedef typename type_trait<T_arg4>::take arg4_type_;
-  typedef typename type_trait<T_arg5>::take arg5_type_;
-
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-private:
-  typedef internal::slot_rep rep_type;
-public:
-  typedef T_return (*call_type)(rep_type*, arg1_type_,arg2_type_,arg3_type_,arg4_type_,arg5_type_);
-#endif
-
-  /** Invoke the contained functor unless slot is in blocking state.
-   * @param _A_a1 Argument to be passed on to the functor.
-   * @param _A_a2 Argument to be passed on to the functor.
-   * @param _A_a3 Argument to be passed on to the functor.
-   * @param _A_a4 Argument to be passed on to the functor.
-   * @param _A_a5 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  inline T_return operator()(arg1_type_ _A_a1,arg2_type_ _A_a2,arg3_type_ _A_a3,arg4_type_ _A_a4,arg5_type_ _A_a5) const
-    {
-      if (!empty() && !blocked())
-        return (reinterpret_cast<call_type>(slot_base::rep_->call_))(slot_base::rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
-      return T_return();
-    }
-
-  inline slot5() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desirer functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  slot5(const T_functor& _A_func)
-    : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))
-    {
-      //The slot_base:: is necessary to stop the HP-UX aCC compiler from being confused. murrayc.
-      slot_base::rep_->call_ = internal::slot_call5<T_functor, T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>::address();
-    }
-
-  slot5(const slot5& src)
-    : slot_base(src) {}
-
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  slot5& operator=(const slot5& src)
-    { slot_base::operator=(src); return *this; }
-};
-
-/** Converts an arbitrary functor to a unified type which is opaque.
- * sigc::slot itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- * - @e T_arg1 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg2 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg3 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg4 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg5 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg6 Argument type used in the definition of operator()(). The default @p nil means no argument.
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * You should use the more convenient unnumbered sigc::slot template.
- *
- * @ingroup slot
- */
-/* TODO: Where put the following bit of information? I can't make any
- *       sense of the "because", by the way!
- *
- * Because slot is opaque, visit_each() will not visit its internal members.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-class slot6
-  : public slot_base
-{
-public:
-  typedef T_return result_type;
-  typedef typename type_trait<T_arg1>::take arg1_type_;
-  typedef typename type_trait<T_arg2>::take arg2_type_;
-  typedef typename type_trait<T_arg3>::take arg3_type_;
-  typedef typename type_trait<T_arg4>::take arg4_type_;
-  typedef typename type_trait<T_arg5>::take arg5_type_;
-  typedef typename type_trait<T_arg6>::take arg6_type_;
-
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-private:
-  typedef internal::slot_rep rep_type;
-public:
-  typedef T_return (*call_type)(rep_type*, arg1_type_,arg2_type_,arg3_type_,arg4_type_,arg5_type_,arg6_type_);
-#endif
-
-  /** Invoke the contained functor unless slot is in blocking state.
-   * @param _A_a1 Argument to be passed on to the functor.
-   * @param _A_a2 Argument to be passed on to the functor.
-   * @param _A_a3 Argument to be passed on to the functor.
-   * @param _A_a4 Argument to be passed on to the functor.
-   * @param _A_a5 Argument to be passed on to the functor.
-   * @param _A_a6 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  inline T_return operator()(arg1_type_ _A_a1,arg2_type_ _A_a2,arg3_type_ _A_a3,arg4_type_ _A_a4,arg5_type_ _A_a5,arg6_type_ _A_a6) const
-    {
-      if (!empty() && !blocked())
-        return (reinterpret_cast<call_type>(slot_base::rep_->call_))(slot_base::rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
-      return T_return();
-    }
-
-  inline slot6() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desirer functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  slot6(const T_functor& _A_func)
-    : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))
-    {
-      //The slot_base:: is necessary to stop the HP-UX aCC compiler from being confused. murrayc.
-      slot_base::rep_->call_ = internal::slot_call6<T_functor, T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>::address();
-    }
-
-  slot6(const slot6& src)
-    : slot_base(src) {}
-
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  slot6& operator=(const slot6& src)
-    { slot_base::operator=(src); return *this; }
-};
-
-/** Converts an arbitrary functor to a unified type which is opaque.
- * sigc::slot itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- * - @e T_arg1 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg2 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg3 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg4 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg5 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg6 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg7 Argument type used in the definition of operator()(). The default @p nil means no argument.
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * You should use the more convenient unnumbered sigc::slot template.
- *
- * @ingroup slot
- */
-/* TODO: Where put the following bit of information? I can't make any
- *       sense of the "because", by the way!
- *
- * Because slot is opaque, visit_each() will not visit its internal members.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-class slot7
-  : public slot_base
-{
-public:
-  typedef T_return result_type;
-  typedef typename type_trait<T_arg1>::take arg1_type_;
-  typedef typename type_trait<T_arg2>::take arg2_type_;
-  typedef typename type_trait<T_arg3>::take arg3_type_;
-  typedef typename type_trait<T_arg4>::take arg4_type_;
-  typedef typename type_trait<T_arg5>::take arg5_type_;
-  typedef typename type_trait<T_arg6>::take arg6_type_;
-  typedef typename type_trait<T_arg7>::take arg7_type_;
-
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-private:
-  typedef internal::slot_rep rep_type;
-public:
-  typedef T_return (*call_type)(rep_type*, arg1_type_,arg2_type_,arg3_type_,arg4_type_,arg5_type_,arg6_type_,arg7_type_);
-#endif
-
-  /** Invoke the contained functor unless slot is in blocking state.
-   * @param _A_a1 Argument to be passed on to the functor.
-   * @param _A_a2 Argument to be passed on to the functor.
-   * @param _A_a3 Argument to be passed on to the functor.
-   * @param _A_a4 Argument to be passed on to the functor.
-   * @param _A_a5 Argument to be passed on to the functor.
-   * @param _A_a6 Argument to be passed on to the functor.
-   * @param _A_a7 Argument to be passed on to the functor.
-   * @return The return value of the functor invocation.
-   */
-  inline T_return operator()(arg1_type_ _A_a1,arg2_type_ _A_a2,arg3_type_ _A_a3,arg4_type_ _A_a4,arg5_type_ _A_a5,arg6_type_ _A_a6,arg7_type_ _A_a7) const
-    {
-      if (!empty() && !blocked())
-        return (reinterpret_cast<call_type>(slot_base::rep_->call_))(slot_base::rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
-      return T_return();
-    }
-
-  inline slot7() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desirer functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  slot7(const T_functor& _A_func)
-    : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))
-    {
-      //The slot_base:: is necessary to stop the HP-UX aCC compiler from being confused. murrayc.
-      slot_base::rep_->call_ = internal::slot_call7<T_functor, T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::address();
-    }
-
-  slot7(const slot7& src)
-    : slot_base(src) {}
-
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  slot7& operator=(const slot7& src)
-    { slot_base::operator=(src); return *this; }
-};
-
-
-/** Convenience wrapper for the numbered sigc::slot# templates.
- * Slots convert arbitrary functors to unified types which are opaque.
- * sigc::slot itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- * - @e T_arg1 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg2 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg3 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg4 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg5 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg6 Argument type used in the definition of operator()(). The default @p nil means no argument.
- * - @e T_arg7 Argument type used in the definition of operator()(). The default @p nil means no argument.
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * @par Example:
- *   @code
- *   void foo(int) {}
- *   sigc::slot<void, long> s = sigc::ptr_fun(&foo);
- *   s(19);
- *   @endcode
- *
- * @ingroup slot
- */
-template <class T_return, class T_arg1 = nil,class T_arg2 = nil,class T_arg3 = nil,class T_arg4 = nil,class T_arg5 = nil,class T_arg6 = nil,class T_arg7 = nil>
-class slot 
-  : public slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-{
-public:
-  typedef slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> parent_type;
-
-  inline slot() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desirer functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  slot(const T_functor& _A_func)
-    : parent_type(_A_func) {}
-
-  slot(const slot& src)
-    : parent_type(reinterpret_cast<const parent_type&>(src)) {}
-};
-
-
-
-/** Convenience wrapper for the numbered sigc::slot0 template.
- * See the base class for useful methods.
- * This is the template specialization of the unnumbered sigc::slot
- * template for 0 argument(s), specialized for different numbers of arguments
- * This is possible because the template has default (nil) template types.
- */
-template <class T_return>
-class slot <T_return, nil, nil, nil, nil, nil, nil, nil>
-  : public slot0<T_return>
-{
-public:
-  typedef slot0<T_return> parent_type;
-
-  inline slot() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desirer functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  slot(const T_functor& _A_func)
-    : parent_type(_A_func) {}
-
-  slot(const slot& src)
-    : parent_type(reinterpret_cast<const parent_type&>(src)) {}
-};
-
-
-/** Convenience wrapper for the numbered sigc::slot1 template.
- * See the base class for useful methods.
- * This is the template specialization of the unnumbered sigc::slot
- * template for 1 argument(s), specialized for different numbers of arguments
- * This is possible because the template has default (nil) template types.
- */
-template <class T_return, class T_arg1>
-class slot <T_return, T_arg1, nil, nil, nil, nil, nil, nil>
-  : public slot1<T_return, T_arg1>
-{
-public:
-  typedef slot1<T_return, T_arg1> parent_type;
-
-  inline slot() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desirer functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  slot(const T_functor& _A_func)
-    : parent_type(_A_func) {}
-
-  slot(const slot& src)
-    : parent_type(reinterpret_cast<const parent_type&>(src)) {}
-};
-
-
-/** Convenience wrapper for the numbered sigc::slot2 template.
- * See the base class for useful methods.
- * This is the template specialization of the unnumbered sigc::slot
- * template for 2 argument(s), specialized for different numbers of arguments
- * This is possible because the template has default (nil) template types.
- */
-template <class T_return, class T_arg1,class T_arg2>
-class slot <T_return, T_arg1, T_arg2, nil, nil, nil, nil, nil>
-  : public slot2<T_return, T_arg1,T_arg2>
-{
-public:
-  typedef slot2<T_return, T_arg1,T_arg2> parent_type;
-
-  inline slot() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desirer functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  slot(const T_functor& _A_func)
-    : parent_type(_A_func) {}
-
-  slot(const slot& src)
-    : parent_type(reinterpret_cast<const parent_type&>(src)) {}
-};
-
-
-/** Convenience wrapper for the numbered sigc::slot3 template.
- * See the base class for useful methods.
- * This is the template specialization of the unnumbered sigc::slot
- * template for 3 argument(s), specialized for different numbers of arguments
- * This is possible because the template has default (nil) template types.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3>
-class slot <T_return, T_arg1, T_arg2, T_arg3, nil, nil, nil, nil>
-  : public slot3<T_return, T_arg1,T_arg2,T_arg3>
-{
-public:
-  typedef slot3<T_return, T_arg1,T_arg2,T_arg3> parent_type;
-
-  inline slot() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desirer functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  slot(const T_functor& _A_func)
-    : parent_type(_A_func) {}
-
-  slot(const slot& src)
-    : parent_type(reinterpret_cast<const parent_type&>(src)) {}
-};
-
-
-/** Convenience wrapper for the numbered sigc::slot4 template.
- * See the base class for useful methods.
- * This is the template specialization of the unnumbered sigc::slot
- * template for 4 argument(s), specialized for different numbers of arguments
- * This is possible because the template has default (nil) template types.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-class slot <T_return, T_arg1, T_arg2, T_arg3, T_arg4, nil, nil, nil>
-  : public slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4>
-{
-public:
-  typedef slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4> parent_type;
-
-  inline slot() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desirer functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  slot(const T_functor& _A_func)
-    : parent_type(_A_func) {}
-
-  slot(const slot& src)
-    : parent_type(reinterpret_cast<const parent_type&>(src)) {}
-};
-
-
-/** Convenience wrapper for the numbered sigc::slot5 template.
- * See the base class for useful methods.
- * This is the template specialization of the unnumbered sigc::slot
- * template for 5 argument(s), specialized for different numbers of arguments
- * This is possible because the template has default (nil) template types.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-class slot <T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil, nil>
-  : public slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-{
-public:
-  typedef slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> parent_type;
-
-  inline slot() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desirer functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  slot(const T_functor& _A_func)
-    : parent_type(_A_func) {}
-
-  slot(const slot& src)
-    : parent_type(reinterpret_cast<const parent_type&>(src)) {}
-};
-
-
-/** Convenience wrapper for the numbered sigc::slot6 template.
- * See the base class for useful methods.
- * This is the template specialization of the unnumbered sigc::slot
- * template for 6 argument(s), specialized for different numbers of arguments
- * This is possible because the template has default (nil) template types.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-class slot <T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil>
-  : public slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-{
-public:
-  typedef slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> parent_type;
-
-  inline slot() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desirer functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  slot(const T_functor& _A_func)
-    : parent_type(_A_func) {}
-
-  slot(const slot& src)
-    : parent_type(reinterpret_cast<const parent_type&>(src)) {}
-};
-
-
-
-} /* namespace sigc */
-#endif /* _SIGC_FUNCTORS_MACROS_SLOTHM4_ */
Index: stardict-3.0.1/src/sigc++/hide.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/hide.h
+++ /dev/null
@@ -1,105 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-
-#ifndef _SIGC_MACROS_HIDEHM4_
-#define _SIGC_MACROS_HIDEHM4_
-
-#include <sigc++/slot.h>
-#include <sigc++/adaptors/hide.h>
-
-
-#ifndef LIBSIGC_DISABLE_DEPRECATED
-
-namespace SigC {
-
-template <class T_hidden1, class T_return>
-inline SigC::Slot1<T_return, T_hidden1>
-hide(const SigC::Slot0<T_return>& _A_slot)
-{ return ::sigc::hide_functor<0, SigC::Slot0<T_return> >
-      (_A_slot); }
-
-template <class T_hidden1, class T_return, class T_arg1>
-inline SigC::Slot2<T_return, T_arg1, T_hidden1>
-hide(const SigC::Slot1<T_return, T_arg1>& _A_slot)
-{ return ::sigc::hide_functor<0, SigC::Slot1<T_return, T_arg1> >
-      (_A_slot); }
-
-template <class T_hidden1, class T_return, class T_arg1,class T_arg2>
-inline SigC::Slot3<T_return, T_arg1,T_arg2, T_hidden1>
-hide(const SigC::Slot2<T_return, T_arg1,T_arg2>& _A_slot)
-{ return ::sigc::hide_functor<0, SigC::Slot2<T_return, T_arg1,T_arg2> >
-      (_A_slot); }
-
-template <class T_hidden1, class T_return, class T_arg1,class T_arg2,class T_arg3>
-inline SigC::Slot4<T_return, T_arg1,T_arg2,T_arg3, T_hidden1>
-hide(const SigC::Slot3<T_return, T_arg1,T_arg2,T_arg3>& _A_slot)
-{ return ::sigc::hide_functor<0, SigC::Slot3<T_return, T_arg1,T_arg2,T_arg3> >
-      (_A_slot); }
-
-template <class T_hidden1, class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-inline SigC::Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4, T_hidden1>
-hide(const SigC::Slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4>& _A_slot)
-{ return ::sigc::hide_functor<0, SigC::Slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4> >
-      (_A_slot); }
-
-template <class T_hidden1, class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-inline SigC::Slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_hidden1>
-hide(const SigC::Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_slot)
-{ return ::sigc::hide_functor<0, SigC::Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> >
-      (_A_slot); }
-
-template <class T_hidden1, class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-inline SigC::Slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_hidden1>
-hide(const SigC::Slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>& _A_slot)
-{ return ::sigc::hide_functor<0, SigC::Slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> >
-      (_A_slot); }
-
-
-template <class T_hidden1,class T_hidden2, class T_return>
-inline SigC::Slot2<T_return, T_hidden1,T_hidden2>
-hide(const SigC::Slot0<T_return>& _A_slot)
-{ return ::sigc::hide<0>(
-    ::sigc::hide_functor<0, SigC::Slot0<T_return> >
-      (_A_slot)); }
-
-template <class T_hidden1,class T_hidden2, class T_return, class T_arg1>
-inline SigC::Slot3<T_return, T_arg1, T_hidden1,T_hidden2>
-hide(const SigC::Slot1<T_return, T_arg1>& _A_slot)
-{ return ::sigc::hide<0>(
-    ::sigc::hide_functor<0, SigC::Slot1<T_return, T_arg1> >
-      (_A_slot)); }
-
-template <class T_hidden1,class T_hidden2, class T_return, class T_arg1,class T_arg2>
-inline SigC::Slot4<T_return, T_arg1,T_arg2, T_hidden1,T_hidden2>
-hide(const SigC::Slot2<T_return, T_arg1,T_arg2>& _A_slot)
-{ return ::sigc::hide<0>(
-    ::sigc::hide_functor<0, SigC::Slot2<T_return, T_arg1,T_arg2> >
-      (_A_slot)); }
-
-template <class T_hidden1,class T_hidden2, class T_return, class T_arg1,class T_arg2,class T_arg3>
-inline SigC::Slot5<T_return, T_arg1,T_arg2,T_arg3, T_hidden1,T_hidden2>
-hide(const SigC::Slot3<T_return, T_arg1,T_arg2,T_arg3>& _A_slot)
-{ return ::sigc::hide<0>(
-    ::sigc::hide_functor<0, SigC::Slot3<T_return, T_arg1,T_arg2,T_arg3> >
-      (_A_slot)); }
-
-template <class T_hidden1,class T_hidden2, class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-inline SigC::Slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4, T_hidden1,T_hidden2>
-hide(const SigC::Slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4>& _A_slot)
-{ return ::sigc::hide<0>(
-    ::sigc::hide_functor<0, SigC::Slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4> >
-      (_A_slot)); }
-
-template <class T_hidden1,class T_hidden2, class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-inline SigC::Slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_hidden1,T_hidden2>
-hide(const SigC::Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>& _A_slot)
-{ return ::sigc::hide<0>(
-    ::sigc::hide_functor<0, SigC::Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> >
-      (_A_slot)); }
-
-
-
-} /* namespace SigC */
-
-#endif /* LIBSIGC_DISABLE_DEPRECATED */
-#endif /* _SIGC_MACROS_HIDEHM4_ */
Index: stardict-3.0.1/src/sigc++/limit_reference.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/limit_reference.h
+++ /dev/null
@@ -1,455 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-
-
-#ifndef _SIGC_MACROS_LIMIT_REFERENCEHM4_
-#define _SIGC_MACROS_LIMIT_REFERENCEHM4_
-
-
-#include <sigc++/type_traits.h>
-#include <sigc++/trackable.h>
-
-
-namespace sigc {
-
-
-/** A limit_reference<Foo> object stores a reference (Foo&), but make sure that,
- * if Foo inherits from sigc::trackable, then visit_each<>() will "limit" itself to the
- * sigc::trackable reference instead of the derived reference. This avoids use of
- * a reference to the derived type when the derived destructor has run. That can be
- * a problem when using virtual inheritance.
- *
- * If Foo inherits from trackable then both the derived reference and the
- * sigc::trackable reference are stored, so we can later retrieve the sigc::trackable
- * reference without doing an implicit conversion. To retrieve the derived reference
- * (so that you invoke methods or members of it), use invoke(). To retrieve the trackable
- * reference (so that you can call visit_each() on it), you use visit().
- *
- * If Foo does not inherit from sigc::trackable then invoke() and visit() just return the
- * derived reference.
- *
- * This is used for bound (sigc::bind) slot parameters (via bound_argument), bound return values, 
- * and, with mem_fun(), the reference to the handling object.
- *
- * - @e T_type The type of the reference.
- */
-template <class T_type,
-          bool I_derives_trackable =
-            is_base_and_derived<trackable, T_type>::value>
-class limit_reference
-{
-public:
-  /** Constructor.
-   * @param _A_target The reference to limit.
-   */
-  limit_reference(T_type& _A_target)
-    : visited(_A_target)
-    {}
-
-  /** Retrieve the entity to visit for visit_each().
-   * Depending on the template specialization, this is either a derived reference, or sigc::trackable& if T_type derives from sigc::trackable.
-   * @return The reference.
-   */
-  inline const T_type& visit() const
-    { return visited; }
-
-  /** Retrieve the reference.
-   * This is always a reference to the derived instance.
-   * @return The reference.
-   */
-  inline T_type& invoke() const
-    { return visited; }
-
-private:
-  /** The reference.
-   */
-  T_type& visited;
-};
-
-/** limit_reference object for a class that derives from trackable.
- * - @e T_type The type of the reference.
- */
-template <class T_type>
-class limit_reference<T_type, true>
-{
-public:
-  /** Constructor.
-   * @param _A_target The reference to limit.
-   */
-  limit_reference(T_type& _A_target)
-    : visited(_A_target),
-      invoked(_A_target)
-    {}
-
-  /** Retrieve the entity to visit for visit_each().
-   * Depending on the template specialization, this is either a derived reference, or sigc::trackable& if T_type derives from sigc::trackable.
-   * @return The reference.
-   */
-  inline const trackable& visit() const
-    { return visited; }
-
-  /** Retrieve the reference.
-   * This is always a reference to the derived instance.
-   * @return The reference.
-   */
-  inline T_type& invoke() const
-    { return invoked; }
-
-private:
-  /** The trackable reference.
-   */
-  trackable& visited;
-
-  /** The reference.
-   */
-  T_type& invoked;
-};
-
-/** Implementation of visit_each() specialized for the limit_reference
- * class, to call visit_each() on the entity returned by the limit_reference's
- * visit() method.
- * - @e T_action The type of functor to invoke.
- * - @e T_type The type of the reference.
- * @param _A_action The functor to invoke.
- * @param _A_argument The visited instance.
- */
-template <class T_action, class T_type, bool I_derives_trackable>
-void
-visit_each(const T_action& _A_action,
-           const limit_reference<T_type, I_derives_trackable>& _A_target)
-{
-  visit_each(_A_action, _A_target.visit());
-}
-
-
-/** A const_limit_reference<Foo> object stores a reference (Foo&), but make sure that,
- * if Foo inherits from sigc::trackable, then visit_each<>() will "limit" itself to the
- * sigc::trackable reference instead of the derived reference. This avoids use of
- * a reference to the derived type when the derived destructor has run. That can be
- * a problem when using virtual inheritance.
- *
- * If Foo inherits from trackable then both the derived reference and the
- * sigc::trackable reference are stored, so we can later retrieve the sigc::trackable
- * reference without doing an implicit conversion. To retrieve the derived reference
- * (so that you invoke methods or members of it), use invoke(). To retrieve the trackable
- * reference (so that you can call visit_each() on it), you use visit().
- *
- * If Foo does not inherit from sigc::trackable then invoke() and visit() just return the
- * derived reference.
- *
- * This is used for bound (sigc::bind) slot parameters (via bound_argument), bound return values, 
- * and, with mem_fun(), the reference to the handling object.
- *
- * - @e T_type The type of the reference.
- */
-template <class T_type,
-          bool I_derives_trackable =
-            is_base_and_derived<trackable, T_type>::value>
-class const_limit_reference
-{
-public:
-  /** Constructor.
-   * @param _A_target The reference to limit.
-   */
-  const_limit_reference(const T_type& _A_target)
-    : visited(_A_target)
-    {}
-
-  /** Retrieve the entity to visit for visit_each().
-   * Depending on the template specialization, this is either a derived reference, or sigc::trackable& if T_type derives from sigc::trackable.
-   * @return The reference.
-   */
-  inline const T_type& visit() const
-    { return visited; }
-
-  /** Retrieve the reference.
-   * This is always a reference to the derived instance.
-   * @return The reference.
-   */
-  inline const T_type& invoke() const
-    { return visited; }
-
-private:
-  /** The reference.
-   */
-  const T_type& visited;
-};
-
-/** const_limit_reference object for a class that derives from trackable.
- * - @e T_type The type of the reference.
- */
-template <class T_type>
-class const_limit_reference<T_type, true>
-{
-public:
-  /** Constructor.
-   * @param _A_target The reference to limit.
-   */
-  const_limit_reference(const T_type& _A_target)
-    : visited(_A_target),
-      invoked(_A_target)
-    {}
-
-  /** Retrieve the entity to visit for visit_each().
-   * Depending on the template specialization, this is either a derived reference, or sigc::trackable& if T_type derives from sigc::trackable.
-   * @return The reference.
-   */
-  inline const trackable& visit() const
-    { return visited; }
-
-  /** Retrieve the reference.
-   * This is always a reference to the derived instance.
-   * @return The reference.
-   */
-  inline const T_type& invoke() const
-    { return invoked; }
-
-private:
-  /** The trackable reference.
-   */
-  const trackable& visited;
-
-  /** The reference.
-   */
-  const T_type& invoked;
-};
-
-/** Implementation of visit_each() specialized for the const_limit_reference
- * class, to call visit_each() on the entity returned by the const_limit_reference's
- * visit() method.
- * - @e T_action The type of functor to invoke.
- * - @e T_type The type of the reference.
- * @param _A_action The functor to invoke.
- * @param _A_argument The visited instance.
- */
-template <class T_action, class T_type, bool I_derives_trackable>
-void
-visit_each(const T_action& _A_action,
-           const const_limit_reference<T_type, I_derives_trackable>& _A_target)
-{
-  visit_each(_A_action, _A_target.visit());
-}
-
-
-/** A volatile_limit_reference<Foo> object stores a reference (Foo&), but make sure that,
- * if Foo inherits from sigc::trackable, then visit_each<>() will "limit" itself to the
- * sigc::trackable reference instead of the derived reference. This avoids use of
- * a reference to the derived type when the derived destructor has run. That can be
- * a problem when using virtual inheritance.
- *
- * If Foo inherits from trackable then both the derived reference and the
- * sigc::trackable reference are stored, so we can later retrieve the sigc::trackable
- * reference without doing an implicit conversion. To retrieve the derived reference
- * (so that you invoke methods or members of it), use invoke(). To retrieve the trackable
- * reference (so that you can call visit_each() on it), you use visit().
- *
- * If Foo does not inherit from sigc::trackable then invoke() and visit() just return the
- * derived reference.
- *
- * This is used for bound (sigc::bind) slot parameters (via bound_argument), bound return values, 
- * and, with mem_fun(), the reference to the handling object.
- *
- * - @e T_type The type of the reference.
- */
-template <class T_type,
-          bool I_derives_trackable =
-            is_base_and_derived<trackable, T_type>::value>
-class volatile_limit_reference
-{
-public:
-  /** Constructor.
-   * @param _A_target The reference to limit.
-   */
-  volatile_limit_reference(T_type& _A_target)
-    : visited(_A_target)
-    {}
-
-  /** Retrieve the entity to visit for visit_each().
-   * Depending on the template specialization, this is either a derived reference, or sigc::trackable& if T_type derives from sigc::trackable.
-   * @return The reference.
-   */
-  inline const T_type& visit() const
-    { return visited; }
-
-  /** Retrieve the reference.
-   * This is always a reference to the derived instance.
-   * @return The reference.
-   */
-  inline volatile T_type& invoke() const
-    { return visited; }
-
-private:
-  /** The reference.
-   */
-  T_type& visited;
-};
-
-/** volatile_limit_reference object for a class that derives from trackable.
- * - @e T_type The type of the reference.
- */
-template <class T_type>
-class volatile_limit_reference<T_type, true>
-{
-public:
-  /** Constructor.
-   * @param _A_target The reference to limit.
-   */
-  volatile_limit_reference(T_type& _A_target)
-    : visited(_A_target),
-      invoked(_A_target)
-    {}
-
-  /** Retrieve the entity to visit for visit_each().
-   * Depending on the template specialization, this is either a derived reference, or sigc::trackable& if T_type derives from sigc::trackable.
-   * @return The reference.
-   */
-  inline const trackable& visit() const
-    { return visited; }
-
-  /** Retrieve the reference.
-   * This is always a reference to the derived instance.
-   * @return The reference.
-   */
-  inline volatile T_type& invoke() const
-    { return invoked; }
-
-private:
-  /** The trackable reference.
-   */
-  trackable& visited;
-
-  /** The reference.
-   */
-  T_type& invoked;
-};
-
-/** Implementation of visit_each() specialized for the volatile_limit_reference
- * class, to call visit_each() on the entity returned by the volatile_limit_reference's
- * visit() method.
- * - @e T_action The type of functor to invoke.
- * - @e T_type The type of the reference.
- * @param _A_action The functor to invoke.
- * @param _A_argument The visited instance.
- */
-template <class T_action, class T_type, bool I_derives_trackable>
-void
-visit_each(const T_action& _A_action,
-           const volatile_limit_reference<T_type, I_derives_trackable>& _A_target)
-{
-  visit_each(_A_action, _A_target.visit());
-}
-
-
-/** A const_volatile_limit_reference<Foo> object stores a reference (Foo&), but make sure that,
- * if Foo inherits from sigc::trackable, then visit_each<>() will "limit" itself to the
- * sigc::trackable reference instead of the derived reference. This avoids use of
- * a reference to the derived type when the derived destructor has run. That can be
- * a problem when using virtual inheritance.
- *
- * If Foo inherits from trackable then both the derived reference and the
- * sigc::trackable reference are stored, so we can later retrieve the sigc::trackable
- * reference without doing an implicit conversion. To retrieve the derived reference
- * (so that you invoke methods or members of it), use invoke(). To retrieve the trackable
- * reference (so that you can call visit_each() on it), you use visit().
- *
- * If Foo does not inherit from sigc::trackable then invoke() and visit() just return the
- * derived reference.
- *
- * This is used for bound (sigc::bind) slot parameters (via bound_argument), bound return values, 
- * and, with mem_fun(), the reference to the handling object.
- *
- * - @e T_type The type of the reference.
- */
-template <class T_type,
-          bool I_derives_trackable =
-            is_base_and_derived<trackable, T_type>::value>
-class const_volatile_limit_reference
-{
-public:
-  /** Constructor.
-   * @param _A_target The reference to limit.
-   */
-  const_volatile_limit_reference(const T_type& _A_target)
-    : visited(_A_target)
-    {}
-
-  /** Retrieve the entity to visit for visit_each().
-   * Depending on the template specialization, this is either a derived reference, or sigc::trackable& if T_type derives from sigc::trackable.
-   * @return The reference.
-   */
-  inline const T_type& visit() const
-    { return visited; }
-
-  /** Retrieve the reference.
-   * This is always a reference to the derived instance.
-   * @return The reference.
-   */
-  inline const volatile T_type& invoke() const
-    { return visited; }
-
-private:
-  /** The reference.
-   */
-  const T_type& visited;
-};
-
-/** const_volatile_limit_reference object for a class that derives from trackable.
- * - @e T_type The type of the reference.
- */
-template <class T_type>
-class const_volatile_limit_reference<T_type, true>
-{
-public:
-  /** Constructor.
-   * @param _A_target The reference to limit.
-   */
-  const_volatile_limit_reference(const T_type& _A_target)
-    : visited(_A_target),
-      invoked(_A_target)
-    {}
-
-  /** Retrieve the entity to visit for visit_each().
-   * Depending on the template specialization, this is either a derived reference, or sigc::trackable& if T_type derives from sigc::trackable.
-   * @return The reference.
-   */
-  inline const trackable& visit() const
-    { return visited; }
-
-  /** Retrieve the reference.
-   * This is always a reference to the derived instance.
-   * @return The reference.
-   */
-  inline const volatile T_type& invoke() const
-    { return invoked; }
-
-private:
-  /** The trackable reference.
-   */
-  const trackable& visited;
-
-  /** The reference.
-   */
-  const T_type& invoked;
-};
-
-/** Implementation of visit_each() specialized for the const_volatile_limit_reference
- * class, to call visit_each() on the entity returned by the const_volatile_limit_reference's
- * visit() method.
- * - @e T_action The type of functor to invoke.
- * - @e T_type The type of the reference.
- * @param _A_action The functor to invoke.
- * @param _A_argument The visited instance.
- */
-template <class T_action, class T_type, bool I_derives_trackable>
-void
-visit_each(const T_action& _A_action,
-           const const_volatile_limit_reference<T_type, I_derives_trackable>& _A_target)
-{
-  visit_each(_A_action, _A_target.visit());
-}
-
-
-} /* namespace sigc */
-
-
-#endif /* _SIGC_MACROS_LIMIT_REFERENCEHM4_ */
Index: stardict-3.0.1/src/sigc++/method_slot.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/method_slot.h
+++ /dev/null
@@ -1,387 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-
-
-#ifndef _SIGC_MACROS_METHOD_SLOTHM4_
-#define _SIGC_MACROS_METHOD_SLOTHM4_
-
-#include <sigc++/slot.h>
-#include <sigc++/functors/mem_fun.h>
-
-#ifndef LIBSIGC_DISABLE_DEPRECATED
-
-namespace SigC {
-
-/** Creates a functor of type Sigc::Slot1 that wraps a  method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_obj>
-inline Slot1<T_return, T_obj&>
-slot(T_return (T_obj::*_A_func)() )
-{ return ::sigc::mem_functor0<T_return, T_obj>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot2 that wraps a  method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1, class T_obj>
-inline Slot2<T_return, T_obj&, T_arg1>
-slot(T_return (T_obj::*_A_func)(T_arg1) )
-{ return ::sigc::mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot3 that wraps a  method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2, class T_obj>
-inline Slot3<T_return, T_obj&, T_arg1,T_arg2>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2) )
-{ return ::sigc::mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot4 that wraps a  method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_obj>
-inline Slot4<T_return, T_obj&, T_arg1,T_arg2,T_arg3>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) )
-{ return ::sigc::mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot5 that wraps a  method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_obj>
-inline Slot5<T_return, T_obj&, T_arg1,T_arg2,T_arg3,T_arg4>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) )
-{ return ::sigc::mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot6 that wraps a  method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_obj>
-inline Slot6<T_return, T_obj&, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) )
-{ return ::sigc::mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot7 that wraps a  method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_obj>
-inline Slot7<T_return, T_obj&, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) )
-{ return ::sigc::mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
-
-
-/** Creates a functor of type Sigc::Slot1 that wraps a const method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_obj>
-inline Slot1<T_return, T_obj&>
-slot(T_return (T_obj::*_A_func)() const)
-{ return ::sigc::const_mem_functor0<T_return, T_obj>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot2 that wraps a const method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1, class T_obj>
-inline Slot2<T_return, T_obj&, T_arg1>
-slot(T_return (T_obj::*_A_func)(T_arg1) const)
-{ return ::sigc::const_mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot3 that wraps a const method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2, class T_obj>
-inline Slot3<T_return, T_obj&, T_arg1,T_arg2>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2) const)
-{ return ::sigc::const_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot4 that wraps a const method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_obj>
-inline Slot4<T_return, T_obj&, T_arg1,T_arg2,T_arg3>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) const)
-{ return ::sigc::const_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot5 that wraps a const method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_obj>
-inline Slot5<T_return, T_obj&, T_arg1,T_arg2,T_arg3,T_arg4>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const)
-{ return ::sigc::const_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot6 that wraps a const method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_obj>
-inline Slot6<T_return, T_obj&, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const)
-{ return ::sigc::const_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot7 that wraps a const method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_obj>
-inline Slot7<T_return, T_obj&, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const)
-{ return ::sigc::const_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
-
-
-/** Creates a functor of type Sigc::Slot1 that wraps a volatile method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_obj>
-inline Slot1<T_return, T_obj&>
-slot(T_return (T_obj::*_A_func)() volatile)
-{ return ::sigc::volatile_mem_functor0<T_return, T_obj>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot2 that wraps a volatile method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1, class T_obj>
-inline Slot2<T_return, T_obj&, T_arg1>
-slot(T_return (T_obj::*_A_func)(T_arg1) volatile)
-{ return ::sigc::volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot3 that wraps a volatile method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2, class T_obj>
-inline Slot3<T_return, T_obj&, T_arg1,T_arg2>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2) volatile)
-{ return ::sigc::volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot4 that wraps a volatile method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_obj>
-inline Slot4<T_return, T_obj&, T_arg1,T_arg2,T_arg3>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) volatile)
-{ return ::sigc::volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot5 that wraps a volatile method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_obj>
-inline Slot5<T_return, T_obj&, T_arg1,T_arg2,T_arg3,T_arg4>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile)
-{ return ::sigc::volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot6 that wraps a volatile method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_obj>
-inline Slot6<T_return, T_obj&, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile)
-{ return ::sigc::volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot7 that wraps a volatile method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_obj>
-inline Slot7<T_return, T_obj&, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile)
-{ return ::sigc::volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
-
-
-/** Creates a functor of type Sigc::Slot1 that wraps a const volatile method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_obj>
-inline Slot1<T_return, T_obj&>
-slot(T_return (T_obj::*_A_func)() const volatile)
-{ return ::sigc::const_volatile_mem_functor0<T_return, T_obj>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot2 that wraps a const volatile method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1, class T_obj>
-inline Slot2<T_return, T_obj&, T_arg1>
-slot(T_return (T_obj::*_A_func)(T_arg1) const volatile)
-{ return ::sigc::const_volatile_mem_functor1<T_return, T_obj, T_arg1>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot3 that wraps a const volatile method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2, class T_obj>
-inline Slot3<T_return, T_obj&, T_arg1,T_arg2>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2) const volatile)
-{ return ::sigc::const_volatile_mem_functor2<T_return, T_obj, T_arg1,T_arg2>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot4 that wraps a const volatile method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_obj>
-inline Slot4<T_return, T_obj&, T_arg1,T_arg2,T_arg3>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3) const volatile)
-{ return ::sigc::const_volatile_mem_functor3<T_return, T_obj, T_arg1,T_arg2,T_arg3>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot5 that wraps a const volatile method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_obj>
-inline Slot5<T_return, T_obj&, T_arg1,T_arg2,T_arg3,T_arg4>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile)
-{ return ::sigc::const_volatile_mem_functor4<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot6 that wraps a const volatile method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_obj>
-inline Slot6<T_return, T_obj&, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile)
-{ return ::sigc::const_volatile_mem_functor5<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
-
-/** Creates a functor of type Sigc::Slot7 that wraps a const volatile method.
- *
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_obj>
-inline Slot7<T_return, T_obj&, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-slot(T_return (T_obj::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile)
-{ return ::sigc::const_volatile_mem_functor6<T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
-
-
-
-}
-
-#endif
-#endif /* _SIGC_MACROS_METHOD_SLOTHM4_ */
Index: stardict-3.0.1/src/sigc++/object.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/object.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#ifndef _SIGC_OBJECT_HPP_
-#define _SIGC_OBJECT_HPP_
-
-#include <sigc++/trackable.h>
-
-#ifndef LIBSIGC_DISABLE_DEPRECATED
-
-namespace SigC {
-
-// Object
-typedef ::sigc::trackable Object;
-
-}
-
-#endif /* LIBSIGC_DISABLE_DEPRECATED */
-
-#endif /* _SIGC_OBJECT_HPP_ */
Index: stardict-3.0.1/src/sigc++/object_slot.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/object_slot.h
+++ /dev/null
@@ -1,536 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-
-
-#ifndef _SIGC_MACROS_OBJECT_SLOTHM4_
-#define _SIGC_MACROS_OBJECT_SLOTHM4_
-
-#include <sigc++/slot.h>
-#include <sigc++/object.h>
-#include <sigc++/functors/mem_fun.h>
-
-#ifndef LIBSIGC_DISABLE_DEPRECATED
-
-namespace SigC {
-
-/** Creates a functor of type SigC::Slot0 that encapsulates a  method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_obj1, class T_obj2>
-inline Slot0<T_return>
-slot( T_obj1& _A_obj, T_return (T_obj2::*_A_func)() )
-{ (void)dynamic_cast< Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_mem_functor0<T_return, T_obj2>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot1 that encapsulates a  method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1, class T_obj1, class T_obj2>
-inline Slot1<T_return, T_arg1>
-slot( T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) )
-{ (void)dynamic_cast< Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_mem_functor1<T_return, T_obj2, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot2 that encapsulates a  method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2, class T_obj1, class T_obj2>
-inline Slot2<T_return, T_arg1,T_arg2>
-slot( T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) )
-{ (void)dynamic_cast< Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_mem_functor2<T_return, T_obj2, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot3 that encapsulates a  method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_obj1, class T_obj2>
-inline Slot3<T_return, T_arg1,T_arg2,T_arg3>
-slot( T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) )
-{ (void)dynamic_cast< Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_mem_functor3<T_return, T_obj2, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot4 that encapsulates a  method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_obj1, class T_obj2>
-inline Slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4>
-slot( T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) )
-{ (void)dynamic_cast< Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_mem_functor4<T_return, T_obj2, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot5 that encapsulates a  method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_obj1, class T_obj2>
-inline Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-slot( T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) )
-{ (void)dynamic_cast< Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_mem_functor5<T_return, T_obj2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot6 that encapsulates a  method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_obj1, class T_obj2>
-inline Slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-slot( T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) )
-{ (void)dynamic_cast< Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_mem_functor6<T_return, T_obj2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot7 that encapsulates a  method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_obj1, class T_obj2>
-inline Slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-slot( T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) )
-{ (void)dynamic_cast< Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_mem_functor7<T_return, T_obj2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-
-/** Creates a functor of type SigC::Slot0 that encapsulates a const method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_obj1, class T_obj2>
-inline Slot0<T_return>
-slot(const T_obj1& _A_obj, T_return (T_obj2::*_A_func)() const)
-{ (void)dynamic_cast<const Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_const_mem_functor0<T_return, T_obj2>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot1 that encapsulates a const method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1, class T_obj1, class T_obj2>
-inline Slot1<T_return, T_arg1>
-slot(const T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const)
-{ (void)dynamic_cast<const Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_const_mem_functor1<T_return, T_obj2, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot2 that encapsulates a const method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2, class T_obj1, class T_obj2>
-inline Slot2<T_return, T_arg1,T_arg2>
-slot(const T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const)
-{ (void)dynamic_cast<const Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_const_mem_functor2<T_return, T_obj2, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot3 that encapsulates a const method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_obj1, class T_obj2>
-inline Slot3<T_return, T_arg1,T_arg2,T_arg3>
-slot(const T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const)
-{ (void)dynamic_cast<const Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_const_mem_functor3<T_return, T_obj2, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot4 that encapsulates a const method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_obj1, class T_obj2>
-inline Slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4>
-slot(const T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const)
-{ (void)dynamic_cast<const Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_const_mem_functor4<T_return, T_obj2, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot5 that encapsulates a const method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_obj1, class T_obj2>
-inline Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-slot(const T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const)
-{ (void)dynamic_cast<const Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_const_mem_functor5<T_return, T_obj2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot6 that encapsulates a const method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_obj1, class T_obj2>
-inline Slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-slot(const T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const)
-{ (void)dynamic_cast<const Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_const_mem_functor6<T_return, T_obj2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot7 that encapsulates a const method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_obj1, class T_obj2>
-inline Slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-slot(const T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const)
-{ (void)dynamic_cast<const Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_const_mem_functor7<T_return, T_obj2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-
-/** Creates a functor of type SigC::Slot0 that encapsulates a volatile method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_obj1, class T_obj2>
-inline Slot0<T_return>
-slot( T_obj1& _A_obj, T_return (T_obj2::*_A_func)() volatile)
-{ (void)dynamic_cast< Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_volatile_mem_functor0<T_return, T_obj2>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot1 that encapsulates a volatile method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1, class T_obj1, class T_obj2>
-inline Slot1<T_return, T_arg1>
-slot( T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) volatile)
-{ (void)dynamic_cast< Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_volatile_mem_functor1<T_return, T_obj2, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot2 that encapsulates a volatile method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2, class T_obj1, class T_obj2>
-inline Slot2<T_return, T_arg1,T_arg2>
-slot( T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) volatile)
-{ (void)dynamic_cast< Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_volatile_mem_functor2<T_return, T_obj2, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot3 that encapsulates a volatile method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_obj1, class T_obj2>
-inline Slot3<T_return, T_arg1,T_arg2,T_arg3>
-slot( T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) volatile)
-{ (void)dynamic_cast< Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_volatile_mem_functor3<T_return, T_obj2, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot4 that encapsulates a volatile method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_obj1, class T_obj2>
-inline Slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4>
-slot( T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile)
-{ (void)dynamic_cast< Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_volatile_mem_functor4<T_return, T_obj2, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot5 that encapsulates a volatile method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_obj1, class T_obj2>
-inline Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-slot( T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile)
-{ (void)dynamic_cast< Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_volatile_mem_functor5<T_return, T_obj2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot6 that encapsulates a volatile method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_obj1, class T_obj2>
-inline Slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-slot( T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile)
-{ (void)dynamic_cast< Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_volatile_mem_functor6<T_return, T_obj2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot7 that encapsulates a volatile method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_obj1, class T_obj2>
-inline Slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-slot( T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile)
-{ (void)dynamic_cast< Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_volatile_mem_functor7<T_return, T_obj2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-
-/** Creates a functor of type SigC::Slot0 that encapsulates a const volatile method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_obj1, class T_obj2>
-inline Slot0<T_return>
-slot(const T_obj1& _A_obj, T_return (T_obj2::*_A_func)() const volatile)
-{ (void)dynamic_cast<const Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_const_volatile_mem_functor0<T_return, T_obj2>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot1 that encapsulates a const volatile method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1, class T_obj1, class T_obj2>
-inline Slot1<T_return, T_arg1>
-slot(const T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1) const volatile)
-{ (void)dynamic_cast<const Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_const_volatile_mem_functor1<T_return, T_obj2, T_arg1>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot2 that encapsulates a const volatile method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2, class T_obj1, class T_obj2>
-inline Slot2<T_return, T_arg1,T_arg2>
-slot(const T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) const volatile)
-{ (void)dynamic_cast<const Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_const_volatile_mem_functor2<T_return, T_obj2, T_arg1,T_arg2>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot3 that encapsulates a const volatile method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_obj1, class T_obj2>
-inline Slot3<T_return, T_arg1,T_arg2,T_arg3>
-slot(const T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) const volatile)
-{ (void)dynamic_cast<const Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_const_volatile_mem_functor3<T_return, T_obj2, T_arg1,T_arg2,T_arg3>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot4 that encapsulates a const volatile method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_obj1, class T_obj2>
-inline Slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4>
-slot(const T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) const volatile)
-{ (void)dynamic_cast<const Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_const_volatile_mem_functor4<T_return, T_obj2, T_arg1,T_arg2,T_arg3,T_arg4>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot5 that encapsulates a const volatile method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_obj1, class T_obj2>
-inline Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-slot(const T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) const volatile)
-{ (void)dynamic_cast<const Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_const_volatile_mem_functor5<T_return, T_obj2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot6 that encapsulates a const volatile method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_obj1, class T_obj2>
-inline Slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-slot(const T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) const volatile)
-{ (void)dynamic_cast<const Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_const_volatile_mem_functor6<T_return, T_obj2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_obj, _A_func); }
-
-/** Creates a functor of type SigC::Slot7 that encapsulates a const volatile method and an object instance.
- * @e _A_obj must be of a type that inherits from SigC::Object.
- *
- * @param _A_obj Reference to object instance the functor should operate on.
- * @param _A_func Pointer to method that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::mem_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_obj1, class T_obj2>
-inline Slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-slot(const T_obj1& _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) const volatile)
-{ (void)dynamic_cast<const Object&>(_A_obj); // trigger compiler error if T_obj1 does not derive from SigC::Object
-  return ::sigc::bound_const_volatile_mem_functor7<T_return, T_obj2, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_obj, _A_func); }
-
-
-
-}
-
-#endif
-#endif /* _SIGC_MACROS_OBJECT_SLOTHM4_ */
Index: stardict-3.0.1/src/sigc++/reference_wrapper.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/reference_wrapper.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#ifndef _SIGC_REFERENCE_WRAPPER_H_
-#define _SIGC_REFERENCE_WRAPPER_H_
-
-namespace sigc {
-
-/** Reference wrapper.
- * Use sigc::ref() to create a reference wrapper.
- */
-template <class T_type>
-struct reference_wrapper
-{
-  explicit reference_wrapper(T_type& v)
-    : value_(v)  {}
-
-  operator T_type& () const
-    { return value_; }
-
-  T_type& value_;
-};
-
-/** Const reference wrapper.
- * Use sigc::ref() to create a const reference wrapper.
- */
-template <class T_type>
-struct const_reference_wrapper
-{
-  explicit const_reference_wrapper(const T_type& v)
-    : value_(v)  {}
-
-  operator const T_type& () const
-    { return value_; }
-
-  const T_type& value_;
-};
-
-/** Creates a reference wrapper.
- * Passing an object throught sigc::ref() makes libsigc++ adaptors
- * like, e.g., sigc::bind store references to the object instead of copies.
- * If the object type inherits from sigc::trackable this will ensure
- * automatic invalidation of the adaptors when the object is deleted
- * or overwritten.
- *
- * @param v Reference to store.
- * @return A reference wrapper.
- */
-template <class T_type>
-reference_wrapper<T_type> ref(T_type& v)
-{ return reference_wrapper<T_type>(v); }
-
-/** Creates a const reference wrapper.
- * Passing an object throught sigc::ref() makes libsigc++ adaptors
- * like, e.g., sigc::bind store references to the object instead of copies.
- * If the object type inherits from sigc::trackable this will ensure
- * automatic invalidation of the adaptors when the object is deleted
- * or overwritten.
- *
- * @param v Reference to store.
- * @return A reference wrapper.
- */
-template <class T_type>
-const_reference_wrapper<T_type> ref(const T_type& v)
-{ return const_reference_wrapper<T_type>(v); }
-
-template <class T_type>
-struct unwrap_reference
-{
-  typedef T_type type;
-};
-
-template <class T_type>
-struct unwrap_reference<reference_wrapper<T_type> >
-{
-  typedef T_type& type;
-};
-
-template <class T_type>
-struct unwrap_reference<const_reference_wrapper<T_type> >
-{
-  typedef const T_type& type;
-};
-
-template <class T_type>
-T_type& unwrap(const reference_wrapper<T_type>& v)
-{ return v; }
-
-template <class T_type>
-const T_type& unwrap(const const_reference_wrapper<T_type>& v)
-{ return v; }
-
-} /* namespace sigc */
-
-#endif /* _SIGC_REFERENCE_WRAPPER_H_ */
Index: stardict-3.0.1/src/sigc++/retype.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/retype.h
+++ /dev/null
@@ -1,322 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-#ifndef _SIGC_MACROS_RETYPEHM4_
-#define _SIGC_MACROS_RETYPEHM4_
-#include <sigc++/adaptors/adaptor_trait.h>
-#include <sigc++/slot.h>
-
-#ifndef LIBSIGC_DISABLE_DEPRECATED
-
-namespace SigC {
-
-template <class T_functor, class T_return, class T_type1=::sigc::nil,class T_type2=::sigc::nil,class T_type3=::sigc::nil,class T_type4=::sigc::nil,class T_type5=::sigc::nil,class T_type6=::sigc::nil,class T_type7=::sigc::nil>
-struct retype_slot_functor
-  : public ::sigc::adapts<T_functor>
-{
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef T_return type; };
-  typedef T_return result_type;
-
-  T_return operator()();
-
-  template <class T_arg1>
-  inline T_return operator()(T_arg1 _A_a1)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take>
-        (static_cast<T_type1>(_A_a1)));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  inline T_return sun_forte_workaround(T_arg1 _A_a1)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take>
-        (static_cast<T_type1>(_A_a1)));
-    }
-  #endif
-  
-  template <class T_arg1,class T_arg2>
-  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2)));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  inline T_return sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2)));
-    }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3>
-  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3)));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  inline T_return sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3)));
-    }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take,typename ::sigc::type_trait<T_type4>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4)));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  inline T_return sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take,typename ::sigc::type_trait<T_type4>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4)));
-    }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take,typename ::sigc::type_trait<T_type4>::take,typename ::sigc::type_trait<T_type5>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5)));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  inline T_return sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take,typename ::sigc::type_trait<T_type4>::take,typename ::sigc::type_trait<T_type5>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5)));
-    }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take,typename ::sigc::type_trait<T_type4>::take,typename ::sigc::type_trait<T_type5>::take,typename ::sigc::type_trait<T_type6>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5),static_cast<T_type6>(_A_a6)));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  inline T_return sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take,typename ::sigc::type_trait<T_type4>::take,typename ::sigc::type_trait<T_type5>::take,typename ::sigc::type_trait<T_type6>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5),static_cast<T_type6>(_A_a6)));
-    }
-  #endif
-  
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  inline T_return operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take,typename ::sigc::type_trait<T_type4>::take,typename ::sigc::type_trait<T_type5>::take,typename ::sigc::type_trait<T_type6>::take,typename ::sigc::type_trait<T_type7>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5),static_cast<T_type6>(_A_a6),static_cast<T_type7>(_A_a7)));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  inline T_return sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
-    { return T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take,typename ::sigc::type_trait<T_type4>::take,typename ::sigc::type_trait<T_type5>::take,typename ::sigc::type_trait<T_type6>::take,typename ::sigc::type_trait<T_type7>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5),static_cast<T_type6>(_A_a6),static_cast<T_type7>(_A_a7)));
-    }
-  #endif
-  
-
-  retype_slot_functor(typename ::sigc::type_trait<T_functor>::take _A_functor)
-    : ::sigc::adapts<T_functor>(_A_functor)
-    {}
-};
-
-template <class T_functor, class T_return, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6,class T_type7>
-T_return retype_slot_functor<T_functor, T_return, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6,T_type7>::operator()()
-  { return T_return(this->functor_()); }
-
-
-// void specialization needed because of explicit cast to T_return
-template <class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6,class T_type7>
-struct retype_slot_functor<T_functor, void, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6,T_type7>
-  : public ::sigc::adapts<T_functor>
-{
-  template <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void>
-  struct deduce_result_type
-    { typedef void type; };
-  typedef void result_type;
-
-  void operator()();
-
-  template <class T_arg1>
-  inline void operator()(T_arg1 _A_a1)
-    { T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take>
-        (static_cast<T_type1>(_A_a1)));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1>
-  inline void sun_forte_workaround(T_arg1 _A_a1)
-    { T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take>
-        (static_cast<T_type1>(_A_a1)));
-    }
-  #endif
-    
-  template <class T_arg1,class T_arg2>
-  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2)
-    { T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2)));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2>
-  inline void sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2)
-    { T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2)));
-    }
-  #endif
-    
-  template <class T_arg1,class T_arg2,class T_arg3>
-  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
-    { T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3)));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3>
-  inline void sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3)
-    { T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3)));
-    }
-  #endif
-    
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
-    { T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take,typename ::sigc::type_trait<T_type4>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4)));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-  inline void sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4)
-    { T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take,typename ::sigc::type_trait<T_type4>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4)));
-    }
-  #endif
-    
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
-    { T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take,typename ::sigc::type_trait<T_type4>::take,typename ::sigc::type_trait<T_type5>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5)));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-  inline void sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5)
-    { T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take,typename ::sigc::type_trait<T_type4>::take,typename ::sigc::type_trait<T_type5>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5)));
-    }
-  #endif
-    
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
-    { T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take,typename ::sigc::type_trait<T_type4>::take,typename ::sigc::type_trait<T_type5>::take,typename ::sigc::type_trait<T_type6>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5),static_cast<T_type6>(_A_a6)));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-  inline void sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6)
-    { T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take,typename ::sigc::type_trait<T_type4>::take,typename ::sigc::type_trait<T_type5>::take,typename ::sigc::type_trait<T_type6>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5),static_cast<T_type6>(_A_a6)));
-    }
-  #endif
-    
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  inline void operator()(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
-    { T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take,typename ::sigc::type_trait<T_type4>::take,typename ::sigc::type_trait<T_type5>::take,typename ::sigc::type_trait<T_type6>::take,typename ::sigc::type_trait<T_type7>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5),static_cast<T_type6>(_A_a6),static_cast<T_type7>(_A_a7)));
-    }
-
-  #ifndef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-  inline void sun_forte_workaround(T_arg1 _A_a1,T_arg2 _A_a2,T_arg3 _A_a3,T_arg4 _A_a4,T_arg5 _A_a5,T_arg6 _A_a6,T_arg7 _A_a7)
-    { T_return(this->functor_.SIGC_WORKAROUND_OPERATOR_PARENTHESES<typename ::sigc::type_trait<T_type1>::take,typename ::sigc::type_trait<T_type2>::take,typename ::sigc::type_trait<T_type3>::take,typename ::sigc::type_trait<T_type4>::take,typename ::sigc::type_trait<T_type5>::take,typename ::sigc::type_trait<T_type6>::take,typename ::sigc::type_trait<T_type7>::take>
-        (static_cast<T_type1>(_A_a1),static_cast<T_type2>(_A_a2),static_cast<T_type3>(_A_a3),static_cast<T_type4>(_A_a4),static_cast<T_type5>(_A_a5),static_cast<T_type6>(_A_a6),static_cast<T_type7>(_A_a7)));
-    }
-  #endif
-    
-
-  retype_slot_functor(typename ::sigc::type_trait<T_functor>::take _A_functor)
-    : ::sigc::adapts<T_functor>(_A_functor)
-    {}
-};
-
-template <class T_functor, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6,class T_type7>
-void retype_slot_functor<T_functor, void, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6,T_type7>::operator()()
-  { this->functor_(); }
-
-
-//template specialization of visit_each<>(action, functor):
-template <class T_action, class T_functor, class T_return, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6,class T_type7>
-void visit_each(const T_action& _A_action,
-                const retype_slot_functor<T_functor, T_return, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6,T_type7>& _A_target)
-{
-  visit_each(_A_action, _A_target.functor_);
-}
-
-
-template <class T_return, class T_ret>
-inline Slot0<T_return>
-retype(const Slot0<T_ret>& _A_slot)
-{ return Slot0<T_return>
-    (retype_slot_functor<Slot0<T_ret>, T_return>
-      (_A_slot)); }
-
-template <class T_return, class T_arg1, class T_ret, class T_type1>
-inline Slot1<T_return, T_arg1>
-retype(const Slot1<T_ret, T_type1>& _A_slot)
-{ return Slot1<T_return, T_arg1>
-    (retype_slot_functor<Slot1<T_ret, T_type1>, T_return, T_type1>
-      (_A_slot)); }
-
-template <class T_return, class T_arg1,class T_arg2, class T_ret, class T_type1,class T_type2>
-inline Slot2<T_return, T_arg1,T_arg2>
-retype(const Slot2<T_ret, T_type1,T_type2>& _A_slot)
-{ return Slot2<T_return, T_arg1,T_arg2>
-    (retype_slot_functor<Slot2<T_ret, T_type1, T_type2>, T_return, T_type1,T_type2>
-      (_A_slot)); }
-
-template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_ret, class T_type1,class T_type2,class T_type3>
-inline Slot3<T_return, T_arg1,T_arg2,T_arg3>
-retype(const Slot3<T_ret, T_type1,T_type2,T_type3>& _A_slot)
-{ return Slot3<T_return, T_arg1,T_arg2,T_arg3>
-    (retype_slot_functor<Slot3<T_ret, T_type1, T_type2, T_type3>, T_return, T_type1,T_type2,T_type3>
-      (_A_slot)); }
-
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_ret, class T_type1,class T_type2,class T_type3,class T_type4>
-inline Slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4>
-retype(const Slot4<T_ret, T_type1,T_type2,T_type3,T_type4>& _A_slot)
-{ return Slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4>
-    (retype_slot_functor<Slot4<T_ret, T_type1, T_type2, T_type3, T_type4>, T_return, T_type1,T_type2,T_type3,T_type4>
-      (_A_slot)); }
-
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_ret, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5>
-inline Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-retype(const Slot5<T_ret, T_type1,T_type2,T_type3,T_type4,T_type5>& _A_slot)
-{ return Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-    (retype_slot_functor<Slot5<T_ret, T_type1, T_type2, T_type3, T_type4, T_type5>, T_return, T_type1,T_type2,T_type3,T_type4,T_type5>
-      (_A_slot)); }
-
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_ret, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6>
-inline Slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-retype(const Slot6<T_ret, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6>& _A_slot)
-{ return Slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-    (retype_slot_functor<Slot6<T_ret, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6>, T_return, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6>
-      (_A_slot)); }
-
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_ret, class T_type1,class T_type2,class T_type3,class T_type4,class T_type5,class T_type6,class T_type7>
-inline Slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-retype(const Slot7<T_ret, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6,T_type7>& _A_slot)
-{ return Slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-    (retype_slot_functor<Slot7<T_ret, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7>, T_return, T_type1,T_type2,T_type3,T_type4,T_type5,T_type6,T_type7>
-      (_A_slot)); }
-
-
-} /* namespace SigC */
-
-#endif /* LIBSIGC_DISABLE_DEPRECATED */
-#endif /* _SIGC_MACROS_RETYPEHM4_ */
Index: stardict-3.0.1/src/sigc++/retype_return.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/retype_return.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#ifndef _SIGC_RETYPE_RETURN_HPP_
-#define _SIGC_RETYPE_RETURN_HPP_
-
-#include <sigc++/adaptors/retype_return.h>
-
-#ifndef LIBSIGC_DISABLE_DEPRECATED
-
-namespace SigC {
-
-using ::sigc::retype_return;
-using ::sigc::hide_return;
-
-}
-
-#endif /* LIBSIGC_DISABLE_DEPRECATED */
-
-#endif /* _SIGC_RETYPE_RETURN_HPP_ */
Index: stardict-3.0.1/src/sigc++/sigc++.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/sigc++.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright 2003, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-
-#ifndef SIGCXX_SIGCXX_H
-#define SIGCXX_SIGCXX_H
-
-#include <sigc++/signal.h>
-#include <sigc++/connection.h>
-#include <sigc++/trackable.h>
-#include <sigc++/adaptors/adaptors.h>
-#include <sigc++/functors/functors.h>
-
-#endif /* SIGCXX_SIGCXX_H */
-
Index: stardict-3.0.1/src/sigc++/signal_base.cc
===================================================================
--- stardict-3.0.1.orig/src/sigc++/signal_base.cc
+++ /dev/null
@@ -1,152 +0,0 @@
-// -*- c++ -*-
-/*
- * Copyright 2003, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#include <sigc++/signal_base.h>
-
-namespace sigc {
-namespace internal {
-
-signal_impl::signal_impl()
-: ref_count_(0), exec_count_(0), deferred_(0)
-{}
-
-// only MSVC needs this to guarantee that all new/delete are executed from the DLL module
-#ifdef SIGC_NEW_DELETE_IN_LIBRARY_ONLY
-void* signal_impl::operator new(size_t size_)
-{
-  return malloc(size_);
-}
-
-void signal_impl::operator delete(void* p)
-{
-  free(p);
-}
-#endif
-
-void signal_impl::clear()
-{
-  slots_.clear();
-}
-
-signal_impl::size_type signal_impl::size() const
-{
-  return slots_.size();
-}
-
-signal_impl::iterator_type signal_impl::connect(const slot_base& slot_)
-{
-  return insert(slots_.end(), slot_);
-}
-
-signal_impl::iterator_type signal_impl::erase(iterator_type i)
-{
-  return slots_.erase(i);
-}
-    
-signal_impl::iterator_type signal_impl::insert(signal_impl::iterator_type i, const slot_base& slot_)
-{
-  iterator_type temp = slots_.insert(i, slot_);
-  temp->set_parent(this, &notify);
-  return temp;
-}
-
-void signal_impl::sweep()
-{
-  deferred_ = false;
-  iterator_type i = slots_.begin();
-  while (i != slots_.end())
-    if ((*i).empty())
-      i = slots_.erase(i);
-    else
-      ++i;
-}
-
-void* signal_impl::notify(void* d)
-{
-  signal_impl* self = reinterpret_cast<signal_impl*>(d);
-  if (self->exec_count_ == 0)
-    self->sweep();
-  else                       // This is occuring during signal emission.
-    self->deferred_ = true;  // => sweep() will be called from ~signal_exec().
-  return 0;                  // This is safer because we don't have to care about our iterators in emit().
-}
-
-} /* namespace internal */
-
-signal_base::signal_base()
-: impl_(0)
-{}
-
-signal_base::signal_base(const signal_base& src)
-: trackable(),
-  impl_(src.impl())
-{
-  impl_->reference();
-}
-
-signal_base::~signal_base()
-{
-  if (impl_)
-    impl_->unreference();
-}
-
-void signal_base::clear()
-{
-  if (impl_)
-    impl_->clear();
-}
-
-signal_base::size_type signal_base::size() const
-{
-  return (impl_ ? impl_->size() : 0);
-}
-
-signal_base::iterator_type signal_base::connect(const slot_base& slot_)
-{
-  return impl()->connect(slot_);
-}
-
-signal_base::iterator_type signal_base::insert(iterator_type i, const slot_base& slot_)
-{
-  return impl()->insert(i, slot_);
-}
-
-signal_base::iterator_type signal_base::erase(iterator_type i)
-{
-  return impl()->erase(i);
-}
-
-signal_base& signal_base::operator = (const signal_base& src)
-{
-  if (impl_) impl_->unreference();
-  impl_ = src.impl();
-  impl_->reference();
-  return *this;
-}
-
-internal::signal_impl* signal_base::impl() const
-{
-  if (!impl_) {
-    impl_ = new internal::signal_impl;
-    impl_->reference();  // start with a reference count of 1
-  }
-  return impl_;
-}
-
-} /* sigc */
Index: stardict-3.0.1/src/sigc++/signal_base.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/signal_base.h
+++ /dev/null
@@ -1,300 +0,0 @@
-// -*- c++ -*-
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-
-#ifndef _SIGC_SIGNAL_BASE_H_
-#define _SIGC_SIGNAL_BASE_H_
-
-#include <list>
-#include <sigc++config.h>
-#include <sigc++/type_traits.h>
-#include <sigc++/trackable.h>
-#include <sigc++/functors/slot.h>
-#include <sigc++/functors/mem_fun.h>
-
-namespace sigc
-{
-
-namespace internal
-{
-
-/** Implementation of the signal interface.
- * signal_impl manages a list of slots. When a slot becomes
- * invalid (because some referred object dies), notify() is executed.
- * notify() either calls sweep() directly or defers the execution of
- * sweep() when the signal is being emitted. sweep() removes all
- * invalid slot from the list.
- */
-struct SIGC_API signal_impl
-{
-  typedef size_t size_type;
-  typedef std::list<slot_base> slot_list;
-  typedef slot_list::iterator       iterator_type;
-  typedef slot_list::const_iterator const_iterator_type;
-
-  signal_impl();
-
-  // only MSVC needs this to guarantee that all new/delete are executed from the DLL module
-#ifdef SIGC_NEW_DELETE_IN_LIBRARY_ONLY
-  void* operator new(size_t size_);
-  void operator delete(void* p);
-#endif
-
-  /// Increments the reference counter.
-  inline void reference()
-    { ++ref_count_; }
-
-  /// Increments the reference and execution counter.
-  inline void reference_exec()
-    { ++ref_count_; ++exec_count_; }
-
-  /** Decrements the reference counter.
-   * The object is deleted when the reference counter reaches zero.
-   */
-  inline void unreference()
-    { if (!(--ref_count_)) delete this; }
-
-  /** Decrements the reference and execution counter.
-   * Invokes sweep() if the execution counter reaches zero and the
-   * removal of one or more slots has been deferred.
-   */
-  inline void unreference_exec()
-    {
-      if (!(--ref_count_)) delete this;
-      else if (!(--exec_count_) && deferred_) sweep();
-    }
-
-  /** Returns whether the list of slots is empty.
-   * @return @p true if the list of slots is empty.
-   */
-  inline bool empty() const
-    { return slots_.empty(); }
-
-  /// Empties the list of slots.
-  void clear();
-
-  /** Returns the number of slots in the list.
-   * @return The number of slots in the list.
-   */
-  size_type size() const;
-
-  /** Adds a slot at the bottom of the list of slots.
-   * @param slot_ The slot to add to the list of slots.
-   * @return An iterator pointing to the new slot in the list.
-   */
-  iterator_type connect(const slot_base& slot_);
-
-  /** Adds a slot at the given position into the list of slots.
-   * @param i An iterator indicating the position where @p slot_ should be inserted.
-   * @param slot_ The slot to add to the list of slots.
-   * @return An iterator pointing to the new slot in the list.
-   */
-  iterator_type insert(iterator_type i, const slot_base& slot_);
-
-  /** Removes the slot at the given position from the list of slots.
-   * @param i An iterator pointing to the slot to be removed.
-   * @return An iterator pointing to the slot in the list after the one removed.
-   */
-  iterator_type erase(iterator_type i);
-
-  /// Removes invalid slots from the list of slots.
-  void sweep();
-
-  /** Callback that is executed when some slot becomes invalid.
-   * This callback is registered in every slot when inserted into
-   * the list of slots. It is executed when a slot becomes invalid
-   * because of some referred object being destroyed.
-   * It either calls sweep() directly or defers the execution of
-   * sweep() when the signal is being emitted.
-   * @param d The signal object (@p this).
-   */
-  static void* notify(void* d);
-
-  /** Reference counter.
-   * The object is destroyed when @em ref_count_ reaches zero.
-   */
-  short ref_count_;
-
-  /** Execution counter.
-   * Indicates whether the signal is being emitted.
-   */
-  short exec_count_;
-
-  /// Indicates whether the execution of sweep() is being deferred.
-  bool deferred_;
-
-  /// The list of slots.
-  std::list<slot_base> slots_;
-};
-
-/// Exception safe sweeper for cleaning up invalid slots on the slot list.
-struct SIGC_API signal_exec
-{
-  /// The parent sigc::signal_impl object.
-  signal_impl* sig_;
-
-  /** Increments the reference and execution counter of the parent sigc::signal_impl object.
-   * @param sig The parent sigc::signal_impl object.
-   */
-  inline signal_exec(const signal_impl* sig)
-    : sig_(const_cast<signal_impl*>(sig) )
-    { sig_->reference_exec(); }
-
-  /// Decrements the reference and execution counter of the parent sigc::signal_impl object.
-  inline ~signal_exec()
-    { sig_->unreference_exec(); }
-};
-
-/** Temporary slot list used during signal emission.
- *  Through evolution this class is slightly misnamed.  It is now
- *  an index into the slot_list passed into it.  It simply keeps track
- *  of where the end of this list was at construction, and pretends that's
- *  the end of your list.  This way you may connect during emittion without
- *  inadvertently entering an infinite loop, as well as make other
- *  modifications to the slot_list at your own risk.
- */
-struct temp_slot_list
-{
-  typedef signal_impl::slot_list slot_list;
-  typedef signal_impl::iterator_type iterator;
-  typedef signal_impl::const_iterator_type const_iterator;
-
-  temp_slot_list(slot_list &slots) : slots_(slots)
-  {
-    placeholder = slots_.insert(slots_.end(), slot_base());
-  }
-
-  ~temp_slot_list()
-  {
-    slots_.erase(placeholder);
-  }
-
-  iterator begin() { return slots_.begin(); }
-  iterator end() { return placeholder; }
-  const_iterator begin() const { return slots_.begin(); }
-  const_iterator end() const { return placeholder; }
-
-private:
-  slot_list &slots_;
-  slot_list::iterator placeholder;
-};
-  
-} /* namespace internal */
-
-
-/** @defgroup signal Signals
- * Use sigc::signal::connect() with sigc::mem_fun() and sigc::ptr_fun() to connect a method or function with a signal.
- *
- * @code
- * signal_clicked.connect( sigc::mem_fun(*this, &MyWindow::on_clicked) );
- * @endcode
- *
- * When the signal is emitted your method will be called.
- *
- * signal::connect() returns a connection, which you can later use to disconnect your method.
- * If the type of your object inherits from sigc::trackable the method is disconnected
- * automatically when your object is destroyed.
- *
- * When signals are copied they share the underlying information,
- * so you can have a protected/private sigc::signal member and a public accessor method.
- *
- * signal and slot objects provide the core functionality of this
- * library. A slot is a container for an arbitrary functor.
- * A signal is a list of slots that are executed on emission.
- * For compile time type safety a list of template arguments
- * must be provided for the signal template that determines the
- * parameter list for emission. Functors and closures are converted
- * into slots implicitely on connection, triggering compiler errors
- * if the given functor or closure cannot be invoked with the
- * parameter list of the signal to connect to.
- */
-
-/** Base class for the sigc::signal# templates.
- * signal_base integrates most of the interface of the derived sigc::signal#
- * templates. The implementation, however, resides in sigc::internal::signal_impl.
- * A sigc::internal::signal_impl object is dynamically allocated from signal_base
- * when first connecting a slot to the signal. This ensures that empty signals
- * don't waste memory.
- *
- * @ingroup signal
- */
-struct SIGC_API signal_base : public trackable
-{
-  typedef size_t size_type;
-
-  signal_base();
-
-  signal_base(const signal_base& src);
-
-  ~signal_base();
-
-  signal_base& operator = (const signal_base& src);
-
-  /** Returns whether the list of slots is empty.
-   * @return @p true if the list of slots is empty.
-   */
-  inline bool empty() const
-    { return (!impl_ || impl_->empty()); }
-
-  /// Empties the list of slots.
-  void clear();
-
-  /** Returns the number of slots in the list.
-   * @return The number of slots in the list.
-   */
-  size_type size() const;
-
-protected:
-  typedef internal::signal_impl::iterator_type iterator_type;
-
-  /** Adds a slot at the end of the list of slots.
-   * With connect(), slots can also be added during signal emission.
-   * In this case, they won't be executed until the next emission occurs.
-   * @param slot_ The slot to add to the list of slots.
-   * @return An iterator pointing to the new slot in the list.
-   */
-  iterator_type connect(const slot_base& slot_);
-
-  /** Adds a slot at the given position into the list of slots.
-   * Note that this function does not work during signal emission!
-   * @param i An iterator indicating the position where @e slot_ should be inserted.
-   * @param slot_ The slot to add to the list of slots.
-   * @return An iterator pointing to the new slot in the list.
-   */
-  iterator_type insert(iterator_type i, const slot_base& slot_);
-
-  /** Removes the slot at the given position from the list of slots.
-   * Note that this function does not work during signal emission!
-   * @param i An iterator pointing to the slot to be removed.
-   * @return An iterator pointing to the slot in the list after the one removed.
-   */
-  iterator_type erase(iterator_type i);
-
-  /** Returns the signal_impl object encapsulating the list of slots.
-   * @return The signal_impl object encapsulating the list of slots.
-   */
-  internal::signal_impl* impl() const;
-
-  /// The signal_impl object encapsulating the slot list.
-  mutable internal::signal_impl* impl_;
-};
-
-} //namespace sigc
-
-#endif /* _SIGC_SIGNAL_BASE_H_ */
Index: stardict-3.0.1/src/sigc++/signal.cc
===================================================================
--- stardict-3.0.1.orig/src/sigc++/signal.cc
+++ /dev/null
@@ -1,25 +0,0 @@
-// -*- c++ -*-
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#include <sigc++/signal.h>
-
-namespace sigc {
-
-
-} /* sigc */
Index: stardict-3.0.1/src/sigc++/signal.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/signal.h
+++ /dev/null
@@ -1,3313 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-
-#ifndef _SIGC_SIGNAL_H_
-#define _SIGC_SIGNAL_H_
-
-#include <list>
-#include <sigc++/signal_base.h>
-#include <sigc++/type_traits.h>
-#include <sigc++/trackable.h>
-#include <sigc++/functors/slot.h>
-#include <sigc++/functors/mem_fun.h>
-
-//SIGC_TYPEDEF_REDEFINE_ALLOWED:
-// TODO: This should have its own test, but I can not create one that gives the error instead of just a warning. murrayc.
-// I have just used this because there is a correlation between these two problems.
-#ifdef SIGC_TEMPLATE_SPECIALIZATION_OPERATOR_OVERLOAD
-  //Compilers, such as older versions of SUN Forte C++, that do not allow this also often
-  //do not allow a typedef to have the same name as a class in the typedef's definition.
-  //For Sun Forte CC 5.7 (SUN Workshop 10), comment this out to fix the build.
-  #define SIGC_TYPEDEF_REDEFINE_ALLOWED 1
-#endif
-
-namespace sigc {
-
-/** STL-style iterator for slot_list.
- *
- * @ingroup signal
- */
-template <typename T_slot>
-struct slot_iterator
-{
-  typedef size_t                          size_type;
-  typedef ptrdiff_t                       difference_type;
-  typedef std::bidirectional_iterator_tag iterator_category;
-
-  typedef T_slot  slot_type;
-
-  typedef T_slot  value_type;
-  typedef T_slot* pointer;
-  typedef T_slot& reference;
-
-  typedef typename internal::signal_impl::iterator_type iterator_type;
-
-  slot_iterator()
-    {}
-
-  explicit slot_iterator(const iterator_type& i)
-    : i_(i) {}
-
-  reference operator*() const
-    { return static_cast<reference>(*i_); }
-
-  pointer operator->() const
-    { return &(operator*()); }
-
-  slot_iterator& operator++()
-    {
-      ++i_;
-      return *this;
-    }
-
-  slot_iterator operator++(int)
-    { 
-      slot_iterator __tmp(*this);
-      ++i_;
-      return __tmp;
-    }
-
-  slot_iterator& operator--()
-    {
-      --i_;
-      return *this;
-    }
-
-  slot_iterator operator--(int)
-    {
-      slot_iterator __tmp(*this);
-      --i_;
-      return __tmp;
-    }
-
-  bool operator == (const slot_iterator& other) const
-    { return i_ == other.i_; }
-
-  bool operator != (const slot_iterator& other) const
-    { return i_ != other.i_; }
-
-  iterator_type i_;
-};
-
-/** STL-style const iterator for slot_list.
- *
- * @ingroup signal
- */
-template <typename T_slot>
-struct slot_const_iterator
-{
-  typedef size_t                          size_type;
-  typedef ptrdiff_t                       difference_type;
-  typedef std::bidirectional_iterator_tag iterator_category;
-
-  typedef T_slot        slot_type;
-
-  typedef T_slot        value_type;
-  typedef const T_slot* pointer;
-  typedef const T_slot& reference;
-
-  typedef typename internal::signal_impl::const_iterator_type iterator_type;
-
-  slot_const_iterator()
-    {}
-
-  explicit slot_const_iterator(const iterator_type& i)
-    : i_(i) {}
-
-  reference operator*() const
-    { return static_cast<reference>(*i_); }
-
-  pointer operator->() const
-    { return &(operator*()); }
-
-  slot_const_iterator& operator++()
-    {
-      ++i_;
-      return *this;
-    }
-
-  slot_const_iterator operator++(int)
-    { 
-      slot_const_iterator __tmp(*this);
-      ++i_;
-      return __tmp;
-    }
-
-  slot_const_iterator& operator--()
-    {
-      --i_;
-      return *this;
-    }
-
-  slot_const_iterator operator--(int)
-    {
-      slot_const_iterator __tmp(*this);
-      --i_;
-      return __tmp;
-    }
-
-  bool operator == (const slot_const_iterator& other) const
-    { return i_ == other.i_; }
-
-  bool operator != (const slot_const_iterator& other) const
-    { return i_ != other.i_; }
-
-  iterator_type i_;
-};
-
-/** STL-style list interface for sigc::signal#.
- * slot_list can be used to iterate over the list of slots that
- * is managed by a signal. Slots can be added or removed from
- * the list while existing iterators stay valid. A slot_list
- * object can be retrieved from the signal's slots() function.
- *
- * @ingroup signal
- */
-template <class T_slot>
-struct slot_list
-{
-  typedef T_slot slot_type;
-
-  typedef slot_type&       reference;
-  typedef const slot_type& const_reference;
-
-  typedef slot_iterator<slot_type>              iterator;
-  typedef slot_const_iterator<slot_type>        const_iterator;
-  
-  #ifndef SIGC_HAVE_SUN_REVERSE_ITERATOR
-  typedef std::reverse_iterator<iterator>       reverse_iterator;
-  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
-  #else
-  typedef std::reverse_iterator<iterator, std::random_access_iterator_tag,
-                                int, int&, int*, ptrdiff_t> reverse_iterator;
-
-  typedef std::reverse_iterator<const_iterator, std::random_access_iterator_tag,
-                                int, const int&, const int*, ptrdiff_t> const_reverse_iterator;
-  #endif /* SIGC_HAVE_SUN_REVERSE_ITERATOR */
-
-
-
-
-  slot_list()
-    : list_(0) {}
-
-  explicit slot_list(internal::signal_impl* __list)
-    : list_(__list) {}
-
-  iterator begin()
-    { return iterator(list_->slots_.begin()); }
-
-  const_iterator begin() const
-    { return const_iterator(list_->slots_.begin()); }
-
-  iterator end()
-    { return iterator(list_->slots_.end()); }
-
-  const_iterator end() const
-    { return const_iterator(list_->slots_.end()); }
-
-  reverse_iterator rbegin() 
-    { return reverse_iterator(end()); }
-
-  const_reverse_iterator rbegin() const 
-    { return const_reverse_iterator(end()); }
-
-  reverse_iterator rend()
-    { return reverse_iterator(begin()); }
-
-  const_reverse_iterator rend() const
-    { return const_reverse_iterator(begin()); }
-
-  reference front()
-    { return *begin(); }
-
-  const_reference front() const
-    { return *begin(); }
-
-  reference back()
-    { return *(--end()); }
-
-  const_reference back() const
-    { return *(--end()); }
-
-  iterator insert(iterator i, const slot_type& slot_)
-    { return iterator(list_->insert(i.i_, static_cast<const slot_base&>(slot_))); }
-
-  void push_front(const slot_type& c)
-    { insert(begin(), c); }
-
-  void push_back(const slot_type& c)
-    { insert(end(), c); }
-
-  iterator erase(iterator i)
-    { return iterator(list_->erase(i.i_)); }
-
-  iterator erase(iterator first_, iterator last_)
-    {
-      while (first_ != last_)
-        first_ = erase(first_);
-      return last_;
-    }
-
-  void pop_front()
-    { erase(begin()); }
-
-  void pop_back()
-    { 
-      iterator tmp_ = end();
-      erase(--tmp_);
-    }
-
-protected:
-  internal::signal_impl* list_;
-};
-
-
-namespace internal {
-
-/** Special iterator over sigc::internal::signal_impl's slot list that holds extra data.
- * This iterators is for use in accumulators. operator*() executes
- * the slot. The return value is buffered, so that in an expression
- * like @code a = (*i) * (*i); @endcode the slot is executed only once.
- */
-template <class T_emitter, class T_result = typename T_emitter::result_type>
-struct slot_iterator_buf
-{
-  typedef size_t                           size_type;
-  typedef ptrdiff_t                        difference_type;
-  typedef std::bidirectional_iterator_tag  iterator_category;
-
-  typedef T_emitter                        emitter_type;
-  typedef T_result                         result_type;
-  typedef typename T_emitter::slot_type    slot_type;
-
-  typedef signal_impl::const_iterator_type iterator_type;
-
-  slot_iterator_buf()
-    : c_(0), invoked_(false) {}
-
-  slot_iterator_buf(const iterator_type& i, const emitter_type* c)
-    : i_(i), c_(c), invoked_(false) {}
-
-  result_type operator*() const
-    {
-      if (!i_->empty() && !i_->blocked() && !invoked_)
-        {
-          r_ = (*c_)(static_cast<const slot_type&>(*i_));
-          invoked_ = true;
-        }
-      return r_;
-    }
-
-  slot_iterator_buf& operator++()
-    {
-      ++i_;
-      invoked_ = false;
-      return *this;
-    }
-
-  slot_iterator_buf operator++(int)
-    { 
-      slot_iterator_buf __tmp(*this);
-      ++i_;
-      invoked_ = false;
-      return __tmp;
-    }
-
-  slot_iterator_buf& operator--()
-    {
-      --i_;
-      invoked_ = false;
-      return *this;
-    }
-
-  slot_iterator_buf operator--(int)
-    {
-      slot_iterator_buf __tmp(*this);
-      --i_;
-      invoked_ = false;
-      return __tmp;
-    }
-
-  bool operator == (const slot_iterator_buf& other) const
-    { return (!c_ || (i_ == other.i_)); } /* If '!c_' the iterators are empty.
-                                           * Unfortunately, empty stl iterators are not equal.
-                                           * We are forcing equality so that 'first==last'
-                                           * in the accumulator's emit function yields true. */
-
-  bool operator != (const slot_iterator_buf& other) const
-    { return (c_ && (i_ != other.i_)); }
-
-private:
-  iterator_type i_;
-  const emitter_type* c_;
-  mutable result_type r_;
-  mutable bool invoked_;
-};
-
-/** Template specialization of slot_iterator_buf for void return signals.
- */
-template <class T_emitter>
-struct slot_iterator_buf<T_emitter, void>
-{
-  typedef size_t                           size_type;
-  typedef ptrdiff_t                        difference_type;
-  typedef std::bidirectional_iterator_tag  iterator_category;
-
-  typedef T_emitter                        emitter_type;
-  typedef void                             result_type;
-  typedef typename T_emitter::slot_type    slot_type;
-
-  typedef signal_impl::const_iterator_type iterator_type;
-
-  slot_iterator_buf()
-    : c_(0), invoked_(false) {}
-
-  slot_iterator_buf(const iterator_type& i, const emitter_type* c)
-    : i_(i), c_(c), invoked_(false) {}
-
-  void operator*() const
-    {
-      if (!i_->empty() && !i_->blocked() && !invoked_)
-        {
-          (*c_)(static_cast<const slot_type&>(*i_));
-          invoked_ = true;
-        }
-    }
-
-  slot_iterator_buf& operator++()
-    {
-      ++i_;
-      invoked_ = false;
-      return *this;
-    }
-
-  slot_iterator_buf operator++(int)
-    { 
-      slot_iterator_buf __tmp(*this);
-      ++i_;
-      invoked_ = false;
-      return __tmp;
-    }
-
-  slot_iterator_buf& operator--()
-    {
-      --i_;
-      invoked_ = false;
-      return *this;
-    }
-
-  slot_iterator_buf operator--(int)
-    {
-      slot_iterator_buf __tmp(*this);
-      --i_;
-      invoked_ = false;
-      return __tmp;
-    }
-
-  bool operator == (const slot_iterator_buf& other) const
-    { return i_ == other.i_; }
-
-  bool operator != (const slot_iterator_buf& other) const
-    { return i_ != other.i_; }
-
-private:
-  iterator_type i_;
-  const emitter_type* c_;
-  mutable bool invoked_;
-};
-
-/** Abstracts signal emission.
- * This template implements the emit() function of signal0.
- * Template specializations are available to optimize signal
- * emission when no accumulator is used, i.e. the template
- * argument @e T_accumulator is @p nil.
- */
-template <class T_return, class T_accumulator>
-struct signal_emit0
-{
-  typedef signal_emit0<T_return, T_accumulator> self_type;
-  typedef typename T_accumulator::result_type result_type;
-  typedef slot<T_return> slot_type;
-  typedef internal::slot_iterator_buf<self_type> slot_iterator_buf_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-
-  signal_emit0()  {}
-
-  /** Invokes a slot.
-   * @param _A_slot Some slot to invoke.
-   * @return The slot's return value.
-   */
-  T_return operator()(const slot_type& _A_slot) const
-    { return (reinterpret_cast<typename slot_type::call_type>(_A_slot.rep_->call_))(_A_slot.rep_); }
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-
-   * @return The accumulated return values of the slot invocations as processed by the accumulator.
-   */
-  static result_type emit(signal_impl* impl)
-    {
-      T_accumulator accumulator;
-
-      if (!impl)
-        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
-
-      signal_exec exec(impl);
-      temp_slot_list slots(impl->slots_);
-
-      self_type self ;
-      return accumulator(slot_iterator_buf_type(slots.begin(), &self),
-                         slot_iterator_buf_type(slots.end(), &self));
-    }
-  
-};
-
-/** Abstracts signal emission.
- * This template specialization implements an optimized emit()
- * function for the case that no accumulator is used.
- */
-template <class T_return>
-struct signal_emit0<T_return, nil>
-{
-  typedef signal_emit0<T_return, nil > self_type;
-  typedef T_return result_type;
-  typedef slot<T_return> slot_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-  typedef typename slot_type::call_type call_type;
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The return value of the last slot invoked is returned.
-   * @param first An iterator pointing to the first slot in the list.
-   * @param last An iterator pointing to the last slot in the list.
-   * @return The return value of the last slot invoked.
-   */
-  static result_type emit(signal_impl* impl)
-    {
-      if (!impl || impl->slots_.empty())
-        return T_return();
-        
-      signal_exec exec(impl);
-      T_return r_ = T_return(); 
-      
-      //Use this scope to make sure that "slots" is destroyed before "exec" is destroyed.
-      //This avoids a leak on MSVC++ - see http://bugzilla.gnome.org/show_bug.cgi?id=306249
-      { 
-        temp_slot_list slots(impl->slots_);
-        iterator_type it = slots.begin();
-        for (; it != slots.end(); ++it)
-          if (!it->empty() && !it->blocked()) break;
-          
-        if (it == slots.end())
-          return T_return(); // note that 'T_return r_();' doesn't work => define 'r_' after this line and initialize as follows:
-  
-        r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_);
-        for (++it; it != slots.end(); ++it)
-          {
-            if (it->empty() || it->blocked())
-              continue;
-            r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_);
-          }
-      }
-      
-      return r_;
-    }
-};
-
-/** Abstracts signal emission.
- * This template specialization implements an optimized emit()
- * function for the case that no accumulator is used and the
- * return type is @p void.
- */
-template <>
-struct signal_emit0<void, nil>
-{
-  typedef signal_emit0<void, nil> self_type;
-  typedef void result_type;
-  typedef slot<void> slot_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-  typedef void (*call_type)(slot_rep*);
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * @param first An iterator pointing to the first slot in the list.
-   * @param last An iterator pointing to the last slot in the list.
-   */
-  static result_type emit(signal_impl* impl)
-    {
-      if (!impl || impl->slots_.empty()) return;
-      signal_exec exec(impl);
-      temp_slot_list slots(impl->slots_);
-
-      for (iterator_type it = slots.begin(); it != slots.end(); ++it)
-        {
-          if (it->empty() || it->blocked())
-            continue;
-          (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_);
-        }
-    }
-};
-
-/** Abstracts signal emission.
- * This template implements the emit() function of signal1.
- * Template specializations are available to optimize signal
- * emission when no accumulator is used, i.e. the template
- * argument @e T_accumulator is @p nil.
- */
-template <class T_return, class T_arg1, class T_accumulator>
-struct signal_emit1
-{
-  typedef signal_emit1<T_return, T_arg1, T_accumulator> self_type;
-  typedef typename T_accumulator::result_type result_type;
-  typedef slot<T_return, T_arg1> slot_type;
-  typedef internal::slot_iterator_buf<self_type> slot_iterator_buf_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-
-  /** Instantiates the class.
-   * The parameters are stored in member variables. operator()() passes
-   * the values on to some slot.
-   */
-  signal_emit1(typename type_trait<T_arg1>::take _A_a1) 
-    : _A_a1_(_A_a1) {}
-
-
-  /** Invokes a slot using the buffered parameter values.
-   * @param _A_slot Some slot to invoke.
-   * @return The slot's return value.
-   */
-  T_return operator()(const slot_type& _A_slot) const
-    { return (reinterpret_cast<typename slot_type::call_type>(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_); }
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are buffered in a temporary instance of signal_emit1.
-
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @return The accumulated return values of the slot invocations as processed by the accumulator.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1)
-    {
-      T_accumulator accumulator;
-
-      if (!impl)
-        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
-
-      signal_exec exec(impl);
-      temp_slot_list slots(impl->slots_);
-
-      self_type self (_A_a1);
-      return accumulator(slot_iterator_buf_type(slots.begin(), &self),
-                         slot_iterator_buf_type(slots.end(), &self));
-    }
-  
-  typename type_trait<T_arg1>::take _A_a1_;
-};
-
-/** Abstracts signal emission.
- * This template specialization implements an optimized emit()
- * function for the case that no accumulator is used.
- */
-template <class T_return, class T_arg1>
-struct signal_emit1<T_return, T_arg1, nil>
-{
-  typedef signal_emit1<T_return, T_arg1, nil > self_type;
-  typedef T_return result_type;
-  typedef slot<T_return, T_arg1> slot_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-  typedef typename slot_type::call_type call_type;
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are passed directly on to the slots.
-   * The return value of the last slot invoked is returned.
-   * @param first An iterator pointing to the first slot in the list.
-   * @param last An iterator pointing to the last slot in the list.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @return The return value of the last slot invoked.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1)
-    {
-      if (!impl || impl->slots_.empty())
-        return T_return();
-        
-      signal_exec exec(impl);
-      T_return r_ = T_return(); 
-      
-      //Use this scope to make sure that "slots" is destroyed before "exec" is destroyed.
-      //This avoids a leak on MSVC++ - see http://bugzilla.gnome.org/show_bug.cgi?id=306249
-      { 
-        temp_slot_list slots(impl->slots_);
-        iterator_type it = slots.begin();
-        for (; it != slots.end(); ++it)
-          if (!it->empty() && !it->blocked()) break;
-          
-        if (it == slots.end())
-          return T_return(); // note that 'T_return r_();' doesn't work => define 'r_' after this line and initialize as follows:
-  
-        r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1);
-        for (++it; it != slots.end(); ++it)
-          {
-            if (it->empty() || it->blocked())
-              continue;
-            r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1);
-          }
-      }
-      
-      return r_;
-    }
-};
-
-/** Abstracts signal emission.
- * This template specialization implements an optimized emit()
- * function for the case that no accumulator is used and the
- * return type is @p void.
- */
-template <class T_arg1>
-struct signal_emit1<void, T_arg1, nil>
-{
-  typedef signal_emit1<void, T_arg1, nil> self_type;
-  typedef void result_type;
-  typedef slot<void, T_arg1> slot_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-  typedef typename slot_type::call_type call_type;
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are passed directly on to the slots.
-   * @param first An iterator pointing to the first slot in the list.
-   * @param last An iterator pointing to the last slot in the list.
-   * @param _A_a1 Argument to be passed on to the slots.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1)
-    {
-      if (!impl || impl->slots_.empty()) return;
-      signal_exec exec(impl);
-      temp_slot_list slots(impl->slots_);
-
-      for (iterator_type it = slots.begin(); it != slots.end(); ++it)
-        {
-          if (it->empty() || it->blocked())
-            continue;
-          (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1);
-        }
-    }
-};
-
-/** Abstracts signal emission.
- * This template implements the emit() function of signal2.
- * Template specializations are available to optimize signal
- * emission when no accumulator is used, i.e. the template
- * argument @e T_accumulator is @p nil.
- */
-template <class T_return, class T_arg1,class T_arg2, class T_accumulator>
-struct signal_emit2
-{
-  typedef signal_emit2<T_return, T_arg1,T_arg2, T_accumulator> self_type;
-  typedef typename T_accumulator::result_type result_type;
-  typedef slot<T_return, T_arg1,T_arg2> slot_type;
-  typedef internal::slot_iterator_buf<self_type> slot_iterator_buf_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-
-  /** Instantiates the class.
-   * The parameters are stored in member variables. operator()() passes
-   * the values on to some slot.
-   */
-  signal_emit2(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) 
-    : _A_a1_(_A_a1),_A_a2_(_A_a2) {}
-
-
-  /** Invokes a slot using the buffered parameter values.
-   * @param _A_slot Some slot to invoke.
-   * @return The slot's return value.
-   */
-  T_return operator()(const slot_type& _A_slot) const
-    { return (reinterpret_cast<typename slot_type::call_type>(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_,_A_a2_); }
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are buffered in a temporary instance of signal_emit2.
-
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @return The accumulated return values of the slot invocations as processed by the accumulator.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2)
-    {
-      T_accumulator accumulator;
-
-      if (!impl)
-        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
-
-      signal_exec exec(impl);
-      temp_slot_list slots(impl->slots_);
-
-      self_type self (_A_a1,_A_a2);
-      return accumulator(slot_iterator_buf_type(slots.begin(), &self),
-                         slot_iterator_buf_type(slots.end(), &self));
-    }
-  
-  typename type_trait<T_arg1>::take _A_a1_;
-  typename type_trait<T_arg2>::take _A_a2_;
-};
-
-/** Abstracts signal emission.
- * This template specialization implements an optimized emit()
- * function for the case that no accumulator is used.
- */
-template <class T_return, class T_arg1,class T_arg2>
-struct signal_emit2<T_return, T_arg1,T_arg2, nil>
-{
-  typedef signal_emit2<T_return, T_arg1,T_arg2, nil > self_type;
-  typedef T_return result_type;
-  typedef slot<T_return, T_arg1,T_arg2> slot_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-  typedef typename slot_type::call_type call_type;
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are passed directly on to the slots.
-   * The return value of the last slot invoked is returned.
-   * @param first An iterator pointing to the first slot in the list.
-   * @param last An iterator pointing to the last slot in the list.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @return The return value of the last slot invoked.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2)
-    {
-      if (!impl || impl->slots_.empty())
-        return T_return();
-        
-      signal_exec exec(impl);
-      T_return r_ = T_return(); 
-      
-      //Use this scope to make sure that "slots" is destroyed before "exec" is destroyed.
-      //This avoids a leak on MSVC++ - see http://bugzilla.gnome.org/show_bug.cgi?id=306249
-      { 
-        temp_slot_list slots(impl->slots_);
-        iterator_type it = slots.begin();
-        for (; it != slots.end(); ++it)
-          if (!it->empty() && !it->blocked()) break;
-          
-        if (it == slots.end())
-          return T_return(); // note that 'T_return r_();' doesn't work => define 'r_' after this line and initialize as follows:
-  
-        r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2);
-        for (++it; it != slots.end(); ++it)
-          {
-            if (it->empty() || it->blocked())
-              continue;
-            r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2);
-          }
-      }
-      
-      return r_;
-    }
-};
-
-/** Abstracts signal emission.
- * This template specialization implements an optimized emit()
- * function for the case that no accumulator is used and the
- * return type is @p void.
- */
-template <class T_arg1,class T_arg2>
-struct signal_emit2<void, T_arg1,T_arg2, nil>
-{
-  typedef signal_emit2<void, T_arg1,T_arg2, nil> self_type;
-  typedef void result_type;
-  typedef slot<void, T_arg1,T_arg2> slot_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-  typedef typename slot_type::call_type call_type;
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are passed directly on to the slots.
-   * @param first An iterator pointing to the first slot in the list.
-   * @param last An iterator pointing to the last slot in the list.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2)
-    {
-      if (!impl || impl->slots_.empty()) return;
-      signal_exec exec(impl);
-      temp_slot_list slots(impl->slots_);
-
-      for (iterator_type it = slots.begin(); it != slots.end(); ++it)
-        {
-          if (it->empty() || it->blocked())
-            continue;
-          (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2);
-        }
-    }
-};
-
-/** Abstracts signal emission.
- * This template implements the emit() function of signal3.
- * Template specializations are available to optimize signal
- * emission when no accumulator is used, i.e. the template
- * argument @e T_accumulator is @p nil.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_accumulator>
-struct signal_emit3
-{
-  typedef signal_emit3<T_return, T_arg1,T_arg2,T_arg3, T_accumulator> self_type;
-  typedef typename T_accumulator::result_type result_type;
-  typedef slot<T_return, T_arg1,T_arg2,T_arg3> slot_type;
-  typedef internal::slot_iterator_buf<self_type> slot_iterator_buf_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-
-  /** Instantiates the class.
-   * The parameters are stored in member variables. operator()() passes
-   * the values on to some slot.
-   */
-  signal_emit3(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) 
-    : _A_a1_(_A_a1),_A_a2_(_A_a2),_A_a3_(_A_a3) {}
-
-
-  /** Invokes a slot using the buffered parameter values.
-   * @param _A_slot Some slot to invoke.
-   * @return The slot's return value.
-   */
-  T_return operator()(const slot_type& _A_slot) const
-    { return (reinterpret_cast<typename slot_type::call_type>(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_,_A_a2_,_A_a3_); }
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are buffered in a temporary instance of signal_emit3.
-
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @return The accumulated return values of the slot invocations as processed by the accumulator.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3)
-    {
-      T_accumulator accumulator;
-
-      if (!impl)
-        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
-
-      signal_exec exec(impl);
-      temp_slot_list slots(impl->slots_);
-
-      self_type self (_A_a1,_A_a2,_A_a3);
-      return accumulator(slot_iterator_buf_type(slots.begin(), &self),
-                         slot_iterator_buf_type(slots.end(), &self));
-    }
-  
-  typename type_trait<T_arg1>::take _A_a1_;
-  typename type_trait<T_arg2>::take _A_a2_;
-  typename type_trait<T_arg3>::take _A_a3_;
-};
-
-/** Abstracts signal emission.
- * This template specialization implements an optimized emit()
- * function for the case that no accumulator is used.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3>
-struct signal_emit3<T_return, T_arg1,T_arg2,T_arg3, nil>
-{
-  typedef signal_emit3<T_return, T_arg1,T_arg2,T_arg3, nil > self_type;
-  typedef T_return result_type;
-  typedef slot<T_return, T_arg1,T_arg2,T_arg3> slot_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-  typedef typename slot_type::call_type call_type;
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are passed directly on to the slots.
-   * The return value of the last slot invoked is returned.
-   * @param first An iterator pointing to the first slot in the list.
-   * @param last An iterator pointing to the last slot in the list.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @return The return value of the last slot invoked.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3)
-    {
-      if (!impl || impl->slots_.empty())
-        return T_return();
-        
-      signal_exec exec(impl);
-      T_return r_ = T_return(); 
-      
-      //Use this scope to make sure that "slots" is destroyed before "exec" is destroyed.
-      //This avoids a leak on MSVC++ - see http://bugzilla.gnome.org/show_bug.cgi?id=306249
-      { 
-        temp_slot_list slots(impl->slots_);
-        iterator_type it = slots.begin();
-        for (; it != slots.end(); ++it)
-          if (!it->empty() && !it->blocked()) break;
-          
-        if (it == slots.end())
-          return T_return(); // note that 'T_return r_();' doesn't work => define 'r_' after this line and initialize as follows:
-  
-        r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3);
-        for (++it; it != slots.end(); ++it)
-          {
-            if (it->empty() || it->blocked())
-              continue;
-            r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3);
-          }
-      }
-      
-      return r_;
-    }
-};
-
-/** Abstracts signal emission.
- * This template specialization implements an optimized emit()
- * function for the case that no accumulator is used and the
- * return type is @p void.
- */
-template <class T_arg1,class T_arg2,class T_arg3>
-struct signal_emit3<void, T_arg1,T_arg2,T_arg3, nil>
-{
-  typedef signal_emit3<void, T_arg1,T_arg2,T_arg3, nil> self_type;
-  typedef void result_type;
-  typedef slot<void, T_arg1,T_arg2,T_arg3> slot_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-  typedef typename slot_type::call_type call_type;
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are passed directly on to the slots.
-   * @param first An iterator pointing to the first slot in the list.
-   * @param last An iterator pointing to the last slot in the list.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3)
-    {
-      if (!impl || impl->slots_.empty()) return;
-      signal_exec exec(impl);
-      temp_slot_list slots(impl->slots_);
-
-      for (iterator_type it = slots.begin(); it != slots.end(); ++it)
-        {
-          if (it->empty() || it->blocked())
-            continue;
-          (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3);
-        }
-    }
-};
-
-/** Abstracts signal emission.
- * This template implements the emit() function of signal4.
- * Template specializations are available to optimize signal
- * emission when no accumulator is used, i.e. the template
- * argument @e T_accumulator is @p nil.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_accumulator>
-struct signal_emit4
-{
-  typedef signal_emit4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, T_accumulator> self_type;
-  typedef typename T_accumulator::result_type result_type;
-  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4> slot_type;
-  typedef internal::slot_iterator_buf<self_type> slot_iterator_buf_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-
-  /** Instantiates the class.
-   * The parameters are stored in member variables. operator()() passes
-   * the values on to some slot.
-   */
-  signal_emit4(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) 
-    : _A_a1_(_A_a1),_A_a2_(_A_a2),_A_a3_(_A_a3),_A_a4_(_A_a4) {}
-
-
-  /** Invokes a slot using the buffered parameter values.
-   * @param _A_slot Some slot to invoke.
-   * @return The slot's return value.
-   */
-  T_return operator()(const slot_type& _A_slot) const
-    { return (reinterpret_cast<typename slot_type::call_type>(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_,_A_a2_,_A_a3_,_A_a4_); }
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are buffered in a temporary instance of signal_emit4.
-
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @param _A_a4 Argument to be passed on to the slots.
-   * @return The accumulated return values of the slot invocations as processed by the accumulator.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4)
-    {
-      T_accumulator accumulator;
-
-      if (!impl)
-        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
-
-      signal_exec exec(impl);
-      temp_slot_list slots(impl->slots_);
-
-      self_type self (_A_a1,_A_a2,_A_a3,_A_a4);
-      return accumulator(slot_iterator_buf_type(slots.begin(), &self),
-                         slot_iterator_buf_type(slots.end(), &self));
-    }
-  
-  typename type_trait<T_arg1>::take _A_a1_;
-  typename type_trait<T_arg2>::take _A_a2_;
-  typename type_trait<T_arg3>::take _A_a3_;
-  typename type_trait<T_arg4>::take _A_a4_;
-};
-
-/** Abstracts signal emission.
- * This template specialization implements an optimized emit()
- * function for the case that no accumulator is used.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-struct signal_emit4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, nil>
-{
-  typedef signal_emit4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, nil > self_type;
-  typedef T_return result_type;
-  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4> slot_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-  typedef typename slot_type::call_type call_type;
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are passed directly on to the slots.
-   * The return value of the last slot invoked is returned.
-   * @param first An iterator pointing to the first slot in the list.
-   * @param last An iterator pointing to the last slot in the list.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @param _A_a4 Argument to be passed on to the slots.
-   * @return The return value of the last slot invoked.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4)
-    {
-      if (!impl || impl->slots_.empty())
-        return T_return();
-        
-      signal_exec exec(impl);
-      T_return r_ = T_return(); 
-      
-      //Use this scope to make sure that "slots" is destroyed before "exec" is destroyed.
-      //This avoids a leak on MSVC++ - see http://bugzilla.gnome.org/show_bug.cgi?id=306249
-      { 
-        temp_slot_list slots(impl->slots_);
-        iterator_type it = slots.begin();
-        for (; it != slots.end(); ++it)
-          if (!it->empty() && !it->blocked()) break;
-          
-        if (it == slots.end())
-          return T_return(); // note that 'T_return r_();' doesn't work => define 'r_' after this line and initialize as follows:
-  
-        r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4);
-        for (++it; it != slots.end(); ++it)
-          {
-            if (it->empty() || it->blocked())
-              continue;
-            r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4);
-          }
-      }
-      
-      return r_;
-    }
-};
-
-/** Abstracts signal emission.
- * This template specialization implements an optimized emit()
- * function for the case that no accumulator is used and the
- * return type is @p void.
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-struct signal_emit4<void, T_arg1,T_arg2,T_arg3,T_arg4, nil>
-{
-  typedef signal_emit4<void, T_arg1,T_arg2,T_arg3,T_arg4, nil> self_type;
-  typedef void result_type;
-  typedef slot<void, T_arg1,T_arg2,T_arg3,T_arg4> slot_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-  typedef typename slot_type::call_type call_type;
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are passed directly on to the slots.
-   * @param first An iterator pointing to the first slot in the list.
-   * @param last An iterator pointing to the last slot in the list.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @param _A_a4 Argument to be passed on to the slots.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4)
-    {
-      if (!impl || impl->slots_.empty()) return;
-      signal_exec exec(impl);
-      temp_slot_list slots(impl->slots_);
-
-      for (iterator_type it = slots.begin(); it != slots.end(); ++it)
-        {
-          if (it->empty() || it->blocked())
-            continue;
-          (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4);
-        }
-    }
-};
-
-/** Abstracts signal emission.
- * This template implements the emit() function of signal5.
- * Template specializations are available to optimize signal
- * emission when no accumulator is used, i.e. the template
- * argument @e T_accumulator is @p nil.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_accumulator>
-struct signal_emit5
-{
-  typedef signal_emit5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_accumulator> self_type;
-  typedef typename T_accumulator::result_type result_type;
-  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> slot_type;
-  typedef internal::slot_iterator_buf<self_type> slot_iterator_buf_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-
-  /** Instantiates the class.
-   * The parameters are stored in member variables. operator()() passes
-   * the values on to some slot.
-   */
-  signal_emit5(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) 
-    : _A_a1_(_A_a1),_A_a2_(_A_a2),_A_a3_(_A_a3),_A_a4_(_A_a4),_A_a5_(_A_a5) {}
-
-
-  /** Invokes a slot using the buffered parameter values.
-   * @param _A_slot Some slot to invoke.
-   * @return The slot's return value.
-   */
-  T_return operator()(const slot_type& _A_slot) const
-    { return (reinterpret_cast<typename slot_type::call_type>(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_,_A_a2_,_A_a3_,_A_a4_,_A_a5_); }
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are buffered in a temporary instance of signal_emit5.
-
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @param _A_a4 Argument to be passed on to the slots.
-   * @param _A_a5 Argument to be passed on to the slots.
-   * @return The accumulated return values of the slot invocations as processed by the accumulator.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5)
-    {
-      T_accumulator accumulator;
-
-      if (!impl)
-        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
-
-      signal_exec exec(impl);
-      temp_slot_list slots(impl->slots_);
-
-      self_type self (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
-      return accumulator(slot_iterator_buf_type(slots.begin(), &self),
-                         slot_iterator_buf_type(slots.end(), &self));
-    }
-  
-  typename type_trait<T_arg1>::take _A_a1_;
-  typename type_trait<T_arg2>::take _A_a2_;
-  typename type_trait<T_arg3>::take _A_a3_;
-  typename type_trait<T_arg4>::take _A_a4_;
-  typename type_trait<T_arg5>::take _A_a5_;
-};
-
-/** Abstracts signal emission.
- * This template specialization implements an optimized emit()
- * function for the case that no accumulator is used.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-struct signal_emit5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, nil>
-{
-  typedef signal_emit5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, nil > self_type;
-  typedef T_return result_type;
-  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> slot_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-  typedef typename slot_type::call_type call_type;
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are passed directly on to the slots.
-   * The return value of the last slot invoked is returned.
-   * @param first An iterator pointing to the first slot in the list.
-   * @param last An iterator pointing to the last slot in the list.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @param _A_a4 Argument to be passed on to the slots.
-   * @param _A_a5 Argument to be passed on to the slots.
-   * @return The return value of the last slot invoked.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5)
-    {
-      if (!impl || impl->slots_.empty())
-        return T_return();
-        
-      signal_exec exec(impl);
-      T_return r_ = T_return(); 
-      
-      //Use this scope to make sure that "slots" is destroyed before "exec" is destroyed.
-      //This avoids a leak on MSVC++ - see http://bugzilla.gnome.org/show_bug.cgi?id=306249
-      { 
-        temp_slot_list slots(impl->slots_);
-        iterator_type it = slots.begin();
-        for (; it != slots.end(); ++it)
-          if (!it->empty() && !it->blocked()) break;
-          
-        if (it == slots.end())
-          return T_return(); // note that 'T_return r_();' doesn't work => define 'r_' after this line and initialize as follows:
-  
-        r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
-        for (++it; it != slots.end(); ++it)
-          {
-            if (it->empty() || it->blocked())
-              continue;
-            r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
-          }
-      }
-      
-      return r_;
-    }
-};
-
-/** Abstracts signal emission.
- * This template specialization implements an optimized emit()
- * function for the case that no accumulator is used and the
- * return type is @p void.
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-struct signal_emit5<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, nil>
-{
-  typedef signal_emit5<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, nil> self_type;
-  typedef void result_type;
-  typedef slot<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> slot_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-  typedef typename slot_type::call_type call_type;
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are passed directly on to the slots.
-   * @param first An iterator pointing to the first slot in the list.
-   * @param last An iterator pointing to the last slot in the list.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @param _A_a4 Argument to be passed on to the slots.
-   * @param _A_a5 Argument to be passed on to the slots.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5)
-    {
-      if (!impl || impl->slots_.empty()) return;
-      signal_exec exec(impl);
-      temp_slot_list slots(impl->slots_);
-
-      for (iterator_type it = slots.begin(); it != slots.end(); ++it)
-        {
-          if (it->empty() || it->blocked())
-            continue;
-          (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5);
-        }
-    }
-};
-
-/** Abstracts signal emission.
- * This template implements the emit() function of signal6.
- * Template specializations are available to optimize signal
- * emission when no accumulator is used, i.e. the template
- * argument @e T_accumulator is @p nil.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_accumulator>
-struct signal_emit6
-{
-  typedef signal_emit6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_accumulator> self_type;
-  typedef typename T_accumulator::result_type result_type;
-  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> slot_type;
-  typedef internal::slot_iterator_buf<self_type> slot_iterator_buf_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-
-  /** Instantiates the class.
-   * The parameters are stored in member variables. operator()() passes
-   * the values on to some slot.
-   */
-  signal_emit6(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) 
-    : _A_a1_(_A_a1),_A_a2_(_A_a2),_A_a3_(_A_a3),_A_a4_(_A_a4),_A_a5_(_A_a5),_A_a6_(_A_a6) {}
-
-
-  /** Invokes a slot using the buffered parameter values.
-   * @param _A_slot Some slot to invoke.
-   * @return The slot's return value.
-   */
-  T_return operator()(const slot_type& _A_slot) const
-    { return (reinterpret_cast<typename slot_type::call_type>(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_,_A_a2_,_A_a3_,_A_a4_,_A_a5_,_A_a6_); }
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are buffered in a temporary instance of signal_emit6.
-
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @param _A_a4 Argument to be passed on to the slots.
-   * @param _A_a5 Argument to be passed on to the slots.
-   * @param _A_a6 Argument to be passed on to the slots.
-   * @return The accumulated return values of the slot invocations as processed by the accumulator.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6)
-    {
-      T_accumulator accumulator;
-
-      if (!impl)
-        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
-
-      signal_exec exec(impl);
-      temp_slot_list slots(impl->slots_);
-
-      self_type self (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
-      return accumulator(slot_iterator_buf_type(slots.begin(), &self),
-                         slot_iterator_buf_type(slots.end(), &self));
-    }
-  
-  typename type_trait<T_arg1>::take _A_a1_;
-  typename type_trait<T_arg2>::take _A_a2_;
-  typename type_trait<T_arg3>::take _A_a3_;
-  typename type_trait<T_arg4>::take _A_a4_;
-  typename type_trait<T_arg5>::take _A_a5_;
-  typename type_trait<T_arg6>::take _A_a6_;
-};
-
-/** Abstracts signal emission.
- * This template specialization implements an optimized emit()
- * function for the case that no accumulator is used.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-struct signal_emit6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, nil>
-{
-  typedef signal_emit6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, nil > self_type;
-  typedef T_return result_type;
-  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> slot_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-  typedef typename slot_type::call_type call_type;
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are passed directly on to the slots.
-   * The return value of the last slot invoked is returned.
-   * @param first An iterator pointing to the first slot in the list.
-   * @param last An iterator pointing to the last slot in the list.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @param _A_a4 Argument to be passed on to the slots.
-   * @param _A_a5 Argument to be passed on to the slots.
-   * @param _A_a6 Argument to be passed on to the slots.
-   * @return The return value of the last slot invoked.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6)
-    {
-      if (!impl || impl->slots_.empty())
-        return T_return();
-        
-      signal_exec exec(impl);
-      T_return r_ = T_return(); 
-      
-      //Use this scope to make sure that "slots" is destroyed before "exec" is destroyed.
-      //This avoids a leak on MSVC++ - see http://bugzilla.gnome.org/show_bug.cgi?id=306249
-      { 
-        temp_slot_list slots(impl->slots_);
-        iterator_type it = slots.begin();
-        for (; it != slots.end(); ++it)
-          if (!it->empty() && !it->blocked()) break;
-          
-        if (it == slots.end())
-          return T_return(); // note that 'T_return r_();' doesn't work => define 'r_' after this line and initialize as follows:
-  
-        r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
-        for (++it; it != slots.end(); ++it)
-          {
-            if (it->empty() || it->blocked())
-              continue;
-            r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
-          }
-      }
-      
-      return r_;
-    }
-};
-
-/** Abstracts signal emission.
- * This template specialization implements an optimized emit()
- * function for the case that no accumulator is used and the
- * return type is @p void.
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-struct signal_emit6<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, nil>
-{
-  typedef signal_emit6<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, nil> self_type;
-  typedef void result_type;
-  typedef slot<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> slot_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-  typedef typename slot_type::call_type call_type;
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are passed directly on to the slots.
-   * @param first An iterator pointing to the first slot in the list.
-   * @param last An iterator pointing to the last slot in the list.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @param _A_a4 Argument to be passed on to the slots.
-   * @param _A_a5 Argument to be passed on to the slots.
-   * @param _A_a6 Argument to be passed on to the slots.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6)
-    {
-      if (!impl || impl->slots_.empty()) return;
-      signal_exec exec(impl);
-      temp_slot_list slots(impl->slots_);
-
-      for (iterator_type it = slots.begin(); it != slots.end(); ++it)
-        {
-          if (it->empty() || it->blocked())
-            continue;
-          (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6);
-        }
-    }
-};
-
-/** Abstracts signal emission.
- * This template implements the emit() function of signal7.
- * Template specializations are available to optimize signal
- * emission when no accumulator is used, i.e. the template
- * argument @e T_accumulator is @p nil.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_accumulator>
-struct signal_emit7
-{
-  typedef signal_emit7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_accumulator> self_type;
-  typedef typename T_accumulator::result_type result_type;
-  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> slot_type;
-  typedef internal::slot_iterator_buf<self_type> slot_iterator_buf_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-
-  /** Instantiates the class.
-   * The parameters are stored in member variables. operator()() passes
-   * the values on to some slot.
-   */
-  signal_emit7(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) 
-    : _A_a1_(_A_a1),_A_a2_(_A_a2),_A_a3_(_A_a3),_A_a4_(_A_a4),_A_a5_(_A_a5),_A_a6_(_A_a6),_A_a7_(_A_a7) {}
-
-
-  /** Invokes a slot using the buffered parameter values.
-   * @param _A_slot Some slot to invoke.
-   * @return The slot's return value.
-   */
-  T_return operator()(const slot_type& _A_slot) const
-    { return (reinterpret_cast<typename slot_type::call_type>(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_,_A_a2_,_A_a3_,_A_a4_,_A_a5_,_A_a6_,_A_a7_); }
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are buffered in a temporary instance of signal_emit7.
-
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @param _A_a4 Argument to be passed on to the slots.
-   * @param _A_a5 Argument to be passed on to the slots.
-   * @param _A_a6 Argument to be passed on to the slots.
-   * @param _A_a7 Argument to be passed on to the slots.
-   * @return The accumulated return values of the slot invocations as processed by the accumulator.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7)
-    {
-      T_accumulator accumulator;
-
-      if (!impl)
-        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
-
-      signal_exec exec(impl);
-      temp_slot_list slots(impl->slots_);
-
-      self_type self (_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
-      return accumulator(slot_iterator_buf_type(slots.begin(), &self),
-                         slot_iterator_buf_type(slots.end(), &self));
-    }
-  
-  typename type_trait<T_arg1>::take _A_a1_;
-  typename type_trait<T_arg2>::take _A_a2_;
-  typename type_trait<T_arg3>::take _A_a3_;
-  typename type_trait<T_arg4>::take _A_a4_;
-  typename type_trait<T_arg5>::take _A_a5_;
-  typename type_trait<T_arg6>::take _A_a6_;
-  typename type_trait<T_arg7>::take _A_a7_;
-};
-
-/** Abstracts signal emission.
- * This template specialization implements an optimized emit()
- * function for the case that no accumulator is used.
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-struct signal_emit7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, nil>
-{
-  typedef signal_emit7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, nil > self_type;
-  typedef T_return result_type;
-  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> slot_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-  typedef typename slot_type::call_type call_type;
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are passed directly on to the slots.
-   * The return value of the last slot invoked is returned.
-   * @param first An iterator pointing to the first slot in the list.
-   * @param last An iterator pointing to the last slot in the list.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @param _A_a4 Argument to be passed on to the slots.
-   * @param _A_a5 Argument to be passed on to the slots.
-   * @param _A_a6 Argument to be passed on to the slots.
-   * @param _A_a7 Argument to be passed on to the slots.
-   * @return The return value of the last slot invoked.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7)
-    {
-      if (!impl || impl->slots_.empty())
-        return T_return();
-        
-      signal_exec exec(impl);
-      T_return r_ = T_return(); 
-      
-      //Use this scope to make sure that "slots" is destroyed before "exec" is destroyed.
-      //This avoids a leak on MSVC++ - see http://bugzilla.gnome.org/show_bug.cgi?id=306249
-      { 
-        temp_slot_list slots(impl->slots_);
-        iterator_type it = slots.begin();
-        for (; it != slots.end(); ++it)
-          if (!it->empty() && !it->blocked()) break;
-          
-        if (it == slots.end())
-          return T_return(); // note that 'T_return r_();' doesn't work => define 'r_' after this line and initialize as follows:
-  
-        r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
-        for (++it; it != slots.end(); ++it)
-          {
-            if (it->empty() || it->blocked())
-              continue;
-            r_ = (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
-          }
-      }
-      
-      return r_;
-    }
-};
-
-/** Abstracts signal emission.
- * This template specialization implements an optimized emit()
- * function for the case that no accumulator is used and the
- * return type is @p void.
- */
-template <class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-struct signal_emit7<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, nil>
-{
-  typedef signal_emit7<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, nil> self_type;
-  typedef void result_type;
-  typedef slot<void, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> slot_type;
-  typedef signal_impl::const_iterator_type iterator_type;
-  typedef typename slot_type::call_type call_type;
-
-  /** Executes a list of slots using an accumulator of type @e T_accumulator.
-   * The arguments are passed directly on to the slots.
-   * @param first An iterator pointing to the first slot in the list.
-   * @param last An iterator pointing to the last slot in the list.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @param _A_a4 Argument to be passed on to the slots.
-   * @param _A_a5 Argument to be passed on to the slots.
-   * @param _A_a6 Argument to be passed on to the slots.
-   * @param _A_a7 Argument to be passed on to the slots.
-   */
-  static result_type emit(signal_impl* impl, typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7)
-    {
-      if (!impl || impl->slots_.empty()) return;
-      signal_exec exec(impl);
-      temp_slot_list slots(impl->slots_);
-
-      for (iterator_type it = slots.begin(); it != slots.end(); ++it)
-        {
-          if (it->empty() || it->blocked())
-            continue;
-          (reinterpret_cast<call_type>(it->rep_->call_))(it->rep_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7);
-        }
-    }
-};
-
-
-} /* namespace internal */
-
-/** Signal declaration.
- * signal0 can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitely.
- *
- * If you want to connect one signal to another, use make_slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The following template arguments are used:
- * - @e T_return The desired return type for the emit() function (may be overridden by the accumulator).
- * - @e T_accumulator The accumulator type used for emission. The default @p nil means that no accumulator should be used, i.e. signal emission returns the return value of the last slot invoked.
- *
- * You should use the more convenient unnumbered sigc::signal template.
- *
- * @ingroup signal
- */
-template <class T_return, class T_accumulator=nil>
-class signal0
-  : public signal_base
-{
-public:
-  typedef internal::signal_emit0<T_return, T_accumulator> emitter_type;
-  typedef typename emitter_type::result_type         result_type;
-  typedef slot<T_return>    slot_type;
-  typedef slot_list<slot_type>                       slot_list_type;
-  typedef typename slot_list_type::iterator               iterator;
-  typedef typename slot_list_type::const_iterator         const_iterator;
-  typedef typename slot_list_type::reverse_iterator       reverse_iterator;
-  typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
-
-#ifdef SIGC_TYPEDEF_REDEFINE_ALLOWED
-  /** This typedef is only for backwards-compatibility.
-   * It is not available when using the SUN Forte compiler.
-   * @deprecated slot_list_type;
-   */
-  typedef slot_list_type slot_list;
-#endif
-
-  /** Add a slot to the list of slots.
-   * Any functor or slot may be passed into connect().
-   * It will be converted into a slot implicitely.
-   * The returned iterator may be stored for disconnection
-   * of the slot at some later point. It stays valid until
-   * the slot is removed from the list of slots. The iterator
-   * can also be implicitely converted into a sigc::connection object
-   * that may be used safely beyond the life time of the slot.
-   * @param slot_ The slot to add to the list of slots.
-   * @return An iterator pointing to the new slot in the list.
-   */
-  iterator connect(const slot_type& slot_)
-    { return iterator(signal_base::connect(static_cast<const slot_base&>(slot_))); }
-
-  /** Triggers the emission of the signal.
-   * During signal emission all slots that have been connected
-   * to the signal are invoked unless they are manually set into
-   * a blocking state. The parameters are passed on to the slots.
-   * If @e T_accumulated is not @p nil, an accumulator of this type
-   * is used to process the return values of the slot invocations.
-   * Otherwise, the return value of the last slot invoked is returned.
-   * @return The accumulated return values of the slot invocations.
-   */
-  result_type emit() const
-    { return emitter_type::emit(impl_); }
-
-  /** Triggers the emission of the signal (see emit()). */
-  result_type operator()() const
-    { return emit(); }
-
-  /** Creates a functor that calls emit() on this signal.
-   * @code
-   * sigc::mem_fun(mysignal, &sigc::signal0::emit)
-   * @endcode
-   * yields the same result.
-   * @return A functor that calls emit() on this signal.
-   */
-  bound_const_mem_functor0<result_type, signal0> make_slot() const
-    { return bound_const_mem_functor0<result_type, signal0>(this, &signal0::emit); }
-
-  /** Creates an STL-style interface for the signal's list of slots.
-   * This interface supports iteration, insertion and removal of slots.
-   * @return An STL-style interface for the signal's list of slots.
-   */
-  slot_list_type slots()
-    { return slot_list_type(impl()); }
-
-  /** Creates an STL-style interface for the signal's list of slots.
-   * This interface supports iteration, insertion and removal of slots.
-   * @return An STL-style interface for the signal's list of slots.
-   */
-  const slot_list_type slots() const
-    { return slot_list_type(const_cast<signal0*>(this)->impl()); }
-
-  signal0() {}
-
-  signal0(const signal0& src)
-    : signal_base(src) {}
-};
-
-/** Signal declaration.
- * signal1 can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitely.
- *
- * If you want to connect one signal to another, use make_slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The following template arguments are used:
- * - @e T_return The desired return type for the emit() function (may be overridden by the accumulator).
- * - @e T_arg1 Argument type used in the definition of emit().
- * - @e T_accumulator The accumulator type used for emission. The default @p nil means that no accumulator should be used, i.e. signal emission returns the return value of the last slot invoked.
- *
- * You should use the more convenient unnumbered sigc::signal template.
- *
- * @ingroup signal
- */
-template <class T_return, class T_arg1, class T_accumulator=nil>
-class signal1
-  : public signal_base
-{
-public:
-  typedef internal::signal_emit1<T_return, T_arg1, T_accumulator> emitter_type;
-  typedef typename emitter_type::result_type         result_type;
-  typedef slot<T_return, T_arg1>    slot_type;
-  typedef slot_list<slot_type>                       slot_list_type;
-  typedef typename slot_list_type::iterator               iterator;
-  typedef typename slot_list_type::const_iterator         const_iterator;
-  typedef typename slot_list_type::reverse_iterator       reverse_iterator;
-  typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
-
-#ifdef SIGC_TYPEDEF_REDEFINE_ALLOWED
-  /** This typedef is only for backwards-compatibility.
-   * It is not available when using the SUN Forte compiler.
-   * @deprecated slot_list_type;
-   */
-  typedef slot_list_type slot_list;
-#endif
-
-  /** Add a slot to the list of slots.
-   * Any functor or slot may be passed into connect().
-   * It will be converted into a slot implicitely.
-   * The returned iterator may be stored for disconnection
-   * of the slot at some later point. It stays valid until
-   * the slot is removed from the list of slots. The iterator
-   * can also be implicitely converted into a sigc::connection object
-   * that may be used safely beyond the life time of the slot.
-   * @param slot_ The slot to add to the list of slots.
-   * @return An iterator pointing to the new slot in the list.
-   */
-  iterator connect(const slot_type& slot_)
-    { return iterator(signal_base::connect(static_cast<const slot_base&>(slot_))); }
-
-  /** Triggers the emission of the signal.
-   * During signal emission all slots that have been connected
-   * to the signal are invoked unless they are manually set into
-   * a blocking state. The parameters are passed on to the slots.
-   * If @e T_accumulated is not @p nil, an accumulator of this type
-   * is used to process the return values of the slot invocations.
-   * Otherwise, the return value of the last slot invoked is returned.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @return The accumulated return values of the slot invocations.
-   */
-  result_type emit(typename type_trait<T_arg1>::take _A_a1) const
-    { return emitter_type::emit(impl_, _A_a1); }
-
-  /** Triggers the emission of the signal (see emit()). */
-  result_type operator()(typename type_trait<T_arg1>::take _A_a1) const
-    { return emit(_A_a1); }
-
-  /** Creates a functor that calls emit() on this signal.
-   * @code
-   * sigc::mem_fun(mysignal, &sigc::signal1::emit)
-   * @endcode
-   * yields the same result.
-   * @return A functor that calls emit() on this signal.
-   */
-  bound_const_mem_functor1<result_type, signal1, typename type_trait<T_arg1>::take> make_slot() const
-    { return bound_const_mem_functor1<result_type, signal1, typename type_trait<T_arg1>::take>(this, &signal1::emit); }
-
-  /** Creates an STL-style interface for the signal's list of slots.
-   * This interface supports iteration, insertion and removal of slots.
-   * @return An STL-style interface for the signal's list of slots.
-   */
-  slot_list_type slots()
-    { return slot_list_type(impl()); }
-
-  /** Creates an STL-style interface for the signal's list of slots.
-   * This interface supports iteration, insertion and removal of slots.
-   * @return An STL-style interface for the signal's list of slots.
-   */
-  const slot_list_type slots() const
-    { return slot_list_type(const_cast<signal1*>(this)->impl()); }
-
-  signal1() {}
-
-  signal1(const signal1& src)
-    : signal_base(src) {}
-};
-
-/** Signal declaration.
- * signal2 can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitely.
- *
- * If you want to connect one signal to another, use make_slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The following template arguments are used:
- * - @e T_return The desired return type for the emit() function (may be overridden by the accumulator).
- * - @e T_arg1 Argument type used in the definition of emit().
- * - @e T_arg2 Argument type used in the definition of emit().
- * - @e T_accumulator The accumulator type used for emission. The default @p nil means that no accumulator should be used, i.e. signal emission returns the return value of the last slot invoked.
- *
- * You should use the more convenient unnumbered sigc::signal template.
- *
- * @ingroup signal
- */
-template <class T_return, class T_arg1,class T_arg2, class T_accumulator=nil>
-class signal2
-  : public signal_base
-{
-public:
-  typedef internal::signal_emit2<T_return, T_arg1,T_arg2, T_accumulator> emitter_type;
-  typedef typename emitter_type::result_type         result_type;
-  typedef slot<T_return, T_arg1,T_arg2>    slot_type;
-  typedef slot_list<slot_type>                       slot_list_type;
-  typedef typename slot_list_type::iterator               iterator;
-  typedef typename slot_list_type::const_iterator         const_iterator;
-  typedef typename slot_list_type::reverse_iterator       reverse_iterator;
-  typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
-
-#ifdef SIGC_TYPEDEF_REDEFINE_ALLOWED
-  /** This typedef is only for backwards-compatibility.
-   * It is not available when using the SUN Forte compiler.
-   * @deprecated slot_list_type;
-   */
-  typedef slot_list_type slot_list;
-#endif
-
-  /** Add a slot to the list of slots.
-   * Any functor or slot may be passed into connect().
-   * It will be converted into a slot implicitely.
-   * The returned iterator may be stored for disconnection
-   * of the slot at some later point. It stays valid until
-   * the slot is removed from the list of slots. The iterator
-   * can also be implicitely converted into a sigc::connection object
-   * that may be used safely beyond the life time of the slot.
-   * @param slot_ The slot to add to the list of slots.
-   * @return An iterator pointing to the new slot in the list.
-   */
-  iterator connect(const slot_type& slot_)
-    { return iterator(signal_base::connect(static_cast<const slot_base&>(slot_))); }
-
-  /** Triggers the emission of the signal.
-   * During signal emission all slots that have been connected
-   * to the signal are invoked unless they are manually set into
-   * a blocking state. The parameters are passed on to the slots.
-   * If @e T_accumulated is not @p nil, an accumulator of this type
-   * is used to process the return values of the slot invocations.
-   * Otherwise, the return value of the last slot invoked is returned.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @return The accumulated return values of the slot invocations.
-   */
-  result_type emit(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
-    { return emitter_type::emit(impl_, _A_a1,_A_a2); }
-
-  /** Triggers the emission of the signal (see emit()). */
-  result_type operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2) const
-    { return emit(_A_a1,_A_a2); }
-
-  /** Creates a functor that calls emit() on this signal.
-   * @code
-   * sigc::mem_fun(mysignal, &sigc::signal2::emit)
-   * @endcode
-   * yields the same result.
-   * @return A functor that calls emit() on this signal.
-   */
-  bound_const_mem_functor2<result_type, signal2, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take> make_slot() const
-    { return bound_const_mem_functor2<result_type, signal2, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take>(this, &signal2::emit); }
-
-  /** Creates an STL-style interface for the signal's list of slots.
-   * This interface supports iteration, insertion and removal of slots.
-   * @return An STL-style interface for the signal's list of slots.
-   */
-  slot_list_type slots()
-    { return slot_list_type(impl()); }
-
-  /** Creates an STL-style interface for the signal's list of slots.
-   * This interface supports iteration, insertion and removal of slots.
-   * @return An STL-style interface for the signal's list of slots.
-   */
-  const slot_list_type slots() const
-    { return slot_list_type(const_cast<signal2*>(this)->impl()); }
-
-  signal2() {}
-
-  signal2(const signal2& src)
-    : signal_base(src) {}
-};
-
-/** Signal declaration.
- * signal3 can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitely.
- *
- * If you want to connect one signal to another, use make_slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The following template arguments are used:
- * - @e T_return The desired return type for the emit() function (may be overridden by the accumulator).
- * - @e T_arg1 Argument type used in the definition of emit().
- * - @e T_arg2 Argument type used in the definition of emit().
- * - @e T_arg3 Argument type used in the definition of emit().
- * - @e T_accumulator The accumulator type used for emission. The default @p nil means that no accumulator should be used, i.e. signal emission returns the return value of the last slot invoked.
- *
- * You should use the more convenient unnumbered sigc::signal template.
- *
- * @ingroup signal
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_accumulator=nil>
-class signal3
-  : public signal_base
-{
-public:
-  typedef internal::signal_emit3<T_return, T_arg1,T_arg2,T_arg3, T_accumulator> emitter_type;
-  typedef typename emitter_type::result_type         result_type;
-  typedef slot<T_return, T_arg1,T_arg2,T_arg3>    slot_type;
-  typedef slot_list<slot_type>                       slot_list_type;
-  typedef typename slot_list_type::iterator               iterator;
-  typedef typename slot_list_type::const_iterator         const_iterator;
-  typedef typename slot_list_type::reverse_iterator       reverse_iterator;
-  typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
-
-#ifdef SIGC_TYPEDEF_REDEFINE_ALLOWED
-  /** This typedef is only for backwards-compatibility.
-   * It is not available when using the SUN Forte compiler.
-   * @deprecated slot_list_type;
-   */
-  typedef slot_list_type slot_list;
-#endif
-
-  /** Add a slot to the list of slots.
-   * Any functor or slot may be passed into connect().
-   * It will be converted into a slot implicitely.
-   * The returned iterator may be stored for disconnection
-   * of the slot at some later point. It stays valid until
-   * the slot is removed from the list of slots. The iterator
-   * can also be implicitely converted into a sigc::connection object
-   * that may be used safely beyond the life time of the slot.
-   * @param slot_ The slot to add to the list of slots.
-   * @return An iterator pointing to the new slot in the list.
-   */
-  iterator connect(const slot_type& slot_)
-    { return iterator(signal_base::connect(static_cast<const slot_base&>(slot_))); }
-
-  /** Triggers the emission of the signal.
-   * During signal emission all slots that have been connected
-   * to the signal are invoked unless they are manually set into
-   * a blocking state. The parameters are passed on to the slots.
-   * If @e T_accumulated is not @p nil, an accumulator of this type
-   * is used to process the return values of the slot invocations.
-   * Otherwise, the return value of the last slot invoked is returned.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @return The accumulated return values of the slot invocations.
-   */
-  result_type emit(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
-    { return emitter_type::emit(impl_, _A_a1,_A_a2,_A_a3); }
-
-  /** Triggers the emission of the signal (see emit()). */
-  result_type operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3) const
-    { return emit(_A_a1,_A_a2,_A_a3); }
-
-  /** Creates a functor that calls emit() on this signal.
-   * @code
-   * sigc::mem_fun(mysignal, &sigc::signal3::emit)
-   * @endcode
-   * yields the same result.
-   * @return A functor that calls emit() on this signal.
-   */
-  bound_const_mem_functor3<result_type, signal3, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take> make_slot() const
-    { return bound_const_mem_functor3<result_type, signal3, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take>(this, &signal3::emit); }
-
-  /** Creates an STL-style interface for the signal's list of slots.
-   * This interface supports iteration, insertion and removal of slots.
-   * @return An STL-style interface for the signal's list of slots.
-   */
-  slot_list_type slots()
-    { return slot_list_type(impl()); }
-
-  /** Creates an STL-style interface for the signal's list of slots.
-   * This interface supports iteration, insertion and removal of slots.
-   * @return An STL-style interface for the signal's list of slots.
-   */
-  const slot_list_type slots() const
-    { return slot_list_type(const_cast<signal3*>(this)->impl()); }
-
-  signal3() {}
-
-  signal3(const signal3& src)
-    : signal_base(src) {}
-};
-
-/** Signal declaration.
- * signal4 can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitely.
- *
- * If you want to connect one signal to another, use make_slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The following template arguments are used:
- * - @e T_return The desired return type for the emit() function (may be overridden by the accumulator).
- * - @e T_arg1 Argument type used in the definition of emit().
- * - @e T_arg2 Argument type used in the definition of emit().
- * - @e T_arg3 Argument type used in the definition of emit().
- * - @e T_arg4 Argument type used in the definition of emit().
- * - @e T_accumulator The accumulator type used for emission. The default @p nil means that no accumulator should be used, i.e. signal emission returns the return value of the last slot invoked.
- *
- * You should use the more convenient unnumbered sigc::signal template.
- *
- * @ingroup signal
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_accumulator=nil>
-class signal4
-  : public signal_base
-{
-public:
-  typedef internal::signal_emit4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, T_accumulator> emitter_type;
-  typedef typename emitter_type::result_type         result_type;
-  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4>    slot_type;
-  typedef slot_list<slot_type>                       slot_list_type;
-  typedef typename slot_list_type::iterator               iterator;
-  typedef typename slot_list_type::const_iterator         const_iterator;
-  typedef typename slot_list_type::reverse_iterator       reverse_iterator;
-  typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
-
-#ifdef SIGC_TYPEDEF_REDEFINE_ALLOWED
-  /** This typedef is only for backwards-compatibility.
-   * It is not available when using the SUN Forte compiler.
-   * @deprecated slot_list_type;
-   */
-  typedef slot_list_type slot_list;
-#endif
-
-  /** Add a slot to the list of slots.
-   * Any functor or slot may be passed into connect().
-   * It will be converted into a slot implicitely.
-   * The returned iterator may be stored for disconnection
-   * of the slot at some later point. It stays valid until
-   * the slot is removed from the list of slots. The iterator
-   * can also be implicitely converted into a sigc::connection object
-   * that may be used safely beyond the life time of the slot.
-   * @param slot_ The slot to add to the list of slots.
-   * @return An iterator pointing to the new slot in the list.
-   */
-  iterator connect(const slot_type& slot_)
-    { return iterator(signal_base::connect(static_cast<const slot_base&>(slot_))); }
-
-  /** Triggers the emission of the signal.
-   * During signal emission all slots that have been connected
-   * to the signal are invoked unless they are manually set into
-   * a blocking state. The parameters are passed on to the slots.
-   * If @e T_accumulated is not @p nil, an accumulator of this type
-   * is used to process the return values of the slot invocations.
-   * Otherwise, the return value of the last slot invoked is returned.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @param _A_a4 Argument to be passed on to the slots.
-   * @return The accumulated return values of the slot invocations.
-   */
-  result_type emit(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
-    { return emitter_type::emit(impl_, _A_a1,_A_a2,_A_a3,_A_a4); }
-
-  /** Triggers the emission of the signal (see emit()). */
-  result_type operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4) const
-    { return emit(_A_a1,_A_a2,_A_a3,_A_a4); }
-
-  /** Creates a functor that calls emit() on this signal.
-   * @code
-   * sigc::mem_fun(mysignal, &sigc::signal4::emit)
-   * @endcode
-   * yields the same result.
-   * @return A functor that calls emit() on this signal.
-   */
-  bound_const_mem_functor4<result_type, signal4, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take> make_slot() const
-    { return bound_const_mem_functor4<result_type, signal4, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take>(this, &signal4::emit); }
-
-  /** Creates an STL-style interface for the signal's list of slots.
-   * This interface supports iteration, insertion and removal of slots.
-   * @return An STL-style interface for the signal's list of slots.
-   */
-  slot_list_type slots()
-    { return slot_list_type(impl()); }
-
-  /** Creates an STL-style interface for the signal's list of slots.
-   * This interface supports iteration, insertion and removal of slots.
-   * @return An STL-style interface for the signal's list of slots.
-   */
-  const slot_list_type slots() const
-    { return slot_list_type(const_cast<signal4*>(this)->impl()); }
-
-  signal4() {}
-
-  signal4(const signal4& src)
-    : signal_base(src) {}
-};
-
-/** Signal declaration.
- * signal5 can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitely.
- *
- * If you want to connect one signal to another, use make_slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The following template arguments are used:
- * - @e T_return The desired return type for the emit() function (may be overridden by the accumulator).
- * - @e T_arg1 Argument type used in the definition of emit().
- * - @e T_arg2 Argument type used in the definition of emit().
- * - @e T_arg3 Argument type used in the definition of emit().
- * - @e T_arg4 Argument type used in the definition of emit().
- * - @e T_arg5 Argument type used in the definition of emit().
- * - @e T_accumulator The accumulator type used for emission. The default @p nil means that no accumulator should be used, i.e. signal emission returns the return value of the last slot invoked.
- *
- * You should use the more convenient unnumbered sigc::signal template.
- *
- * @ingroup signal
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_accumulator=nil>
-class signal5
-  : public signal_base
-{
-public:
-  typedef internal::signal_emit5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_accumulator> emitter_type;
-  typedef typename emitter_type::result_type         result_type;
-  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>    slot_type;
-  typedef slot_list<slot_type>                       slot_list_type;
-  typedef typename slot_list_type::iterator               iterator;
-  typedef typename slot_list_type::const_iterator         const_iterator;
-  typedef typename slot_list_type::reverse_iterator       reverse_iterator;
-  typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
-
-#ifdef SIGC_TYPEDEF_REDEFINE_ALLOWED
-  /** This typedef is only for backwards-compatibility.
-   * It is not available when using the SUN Forte compiler.
-   * @deprecated slot_list_type;
-   */
-  typedef slot_list_type slot_list;
-#endif
-
-  /** Add a slot to the list of slots.
-   * Any functor or slot may be passed into connect().
-   * It will be converted into a slot implicitely.
-   * The returned iterator may be stored for disconnection
-   * of the slot at some later point. It stays valid until
-   * the slot is removed from the list of slots. The iterator
-   * can also be implicitely converted into a sigc::connection object
-   * that may be used safely beyond the life time of the slot.
-   * @param slot_ The slot to add to the list of slots.
-   * @return An iterator pointing to the new slot in the list.
-   */
-  iterator connect(const slot_type& slot_)
-    { return iterator(signal_base::connect(static_cast<const slot_base&>(slot_))); }
-
-  /** Triggers the emission of the signal.
-   * During signal emission all slots that have been connected
-   * to the signal are invoked unless they are manually set into
-   * a blocking state. The parameters are passed on to the slots.
-   * If @e T_accumulated is not @p nil, an accumulator of this type
-   * is used to process the return values of the slot invocations.
-   * Otherwise, the return value of the last slot invoked is returned.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @param _A_a4 Argument to be passed on to the slots.
-   * @param _A_a5 Argument to be passed on to the slots.
-   * @return The accumulated return values of the slot invocations.
-   */
-  result_type emit(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
-    { return emitter_type::emit(impl_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
-
-  /** Triggers the emission of the signal (see emit()). */
-  result_type operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5) const
-    { return emit(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5); }
-
-  /** Creates a functor that calls emit() on this signal.
-   * @code
-   * sigc::mem_fun(mysignal, &sigc::signal5::emit)
-   * @endcode
-   * yields the same result.
-   * @return A functor that calls emit() on this signal.
-   */
-  bound_const_mem_functor5<result_type, signal5, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take> make_slot() const
-    { return bound_const_mem_functor5<result_type, signal5, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take>(this, &signal5::emit); }
-
-  /** Creates an STL-style interface for the signal's list of slots.
-   * This interface supports iteration, insertion and removal of slots.
-   * @return An STL-style interface for the signal's list of slots.
-   */
-  slot_list_type slots()
-    { return slot_list_type(impl()); }
-
-  /** Creates an STL-style interface for the signal's list of slots.
-   * This interface supports iteration, insertion and removal of slots.
-   * @return An STL-style interface for the signal's list of slots.
-   */
-  const slot_list_type slots() const
-    { return slot_list_type(const_cast<signal5*>(this)->impl()); }
-
-  signal5() {}
-
-  signal5(const signal5& src)
-    : signal_base(src) {}
-};
-
-/** Signal declaration.
- * signal6 can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitely.
- *
- * If you want to connect one signal to another, use make_slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The following template arguments are used:
- * - @e T_return The desired return type for the emit() function (may be overridden by the accumulator).
- * - @e T_arg1 Argument type used in the definition of emit().
- * - @e T_arg2 Argument type used in the definition of emit().
- * - @e T_arg3 Argument type used in the definition of emit().
- * - @e T_arg4 Argument type used in the definition of emit().
- * - @e T_arg5 Argument type used in the definition of emit().
- * - @e T_arg6 Argument type used in the definition of emit().
- * - @e T_accumulator The accumulator type used for emission. The default @p nil means that no accumulator should be used, i.e. signal emission returns the return value of the last slot invoked.
- *
- * You should use the more convenient unnumbered sigc::signal template.
- *
- * @ingroup signal
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_accumulator=nil>
-class signal6
-  : public signal_base
-{
-public:
-  typedef internal::signal_emit6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_accumulator> emitter_type;
-  typedef typename emitter_type::result_type         result_type;
-  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>    slot_type;
-  typedef slot_list<slot_type>                       slot_list_type;
-  typedef typename slot_list_type::iterator               iterator;
-  typedef typename slot_list_type::const_iterator         const_iterator;
-  typedef typename slot_list_type::reverse_iterator       reverse_iterator;
-  typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
-
-#ifdef SIGC_TYPEDEF_REDEFINE_ALLOWED
-  /** This typedef is only for backwards-compatibility.
-   * It is not available when using the SUN Forte compiler.
-   * @deprecated slot_list_type;
-   */
-  typedef slot_list_type slot_list;
-#endif
-
-  /** Add a slot to the list of slots.
-   * Any functor or slot may be passed into connect().
-   * It will be converted into a slot implicitely.
-   * The returned iterator may be stored for disconnection
-   * of the slot at some later point. It stays valid until
-   * the slot is removed from the list of slots. The iterator
-   * can also be implicitely converted into a sigc::connection object
-   * that may be used safely beyond the life time of the slot.
-   * @param slot_ The slot to add to the list of slots.
-   * @return An iterator pointing to the new slot in the list.
-   */
-  iterator connect(const slot_type& slot_)
-    { return iterator(signal_base::connect(static_cast<const slot_base&>(slot_))); }
-
-  /** Triggers the emission of the signal.
-   * During signal emission all slots that have been connected
-   * to the signal are invoked unless they are manually set into
-   * a blocking state. The parameters are passed on to the slots.
-   * If @e T_accumulated is not @p nil, an accumulator of this type
-   * is used to process the return values of the slot invocations.
-   * Otherwise, the return value of the last slot invoked is returned.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @param _A_a4 Argument to be passed on to the slots.
-   * @param _A_a5 Argument to be passed on to the slots.
-   * @param _A_a6 Argument to be passed on to the slots.
-   * @return The accumulated return values of the slot invocations.
-   */
-  result_type emit(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
-    { return emitter_type::emit(impl_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
-
-  /** Triggers the emission of the signal (see emit()). */
-  result_type operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6) const
-    { return emit(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6); }
-
-  /** Creates a functor that calls emit() on this signal.
-   * @code
-   * sigc::mem_fun(mysignal, &sigc::signal6::emit)
-   * @endcode
-   * yields the same result.
-   * @return A functor that calls emit() on this signal.
-   */
-  bound_const_mem_functor6<result_type, signal6, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take,typename type_trait<T_arg6>::take> make_slot() const
-    { return bound_const_mem_functor6<result_type, signal6, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take,typename type_trait<T_arg6>::take>(this, &signal6::emit); }
-
-  /** Creates an STL-style interface for the signal's list of slots.
-   * This interface supports iteration, insertion and removal of slots.
-   * @return An STL-style interface for the signal's list of slots.
-   */
-  slot_list_type slots()
-    { return slot_list_type(impl()); }
-
-  /** Creates an STL-style interface for the signal's list of slots.
-   * This interface supports iteration, insertion and removal of slots.
-   * @return An STL-style interface for the signal's list of slots.
-   */
-  const slot_list_type slots() const
-    { return slot_list_type(const_cast<signal6*>(this)->impl()); }
-
-  signal6() {}
-
-  signal6(const signal6& src)
-    : signal_base(src) {}
-};
-
-/** Signal declaration.
- * signal7 can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitely.
- *
- * If you want to connect one signal to another, use make_slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The following template arguments are used:
- * - @e T_return The desired return type for the emit() function (may be overridden by the accumulator).
- * - @e T_arg1 Argument type used in the definition of emit().
- * - @e T_arg2 Argument type used in the definition of emit().
- * - @e T_arg3 Argument type used in the definition of emit().
- * - @e T_arg4 Argument type used in the definition of emit().
- * - @e T_arg5 Argument type used in the definition of emit().
- * - @e T_arg6 Argument type used in the definition of emit().
- * - @e T_arg7 Argument type used in the definition of emit().
- * - @e T_accumulator The accumulator type used for emission. The default @p nil means that no accumulator should be used, i.e. signal emission returns the return value of the last slot invoked.
- *
- * You should use the more convenient unnumbered sigc::signal template.
- *
- * @ingroup signal
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_accumulator=nil>
-class signal7
-  : public signal_base
-{
-public:
-  typedef internal::signal_emit7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_accumulator> emitter_type;
-  typedef typename emitter_type::result_type         result_type;
-  typedef slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>    slot_type;
-  typedef slot_list<slot_type>                       slot_list_type;
-  typedef typename slot_list_type::iterator               iterator;
-  typedef typename slot_list_type::const_iterator         const_iterator;
-  typedef typename slot_list_type::reverse_iterator       reverse_iterator;
-  typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
-
-#ifdef SIGC_TYPEDEF_REDEFINE_ALLOWED
-  /** This typedef is only for backwards-compatibility.
-   * It is not available when using the SUN Forte compiler.
-   * @deprecated slot_list_type;
-   */
-  typedef slot_list_type slot_list;
-#endif
-
-  /** Add a slot to the list of slots.
-   * Any functor or slot may be passed into connect().
-   * It will be converted into a slot implicitely.
-   * The returned iterator may be stored for disconnection
-   * of the slot at some later point. It stays valid until
-   * the slot is removed from the list of slots. The iterator
-   * can also be implicitely converted into a sigc::connection object
-   * that may be used safely beyond the life time of the slot.
-   * @param slot_ The slot to add to the list of slots.
-   * @return An iterator pointing to the new slot in the list.
-   */
-  iterator connect(const slot_type& slot_)
-    { return iterator(signal_base::connect(static_cast<const slot_base&>(slot_))); }
-
-  /** Triggers the emission of the signal.
-   * During signal emission all slots that have been connected
-   * to the signal are invoked unless they are manually set into
-   * a blocking state. The parameters are passed on to the slots.
-   * If @e T_accumulated is not @p nil, an accumulator of this type
-   * is used to process the return values of the slot invocations.
-   * Otherwise, the return value of the last slot invoked is returned.
-   * @param _A_a1 Argument to be passed on to the slots.
-   * @param _A_a2 Argument to be passed on to the slots.
-   * @param _A_a3 Argument to be passed on to the slots.
-   * @param _A_a4 Argument to be passed on to the slots.
-   * @param _A_a5 Argument to be passed on to the slots.
-   * @param _A_a6 Argument to be passed on to the slots.
-   * @param _A_a7 Argument to be passed on to the slots.
-   * @return The accumulated return values of the slot invocations.
-   */
-  result_type emit(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
-    { return emitter_type::emit(impl_, _A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
-
-  /** Triggers the emission of the signal (see emit()). */
-  result_type operator()(typename type_trait<T_arg1>::take _A_a1,typename type_trait<T_arg2>::take _A_a2,typename type_trait<T_arg3>::take _A_a3,typename type_trait<T_arg4>::take _A_a4,typename type_trait<T_arg5>::take _A_a5,typename type_trait<T_arg6>::take _A_a6,typename type_trait<T_arg7>::take _A_a7) const
-    { return emit(_A_a1,_A_a2,_A_a3,_A_a4,_A_a5,_A_a6,_A_a7); }
-
-  /** Creates a functor that calls emit() on this signal.
-   * @code
-   * sigc::mem_fun(mysignal, &sigc::signal7::emit)
-   * @endcode
-   * yields the same result.
-   * @return A functor that calls emit() on this signal.
-   */
-  bound_const_mem_functor7<result_type, signal7, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take,typename type_trait<T_arg6>::take,typename type_trait<T_arg7>::take> make_slot() const
-    { return bound_const_mem_functor7<result_type, signal7, typename type_trait<T_arg1>::take,typename type_trait<T_arg2>::take,typename type_trait<T_arg3>::take,typename type_trait<T_arg4>::take,typename type_trait<T_arg5>::take,typename type_trait<T_arg6>::take,typename type_trait<T_arg7>::take>(this, &signal7::emit); }
-
-  /** Creates an STL-style interface for the signal's list of slots.
-   * This interface supports iteration, insertion and removal of slots.
-   * @return An STL-style interface for the signal's list of slots.
-   */
-  slot_list_type slots()
-    { return slot_list_type(impl()); }
-
-  /** Creates an STL-style interface for the signal's list of slots.
-   * This interface supports iteration, insertion and removal of slots.
-   * @return An STL-style interface for the signal's list of slots.
-   */
-  const slot_list_type slots() const
-    { return slot_list_type(const_cast<signal7*>(this)->impl()); }
-
-  signal7() {}
-
-  signal7(const signal7& src)
-    : signal_base(src) {}
-};
-
-
-
-/** Convenience wrapper for the numbered sigc::signal# templates.
- * signal can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitly.
- *
- * If you want to connect one signal to another, use make_slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The template arguments determine the function signature of
- * the emit() function:
- * - @e T_return The desired return type of the emit() function.
- * - @e T_arg1 Argument type used in the definition of emit(). The default @p nil means no argument.
- * - @e T_arg2 Argument type used in the definition of emit(). The default @p nil means no argument.
- * - @e T_arg3 Argument type used in the definition of emit(). The default @p nil means no argument.
- * - @e T_arg4 Argument type used in the definition of emit(). The default @p nil means no argument.
- * - @e T_arg5 Argument type used in the definition of emit(). The default @p nil means no argument.
- * - @e T_arg6 Argument type used in the definition of emit(). The default @p nil means no argument.
- * - @e T_arg7 Argument type used in the definition of emit(). The default @p nil means no argument.
- *
- * To specify an accumulator type the nested class signal::accumulated can be used.
- *
- * @par Example:
- *   @code
- *   void foo(int) {}
- *   sigc::signal<void, long> sig;
- *   sig.connect(sigc::ptr_fun(&foo));
- *   sig.emit(19);
- *   @endcode
- *
- * @ingroup signal
- */
-template <class T_return, class T_arg1 = nil,class T_arg2 = nil,class T_arg3 = nil,class T_arg4 = nil,class T_arg5 = nil,class T_arg6 = nil,class T_arg7 = nil>
-class signal 
-  : public signal7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, nil>
-{
-public:
-  /** Convenience wrapper for the numbered sigc::signal# templates.
-   * Like sigc::signal but the additional template parameter @e T_accumulator
-   * defines the accumulator type that should be used.
-   *
-   * An accumulator is a functor that uses a pair of special iterators
-   * to step through a list of slots and calculate a return value
-   * from the results of the slot invokations. The iterators' operator*()
-   * executes the slot. The return value is buffered, so that in an expression
-   * like @code a = (*i) * (*i); @endcode the slot is executed only once.
-   * The accumulator must define its return value as @p result_type.
-   * 
-   * @par Example 1:
-   *   This accumulator calculates the arithmetic mean value:
-   *   @code
-   *   struct arithmetic_mean_accumulator
-   *   {
-   *     typedef double result_type;
-   *     template<typename T_iterator>
-   *     result_type operator()(T_iterator first, T_iterator last) const
-   *     {
-   *       result_type value_ = 0;
-   *       int n_ = 0;
-   *       for (; first != last; ++first, ++n_)
-   *         value_ += *first;
-   *       return value_ / n_;
-   *     }
-   *   };
-   *   @endcode
-   *
-   * @par Example 2:
-   *   This accumulator stops signal emission when a slot returns zero:
-   *   @code
-   *   struct interruptable_accumulator
-   *   {
-   *     typedef bool result_type;
-   *     template<typename T_iterator>
-   *     result_type operator()(T_iterator first, T_iterator last) const
-   *     {
-   *       for (; first != last; ++first, ++n_)
-   *         if (!*first) return false;
-   *       return true;
-   *     }
-   *   };
-   *   @endcode
-   *
-   * @ingroup signal
-   */
-  template <class T_accumulator>
-  class accumulated
-    : public signal7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_accumulator>
-  {
-  public:
-    accumulated() {}
-    accumulated(const accumulated& src)
-      : signal7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_accumulator>(src) {}
-  };
-
-  signal() {}
-  signal(const signal& src)
-    : signal7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, nil>(src) {}
-};
-
-
-
-/** Convenience wrapper for the numbered sigc::signal0 template.
- * See the base class for useful methods.
- * This is the template specialization of the unnumbered sigc::signal
- * template for 0 argument(s).
- */
-template <class T_return>
-class signal <T_return, nil,nil,nil,nil,nil,nil,nil>
-  : public signal0<T_return, nil>
-{
-public:
-
-  /** Convenience wrapper for the numbered sigc::signal0 template.
-   * Like sigc::signal but the additional template parameter @e T_accumulator
-   * defines the accumulator type that should be used.
-   */
-  template <class T_accumulator>
-  class accumulated
-    : public signal0<T_return, T_accumulator>
-  {
-  public:
-    accumulated() {}
-    accumulated(const accumulated& src)
-      : signal0<T_return, T_accumulator>(src) {}
-  };
-
-  signal() {}
-  signal(const signal& src)
-    : signal0<T_return, nil>(src) {}
-};
-
-
-/** Convenience wrapper for the numbered sigc::signal1 template.
- * See the base class for useful methods.
- * This is the template specialization of the unnumbered sigc::signal
- * template for 1 argument(s).
- */
-template <class T_return, class T_arg1>
-class signal <T_return, T_arg1, nil,nil,nil,nil,nil,nil>
-  : public signal1<T_return, T_arg1, nil>
-{
-public:
-
-  /** Convenience wrapper for the numbered sigc::signal1 template.
-   * Like sigc::signal but the additional template parameter @e T_accumulator
-   * defines the accumulator type that should be used.
-   */
-  template <class T_accumulator>
-  class accumulated
-    : public signal1<T_return, T_arg1, T_accumulator>
-  {
-  public:
-    accumulated() {}
-    accumulated(const accumulated& src)
-      : signal1<T_return, T_arg1, T_accumulator>(src) {}
-  };
-
-  signal() {}
-  signal(const signal& src)
-    : signal1<T_return, T_arg1, nil>(src) {}
-};
-
-
-/** Convenience wrapper for the numbered sigc::signal2 template.
- * See the base class for useful methods.
- * This is the template specialization of the unnumbered sigc::signal
- * template for 2 argument(s).
- */
-template <class T_return, class T_arg1,class T_arg2>
-class signal <T_return, T_arg1,T_arg2, nil,nil,nil,nil,nil>
-  : public signal2<T_return, T_arg1,T_arg2, nil>
-{
-public:
-
-  /** Convenience wrapper for the numbered sigc::signal2 template.
-   * Like sigc::signal but the additional template parameter @e T_accumulator
-   * defines the accumulator type that should be used.
-   */
-  template <class T_accumulator>
-  class accumulated
-    : public signal2<T_return, T_arg1,T_arg2, T_accumulator>
-  {
-  public:
-    accumulated() {}
-    accumulated(const accumulated& src)
-      : signal2<T_return, T_arg1,T_arg2, T_accumulator>(src) {}
-  };
-
-  signal() {}
-  signal(const signal& src)
-    : signal2<T_return, T_arg1,T_arg2, nil>(src) {}
-};
-
-
-/** Convenience wrapper for the numbered sigc::signal3 template.
- * See the base class for useful methods.
- * This is the template specialization of the unnumbered sigc::signal
- * template for 3 argument(s).
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3>
-class signal <T_return, T_arg1,T_arg2,T_arg3, nil,nil,nil,nil>
-  : public signal3<T_return, T_arg1,T_arg2,T_arg3, nil>
-{
-public:
-
-  /** Convenience wrapper for the numbered sigc::signal3 template.
-   * Like sigc::signal but the additional template parameter @e T_accumulator
-   * defines the accumulator type that should be used.
-   */
-  template <class T_accumulator>
-  class accumulated
-    : public signal3<T_return, T_arg1,T_arg2,T_arg3, T_accumulator>
-  {
-  public:
-    accumulated() {}
-    accumulated(const accumulated& src)
-      : signal3<T_return, T_arg1,T_arg2,T_arg3, T_accumulator>(src) {}
-  };
-
-  signal() {}
-  signal(const signal& src)
-    : signal3<T_return, T_arg1,T_arg2,T_arg3, nil>(src) {}
-};
-
-
-/** Convenience wrapper for the numbered sigc::signal4 template.
- * See the base class for useful methods.
- * This is the template specialization of the unnumbered sigc::signal
- * template for 4 argument(s).
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-class signal <T_return, T_arg1,T_arg2,T_arg3,T_arg4, nil,nil,nil>
-  : public signal4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, nil>
-{
-public:
-
-  /** Convenience wrapper for the numbered sigc::signal4 template.
-   * Like sigc::signal but the additional template parameter @e T_accumulator
-   * defines the accumulator type that should be used.
-   */
-  template <class T_accumulator>
-  class accumulated
-    : public signal4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, T_accumulator>
-  {
-  public:
-    accumulated() {}
-    accumulated(const accumulated& src)
-      : signal4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, T_accumulator>(src) {}
-  };
-
-  signal() {}
-  signal(const signal& src)
-    : signal4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, nil>(src) {}
-};
-
-
-/** Convenience wrapper for the numbered sigc::signal5 template.
- * See the base class for useful methods.
- * This is the template specialization of the unnumbered sigc::signal
- * template for 5 argument(s).
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-class signal <T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, nil,nil>
-  : public signal5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, nil>
-{
-public:
-
-  /** Convenience wrapper for the numbered sigc::signal5 template.
-   * Like sigc::signal but the additional template parameter @e T_accumulator
-   * defines the accumulator type that should be used.
-   */
-  template <class T_accumulator>
-  class accumulated
-    : public signal5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_accumulator>
-  {
-  public:
-    accumulated() {}
-    accumulated(const accumulated& src)
-      : signal5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_accumulator>(src) {}
-  };
-
-  signal() {}
-  signal(const signal& src)
-    : signal5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, nil>(src) {}
-};
-
-
-/** Convenience wrapper for the numbered sigc::signal6 template.
- * See the base class for useful methods.
- * This is the template specialization of the unnumbered sigc::signal
- * template for 6 argument(s).
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-class signal <T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, nil>
-  : public signal6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, nil>
-{
-public:
-
-  /** Convenience wrapper for the numbered sigc::signal6 template.
-   * Like sigc::signal but the additional template parameter @e T_accumulator
-   * defines the accumulator type that should be used.
-   */
-  template <class T_accumulator>
-  class accumulated
-    : public signal6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_accumulator>
-  {
-  public:
-    accumulated() {}
-    accumulated(const accumulated& src)
-      : signal6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_accumulator>(src) {}
-  };
-
-  signal() {}
-  signal(const signal& src)
-    : signal6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, nil>(src) {}
-};
-
-
-
-} /* namespace sigc */
-
-
-#ifndef LIBSIGC_DISABLE_DEPRECATED
-
-namespace SigC {
-
-// SignalN
-/** Signal declaration.
- * Signal0 can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitely.
- *
- * If you want to connect one signal to another, use slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The following template arguments are used:
- * - @e T_return The desired return type for the emit() function (may be overridden by the accumulator).
- * - @e T_accumulator The accumulator type used for emission. The default @p nil means that no accumulator should be used. Signal emission returns the return value of the last slot invoked.
- *
- * @deprecated Use the unnumbered template sigc::signal instead.
- * @ingroup compat
- */
-template <class T_return, class T_accumulator=::sigc::nil>
-class Signal0
-  : public ::sigc::signal0<T_return, T_accumulator>
-{
-public:
-  typedef ::sigc::signal0<T_return, T_accumulator> parent_type;
-  typedef typename parent_type::result_type result_type;
-  typedef typename parent_type::slot_type slot_type;
-
-  Signal0() {}
-  Signal0(const Signal0& src)
-    : ::sigc::signal0<T_return, T_accumulator>(src) {}
-
-  /** Creates a functor that calls emit() on this signal.
-   * @code
-   * sigc::mem_fun(mysignal, &sigc::signal0::emit)
-   * @endcode
-   * yields the same result.
-   * @return A functor that calls emit() on this signal.
-   */
-  slot_type slot() const
-    { return ::sigc::bound_const_mem_functor0<result_type, parent_type>(this, &parent_type::emit); }
-};
-
-/** Signal declaration.
- * Signal1 can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitely.
- *
- * If you want to connect one signal to another, use slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The following template arguments are used:
- * - @e T_return The desired return type for the emit() function (may be overridden by the accumulator).
- * - @e T_arg1 Argument type used in the definition of emit().
- * - @e T_accumulator The accumulator type used for emission. The default @p nil means that no accumulator should be used. Signal emission returns the return value of the last slot invoked.
- *
- * @deprecated Use the unnumbered template sigc::signal instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1, class T_accumulator=::sigc::nil>
-class Signal1
-  : public ::sigc::signal1<T_return, T_arg1, T_accumulator>
-{
-public:
-  typedef ::sigc::signal1<T_return, T_arg1, T_accumulator> parent_type;
-  typedef typename parent_type::result_type result_type;
-  typedef typename parent_type::slot_type slot_type;
-
-  Signal1() {}
-  Signal1(const Signal1& src)
-    : ::sigc::signal1<T_return, T_arg1, T_accumulator>(src) {}
-
-  /** Creates a functor that calls emit() on this signal.
-   * @code
-   * sigc::mem_fun(mysignal, &sigc::signal1::emit)
-   * @endcode
-   * yields the same result.
-   * @return A functor that calls emit() on this signal.
-   */
-  slot_type slot() const
-    { return ::sigc::bound_const_mem_functor1<result_type, parent_type, typename ::sigc::type_trait<T_arg1>::take>(this, &parent_type::emit); }
-};
-
-/** Signal declaration.
- * Signal2 can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitely.
- *
- * If you want to connect one signal to another, use slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The following template arguments are used:
- * - @e T_return The desired return type for the emit() function (may be overridden by the accumulator).
- * - @e T_arg1 Argument type used in the definition of emit().
- * - @e T_arg2 Argument type used in the definition of emit().
- * - @e T_accumulator The accumulator type used for emission. The default @p nil means that no accumulator should be used. Signal emission returns the return value of the last slot invoked.
- *
- * @deprecated Use the unnumbered template sigc::signal instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2, class T_accumulator=::sigc::nil>
-class Signal2
-  : public ::sigc::signal2<T_return, T_arg1,T_arg2, T_accumulator>
-{
-public:
-  typedef ::sigc::signal2<T_return, T_arg1,T_arg2, T_accumulator> parent_type;
-  typedef typename parent_type::result_type result_type;
-  typedef typename parent_type::slot_type slot_type;
-
-  Signal2() {}
-  Signal2(const Signal2& src)
-    : ::sigc::signal2<T_return, T_arg1,T_arg2, T_accumulator>(src) {}
-
-  /** Creates a functor that calls emit() on this signal.
-   * @code
-   * sigc::mem_fun(mysignal, &sigc::signal2::emit)
-   * @endcode
-   * yields the same result.
-   * @return A functor that calls emit() on this signal.
-   */
-  slot_type slot() const
-    { return ::sigc::bound_const_mem_functor2<result_type, parent_type, typename ::sigc::type_trait<T_arg1>::take,typename ::sigc::type_trait<T_arg2>::take>(this, &parent_type::emit); }
-};
-
-/** Signal declaration.
- * Signal3 can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitely.
- *
- * If you want to connect one signal to another, use slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The following template arguments are used:
- * - @e T_return The desired return type for the emit() function (may be overridden by the accumulator).
- * - @e T_arg1 Argument type used in the definition of emit().
- * - @e T_arg2 Argument type used in the definition of emit().
- * - @e T_arg3 Argument type used in the definition of emit().
- * - @e T_accumulator The accumulator type used for emission. The default @p nil means that no accumulator should be used. Signal emission returns the return value of the last slot invoked.
- *
- * @deprecated Use the unnumbered template sigc::signal instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3, class T_accumulator=::sigc::nil>
-class Signal3
-  : public ::sigc::signal3<T_return, T_arg1,T_arg2,T_arg3, T_accumulator>
-{
-public:
-  typedef ::sigc::signal3<T_return, T_arg1,T_arg2,T_arg3, T_accumulator> parent_type;
-  typedef typename parent_type::result_type result_type;
-  typedef typename parent_type::slot_type slot_type;
-
-  Signal3() {}
-  Signal3(const Signal3& src)
-    : ::sigc::signal3<T_return, T_arg1,T_arg2,T_arg3, T_accumulator>(src) {}
-
-  /** Creates a functor that calls emit() on this signal.
-   * @code
-   * sigc::mem_fun(mysignal, &sigc::signal3::emit)
-   * @endcode
-   * yields the same result.
-   * @return A functor that calls emit() on this signal.
-   */
-  slot_type slot() const
-    { return ::sigc::bound_const_mem_functor3<result_type, parent_type, typename ::sigc::type_trait<T_arg1>::take,typename ::sigc::type_trait<T_arg2>::take,typename ::sigc::type_trait<T_arg3>::take>(this, &parent_type::emit); }
-};
-
-/** Signal declaration.
- * Signal4 can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitely.
- *
- * If you want to connect one signal to another, use slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The following template arguments are used:
- * - @e T_return The desired return type for the emit() function (may be overridden by the accumulator).
- * - @e T_arg1 Argument type used in the definition of emit().
- * - @e T_arg2 Argument type used in the definition of emit().
- * - @e T_arg3 Argument type used in the definition of emit().
- * - @e T_arg4 Argument type used in the definition of emit().
- * - @e T_accumulator The accumulator type used for emission. The default @p nil means that no accumulator should be used. Signal emission returns the return value of the last slot invoked.
- *
- * @deprecated Use the unnumbered template sigc::signal instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_accumulator=::sigc::nil>
-class Signal4
-  : public ::sigc::signal4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, T_accumulator>
-{
-public:
-  typedef ::sigc::signal4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, T_accumulator> parent_type;
-  typedef typename parent_type::result_type result_type;
-  typedef typename parent_type::slot_type slot_type;
-
-  Signal4() {}
-  Signal4(const Signal4& src)
-    : ::sigc::signal4<T_return, T_arg1,T_arg2,T_arg3,T_arg4, T_accumulator>(src) {}
-
-  /** Creates a functor that calls emit() on this signal.
-   * @code
-   * sigc::mem_fun(mysignal, &sigc::signal4::emit)
-   * @endcode
-   * yields the same result.
-   * @return A functor that calls emit() on this signal.
-   */
-  slot_type slot() const
-    { return ::sigc::bound_const_mem_functor4<result_type, parent_type, typename ::sigc::type_trait<T_arg1>::take,typename ::sigc::type_trait<T_arg2>::take,typename ::sigc::type_trait<T_arg3>::take,typename ::sigc::type_trait<T_arg4>::take>(this, &parent_type::emit); }
-};
-
-/** Signal declaration.
- * Signal5 can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitely.
- *
- * If you want to connect one signal to another, use slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The following template arguments are used:
- * - @e T_return The desired return type for the emit() function (may be overridden by the accumulator).
- * - @e T_arg1 Argument type used in the definition of emit().
- * - @e T_arg2 Argument type used in the definition of emit().
- * - @e T_arg3 Argument type used in the definition of emit().
- * - @e T_arg4 Argument type used in the definition of emit().
- * - @e T_arg5 Argument type used in the definition of emit().
- * - @e T_accumulator The accumulator type used for emission. The default @p nil means that no accumulator should be used. Signal emission returns the return value of the last slot invoked.
- *
- * @deprecated Use the unnumbered template sigc::signal instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_accumulator=::sigc::nil>
-class Signal5
-  : public ::sigc::signal5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_accumulator>
-{
-public:
-  typedef ::sigc::signal5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_accumulator> parent_type;
-  typedef typename parent_type::result_type result_type;
-  typedef typename parent_type::slot_type slot_type;
-
-  Signal5() {}
-  Signal5(const Signal5& src)
-    : ::sigc::signal5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5, T_accumulator>(src) {}
-
-  /** Creates a functor that calls emit() on this signal.
-   * @code
-   * sigc::mem_fun(mysignal, &sigc::signal5::emit)
-   * @endcode
-   * yields the same result.
-   * @return A functor that calls emit() on this signal.
-   */
-  slot_type slot() const
-    { return ::sigc::bound_const_mem_functor5<result_type, parent_type, typename ::sigc::type_trait<T_arg1>::take,typename ::sigc::type_trait<T_arg2>::take,typename ::sigc::type_trait<T_arg3>::take,typename ::sigc::type_trait<T_arg4>::take,typename ::sigc::type_trait<T_arg5>::take>(this, &parent_type::emit); }
-};
-
-/** Signal declaration.
- * Signal6 can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitely.
- *
- * If you want to connect one signal to another, use slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The following template arguments are used:
- * - @e T_return The desired return type for the emit() function (may be overridden by the accumulator).
- * - @e T_arg1 Argument type used in the definition of emit().
- * - @e T_arg2 Argument type used in the definition of emit().
- * - @e T_arg3 Argument type used in the definition of emit().
- * - @e T_arg4 Argument type used in the definition of emit().
- * - @e T_arg5 Argument type used in the definition of emit().
- * - @e T_arg6 Argument type used in the definition of emit().
- * - @e T_accumulator The accumulator type used for emission. The default @p nil means that no accumulator should be used. Signal emission returns the return value of the last slot invoked.
- *
- * @deprecated Use the unnumbered template sigc::signal instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_accumulator=::sigc::nil>
-class Signal6
-  : public ::sigc::signal6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_accumulator>
-{
-public:
-  typedef ::sigc::signal6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_accumulator> parent_type;
-  typedef typename parent_type::result_type result_type;
-  typedef typename parent_type::slot_type slot_type;
-
-  Signal6() {}
-  Signal6(const Signal6& src)
-    : ::sigc::signal6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_accumulator>(src) {}
-
-  /** Creates a functor that calls emit() on this signal.
-   * @code
-   * sigc::mem_fun(mysignal, &sigc::signal6::emit)
-   * @endcode
-   * yields the same result.
-   * @return A functor that calls emit() on this signal.
-   */
-  slot_type slot() const
-    { return ::sigc::bound_const_mem_functor6<result_type, parent_type, typename ::sigc::type_trait<T_arg1>::take,typename ::sigc::type_trait<T_arg2>::take,typename ::sigc::type_trait<T_arg3>::take,typename ::sigc::type_trait<T_arg4>::take,typename ::sigc::type_trait<T_arg5>::take,typename ::sigc::type_trait<T_arg6>::take>(this, &parent_type::emit); }
-};
-
-/** Signal declaration.
- * Signal7 can be used to connect() slots that are invoked
- * during subsequent calls to emit(). Any functor or slot
- * can be passed into connect(). It is converted into a slot
- * implicitely.
- *
- * If you want to connect one signal to another, use slot()
- * to retrieve a functor that emits the signal when invoked.
- *
- * Be careful if you directly pass one signal into the connect()
- * method of another: a shallow copy of the signal is made and
- * the signal's slots are not disconnected until both the signal
- * and its clone are destroyed which is probably not what you want!
- *
- * An STL-style list interface for the signal's list of slots
- * can be retrieved with slots(). This interface supports
- * iteration, insertion and removal of slots.
- *
- * The following template arguments are used:
- * - @e T_return The desired return type for the emit() function (may be overridden by the accumulator).
- * - @e T_arg1 Argument type used in the definition of emit().
- * - @e T_arg2 Argument type used in the definition of emit().
- * - @e T_arg3 Argument type used in the definition of emit().
- * - @e T_arg4 Argument type used in the definition of emit().
- * - @e T_arg5 Argument type used in the definition of emit().
- * - @e T_arg6 Argument type used in the definition of emit().
- * - @e T_arg7 Argument type used in the definition of emit().
- * - @e T_accumulator The accumulator type used for emission. The default @p nil means that no accumulator should be used. Signal emission returns the return value of the last slot invoked.
- *
- * @deprecated Use the unnumbered template sigc::signal instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_accumulator=::sigc::nil>
-class Signal7
-  : public ::sigc::signal7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_accumulator>
-{
-public:
-  typedef ::sigc::signal7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_accumulator> parent_type;
-  typedef typename parent_type::result_type result_type;
-  typedef typename parent_type::slot_type slot_type;
-
-  Signal7() {}
-  Signal7(const Signal7& src)
-    : ::sigc::signal7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7, T_accumulator>(src) {}
-
-  /** Creates a functor that calls emit() on this signal.
-   * @code
-   * sigc::mem_fun(mysignal, &sigc::signal7::emit)
-   * @endcode
-   * yields the same result.
-   * @return A functor that calls emit() on this signal.
-   */
-  slot_type slot() const
-    { return ::sigc::bound_const_mem_functor7<result_type, parent_type, typename ::sigc::type_trait<T_arg1>::take,typename ::sigc::type_trait<T_arg2>::take,typename ::sigc::type_trait<T_arg3>::take,typename ::sigc::type_trait<T_arg4>::take,typename ::sigc::type_trait<T_arg5>::take,typename ::sigc::type_trait<T_arg6>::take,typename ::sigc::type_trait<T_arg7>::take>(this, &parent_type::emit); }
-};
-
-
-}
-
-#endif /* LIBSIGC_DISABLE_DEPRECATED */
-
-#endif /* _SIGC_SIGNAL_H_ */
Index: stardict-3.0.1/src/sigc++/slot.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/slot.h
+++ /dev/null
@@ -1,614 +0,0 @@
-// -*- c++ -*-
-/* Do not edit! -- generated file */
-
-
-#ifndef _SIGC_MACROS_SLOTHM4_
-#define _SIGC_MACROS_SLOTHM4_
-
-#include <sigc++/functors/slot.h>
-
-#ifndef LIBSIGC_DISABLE_DEPRECATED
-
-namespace SigC {
-
-// SlotN
-/** Converts an arbitrary functor to a unified type which is opaque.
- * Slot0 itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * @par Example:
- *   @code
- *   #include <sigc++/slot.h>
- *   void foo(int) {}
- *   SigC::Slot1<void, long> s = SigC::slot(&foo);
- *   s(19);
- *   @endcode
- *
- * @deprecated Use the unnumbered template sigc::slot instead.
- * @ingroup compat
- */
-template <class T_return>
-class Slot0
-  : public ::sigc::slot<T_return>
-{
-public:
-  typedef ::sigc::slot<T_return> parent_type;
-
-  /// Constructs an empty slot.
-  Slot0() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desired functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  Slot0(const T_functor& _A_func)
-    : ::sigc::slot<T_return>(_A_func) {}
-
-  /** Constructs a slot, copying an existing one.
-   * @param src The existing slot to copy.
-   */
-  Slot0(const parent_type& src)
-    : parent_type(src) {}
-
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  Slot0& operator=(const parent_type& src)
-    { parent_type::operator=(src); return *this; }
-};
-
-/** Converts an arbitrary functor to a unified type which is opaque.
- * Slot1 itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- * - @e T_arg1 Argument type used in the definition of operator()().
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * @par Example:
- *   @code
- *   #include <sigc++/slot.h>
- *   void foo(int) {}
- *   SigC::Slot1<void, long> s = SigC::slot(&foo);
- *   s(19);
- *   @endcode
- *
- * @deprecated Use the unnumbered template sigc::slot instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1>
-class Slot1
-  : public ::sigc::slot<T_return, T_arg1>
-{
-public:
-  typedef ::sigc::slot<T_return, T_arg1> parent_type;
-
-  /// Constructs an empty slot.
-  Slot1() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desired functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  Slot1(const T_functor& _A_func)
-    : ::sigc::slot<T_return, T_arg1>(_A_func) {}
-
-  /** Constructs a slot, copying an existing one.
-   * @param src The existing slot to copy.
-   */
-  Slot1(const parent_type& src)
-    : parent_type(src) {}
-
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  Slot1& operator=(const parent_type& src)
-    { parent_type::operator=(src); return *this; }
-};
-
-/** Converts an arbitrary functor to a unified type which is opaque.
- * Slot2 itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * @par Example:
- *   @code
- *   #include <sigc++/slot.h>
- *   void foo(int) {}
- *   SigC::Slot1<void, long> s = SigC::slot(&foo);
- *   s(19);
- *   @endcode
- *
- * @deprecated Use the unnumbered template sigc::slot instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2>
-class Slot2
-  : public ::sigc::slot<T_return, T_arg1,T_arg2>
-{
-public:
-  typedef ::sigc::slot<T_return, T_arg1,T_arg2> parent_type;
-
-  /// Constructs an empty slot.
-  Slot2() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desired functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  Slot2(const T_functor& _A_func)
-    : ::sigc::slot<T_return, T_arg1,T_arg2>(_A_func) {}
-
-  /** Constructs a slot, copying an existing one.
-   * @param src The existing slot to copy.
-   */
-  Slot2(const parent_type& src)
-    : parent_type(src) {}
-
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  Slot2& operator=(const parent_type& src)
-    { parent_type::operator=(src); return *this; }
-};
-
-/** Converts an arbitrary functor to a unified type which is opaque.
- * Slot3 itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * @par Example:
- *   @code
- *   #include <sigc++/slot.h>
- *   void foo(int) {}
- *   SigC::Slot1<void, long> s = SigC::slot(&foo);
- *   s(19);
- *   @endcode
- *
- * @deprecated Use the unnumbered template sigc::slot instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3>
-class Slot3
-  : public ::sigc::slot<T_return, T_arg1,T_arg2,T_arg3>
-{
-public:
-  typedef ::sigc::slot<T_return, T_arg1,T_arg2,T_arg3> parent_type;
-
-  /// Constructs an empty slot.
-  Slot3() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desired functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  Slot3(const T_functor& _A_func)
-    : ::sigc::slot<T_return, T_arg1,T_arg2,T_arg3>(_A_func) {}
-
-  /** Constructs a slot, copying an existing one.
-   * @param src The existing slot to copy.
-   */
-  Slot3(const parent_type& src)
-    : parent_type(src) {}
-
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  Slot3& operator=(const parent_type& src)
-    { parent_type::operator=(src); return *this; }
-};
-
-/** Converts an arbitrary functor to a unified type which is opaque.
- * Slot4 itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * @par Example:
- *   @code
- *   #include <sigc++/slot.h>
- *   void foo(int) {}
- *   SigC::Slot1<void, long> s = SigC::slot(&foo);
- *   s(19);
- *   @endcode
- *
- * @deprecated Use the unnumbered template sigc::slot instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-class Slot4
-  : public ::sigc::slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4>
-{
-public:
-  typedef ::sigc::slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4> parent_type;
-
-  /// Constructs an empty slot.
-  Slot4() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desired functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  Slot4(const T_functor& _A_func)
-    : ::sigc::slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func) {}
-
-  /** Constructs a slot, copying an existing one.
-   * @param src The existing slot to copy.
-   */
-  Slot4(const parent_type& src)
-    : parent_type(src) {}
-
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  Slot4& operator=(const parent_type& src)
-    { parent_type::operator=(src); return *this; }
-};
-
-/** Converts an arbitrary functor to a unified type which is opaque.
- * Slot5 itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * @par Example:
- *   @code
- *   #include <sigc++/slot.h>
- *   void foo(int) {}
- *   SigC::Slot1<void, long> s = SigC::slot(&foo);
- *   s(19);
- *   @endcode
- *
- * @deprecated Use the unnumbered template sigc::slot instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-class Slot5
-  : public ::sigc::slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-{
-public:
-  typedef ::sigc::slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5> parent_type;
-
-  /// Constructs an empty slot.
-  Slot5() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desired functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  Slot5(const T_functor& _A_func)
-    : ::sigc::slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func) {}
-
-  /** Constructs a slot, copying an existing one.
-   * @param src The existing slot to copy.
-   */
-  Slot5(const parent_type& src)
-    : parent_type(src) {}
-
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  Slot5& operator=(const parent_type& src)
-    { parent_type::operator=(src); return *this; }
-};
-
-/** Converts an arbitrary functor to a unified type which is opaque.
- * Slot6 itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * @par Example:
- *   @code
- *   #include <sigc++/slot.h>
- *   void foo(int) {}
- *   SigC::Slot1<void, long> s = SigC::slot(&foo);
- *   s(19);
- *   @endcode
- *
- * @deprecated Use the unnumbered template sigc::slot instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-class Slot6
-  : public ::sigc::slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-{
-public:
-  typedef ::sigc::slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6> parent_type;
-
-  /// Constructs an empty slot.
-  Slot6() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desired functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  Slot6(const T_functor& _A_func)
-    : ::sigc::slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func) {}
-
-  /** Constructs a slot, copying an existing one.
-   * @param src The existing slot to copy.
-   */
-  Slot6(const parent_type& src)
-    : parent_type(src) {}
-
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  Slot6& operator=(const parent_type& src)
-    { parent_type::operator=(src); return *this; }
-};
-
-/** Converts an arbitrary functor to a unified type which is opaque.
- * Slot7 itself is a functor or to be more precise a closure. It contains
- * a single, arbitrary functor (or closure) that is executed in operator()().
- *
- * The template arguments determine the function signature of operator()():
- * - @e T_return The return type of operator()().
- * - @e T_arg1 Argument type used in the definition of operator()().
- * - @e T_arg2 Argument type used in the definition of operator()().
- * - @e T_arg3 Argument type used in the definition of operator()().
- * - @e T_arg4 Argument type used in the definition of operator()().
- * - @e T_arg5 Argument type used in the definition of operator()().
- * - @e T_arg6 Argument type used in the definition of operator()().
- * - @e T_arg7 Argument type used in the definition of operator()().
- *
- * To use simply assign the slot to the desired functor. If the functor
- * is not compatible with the parameter list defined with the template
- * arguments compiler errors are triggered. When called the slot
- * will invoke the functor with minimal copies.
- * block() and unblock() can be used to block the functor's invocation
- * from operator()() temporarily.
- *
- * @par Example:
- *   @code
- *   #include <sigc++/slot.h>
- *   void foo(int) {}
- *   SigC::Slot1<void, long> s = SigC::slot(&foo);
- *   s(19);
- *   @endcode
- *
- * @deprecated Use the unnumbered template sigc::slot instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-class Slot7
-  : public ::sigc::slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-{
-public:
-  typedef ::sigc::slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> parent_type;
-
-  /// Constructs an empty slot.
-  Slot7() {}
-
-  /** Constructs a slot from an arbitrary functor.
-   * @param _A_func The desired functor the new slot should be assigned to.
-   */
-  template <class T_functor>
-  Slot7(const T_functor& _A_func)
-    : ::sigc::slot<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func) {}
-
-  /** Constructs a slot, copying an existing one.
-   * @param src The existing slot to copy.
-   */
-  Slot7(const parent_type& src)
-    : parent_type(src) {}
-
-  /** Overrides this slot making a copy from another slot.
-   * @param src The slot from which to make a copy.
-   * @return @p this.
-   */
-  Slot7& operator=(const parent_type& src)
-    { parent_type::operator=(src); return *this; }
-};
-
-
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-/* gcc 3.2 reports a strange conflict between SigC::slot() and sigc::slot<>
- * when "using namespace SigC" and later using a slot(obj,func) overload
- * without the prefix "SigC::". Probably a compiler bug. I will investigate.
- *
- * This ugly hack avoids the error:
- */
-// #define slot(...) make_slot(__VA_ARGS__) /* only works for gcc */
-#endif
-
-
-// slot()
-/** Creates a functor of type SigC::Slot0 that wraps an existing non-member function.
- *
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::ptr_fun() instead.
- * @ingroup compat
- */
-template <class T_return>
-inline Slot0<T_return>
-slot(T_return (*_A_func)())
-{ return Slot0<T_return>(_A_func); }
-
-/** Creates a functor of type SigC::Slot1 that wraps an existing non-member function.
- *
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::ptr_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1>
-inline Slot1<T_return, T_arg1>
-slot(T_return (*_A_func)(T_arg1))
-{ return Slot1<T_return, T_arg1>(_A_func); }
-
-/** Creates a functor of type SigC::Slot2 that wraps an existing non-member function.
- *
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::ptr_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2>
-inline Slot2<T_return, T_arg1,T_arg2>
-slot(T_return (*_A_func)(T_arg1,T_arg2))
-{ return Slot2<T_return, T_arg1,T_arg2>(_A_func); }
-
-/** Creates a functor of type SigC::Slot3 that wraps an existing non-member function.
- *
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::ptr_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3>
-inline Slot3<T_return, T_arg1,T_arg2,T_arg3>
-slot(T_return (*_A_func)(T_arg1,T_arg2,T_arg3))
-{ return Slot3<T_return, T_arg1,T_arg2,T_arg3>(_A_func); }
-
-/** Creates a functor of type SigC::Slot4 that wraps an existing non-member function.
- *
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::ptr_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4>
-inline Slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4>
-slot(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4))
-{ return Slot4<T_return, T_arg1,T_arg2,T_arg3,T_arg4>(_A_func); }
-
-/** Creates a functor of type SigC::Slot5 that wraps an existing non-member function.
- *
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::ptr_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5>
-inline Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>
-slot(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5))
-{ return Slot5<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5>(_A_func); }
-
-/** Creates a functor of type SigC::Slot6 that wraps an existing non-member function.
- *
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::ptr_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6>
-inline Slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>
-slot(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6))
-{ return Slot6<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6>(_A_func); }
-
-/** Creates a functor of type SigC::Slot7 that wraps an existing non-member function.
- *
- * @param _A_func Pointer to function that should be wrapped.
- * @return Functor that executes _A_func on invokation.
- *
- * @deprecated Use sigc::ptr_fun() instead.
- * @ingroup compat
- */
-template <class T_return, class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7>
-inline Slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>
-slot(T_return (*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7))
-{ return Slot7<T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(_A_func); }
-
-
-
-}
-
-#endif
-#endif /* _SIGC_MACROS_SLOTHM4_ */
Index: stardict-3.0.1/src/sigc++/trackable.cc
===================================================================
--- stardict-3.0.1.orig/src/sigc++/trackable.cc
+++ /dev/null
@@ -1,127 +0,0 @@
-// -*- c++ -*-
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-
-#include <sigc++/trackable.h>
-#include <iostream>
-
-SIGC_USING_STD(ostream)
-
-using namespace std;
-
-namespace sigc
-{
-
-trackable::trackable()
-: callback_list_(0)
-{}
-
-/* Don't copy the notification list.
-   The objects watching src don't need to be notified when the new object dies. */
-trackable::trackable(const trackable& /*src*/)
-: callback_list_(0)
-{}
-
-trackable& trackable::operator=(const trackable& src)
-{
-  if(this != &src)
-    notify_callbacks(); //Make sure that we have finished with existing stuff before replacing it.
-  
-  return *this;
-}
-
-trackable::~trackable()
-{
-  notify_callbacks();
-}
-
-void trackable::add_destroy_notify_callback(void* data, func_destroy_notify func) const
-{
-  callback_list()->add_callback(data, func);
-}
-
-void trackable::remove_destroy_notify_callback(void* data) const
-{
-  callback_list()->remove_callback(data);
-}
-
-void trackable::notify_callbacks()
-{
-  if (callback_list_)
-    delete callback_list_; //This invokes all of the callbacks.
-
-  callback_list_ = 0;
-}
-
-internal::trackable_callback_list* trackable::callback_list() const
-{
-  if (!callback_list_)
-    callback_list_ = new internal::trackable_callback_list;
-
-  return callback_list_;
-}
-
-      
-namespace internal
-{
-
-trackable_callback_list::~trackable_callback_list()
-{
-  clearing_ = true;
-
-  for (callback_list::iterator i = callbacks_.begin(); i != callbacks_.end(); ++i)
-    (*i).func_((*i).data_);
-}
-
-void trackable_callback_list::add_callback(void* data, func_destroy_notify func)
-{
-  if (!clearing_)  // TODO: Is it okay to silently ignore attempts to add dependencies when the list is being cleared?
-                   //       I'd consider this a serious application bug, since the app is likely to segfault.
-                   //       But then, how should we handle it? Throw an exception? Martin.
-    callbacks_.push_back(trackable_callback(data, func));
-}
-
-void trackable_callback_list::clear()
-{
-  clearing_ = true;
-
-  for (callback_list::iterator i = callbacks_.begin(); i != callbacks_.end(); ++i)
-    (*i).func_((*i).data_);
-
-  callbacks_.clear();
-
-  clearing_ = false;
-}
-
-void trackable_callback_list::remove_callback(void* data)
-{
-  if (clearing_) return; // No circular notices
-
-  for (callback_list::iterator i = callbacks_.begin(); i != callbacks_.end(); ++i)
-    if ((*i).data_ == data)
-    {
-      callbacks_.erase(i);
-      return;
-    }
-}
-
-} /* namespace internal */
-
-
-} /* namespace sigc */
Index: stardict-3.0.1/src/sigc++/trackable.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/trackable.h
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#ifndef _SIGC_TRACKABLE_HPP_
-#define _SIGC_TRACKABLE_HPP_
-#include <list>
-#include <sigc++config.h>
-
-namespace sigc {
-
-namespace internal {
-
-typedef void* (*func_destroy_notify) (void* data);
-
-/** Destroy notification callback.
- * A destroy notification callback consists of a data pointer and a
- * function pointer. The function is executed from the owning callback
- * list (of type sigc::internal::trackable_callback_list) when its parent
- * object (of type sigc::trackable) is destroyed or overwritten.
- */
-struct SIGC_API trackable_callback
-{
-  void* data_;
-  func_destroy_notify func_;
-  trackable_callback(void* data, func_destroy_notify func)
-    : data_(data), func_(func) {}
-};
-
-/** Callback list.
- * A callback list holds an STL list of callbacks of type
- * trackable_callback. Callbacks are added and removed with
- * add_callback(), remove_callback() and clear(). The callbacks
- * are invoked from clear() and from the destructor.
- */
-struct SIGC_API trackable_callback_list
-{
-  /** Add a callback function.
-   * @param data Data that will be sent as a parameter to teh callback function.
-   * @param func The callback function.
-   * 
-   */
-  void add_callback(void* data, func_destroy_notify func);
-
-  /** Remove the callback which has this data associated with it.
-   * @param data The data that was given as a parameter to add_callback().
-   */
-  void remove_callback(void* data);
-
-  /** This invokes all of the callback functions.
-   */
-  void clear();
-
-  trackable_callback_list()
-    : clearing_(false) {}
-
-  /** This invokes all of the callback functions.
-   */
-  ~trackable_callback_list();
-
-private:
-  typedef std::list<trackable_callback> callback_list;
-  callback_list callbacks_;
-  bool          clearing_;
-};
-
-} /* namespace internal */
-
-
-/** Base class for objects with auto-disconnection.
- * trackable must be inherited when objects shall automatically
- * invalidate slots referring to them on destruction.
- * A slot built from a member function of a trackable derived
- * type installs a callback that is invoked when the trackable object
- * is destroyed or overwritten.
- *
- * add_destroy_notify_callback() and remove_destroy_notify_callback()
- * can be used to manually install and remove callbacks when
- * notification of the object dying is needed.
- *
- * notify_callbacks() invokes and removes all previously installed
- * callbacks and can therefore be used to disconnect from all signals.
- *
- * Note that there is no virtual destructor. Don't use @p trackable*
- * as pointer type for managing your data or the destructors of
- * your derived types won't be called when deleting your objects.
- *
- * @ingroup signal
- */
-struct SIGC_API trackable
-{
-  trackable();
-
-  trackable(const trackable& src);
-
-  trackable& operator=(const trackable& src);
-
-  ~trackable();
-
-  /*virtual ~trackable() {} */  /* we would need a virtual dtor for users
-                                   who insist on using "trackable*" as
-                                   pointer type for their own derived objects */
-
-  
-  typedef internal::func_destroy_notify func_destroy_notify;
-  
-  /** Add a callback that is executed (notified) when the trackable object is detroyed.
-   * @param data Passed into func upon notification.
-   * @param func Callback executed upon destruction of the object.
-   */
-  void add_destroy_notify_callback(void* data, func_destroy_notify func) const;
-
-  /** Remove a callback previously installed with add_destroy_notify_callback().
-   * The callback is not executed.
-   * @param data Parameter passed into previous call to add_destroy_notify_callback().
-   */
-  void remove_destroy_notify_callback(void* data) const;
-
-  /// Execute and remove all previously installed callbacks.
-  void notify_callbacks();
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-private:
-  /* The callbacks are held in a list of type trackable_callback_list.
-   * This list is allocated dynamically when the first callback is added.
-   */
-  internal::trackable_callback_list* callback_list() const;
-  mutable internal::trackable_callback_list* callback_list_;
-#endif
-};
-
-} /* namespace sigc */
-
-#endif /* _SIGC_TRACKABLE_HPP_ */
Index: stardict-3.0.1/src/sigc++/type_traits.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/type_traits.h
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#ifndef _SIGC_TYPE_TRAIT_H_
-#define _SIGC_TYPE_TRAIT_H_
-
-#include <sigc++config.h> //To get SIGC_SELF_REFERENCE_IN_MEMBER_INITIALIZATION
-
-
-namespace sigc {
-
-template <class T_type>
-struct type_trait
-{
-  typedef T_type  type;
-  typedef T_type& pass;
-  typedef const T_type& take;
-  typedef T_type* pointer;
-};
-
-template <class T_type, int N>
-struct type_trait<T_type[N]>
-{
-  typedef T_type*  type;
-  typedef T_type*& pass;
-  typedef const T_type*& take;
-  typedef T_type** pointer;
-};
-
-template <class T_type>
-struct type_trait<T_type&>
-{
-  typedef T_type  type;
-  typedef T_type& pass;
-  typedef T_type& take;
-  typedef T_type* pointer;
-};
-
-template <class T_type>
-struct type_trait<const T_type&>
-{
-  typedef const T_type  type;
-  typedef const T_type& pass;
-  typedef const T_type& take;
-  typedef const T_type* pointer;
-};
-
-template<>
-struct type_trait<void>
-{
-  typedef void  type;
-  typedef void  pass;
-  typedef void  take;
-  typedef void* pointer;
-};
-
-
-// From Esa Pulkkin:
-/**
- * Compile-time determination of base-class relationship in C++
- * (adapted to match the syntax of boost's type_traits library).
- *
- * Use this to provide a template specialization for a set of types.
- * For instance,
- *
- * template < class T_thing, bool Tval_derives_from_something = sigc::is_base_and_derived<Something, T_thing>::value >
- * class TheTemplate
- * {
- *   //Standard implementation.
- * }
- *
- * //Specialization for T_things that derive from Something (Tval_derives_from_something is true)
- * template <class T_thing>
- * class TheTemplate<T_thing, true>
- * {
- *   T_thing thing;
-     thing.method_that_is_in_something();
- * }
- */
-template <class T_base, class T_derived>
-struct is_base_and_derived
-{
-private:
-  struct big {
-    char memory[64];
-  };
-
-#ifndef SIGC_SELF_REFERENCE_IN_MEMBER_INITIALIZATION
-
-  //Allow the internal inner class to access the other (big) inner
-  //class.  The Tru64 compiler needs this. murrayc.
-  friend struct internal_class;
-
-  //Certain compilers, notably GCC 3.2, require these functions to be inside an inner class.
-  struct internal_class
-  {
-    static big  is_base_class_(...);
-    static char is_base_class_(typename type_trait<T_base>::pointer);
-  };
-
-public:
-  static const bool value =
-    sizeof(internal_class::is_base_class_(reinterpret_cast<typename type_trait<T_derived>::pointer>(0))) ==
-    sizeof(char);
-
-#else //SIGC_SELF_REFERENCE_IN_MEMBER_INITIALIZATION
-
-  //The AIX xlC compiler does not like these 2 functions being in the inner class.
-  //It says "The incomplete type "test" must not be used as a qualifier.
-  //It does not seem necessary anyway. murrayc.
-  static big  is_base_class_(...);
-  static char is_base_class_(typename type_trait<T_base>::pointer);
-
-public:
-  static const bool value =
-    sizeof(is_base_class_(reinterpret_cast<typename type_trait<T_derived>::pointer>(0))) ==
-    sizeof(char);
-
-#endif //SIGC_SELF_REFERENCE_IN_MEMBER_INITIALIZATION
-
-  void avoid_gcc3_warning_(); //Not implemented. g++ 3.3.5 (but not 3.3.4, and not 3.4) warn that there are no public methods, even though there is a public variable.
-};
-
-template <class T_base>
-struct is_base_and_derived<T_base, T_base>
-{
-  static const bool value = true;
-};
-
-} /* namespace sigc */
-
-#endif /* _SIGC_TYPE_TRAIT_H_ */
Index: stardict-3.0.1/src/sigc++/visit_each.h
===================================================================
--- stardict-3.0.1.orig/src/sigc++/visit_each.h
+++ /dev/null
@@ -1,174 +0,0 @@
-// -*- c++ -*- 
-/*
- * Copyright 2002, The libsigc++ Development Team
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- */
-#ifndef _SIGC_VISIT_EACH_HPP_
-#define _SIGC_VISIT_EACH_HPP_
-
-#include <sigc++/type_traits.h>
-
-namespace sigc {
-
-namespace internal {
-
-//This should really be an inner class of limit_derived_target, without the T_limit template type,
-//But the SUN CC 5.7 (not earlier versions) compiler finds it ambiguous when we specify a particular specialization of it.
-//and does not seem to allow us to tell it explicitly that it's an inner class.
-template <bool I_derived, class T_type, class T_limit>
-struct with_type;
-
-//Specialization for I_derived = false
-template <class T_type, class T_limit> struct
-with_type<false, T_type, T_limit>
-{
-  static void execute_(const T_type&, const T_limit&) {}
-};
-
-//Specialization for I_derived = true
-template <class T_type, class T_limit>
-struct with_type<true, T_type, T_limit>
-{
-  static void execute_(const T_type& _A_type, const T_limit& _A_action)
-  { _A_action.action_(_A_type); }
-};
-
-
-/// Helper struct for visit_each_type().
-template <class T_target, class T_action>
-struct limit_derived_target
-{
-  typedef limit_derived_target<T_target, T_action> T_self;
-
- 
-  template <class T_type>
-  void operator()(const T_type& _A_type) const
-  {
-    with_type<is_base_and_derived<T_target, T_type>::value, T_type, T_self>::execute_(_A_type, *this);
-  }
-
-  limit_derived_target(const T_action& _A_action)
-  : action_(_A_action)
-  {}
-
-  T_action action_;
-};
-
-// Specialization for T_target pointer types, to provide a slightly different execute_() implementation.
-
-template <bool I_derived, class T_type, class T_limit>
-struct with_type_pointer;
-
-//Specialization for I_derived = false
-template <class T_type, class T_limit>
-struct with_type_pointer<false, T_type, T_limit>
-{
- static void execute_(const T_type&, const T_limit&) {}
-};
-
-//Specialization for I_derived = true
-template <class T_type, class T_limit>
-struct with_type_pointer<true, T_type, T_limit>
-{
-  static void execute_(const T_type& _A_type, const T_limit& _A_action) 
-  { _A_action.action_(&_A_type); }
-};
-
-template <class T_target, class T_action>
-struct limit_derived_target<T_target*, T_action>
-{
-  typedef limit_derived_target<T_target*, T_action> T_self;
-
-
-  template <class T_type>
-  void operator()(const T_type& _A_type) const
-  {
-    with_type_pointer<is_base_and_derived<T_target, T_type>::value, T_type, T_self>::execute_(_A_type, *this);
-  }
-
-  limit_derived_target(const T_action& _A_action)
-  : action_(_A_action)
-  {}
-
-  T_action action_;
-};
-
-} /* namespace internal */
-
-
-/** This function performs a functor on each of the targets of a functor.
- * All unknown types just call @e _A_action on them.
- * Add overloads that specialize the @e T_functor argument for your own
- * functor types, so that subobjects get visited. This is needed to enable
- * auto-disconnection support for your functor types.
- *
- * @par Example:
- *   @code
- *   struct some_functor
- *   {
- *     void operator()() {}
- *     some_possibly_sigc_trackable_derived_type some_data_member;
- *     some_other_functor_type some_other_functor;
- *   }
- *
- *   namespace sigc
- *   {
- *     template <class T_action>
- *     void visit_each(const T_action& _A_action,
- *                     const some_functor& _A_target)
- *     {
- *       visit_each(_A_action, _A_target.some_data_member);
- *       visit_each(_A_action, _A_target.some_other_functor);
- *     }
- *   }
- *   @endcode
- *
- * @ingroup functors
- */
-template <class T_action, class T_functor>
-void visit_each(const T_action& _A_action, const T_functor& _A_functor)
-{ _A_action(_A_functor); }
-
-/** This function performs a functor on each of the targets
- * of a functor limited to a restricted type.
- *
- * @ingroup functors
- */
-template <class T_type, class T_action, class T_functor>
-void visit_each_type(const T_action& _A_action, const T_functor& _A_functor)
-{ 
-  typedef internal::limit_derived_target<T_type, T_action> type_limited_action;
-
-  type_limited_action limited_action(_A_action);
-
-  //specifying the types of the template specialization prevents disconnection of bound trackable references (such as with sigc::ref()),
-  //probably because the visit_each<> specializations take various different template types,
-  //in various sequences, and we are probably specifying only a subset of them with this.
-  //
-  //But this is required by the AIX (and maybe IRIX MipsPro  and Tru64) compilers.
-  //I guess that sigc::ref() therefore does not work on those platforms. murrayc
-  //visit_each<type_limited_action, T_functor>(limited_action, _A_functor);
-
-  //g++ (even slightly old ones) is our primary platform, so we could use the non-crashing version. 
-  //However, the expliict version also fixes a crash in a slightl more common case: http://bugzilla.gnome.org/show_bug.cgi?id=169225
-  //Users (and distributors) of libsigc++ on AIX (and maybe IRIX MipsPro  and Tru64) do 
-  //need to use the version above instead, to allow compilation.
-  visit_each(limited_action, _A_functor);
-}
-
-} /* namespace sigc */
-#endif
