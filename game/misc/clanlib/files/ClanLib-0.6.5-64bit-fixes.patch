--- ClanLib-0.6.5/Sources/SmallJPEG/jpgd/jpegdecoder.cpp.64bit-fixes	2001-04-25 18:14:41.000000000 +0200
+++ ClanLib-0.6.5/Sources/SmallJPEG/jpgd/jpegdecoder.cpp	2003-10-08 14:34:32.000000000 +0200
@@ -19,6 +19,7 @@
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 //------------------------------------------------------------------------------
+#include <stdint.h>
 #include "jpegdecoder.h"
 //------------------------------------------------------------------------------
 // Coefficients are stored in this sequence in the data stream.
@@ -102,7 +103,7 @@ void *jpeg_decoder::alloc(int n)
   blocks[i] = q;
 
   // Round to qword boundry, to avoid misaligned accesses with MMX code
-  return ((void *)(((uint)q + 7) & ~7));
+  return ((void *)(((uintptr_t)q + 7) & ~7));
 }
 //------------------------------------------------------------------------------
 // Clear buffer to word values.
@@ -1870,7 +1871,7 @@ void jpeg_decoder::init_frame(void)
   q = (uchar *)alloc(max_blocks_per_row * 64 * sizeof(BLOCK_TYPE) + 8);
 
   // Align to 8-byte boundry, for MMX code
-  q = (uchar *)(((uint)q + 7) & ~7);
+  q = (uchar *)(((uintptr_t)q + 7) & ~7);
 
   // The block_seg[] array's name dates back to the
   // 16-bit assembler implementation. "seg" stood for "segment".
@@ -1880,7 +1881,7 @@ void jpeg_decoder::init_frame(void)
   for (i = 0; i < max_blocks_per_row; i++)
     block_max_zag_set[i] = 64;
 
-  Psample_buf = (uchar *)(((uint)alloc(max_blocks_per_row * 64 + 8) + 7) & ~7);
+  Psample_buf = (uchar *)(((uintptr_t)alloc(max_blocks_per_row * 64 + 8) + 7) & ~7);
 
   total_lines_left = image_y_size;
 
