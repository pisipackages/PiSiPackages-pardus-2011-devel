diff -Nur sauerbraten-old/data/keymap.cfg sauerbraten/data/keymap.cfg
--- sauerbraten-old/data/keymap.cfg	2009-07-24 15:18:29.150203213 +0300
+++ sauerbraten/data/keymap.cfg	2009-06-06 23:59:03.000000000 +0300
@@ -5,6 +5,9 @@
 keymap -2 MOUSE3 
 keymap -4 MOUSE4 
 keymap -5 MOUSE5 
+keymap -6 MOUSE6
+keymap -7 MOUSE7
+keymap -8 MOUSE8
 keymap 8 BACKSPACE 
 keymap 9 TAB 
 keymap 12 CLEAR 
diff -Nur sauerbraten-old/data/menus.cfg sauerbraten/data/menus.cfg
--- sauerbraten-old/data/menus.cfg	2009-07-24 15:18:29.148203162 +0300
+++ sauerbraten/data/menus.cfg	2009-06-06 23:59:07.000000000 +0300
@@ -1114,15 +1114,15 @@
 ]
 
 matmenu = [
-  guibutton "air"                        "editmat air"
-  guibutton "water"                      "editmat water"
-  guibutton "clip"                       "editmat clip"
-  guibutton "glass"                      "editmat glass"
-  guibutton "noclip"                     "editmat noclip"
-  guibutton "lava"                       "editmat lava"
-  guibutton "death"                      "editmat death"
-  guibar
-  guicheckbox "show material volumes"    showmat
+    guibutton "air"                        "editmat air"
+    guibutton "water"                      "editmat water"
+    guibutton "lava"                       "editmat lava"
+    guibutton "clip"                       "editmat clip"
+    guibutton "glass"                      "editmat glass"
+    guibutton "noclip"                     "editmat noclip"
+    guibutton "gameclip"                   "editmat gameclip"
+    guibutton "death"                      "editmat death"
+    guicheckbox "show material volumes"    showmat
 ]
 
 brushmenu = [
diff -Nur sauerbraten-old/src/engine/command.cpp sauerbraten/src/engine/command.cpp
--- sauerbraten-old/src/engine/command.cpp	2009-07-24 15:18:29.167202997 +0300
+++ sauerbraten/src/engine/command.cpp	2009-06-07 00:00:27.000000000 +0300
@@ -126,7 +126,7 @@
 void aliasa(const char *name, char *action)
 {
     ident *b = idents->access(name);
-    if(!b) 
+    if(!b)
     {
         ident b(ID_ALIAS, newstring(name), action, persistidents ? IDF_PERSIST : 0);
         if(overrideidents) b.override = OVERRIDDEN;
@@ -137,12 +137,12 @@
         conoutf(CON_ERROR, "cannot redefine builtin %s with an alias", name);
         delete[] action;
     }
-    else 
+    else
     {
         if(b->action != b->isexecuting) delete[] b->action;
         b->action = action;
         if(overrideidents) b->override = OVERRIDDEN;
-        else 
+        else
         {
             if(b->override != NO_OVERRIDE) b->override = NO_OVERRIDE;
             if(persistidents)
@@ -228,18 +228,18 @@
     *id->storage.s = newstring(str);
     if(dofunc) id->changed();
 }
-int getvar(const char *name) 
-{ 
+int getvar(const char *name)
+{
     GETVAR(id, name, 0);
     return *id->storage.i;
 }
-int getvarmin(const char *name) 
-{ 
+int getvarmin(const char *name)
+{
     GETVAR(id, name, 0);
     return id->minval;
 }
-int getvarmax(const char *name) 
-{ 
+int getvarmax(const char *name)
+{
     GETVAR(id, name, 0);
     return id->maxval;
 }
@@ -313,7 +313,7 @@
 
 const char *parsestring(const char *p)
 {
-    for(; *p; p++) switch(*p) 
+    for(; *p; p++) switch(*p)
     {
         case '\r':
         case '\n':
@@ -342,7 +342,7 @@
                 case 't': *dst++ = '\t'; break;
                 case 'f': *dst++ = '\f'; break;
                 default: *dst++ = e; break;
-            }            
+            }
         }
         else *dst++ = c;
     }
@@ -360,7 +360,7 @@
         switch(c)
         {
             case '\r': continue;
-            case '@': 
+            case '@':
                 if(left == '[') { parsemacro(p, brak, wordbuf); continue; }
                 break;
             case '\"':
@@ -382,10 +382,10 @@
             case '\0':
                 p--;
                 conoutf(CON_ERROR, "missing \"%c\"", right);
-                wordbuf.setsize(0); 
+                wordbuf.setsize(0);
                 bufnest--;
-                return NULL; 
-        } 
+                return NULL;
+        }
         if(c==left) brak++;
         else if(c==right) brak--;
         wordbuf.add(c);
@@ -428,7 +428,7 @@
     {
         p += strspn(p, " \t\r");
         if(p[0]!='/' || p[1]!='/') break;
-        p += strcspn(p, "\n\0");  
+        p += strcspn(p, "\n\0");
     }
     if(*p=='\"')
     {
@@ -465,7 +465,7 @@
     int len = space ? max(n-1, 0) : 0;
     loopj(n) len += (int)strlen(w[j]);
     char *r = newstring("", len);
-    loopi(n)       
+    loopi(n)
     {
         strcat(r, w[i]);  // make string-list out of all arguments
         if(i==n-1) break;
@@ -502,26 +502,26 @@
             if(s) w[i] = s;
             else numargs = i;
         }
-        
+
         p += strcspn(p, ";\n\0");
         cont = *p++!=0;                         // more statements if this isn't the end of the string
         char *c = w[0];
         if(!*c) continue;                       // empty statement
-        
+
         DELETEA(retval);
 
         if(infix)
         {
             switch(infix)
             {
-                case '=':    
+                case '=':
                     aliasa(c, numargs>2 ? w[2] : newstring(""));
                     w[2] = NULL;
                     break;
             }
         }
         else
-        {     
+        {
             ident *id = idents->access(c);
             if(!id)
             {
@@ -533,7 +533,7 @@
             {
                 case ID_CCOMMAND:
                 case ID_COMMAND:                     // game defined commands
-                {   
+                {
                     void *v[MAXWORDS];
                     union
                     {
@@ -574,10 +574,10 @@
                     break;
                 }
 
-                case ID_VAR:                        // game defined variables 
-                    if(numargs <= 1) 
+                case ID_VAR:                        // game defined variables
+                    if(numargs <= 1)
                     {
-                        if(id->flags&IDF_HEX && id->maxval==0xFFFFFF) 
+                        if(id->flags&IDF_HEX && id->maxval==0xFFFFFF)
                             conoutf("%s = 0x%.6X (%d, %d, %d)", c, *id->storage.i, (*id->storage.i>>16)&0xFF, (*id->storage.i>>8)&0xFF, *id->storage.i&0xFF);
                         else
                             conoutf(id->flags&IDF_HEX ? "%s = 0x%X" : "%s = %d", c, *id->storage.i);      // var with no value just prints its current value
@@ -594,7 +594,7 @@
                         if(id->flags&IDF_HEX && numargs > 2)
                         {
                             i1 <<= 16;
-                            i1 |= parseint(w[2])<<8;    
+                            i1 |= parseint(w[2])<<8;
                             i1 |= parseint(w[3]);
                         }
                         if(i1<id->minval || i1>id->maxval)
@@ -603,7 +603,7 @@
                             conoutf(CON_ERROR,
                                 id->flags&IDF_HEX ?
                                     (id->minval <= 255 ? "valid range for %s is %d..0x%X" : "valid range for %s is 0x%X..0x%X") :
-                                    "valid range for %s is %d..%d", 
+                                    "valid range for %s is %d..%d",
                                 id->name, id->minval, id->maxval);
                         }
                         *id->storage.i = i1;
@@ -613,7 +613,7 @@
 #endif
                     }
                     break;
-                  
+
                 case ID_FVAR:
                     if(numargs <= 1) conoutf("%s = %s", c, floatstr(*id->storage.f));
                     else if(id->flags&IDF_READONLY) conoutf(CON_ERROR, "variable %s is read-only", id->name);
@@ -637,7 +637,7 @@
 #endif
                     }
                     break;
- 
+
                 case ID_SVAR:
                     if(numargs <= 1) conoutf(strchr(*id->storage.s, '"') ? "%s = [%s]" : "%s = \"%s\"", c, *id->storage.s);
                     else if(id->flags&IDF_READONLY) conoutf(CON_ERROR, "variable %s is read-only", id->name);
@@ -655,7 +655,7 @@
 #endif
                     }
                     break;
-                        
+
                 case ID_ALIAS:                              // alias, also used as functions and (global) variables
                 {
                     static vector<ident *> argids;
@@ -690,7 +690,7 @@
 int execute(const char *p)
 {
     char *ret = executeret(p);
-    int i = 0; 
+    int i = 0;
     if(ret) { i = parseint(ret); delete[] ret; }
     return i;
 }
@@ -700,7 +700,7 @@
     string s;
     copystring(s, cfgfile);
     char *buf = loadfile(path(s), NULL);
-    if(!buf) 
+    if(!buf)
     {
         if(msg) conoutf(CON_ERROR, "could not read \"%s\"", cfgfile);
         return false;
@@ -793,7 +793,8 @@
 #define ICOMMANDNAME(name) _stdcmd
 
 ICOMMAND(if, "sss", (char *cond, char *t, char *f), commandret = executeret(cond[0] && (!isinteger(cond) || parseint(cond)) ? t : f));
-ICOMMAND(loop, "sis", (char *var, int *n, char *body), 
+ICOMMAND(?, "sss", (char *cond, char *t, char *f), result(cond[0] && (!isinteger(cond) || parseint(cond)) ? t : f));
+ICOMMAND(loop, "sis", (char *var, int *n, char *body),
 {
     if(*n<=0) return;
     ident *id = newident(var);
@@ -802,8 +803,8 @@
     {
         if(i) sprintf(id->action, "%d", i);
         else pushident(*id, newstring("0", 16));
-        execute(body); 
-    } 
+        execute(body);
+    }
     popident(*id);
 });
 ICOMMAND(while, "ss", (char *cond, char *body), while(execute(cond)) execute(body));    // can't get any simpler than this :)
@@ -996,6 +997,7 @@
     vector<char> buf;
 
     int oldlen = strlen(oldval);
+    if(!oldlen) return newstring(s);
     for(;;)
     {
         const char *found = strstr(s, oldval);
@@ -1005,7 +1007,7 @@
             for(const char *n = newval; *n; n++) buf.add(*n);
             s = found + oldlen;
         }
-        else 
+        else
         {
             while(*s) buf.add(*s++);
             buf.add('\0');
@@ -1061,7 +1063,7 @@
 void clearsleep(bool clearoverrides)
 {
     int len = 0;
-    loopv(sleepcmds) if(sleepcmds[i].command) 
+    loopv(sleepcmds) if(sleepcmds[i].command)
     {
         if(clearoverrides && !sleepcmds[i].override) sleepcmds[len++] = sleepcmds[i];
         else delete[] sleepcmds[i].command;
diff -Nur sauerbraten-old/src/engine/console.cpp sauerbraten/src/engine/console.cpp
--- sauerbraten-old/src/engine/console.cpp	2009-07-24 15:18:29.163203068 +0300
+++ sauerbraten/src/engine/console.cpp	2009-06-07 00:00:27.000000000 +0300
@@ -65,42 +65,6 @@
     return height;
 }
 
-void blendbox(int x1, int y1, int x2, int y2, bool border)
-;
-#if 0
-{
-    notextureshader->set();
-
-    glDepthMask(GL_FALSE);
-    glDisable(GL_TEXTURE_2D);
-    glBlendFunc(GL_ZERO, GL_ONE_MINUS_SRC_COLOR);
-    glBegin(GL_QUADS);
-    if(border) glColor3d(0.5, 0.3, 0.4);
-    else glColor3d(1.0, 1.0, 1.0);
-    glVertex2f(x1, y1);
-    glVertex2f(x2, y1);
-    glVertex2f(x2, y2);
-    glVertex2f(x1, y2);
-    glEnd();
-    glDisable(GL_BLEND);
-    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
-    glBegin(GL_QUADS);
-    glColor3d(0.2, 0.7, 0.4);
-    glVertex2f(x1, y1);
-    glVertex2f(x2, y1);
-    glVertex2f(x2, y2);
-    glVertex2f(x1, y2);
-    glEnd();
-    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
-    xtraverts += 8;
-    glEnable(GL_BLEND);
-    glEnable(GL_TEXTURE_2D);
-    glDepthMask(GL_TRUE);
-
-    defaultshader->set();
-}
-#endif
-
 VARP(consize, 0, 5, 100);
 VARP(miniconsize, 0, 5, 100);
 VARP(miniconwidth, 0, 40, 100);
diff -Nur sauerbraten-old/src/engine/octaedit.cpp sauerbraten/src/engine/octaedit.cpp
--- sauerbraten-old/src/engine/octaedit.cpp	2009-07-24 15:18:29.163203068 +0300
+++ sauerbraten/src/engine/octaedit.cpp	2009-06-07 00:00:27.000000000 +0300
@@ -1673,12 +1673,12 @@
         {   
             g.tab(!i ? "Textures" : NULL, 0xAAFFAA);
             if(i+1 != origtab) continue; //don't load textures on non-visible tabs!
-            loopj(TEXGUI_HEIGHT) 
+            loop(h, TEXGUI_HEIGHT) 
             {
                 g.pushlist();
-                loopk(TEXGUI_WIDTH) 
+                loop(w, TEXGUI_WIDTH) 
                 {
-                    int ti = (i*TEXGUI_HEIGHT+j)*TEXGUI_WIDTH+k;
+                    int ti = (i*TEXGUI_HEIGHT+h)*TEXGUI_WIDTH+w;
                     if(ti<curtexnum) 
                     {
                         Texture *tex = notexture, *glowtex = NULL, *layertex = NULL;
@@ -1687,7 +1687,7 @@
                         else if(slot.loaded) 
                         {
                             tex = slot.sts[0].t;
-                            if(slot.texmask&(1<<TEX_GLOW)) { loopv(slot.sts) if(slot.sts[i].type==TEX_GLOW) { glowtex = slot.sts[i].t; break; } }
+                            if(slot.texmask&(1<<TEX_GLOW)) { loopvj(slot.sts) if(slot.sts[j].type==TEX_GLOW) { glowtex = slot.sts[j].t; break; } }
                             if(slot.layer)
                             {
                                 Slot &layer = lookuptexture(slot.layer);
diff -Nur sauerbraten-old/src/engine/octarender.cpp sauerbraten/src/engine/octarender.cpp
--- sauerbraten-old/src/engine/octarender.cpp	2009-07-24 15:18:29.166202992 +0300
+++ sauerbraten/src/engine/octarender.cpp	2009-06-07 00:00:27.000000000 +0300
@@ -1164,7 +1164,7 @@
     if(va->matbuf) delete[] va->matbuf;
     if(va->mapmodels) delete va->mapmodels;
     if(va->grasstris) delete va->grasstris;
-    delete[] (uchar *)va;
+    delete va;
 }
 
 void clearvas(cube *c)
diff -Nur sauerbraten-old/src/engine/rendersky.cpp sauerbraten/src/engine/rendersky.cpp
--- sauerbraten-old/src/engine/rendersky.cpp	2009-07-24 15:18:29.162203067 +0300
+++ sauerbraten/src/engine/rendersky.cpp	2009-06-07 00:00:27.000000000 +0300
@@ -39,7 +39,7 @@
 SVARFR(cloudlayer, "", { if(cloudlayer[0]) cloudoverlay = loadskyoverlay(cloudlayer); });
 FVARR(cloudscrollx, -16, 0, 16);
 FVARR(cloudscrolly, -16, 0, 16);
-FVARR(cloudscale, 0, 1, 64);
+FVARR(cloudscale, 0.001, 1, 64);
 FVARR(spincloudlayer, -720, 0, 720);
 VARR(yawcloudlayer, 0, 0, 360);
 FVARR(cloudheight, -1, 0.2f, 1);
diff -Nur sauerbraten-old/src/engine/serverbrowser.cpp sauerbraten/src/engine/serverbrowser.cpp
--- sauerbraten-old/src/engine/serverbrowser.cpp	2009-07-24 15:18:29.165202853 +0300
+++ sauerbraten/src/engine/serverbrowser.cpp	2009-06-07 00:00:27.000000000 +0300
@@ -290,6 +290,7 @@
         if(lastping >= 0 && totalmillis - lastping >= decay)
         {
             ping = INT_MAX;
+            numplayers = 0;
             lastping = -1;
         }
         if(lastping < 0) lastping = totalmillis;
diff -Nur sauerbraten-old/src/engine/shader.cpp sauerbraten/src/engine/shader.cpp
--- sauerbraten-old/src/engine/shader.cpp	2009-07-24 15:18:29.163203068 +0300
+++ sauerbraten/src/engine/shader.cpp	2009-06-07 00:00:27.000000000 +0300
@@ -1103,6 +1103,7 @@
     standardshader = s->standard;
     forceshaders = false;
     persistidents = false;
+    curparams.setsize(0);
     execute(defer);
     persistidents = waspersisting;
     forceshaders = wasforcing;
diff -Nur sauerbraten-old/src/engine/skelmodel.h sauerbraten/src/engine/skelmodel.h
--- sauerbraten-old/src/engine/skelmodel.h	2009-07-24 15:18:29.163203068 +0300
+++ sauerbraten/src/engine/skelmodel.h	2009-06-07 00:00:27.000000000 +0300
@@ -835,7 +835,6 @@
                 }
             }
             numinterpbones = numgpubones;
-            calcantipodes();
             loopv(tags)
             {
                 boneinfo &info = bones[tags[i].bone];
@@ -875,6 +874,7 @@
                     }
                 }
             }
+            calcantipodes();
         }
 
         void optimize()
diff -Nur sauerbraten-old/src/engine/texture.h sauerbraten/src/engine/texture.h
--- sauerbraten-old/src/engine/texture.h	2009-07-24 15:18:29.165202853 +0300
+++ sauerbraten/src/engine/texture.h	2009-06-20 06:27:44.000000000 +0300
@@ -263,6 +263,7 @@
     {
         cleanup();
         *this = d;
+        if(owner == &d) owner = this;
         d.disown();
     }
 
diff -Nur sauerbraten-old/src/fpsgame/ai.cpp sauerbraten/src/fpsgame/ai.cpp
--- sauerbraten-old/src/fpsgame/ai.cpp	2009-07-24 15:18:29.152203234 +0300
+++ sauerbraten/src/fpsgame/ai.cpp	2009-06-06 23:59:46.000000000 +0300
@@ -135,17 +135,17 @@
     void update()
     {
         bool updating = lastmillis-updatemillis > 100; // fixed rate logic at 10fps
-        if(updating)
-        {
-        	avoid();
-        	forcegun = multiplayer(false) ? -1 : aiforcegun;
-        }
 		loopv(players) if(players[i]->ai)
 		{
+            if(updating && updatemillis < lastmillis)
+            {
+                avoid();
+                forcegun = multiplayer(false) ? -1 : aiforcegun;
+                updatemillis = lastmillis;
+            }
 			if(!intermission) think(players[i], updating);
 			else players[i]->stopmoving();
 		}
-		if(updating) updatemillis = lastmillis;
     }
 
     bool checkothers(vector<int> &targets, fpsent *d, int state, int targtype, int target, bool teams)
@@ -711,7 +711,7 @@
             vec dir = vec(dp).sub(ep).normalize();
             vectoyawpitch(dir, targyaw, targpitch);
             float rtime = (d->skill*guns[d->gunselect].attackdelay/200.f),
-                    skew = clamp(float(lastmillis-d->ai->enemymillis)/float(rtime), 0.f, guns[d->gunselect].projspeed ? 1.f : 1e16f),
+                    skew = clamp(float(lastmillis-d->ai->enemymillis)/float(rtime), 0.f, guns[d->gunselect].projspeed ? 0.25f : 1e16f),
                         cyaw = fabs(targyaw-d->yaw), cpitch = fabs(targpitch-d->pitch);
             if(cyaw <= d->ai->views[0]*skew && cpitch <= d->ai->views[1]*skew) return true;
         }
diff -Nur sauerbraten-old/src/fpsgame/ai.h sauerbraten/src/fpsgame/ai.h
--- sauerbraten-old/src/fpsgame/ai.h	2009-07-24 15:18:29.152203234 +0300
+++ sauerbraten/src/fpsgame/ai.h	2009-06-06 23:59:46.000000000 +0300
@@ -18,7 +18,7 @@
     const float JUMPMIN         = CLOSEDIST*0.25f;                  // decides to jump
     const float JUMPMAX         = CLOSEDIST*1.5f;                   // max jump
     const float SIGHTMIN        = CLOSEDIST*2.f;                    // minimum line of sight
-    const float SIGHTMAX        = CLOSEDIST*256.f;                  // maximum line of sight
+    const float SIGHTMAX        = CLOSEDIST*64.f;                  // maximum line of sight
     const float VIEWMIN         = 70.f;                             // minimum field of view
     const float VIEWMAX         = 150.f;                            // maximum field of view
 
diff -Nur sauerbraten-old/src/fpsgame/client.cpp sauerbraten/src/fpsgame/client.cpp
--- sauerbraten-old/src/fpsgame/client.cpp	2009-07-24 15:18:29.153203186 +0300
+++ sauerbraten/src/fpsgame/client.cpp	2009-06-20 06:43:46.000000000 +0300
@@ -160,7 +160,7 @@
         return d ? d->team : "";
     }
     ICOMMAND(getclientteam, "i", (int *cn), result(getclientteam(*cn)));
-    
+
     int getclientmodel(int cn)
     {
         fpsent *d = getclient(cn);
@@ -180,10 +180,18 @@
     bool isspectator(int cn)
     {
         fpsent *d = getclient(cn);
-        return d->state==CS_SPECTATOR;
+        return d ? (d->state==CS_SPECTATOR) : false;
     }
     ICOMMAND(isspectator, "i", (int *cn), intret(isspectator(*cn) ? 1 : 0));
 
+    bool isai(int cn, int type)
+    {
+        fpsent *d = getclient(cn);
+        int aitype = type > 0 && type < AI_MAX ? type : AI_BOT;
+        return d ? (d->aitype==aitype) : false;
+    }
+    ICOMMAND(isai, "ii", (int *cn, int *type), intret(isai(*cn, *type) ? 1 : 0));
+
     int parseplayer(const char *arg)
     {
         char *end;
@@ -1428,7 +1436,7 @@
                 copystring(oldname, getclientmap());
                 defformatstring(mname)("getmap_%d", lastmillis);
                 defformatstring(fname)("packages/base/%s.ogz", mname);
-                stream *map = openrawfile(fname, "wb");
+                stream *map = openrawfile(path(fname), "wb");
                 if(!map) return;
                 conoutf("received map");
                 map->write(data, len);
@@ -1513,7 +1521,7 @@
         defformatstring(mname)("sendmap_%d", lastmillis);
         save_world(mname, true);
         defformatstring(fname)("packages/base/%s.ogz", mname);
-        stream *map = openrawfile(fname, "rb");
+        stream *map = openrawfile(path(fname), "rb");
         if(map)
         {
             int len = map->size();
diff -Nur sauerbraten-old/src/fpsgame/ctf.h sauerbraten/src/fpsgame/ctf.h
--- sauerbraten-old/src/fpsgame/ctf.h	2009-07-24 15:18:29.152203234 +0300
+++ sauerbraten/src/fpsgame/ctf.h	2009-06-06 23:59:46.000000000 +0300
@@ -173,7 +173,7 @@
 
 #ifdef SERVMODE
     static const int RESETFLAGTIME = 10000;
-    static const int INVISFLAGTIME = 15000;
+    static const int INVISFLAGTIME = 20000;
 
     bool notgotflags;
 
diff -Nur sauerbraten-old/src/fpsgame/fps.cpp sauerbraten/src/fpsgame/fps.cpp
--- sauerbraten-old/src/fpsgame/fps.cpp	2009-07-24 15:18:29.151203135 +0300
+++ sauerbraten/src/fpsgame/fps.cpp	2009-06-06 23:59:46.000000000 +0300
@@ -334,7 +334,7 @@
 
         if(local) damage = d->dodamage(damage);
         else if(actor==player1) return;
-  
+
         fpsent *h = hudplayer();
         if(h!=player1 && actor==h && d!=actor)
         {
@@ -507,7 +507,6 @@
 
     void startgame()
     {
-        respawnent = -1;
         clearmovables();
         clearmonsters();
 
@@ -533,7 +532,7 @@
         intermission = false;
         maptime = 0;
 
-        if(cmode) 
+        if(cmode)
         {
             cmode->preload();
             cmode->setup();
@@ -567,6 +566,7 @@
         ai::savewaypoints();
         ai::clearwaypoints(true);
 
+        respawnent = -1; // so we don't respawn at an old spot
         if(!m_mp(gamemode)) spawnplayer(player1);
         else findplayerspawn(player1, -1);
         entities::resetspawns();
@@ -596,7 +596,7 @@
             addmsg(SV_SOUND, "ci", d, n);
             playsound(n);
         }
-        else 
+        else
         {
             if(d->type==ENT_PLAYER && ((fpsent *)d)->ai)
                 addmsg(SV_SOUND, "ci", d, n);
diff -Nur sauerbraten-old/src/fpsgame/game.h sauerbraten/src/fpsgame/game.h
--- sauerbraten-old/src/fpsgame/game.h	2009-07-24 15:18:29.152203234 +0300
+++ sauerbraten/src/fpsgame/game.h	2009-06-06 23:59:46.000000000 +0300
@@ -93,9 +93,9 @@
     { "coop edit", M_EDIT, "Cooperative Editing: Edit maps with multiple players simultaneously." },
     { "teamplay", M_TEAM | M_OVERTIME, "Teamplay: Collect items for ammo. Frag \fs\f3the enemy team\fr to score points for \fs\f1your team\fr." },
     { "instagib", M_NOITEMS | M_INSTA, "Instagib: You spawn with full rifle ammo and die instantly from one shot. There are no items. Frag everyone to score points." },
-    { "instagib team", M_NOITEMS | M_INSTA | M_TEAM | M_OVERTIME, "Instagib: You spawn with full rifle ammo and die instantly from one shot. There are no items. Frag \fs\f3the enemy team\fr to score points for \fs\f1your team\fr." },
+    { "instagib team", M_NOITEMS | M_INSTA | M_TEAM | M_OVERTIME, "Instagib Team: You spawn with full rifle ammo and die instantly from one shot. There are no items. Frag \fs\f3the enemy team\fr to score points for \fs\f1your team\fr." },
     { "efficiency", M_NOITEMS | M_EFFICIENCY, "Efficiency: You spawn with all weapons and armour. There are no items. Frag everyone to score points." },
-    { "efficiency team", M_NOITEMS | M_EFFICIENCY | M_TEAM | M_OVERTIME, "Efficiency: You spawn with all weapons and armour. There are no items. Frag \fs\f3the enemy team\fr to score points for \fs\f1your team\fr." },
+    { "efficiency team", M_NOITEMS | M_EFFICIENCY | M_TEAM | M_OVERTIME, "Efficiency Team: You spawn with all weapons and armour. There are no items. Frag \fs\f3the enemy team\fr to score points for \fs\f1your team\fr." },
     { "tactics", M_NOITEMS | M_TACTICS, "Tactics: You spawn with two random weapons and armour. There are no items. Frag everyone to score points." },
     { "tactics team", M_NOITEMS | M_TACTICS | M_TEAM | M_OVERTIME, "Tactics Team: You spawn with two random weapons and armour. There are no items. Frag \fs\f3the enemy team\fr to score points for \fs\f1your team\fr." },
     { "capture", M_NOAMMO | M_TACTICS | M_CAPTURE | M_TEAM | M_OVERTIME, "Capture: Capture neutral bases or steal \fs\f3enemy bases\fr by standing next to them.  \fs\f1Your team\fr scores points for every 10 seconds it holds a base. You spawn with two random weapons and armour. Collect extra ammo that spawns at \fs\f1your bases\fr. There are no ammo items." },
diff -Nur sauerbraten-old/src/fpsgame/server.cpp sauerbraten/src/fpsgame/server.cpp
--- sauerbraten-old/src/fpsgame/server.cpp	2009-07-24 15:18:29.152203234 +0300
+++ sauerbraten/src/fpsgame/server.cpp	2009-06-20 06:43:27.000000000 +0300
@@ -312,6 +312,7 @@
     #define MM_AUTOAPPROVE 0x1000
     #define MM_PRIVSERV (MM_MODE | MM_AUTOAPPROVE)
     #define MM_PUBSERV ((1<<MM_OPEN) | (1<<MM_VETO))
+    #define MM_COOPSERV (MM_AUTOAPPROVE | MM_PUBSERV | (1<<MM_LOCKED))
 
     bool notgotitems = true;        // true when map has changed and waiting for clients to send item
     int gamemode = 0;
@@ -386,7 +387,14 @@
     SVAR(serverdesc, "");
     SVAR(serverpass, "");
     SVAR(adminpass, "");
-    VARF(publicserver, 0, 0, 1, { mastermask = publicserver ? MM_PUBSERV : MM_PRIVSERV; });
+    VARF(publicserver, 0, 0, 2, {
+		switch(publicserver)
+		{
+			case 0: default: mastermask = MM_PRIVSERV; break;
+			case 1: mastermask = MM_PUBSERV; break;
+			case 2: mastermask = MM_COOPSERV; break;
+		}
+	});
     SVAR(servermotd, "");
 
     void *newclientinfo() { return new clientinfo; }
@@ -1471,7 +1479,7 @@
             if(!target || target->state.state!=CS_ALIVE || h.lifesequence!=target->state.lifesequence || h.dist<0 || h.dist>RL_DAMRAD) continue;
 
             bool dup = false;
-            loopj(i) if(hits[i].target==h.target) { dup = true; break; }
+            loopj(i) if(hits[j].target==h.target) { dup = true; break; }
             if(dup) continue;
 
             int damage = guns[gun].damage;
@@ -2200,7 +2208,7 @@
             case SV_MAPCHANGE:
             {
                 getstring(text, p);
-                filtertext(text, text);
+                filtertext(text, text, false);
                 int reqmode = getint(p);
                 if(type!=SV_MAPVOTE && !mapreload) break;
                 vote(text, reqmode, sender);
diff -Nur sauerbraten-old/src/fpsgame/waypoint.cpp sauerbraten/src/fpsgame/waypoint.cpp
--- sauerbraten-old/src/fpsgame/waypoint.cpp	2009-07-24 15:18:29.152203234 +0300
+++ sauerbraten/src/fpsgame/waypoint.cpp	2009-06-06 23:59:46.000000000 +0300
@@ -126,6 +126,8 @@
 
     int closestwaypoint(const vec &pos, float mindist, bool links)
     {
+        if(waypoints.empty()) return -1;
+
         if(wpcachedepth<0) buildwpcache();
 
         wpcachestack.setsizenodelete(0);
@@ -179,6 +181,8 @@
 
     void findwaypointswithin(const vec &pos, float mindist, float maxdist, vector<int> &results)
     {
+        if(waypoints.empty()) return;
+
         float mindist2 = mindist*mindist, maxdist2 = maxdist*maxdist;
 
         if(wpcachedepth<0) buildwpcache();
@@ -230,6 +234,8 @@
 
     void avoidset::avoidnear(void *owner, float above, const vec &pos, float limit)
     {
+        if(waypoints.empty()) return;
+
         float limit2 = limit*limit;
 
         if(wpcachedepth<0) buildwpcache();
@@ -570,61 +576,6 @@
         waypoints.setsizenodelete(total);
     }
 
-    void mergewaypoints()
-    {
-        if(!waypointmergepasses) return;
-        float mindist = WAYPOINTRADIUS*waypointmergescale;
-        mindist *= mindist;
-        int totalmerges = 0, totalpasses = 0, merges = 0;
-        do
-        {
-            merges = 0;
-            for(int j = 1; j < waypoints.length(); j++)
-            {
-                waypoint &w = waypoints[j];
-                if(w.links[1] == 0xFFFF) continue;
-                vec o = w.o;
-                int curmerges = 0;
-                for(int k = 1; k < waypoints.length(); k++) if(k != j)
-                {
-                    waypoint &v = waypoints[k];
-                    if(v.links[1] != 0xFFFF && w.o.squaredist(v.o) <= mindist)
-                    {
-                        loopi(MAXWAYPOINTLINKS)
-                        {
-                            int link = v.links[i];
-                            if(!link) break;
-                            if(link != j) linkwaypoint(w, link);
-                        }
-                        for(int i = 1; i < waypoints.length(); i++) if(i != k)
-                        {
-                            waypoint &u = waypoints[i];
-                            if(u.links[1] != 0xFFFF) relinkwaypoint(u, k, j);
-                        }
-                        v.links[0] = 0;
-                        v.links[1] = 0xFFFF;
-                        o.add(v.o);
-                        curmerges++;
-                    }
-                }
-                if(curmerges)
-                {
-                    w.o = o.div(curmerges + 1);
-                    merges += curmerges;
-                }
-            }
-            totalpasses++;
-            totalmerges += merges;
-        } while(merges && totalpasses < waypointmergepasses);
-        if(totalmerges)
-        {
-            remapwaypoints();
-            clearwpcache();
-            conoutf("merged %d waypoints in %d passes", totalmerges, totalpasses);
-        }
-
-    }
-
     bool getwaypointfile(const char *mname, char *wptname)
     {
         if(!mname || !*mname) mname = getclientmap();
@@ -679,8 +630,6 @@
         string wptname;
         if(!getwaypointfile(mname, wptname)) return;
 
-        mergewaypoints();
-
         stream *f = opengzfile(wptname, "wb");
         if(!f) return;
         f->write("OWPT", 4);
diff -Nur sauerbraten-old/src/fpsgame/weapon.cpp sauerbraten/src/fpsgame/weapon.cpp
--- sauerbraten-old/src/fpsgame/weapon.cpp	2009-07-24 15:18:29.152203234 +0300
+++ sauerbraten/src/fpsgame/weapon.cpp	2009-06-06 23:59:46.000000000 +0300
@@ -200,7 +200,7 @@
             bnc.offset = hudgunorigin(GUN_GL, from, to, owner);
             if(owner==hudplayer() && !isthirdperson()) bnc.offset.sub(owner->o).rescale(16).add(owner->o);
         }
-        else bnc.offset = from; 
+        else bnc.offset = from;
         bnc.offset.sub(bnc.o);
         bnc.offsetmillis = OFFSETMILLIS;
 
@@ -212,7 +212,7 @@
         loopv(bouncers)
         {
             bouncent &bnc = *bouncers[i];
-            if(bnc.bouncetype==BNC_GRENADE && bnc.vel.magnitude() > 50.0f) 
+            if(bnc.bouncetype==BNC_GRENADE && bnc.vel.magnitude() > 50.0f)
             {
                 vec pos(bnc.o);
                 pos.add(vec(bnc.offset).mul(bnc.offsetmillis/float(OFFSETMILLIS)));
@@ -237,7 +237,7 @@
                 {
                     int qdam = guns[GUN_GL].damage*(bnc.owner->quadmillis ? 4 : 1);
                     hits.setsizenodelete(0);
-                    explode(bnc.local, bnc.owner, bnc.o, NULL, qdam, GUN_GL);                    
+                    explode(bnc.local, bnc.owner, bnc.o, NULL, qdam, GUN_GL);
                     adddecal(DECAL_SCORCH, bnc.o, vec(0, 0, 1), RL_DAMRAD/2);
                     if(bnc.local)
                         addmsg(SV_EXPLODE, "rci3iv", bnc.owner, lastmillis-maptime, GUN_GL, bnc.id-maptime,
@@ -292,8 +292,8 @@
         p.id = lastmillis;
     }
 
-    void removeprojectiles(fpsent *owner) 
-    { 
+    void removeprojectiles(fpsent *owner)
+    {
         // can't use loopv here due to strange GCC optimizer bug
         int len = projs.length();
         loopi(len) if(projs[i].owner==owner) { projs.remove(i--); len--; }
@@ -312,21 +312,21 @@
             particle_text(d->abovehead(), ds, PART_TEXT, 2000, 0xFF4B19, 4.0f, -8);
         }
     }
-    
+
     void spawnbouncer(const vec &p, const vec &vel, fpsent *d, int type, entitylight *light = NULL)
     {
         vec to(rnd(100)-50, rnd(100)-50, rnd(100)-50);
         to.normalize();
         to.add(p);
         newbouncer(p, to, true, d, type, rnd(1000)+1000, rnd(100)+20, light);
-    }    
+    }
 
     void superdamageeffect(const vec &vel, fpsent *d)
     {
         if(!d->superdamage) return;
         vec from = d->abovehead();
         from.y -= 16;
-        loopi(min(d->superdamage/25, 40)+1) spawnbouncer(from, vel, d, BNC_GIBS);
+        if(blood) loopi(min(d->superdamage/25, 40)+1) spawnbouncer(from, vel, d, BNC_GIBS);
     }
 
     void hit(int damage, dynent *d, fpsent *at, const vec &vel, int gun, int info = 1)
@@ -336,9 +336,9 @@
             extern int hitsound;
             if(hitsound && lasthit != lastmillis) playsound(S_HIT);
             lasthit = lastmillis;
-        } 
+        }
 
-        if(d->type==ENT_INANIMATE) 
+        if(d->type==ENT_INANIMATE)
         {
             hitmovable(damage, (movable *)d, at, vel, gun);
             return;
@@ -354,8 +354,8 @@
 
         if(f->type==ENT_AI) hitmonster(damage, (monster *)f, at, vel, gun);
         else if(!m_mp(gamemode)) damaged(damage, f, at);
-        else 
-        { 
+        else
+        {
             hitmsg &h = hits.add();
             h.target = f->clientnum;
             h.lifesequence = f->lifesequence;
@@ -370,7 +370,7 @@
                     damagecompass(damage, at ? at->o : f->o);
                     playsound(S_PAIN6);
                 }
-                else playsound(S_PAIN1+rnd(5), &f->o); 
+                else playsound(S_PAIN1+rnd(5), &f->o);
             }
         }
     }
@@ -398,10 +398,10 @@
         if(o->state!=CS_ALIVE) return;
         vec dir;
         float dist = projdist(o, dir, v);
-        if(dist<RL_DAMRAD) 
+        if(dist<RL_DAMRAD)
         {
             int damage = (int)(qdam*(1-dist/RL_DISTSCALE/RL_DAMRAD));
-            if(gun==GUN_RL && o==at) damage /= RL_SELFDAMDIV; 
+            if(gun==GUN_RL && o==at) damage /= RL_SELFDAMDIV;
             hit(damage, o, at, dir, gun, int(dist*DMF));
         }
     }
@@ -469,7 +469,7 @@
             if(p.owner->type==ENT_AI) qdam /= MONSTERDAMAGEFACTOR;
             vec v;
             float dist = p.to.dist(p.o, v);
-            float dtime = dist*1000/p.speed; 
+            float dtime = dist*1000/p.speed;
             if(time > dtime) dtime = time;
             v.mul(time/dtime);
             v.add(p.o);
@@ -495,8 +495,8 @@
                     projsplash(p, v, NULL, qdam);
                     exploded = true;
                 }
-                else 
-                {   
+                else
+                {
                     vec pos(v);
                     pos.add(vec(p.offset).mul(p.offsetmillis/float(OFFSETMILLIS)));
                     if(guns[p.gun].part)
@@ -510,9 +510,9 @@
                          particle_splash(guns[p.gun].part, 1, 1, pos, color, 4.8f, 150, 20);
                     }
                     else regular_particle_splash(PART_SMOKE, 2, 300, pos, 0x404040, 2.4f, 50, -20);
-                }   
+                }
             }
-            if(exploded) 
+            if(exploded)
             {
                 if(p.local)
                     addmsg(SV_EXPLODE, "rci3iv", p.owner, lastmillis-maptime, p.gun, p.id-maptime,
@@ -560,7 +560,7 @@
                 if(muzzleflash && d->muzzle.x >= 0)
                     particle_flare(d->muzzle, d->muzzle, gun==GUN_CG ? 100 : 200, PART_MUZZLE_FLASH1, 0xFFFFFF, gun==GUN_CG ? 2.25f : 1.25f, d);
                 if(!local) adddecal(DECAL_BULLET, to, vec(from).sub(to).normalize(), 2.0f);
-                if(muzzlelight) adddynlight(hudgunorigin(gun, d->o, to, d), gun==GUN_CG ? 30 : 15, vec(0.5f, 0.375f, 0.25f), gun==GUN_CG ? 50 : 100, gun==GUN_CG ? 50 : 100, DL_FLASH, 0, vec(0, 0, 0), d); 
+                if(muzzlelight) adddynlight(hudgunorigin(gun, d->o, to, d), gun==GUN_CG ? 30 : 15, vec(0.5f, 0.375f, 0.25f), gun==GUN_CG ? 50 : 100, gun==GUN_CG ? 50 : 100, DL_FLASH, 0, vec(0, 0, 0), d);
                 break;
             }
 
@@ -587,7 +587,7 @@
                 break;
             }
 
-            case GUN_RIFLE: 
+            case GUN_RIFLE:
                 particle_splash(PART_SPARK, 200, 250, to, 0xB49B4B, 0.24f);
                 particle_trail(PART_SMOKE, 500, hudgunorigin(gun, from, to, d), to, 0x404040, 0.6f, 20);
                 if(muzzleflash && d->muzzle.x >= 0)
@@ -610,7 +610,7 @@
             default:
                 playsound(sound, d==hudplayer() ? NULL : &d->o);
                 break;
-        } 
+        }
         if(d->quadmillis && lastmillis-prevaction>200 && !looped) playsound(S_ITEMPUP, d==hudplayer() ? NULL : &d->o);
     }
 
@@ -700,14 +700,14 @@
                 if(hitrays) hitpush(hitrays*qdam, o, d, from, to, d->gunselect, hitrays);
                 if(!raysleft) break;
             }
-            loopj(SGRAYS) if(!done[j]) adddecal(DECAL_BULLET, sg[j], vec(from).sub(sg[j]).normalize(), 2.0f); 
+            loopj(SGRAYS) if(!done[j]) adddecal(DECAL_BULLET, sg[j], vec(from).sub(sg[j]).normalize(), 2.0f);
         }
         else if((o = intersectclosest(from, to, d)))
         {
             hitpush(qdam, o, d, from, to, d->gunselect, 1);
             shorten(from, o->o, to);
         }
-        else if(d->gunselect!=GUN_FIST && d->gunselect!=GUN_BITE) adddecal(DECAL_BULLET, to, vec(from).sub(to).normalize(), d->gunselect==GUN_RIFLE ? 3.0f : 2.0f); 
+        else if(d->gunselect!=GUN_FIST && d->gunselect!=GUN_BITE) adddecal(DECAL_BULLET, to, vec(from).sub(to).normalize(), d->gunselect==GUN_RIFLE ? 3.0f : 2.0f);
     }
 
     void shoot(fpsent *d, const vec &targ)
@@ -718,16 +718,16 @@
         if((d==player1 || d->ai) && !d->attacking) return;
         d->lastaction = lastmillis;
         d->lastattackgun = d->gunselect;
-        if(!d->ammo[d->gunselect]) 
-        { 
+        if(!d->ammo[d->gunselect])
+        {
             if(d==player1)
             {
-                msgsound(S_NOAMMO, d); 
-                d->gunwait = 600; 
-                d->lastattackgun = -1; 
-                weaponswitch(d); 
+                msgsound(S_NOAMMO, d);
+                d->gunwait = 600;
+                d->lastattackgun = -1;
+                weaponswitch(d);
             }
-            return; 
+            return;
         }
         if(d->gunselect) d->ammo[d->gunselect]--;
         vec from = d->o;
@@ -751,10 +751,10 @@
             to.mul(shorten);
             to.add(from);
         }
-        
+
         if(d->gunselect==GUN_SG) createrays(from, to);
         else if(d->gunselect==GUN_CG) offsetray(from, to, 1, to);
-            
+
         hits.setsizenodelete(0);
 
         if(!guns[d->gunselect].projspeed) raydamage(from, to, d);
@@ -764,13 +764,13 @@
         if(d==player1 || d->ai)
         {
             addmsg(SV_SHOOT, "rci2i6iv", d, lastmillis-maptime, d->gunselect,
-                   (int)(from.x*DMF), (int)(from.y*DMF), (int)(from.z*DMF), 
+                   (int)(from.x*DMF), (int)(from.y*DMF), (int)(from.z*DMF),
                    (int)(to.x*DMF), (int)(to.y*DMF), (int)(to.z*DMF),
                    hits.length(), hits.length()*sizeof(hitmsg)/sizeof(int), hits.getbuf());
         }
 
-        d->gunwait = guns[d->gunselect].attackdelay;
-
+		d->gunwait = guns[d->gunselect].attackdelay;
+		if(d->gunselect == GUN_PISTOL && d->ai) d->gunwait += int(d->gunwait*(((101-d->skill)+rnd(111-d->skill))/100.f));
         d->totalshots += guns[d->gunselect].damage*(d->quadmillis ? 4 : 1)*(d->gunselect==GUN_SG ? SGRAYS : 1);
     }
 
@@ -830,7 +830,7 @@
             string debrisname;
             int cull = MDL_CULL_VFC|MDL_CULL_DIST|MDL_CULL_OCCLUDED;
             float fade = 1;
-            if(bnc.bouncetype!=BNC_GRENADE && bnc.lifetime < 250) fade = bnc.lifetime/250.0f; 
+            if(bnc.bouncetype!=BNC_GRENADE && bnc.lifetime < 250) fade = bnc.lifetime/250.0f;
             if(bnc.bouncetype==BNC_GIBS) { mdl = ((int)(size_t)&bnc)&0x40 ? "gibc" : "gibh"; cull |= MDL_LIGHT|MDL_DYNSHADOW; }
             else if(bnc.bouncetype==BNC_DEBRIS) { formatstring(debrisname)("debris/debris0%d", ((((int)(size_t)&bnc)&0xC0)>>6)+1); mdl = debrisname; }
             else if(bnc.bouncetype==BNC_BARRELDEBRIS) { formatstring(debrisname)("barreldebris/debris0%d", ((((int)(size_t)&bnc)&0xC0)>>6)+1); mdl = debrisname; }
@@ -838,7 +838,7 @@
             rendermodel(&bnc.light, mdl, ANIM_MAPMODEL|ANIM_LOOP, pos, yaw, pitch, cull, NULL, NULL, 0, 0, fade);
         }
     }
-    
+
     void renderprojectiles()
     {
         float yaw, pitch;
@@ -859,7 +859,7 @@
             v.add(pos);
             rendermodel(&p.light, "projectiles/rocket", ANIM_MAPMODEL|ANIM_LOOP, v, yaw, pitch, MDL_CULL_VFC|MDL_CULL_OCCLUDED|MDL_LIGHT);
         }
-    }  
+    }
 
     void checkattacksound(fpsent *d, bool local)
     {
@@ -888,14 +888,14 @@
         if(d->clientnum >= 0 && d->state == CS_ALIVE) switch(d->gunselect)
         {
             case GUN_FIST:
-                if(chainsawhudgun && d->attacksound < 0) 
+                if(chainsawhudgun && d->attacksound < 0)
                 {
                     sound = S_CHAINSAW_IDLE;
                     radius = 50;
                 }
                 break;
         }
-        if(d->idlesound != sound) 
+        if(d->idlesound != sound)
         {
             if(d->idlesound >= 0) d->stopidlesound();
             if(sound >= 0)
@@ -924,7 +924,7 @@
         updatebouncers(curtime); // need to do this after the player shoots so grenades don't end up inside player's BB next frame
         fpsent *following = followingplayer();
         if(!following) following = player1;
-        loopv(players) 
+        loopv(players)
         {
             fpsent *d = players[i];
             checkattacksound(d, d==following);
diff -Nur sauerbraten-old/src/shared/command.h sauerbraten/src/shared/command.h
--- sauerbraten-old/src/shared/command.h	2009-07-24 15:18:29.161203400 +0300
+++ sauerbraten/src/shared/command.h	2009-06-07 00:00:42.000000000 +0300
@@ -77,10 +77,10 @@
     { val.s = c; storage.s = s; }
     // ID_ALIAS
     ident(int t, const char *n, char *a, int flags)
-        : type(t), name(n), override(NO_OVERRIDE), stack(NULL), action(a), flags(flags) {}
+        : type(t), name(n), override(NO_OVERRIDE), stack(NULL), action(a), isexecuting(NULL), flags(flags) {}
     // ID_COMMAND, ID_CCOMMAND
     ident(int t, const char *n, const char *narg, void *f = NULL, void *s = NULL, int flags = 0)
-        : type(t), name(n), fun((void (__cdecl *)(void))f), narg(narg), self(s), flags(flags) {}
+        : type(t), name(n), override(NO_OVERRIDE), fun((void (__cdecl *)(void))f), narg(narg), self(s), flags(flags) {}
 
     virtual ~ident() {}        
 
diff -Nur sauerbraten-old/src/shared/crypto.cpp sauerbraten/src/shared/crypto.cpp
--- sauerbraten-old/src/shared/crypto.cpp	2009-07-24 15:18:29.161203400 +0300
+++ sauerbraten/src/shared/crypto.cpp	2009-06-20 06:27:56.000000000 +0300
@@ -146,6 +146,14 @@
         while(j < 56) temp[j++] = 0;
         *(chunk *)(temp+56) = (chunk)length<<3;
         compress((chunk *)temp, val.chunks);
+        if(!*(const uchar *)&islittleendian)
+        {
+            loopk(3) 
+            {
+                uchar *c = &val.bytes[k*sizeof(chunk)];
+                loopl(sizeof(chunk)/2) swap(c[l], c[sizeof(chunk)-1-l]);
+            }
+        }
     }
 }
 
diff -Nur sauerbraten-old/src/shared/tools.h sauerbraten/src/shared/tools.h
--- sauerbraten-old/src/shared/tools.h	2009-07-24 15:18:29.161203400 +0300
+++ sauerbraten/src/shared/tools.h	2009-06-07 00:00:42.000000000 +0300
@@ -764,6 +764,14 @@
 template<class T> inline void bigswap(T *buf, int len) { if(*(const uchar *)&islittleendian) endianswap(buf, len); }
 #endif
 
+/* workaround for some C platforms that have these two functions as macros - not used anywhere */
+#ifdef getchar
+#undef getchar
+#endif
+#ifdef putchar
+#undef putchar
+#endif
+
 struct stream
 {
     virtual ~stream() {}
