From fe964c832dab4b296abc2720aa56a2742fa49f35 Mon Sep 17 00:00:00 2001
From: John Schoenick <john@pointysoftware.net>
Date: Fri, 23 Sep 2011 13:46:05 -0700
Subject: [PATCH] Merge wine multimedia-git onto 1.3.29

---
 configure                                  |  214 ++-
 configure.ac                               |   73 +-
 dlls/dsound/Makefile.in                    |    8 +-
 dlls/dsound/alext.h                        |  183 ++
 dlls/dsound/buffer.c                       | 3410 +++++++++++++++++++---------
 dlls/dsound/capture.c                      | 1727 +++++---------
 dlls/dsound/dsound.c                       | 2190 +++++-------------
 dlls/dsound/dsound_convert.c               |  546 -----
 dlls/dsound/dsound_main.c                  |  780 +++++--
 dlls/dsound/dsound_private.h               |  755 ++++---
 dlls/dsound/duplex.c                       |    5 +-
 dlls/dsound/eax.h                          |  167 ++
 dlls/dsound/efx.h                          |  758 ++++++
 dlls/dsound/mixer.c                        | 1062 ---------
 dlls/dsound/primary.c                      | 2775 ++++++++++++++---------
 dlls/dsound/propset.c                      |  223 ++-
 dlls/dsound/sound3d.c                      | 1089 ---------
 dlls/mciqtz32/mciqtz.c                     |  110 +-
 dlls/ntdll/directory.c                     |    2 +
 dlls/ntdll/heap.c                          |    7 +-
 dlls/ntdll/ntdll_misc.h                    |    3 +-
 dlls/ntdll/server.c                        |   10 +-
 dlls/ntdll/thread.c                        |    1 +
 dlls/ntdll/virtual.c                       |  346 +++-
 dlls/quartz/parser.c                       |    2 +
 dlls/winealsa.drv/mmdevdrv.c               |   29 +-
 dlls/winealsa.drv/waveout.c                | 1480 ++++--------
 dlls/winegstreamer/gsttffilter.c           |  128 +-
 dlls/winemmaudio.drv/Makefile.in           |    9 +
 dlls/winemmaudio.drv/capture.c             |  546 +++++
 dlls/winemmaudio.drv/coreaudio.h           |   32 +
 dlls/winemmaudio.drv/mmaudio.c             |  125 +
 dlls/winemmaudio.drv/render.c              |  662 ++++++
 dlls/winemmaudio.drv/winemmaudio.drv.spec  |    4 +
 dlls/winepulse.drv/Makefile.in             |    9 +
 dlls/winepulse.drv/mmdevdrv.c              | 2087 +++++++++++++++++
 dlls/winepulse.drv/winepulse.drv.spec      |    4 +
 include/config.h.in                        |    3 +
 include/wine/library.h                     |    6 +
 libs/wine/loader.c                         |   27 +
 libs/wine/mmap.c                           |   34 +-
 libs/wine/wine.map                         |    6 +
 loader/main.c                              |   89 +-
 programs/winecfg/Makefile.in               |    1 -
 programs/winecfg/audio.c                   |  223 --
 programs/winecfg/main.c                    |   12 +-
 programs/winecfg/winecfg.h                 |    1 -
 programs/winemenubuilder/winemenubuilder.c |    2 +-
 server/Makefile.in                         |    2 +
 server/rtkit.c                             |  182 ++
 server/thread.c                            |   16 +
 51 files changed, 12479 insertions(+), 9686 deletions(-)
 create mode 100644 dlls/dsound/alext.h
 delete mode 100644 dlls/dsound/dsound_convert.c
 create mode 100644 dlls/dsound/eax.h
 create mode 100644 dlls/dsound/efx.h
 delete mode 100644 dlls/dsound/mixer.c
 delete mode 100644 dlls/dsound/sound3d.c
 create mode 100644 dlls/winemmaudio.drv/Makefile.in
 create mode 100644 dlls/winemmaudio.drv/capture.c
 create mode 100644 dlls/winemmaudio.drv/coreaudio.h
 create mode 100644 dlls/winemmaudio.drv/mmaudio.c
 create mode 100644 dlls/winemmaudio.drv/render.c
 create mode 100644 dlls/winemmaudio.drv/winemmaudio.drv.spec
 create mode 100644 dlls/winepulse.drv/Makefile.in
 create mode 100644 dlls/winepulse.drv/mmdevdrv.c
 create mode 100644 dlls/winepulse.drv/winepulse.drv.spec
 delete mode 100644 programs/winecfg/audio.c
 create mode 100644 server/rtkit.c

diff --git a/configure b/configure
index d8c8d4b..b9ce858 100755
--- a/configure
+++ b/configure
@@ -628,6 +628,8 @@ OSS4INCL
 ALSALIBS
 GSTREAMER_INCL
 GSTREAMER_LIBS
+PULSEINCL
+PULSELIBS
 LIBGETTEXTPO
 ZLIB
 FREETYPEINCL
@@ -642,6 +644,7 @@ gphoto2_devel
 SANEINCL
 sane_devel
 GNUTLSINCL
+DBUSINCL
 HALINCL
 XSLTINCL
 XML2INCL
@@ -780,6 +783,7 @@ with_cms
 with_coreaudio
 with_cups
 with_curses
+with_dbus
 with_fontconfig
 with_freetype
 with_gettextpo
@@ -799,6 +803,7 @@ with_openssl
 with_oss
 with_png
 with_pthread
+with_pulse
 with_sane
 with_tiff
 with_v4l
@@ -1469,6 +1474,7 @@ Optional Packages:
   --without-coreaudio     do not use the CoreAudio sound support
   --without-cups          do not use CUPS
   --without-curses        do not use (n)curses
+  --without-dbus          do not use dbus (will also disable HAL support)
   --without-fontconfig    do not use fontconfig
   --without-freetype      do not use the FreeType library
   --without-gettextpo     do not use the GetTextPO library
@@ -1488,6 +1494,7 @@ Optional Packages:
   --without-oss           do not use the OSS sound support
   --without-png           do not use PNG
   --without-pthread       do not use the pthread library
+  --without-pulse         do not use PulseAudio sound support
   --without-sane          do not use SANE (scanner support)
   --without-tiff          do not use TIFF
   --without-v4l           do not use v4l1 (v4l support)
@@ -2547,6 +2554,12 @@ if test "${with_curses+set}" = set; then :
 fi
 
 
+# Check whether --with-dbus was given.
+if test "${with_dbus+set}" = set; then :
+  withval=$with_dbus;
+fi
+
+
 # Check whether --with-fontconfig was given.
 if test "${with_fontconfig+set}" = set; then :
   withval=$with_fontconfig; if test "x$withval" = "xno"; then ac_cv_header_fontconfig_fontconfig_h=no; fi
@@ -2661,6 +2674,12 @@ if test "${with_pthread+set}" = set; then :
 fi
 
 
+# Check whether --with-pulse was given.
+if test "${with_pulse+set}" = set; then :
+  withval=$with_pulse;
+fi
+
+
 # Check whether --with-sane was given.
 if test "${with_sane+set}" = set; then :
   withval=$with_sane;
@@ -9378,38 +9397,40 @@ fi
 
 HALINCL=""
 
-if test "x$with_hal" != "xno"
+DBUSINCL=""
+
+
+if test "x$with_dbus" != "xno"
 then
     ac_save_CPPFLAGS="$CPPFLAGS"
     if test "$PKG_CONFIG" != "false"
     then
-        ac_hal_libs="`$PKG_CONFIG --libs hal 2>/dev/null`"
-        ac_hal_cflags="`$PKG_CONFIG --cflags hal 2>/dev/null`"
-        CPPFLAGS="$CPPFLAGS $ac_hal_cflags"
+        ac_dbus_libs="`$PKG_CONFIG --libs dbus-1 2>/dev/null`"
+        ac_dbus_cflags="`$PKG_CONFIG --cflags dbus-1 2>/dev/null`"
+        CPPFLAGS="$CPPFLAGS $ac_dbus_cflags"
     fi
-    for ac_header in dbus/dbus.h hal/libhal.h
+    for ac_header in dbus/dbus.h
 do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  ac_fn_c_check_header_mongrel "$LINENO" "dbus/dbus.h" "ac_cv_header_dbus_dbus_h" "$ac_includes_default"
+if test "x$ac_cv_header_dbus_dbus_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_DBUS_DBUS_H 1
 _ACEOF
 
 fi
 
 done
 
-    if test "$ac_cv_header_dbus_dbus_h" = "yes" -a "$ac_cv_header_hal_libhal_h" = "yes"
+    if test "$ac_cv_header_dbus_dbus_h" = "yes"
     then
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dbus_connection_close in -ldbus-1" >&5
-$as_echo_n "checking for dbus_connection_close in -ldbus-1... " >&6; }
-if ${ac_cv_lib_dbus_1_dbus_connection_close+:} false; then :
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -ldbus-1" >&5
+$as_echo_n "checking for -ldbus-1... " >&6; }
+if ${ac_cv_lib_soname_dbus_1+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldbus-1 $ac_hal_libs $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-ldbus-1 $ac_dbus_libs $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -9428,18 +9449,67 @@ return dbus_connection_close ();
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dbus_1_dbus_connection_close=yes
-else
-  ac_cv_lib_dbus_1_dbus_connection_close=no
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_dbus_1=`$ac_cv_path_LDD conftest.exe | grep "dbus-1" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_dbus_1=`otool -L conftest$ac_exeext | grep "libdbus-1\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libdbus-1\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_dbus_1=`$ac_cv_path_LDD conftest$ac_exeext | grep "libdbus-1\\.$LIBEXT" | sed -e "s/^.*\(libdbus-1\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'` ;;
+  esac
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if test "x$ac_cv_lib_soname_dbus_1" = "x"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_dbus_1" >&5
+$as_echo "$ac_cv_lib_soname_dbus_1" >&6; }
+
+cat >>confdefs.h <<_ACEOF
+#define SONAME_LIBDBUS_1 "$ac_cv_lib_soname_dbus_1"
+_ACEOF
+
+       DBUSINCL="$ac_dbus_cflags"
+fi
+    fi
+
+    CPPFLAGS="$ac_save_CPPFLAGS"
+fi
+if test "x$ac_cv_lib_soname_dbus_1" = "x" -a "x$ac_cv_header_DiskArbitration_DiskArbitration_h" != "xyes"; then :
+  case "x$with_dbus" in
+  x)   as_fn_append wine_notices "|libdbus and libhal ${notice_platform}development files not found, HAL and rtkit support disabled" ;;
+  xno) ;;
+  *)   as_fn_error $? "libdbus and libhal ${notice_platform}development files not found, HAL and rtkit support disabled
+This is an error since --with-dbus was requested." "$LINENO" 5 ;;
+esac
+fi
+
+if test "x$with_hal" != "xno" -a "x$ac_cv_lib_soname_dbus_1" != "x"
+then
+    ac_save_CPPFLAGS="$CPPFLAGS"
+    if test "$PKG_CONFIG" != "false"
+    then
+        ac_hal_libs="`$PKG_CONFIG --libs hal 2>/dev/null`"
+        ac_hal_cflags="`$PKG_CONFIG --cflags hal 2>/dev/null`"
+        CPPFLAGS="$CPPFLAGS $ac_hal_cflags"
+    fi
+    for ac_header in hal/libhal.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "hal/libhal.h" "ac_cv_header_hal_libhal_h" "$ac_includes_default"
+if test "x$ac_cv_header_hal_libhal_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_HAL_LIBHAL_H 1
+_ACEOF
+
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dbus_1_dbus_connection_close" >&5
-$as_echo "$ac_cv_lib_dbus_1_dbus_connection_close" >&6; }
-if test "x$ac_cv_lib_dbus_1_dbus_connection_close" = xyes; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lhal" >&5
+
+done
+
+    if test "$ac_cv_header_hal_libhal_h" = "yes"
+    then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lhal" >&5
 $as_echo_n "checking for -lhal... " >&6; }
 if ${ac_cv_lib_soname_hal+:} false; then :
   $as_echo_n "(cached) " >&6
@@ -9489,16 +9559,14 @@ _ACEOF
 
        HALINCL="$ac_hal_cflags"
 fi
-fi
-
     fi
     CPPFLAGS="$ac_save_CPPFLAGS"
 fi
-if test "x$ac_cv_lib_soname_hal" = "x" -a "x$ac_cv_header_DiskArbitration_DiskArbitration_h" != "xyes"; then :
+if test "x$ac_cv_lib_soname_hal" = "x" -a "x$ac_cv_header_DiskArbitration_DiskArbitration_h" != "xyes" -a "x$ac_cv_lib_soname_dbus_1" != "x"; then :
   case "x$with_hal" in
-  x)   as_fn_append wine_notices "|libhal/libdbus ${notice_platform}development files not found, no dynamic device support." ;;
+  x)   as_fn_append wine_notices "|libhal ${notice_platform}development files not found, no dynamic device support." ;;
   xno) ;;
-  *)   as_fn_error $? "libhal/libdbus ${notice_platform}development files not found, no dynamic device support.
+  *)   as_fn_error $? "libhal ${notice_platform}development files not found, no dynamic device support.
 This is an error since --with-hal was requested." "$LINENO" 5 ;;
 esac
 fi
@@ -10510,6 +10578,87 @@ esac
 fi
 fi
 
+PULSELIBS=""
+
+PULSEINCL=""
+
+if test "x$with_pulse" != "xno";
+then
+    ac_save_CPPFLAGS="$CPPFLAGS"
+    if test "$PKG_CONFIG" != "false";
+    then
+        ac_pulse_libs="`$PKG_CONFIG --libs libpulse 2>/dev/null`"
+        ac_pulse_cflags="`$PKG_CONFIG --cflags-only-I libpulse 2>/dev/null`"
+
+        CPPFLAGS="$CPPFLAGS $ac_pulse_cflags"
+        for ac_header in pulse/pulseaudio.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "pulse/pulseaudio.h" "ac_cv_header_pulse_pulseaudio_h" "$ac_includes_default"
+if test "x$ac_cv_header_pulse_pulseaudio_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_PULSE_PULSEAUDIO_H 1
+_ACEOF
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pa_stream_is_corked in -lpulse" >&5
+$as_echo_n "checking for pa_stream_is_corked in -lpulse... " >&6; }
+if ${ac_cv_lib_pulse_pa_stream_is_corked+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpulse $ac_pulse_libs $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char pa_stream_is_corked ();
+int
+main ()
+{
+return pa_stream_is_corked ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_pulse_pa_stream_is_corked=yes
+else
+  ac_cv_lib_pulse_pa_stream_is_corked=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pulse_pa_stream_is_corked" >&5
+$as_echo "$ac_cv_lib_pulse_pa_stream_is_corked" >&6; }
+if test "x$ac_cv_lib_pulse_pa_stream_is_corked" = xyes; then :
+
+$as_echo "#define HAVE_PULSEAUDIO 1" >>confdefs.h
+
+                 PULSELIBS="$ac_pulse_libs"
+                 PULSEINCL="$ac_pulse_cflags"
+fi
+
+
+fi
+
+done
+
+    fi
+    CPPFLAGS="$ac_save_CPPFLAGS"
+fi
+if test "$ac_cv_lib_pulse_pa_stream_is_corked" != "yes"; then :
+  case "x$with_pulse" in
+  x)   as_fn_append wine_warnings "|libpulse ${notice_platform}development files not found or too old, Pulse won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libpulse ${notice_platform}development files not found or too old, Pulse won't be supported.
+This is an error since --with-pulse was requested." "$LINENO" 5 ;;
+esac
+fi
+
 if test "x$with_gstreamer" != "xno"
 then
     ac_save_CPPFLAGS="$CPPFLAGS"
@@ -11769,12 +11918,13 @@ fi
 
 test -n "$ALSALIBS" || enable_winealsa_drv=${enable_winealsa_drv:-no}
 test -n "$COREAUDIO" || enable_winecoreaudio_drv=${enable_winecoreaudio_drv:-no}
+test -n "$PULSELIBS" || enable_winepulse_drv=${enable_winepulse_drv:-no}
 test "x$ac_cv_member_oss_sysinfo_numaudioengines" = xyes || enable_wineoss_drv=${enable_wineoss_drv:-no}
 test "$ac_cv_header_linux_joystick_h" = "yes" || enable_winejoystick_drv=${enable_winejoystick_drv:-no}
 
-if test "x$ALSALIBS$COREAUDIO" = "x" -a \
+if test "x$ALSALIBS$COREAUDIO$PULSELIBS" = "x" -a \
         "x$ac_cv_member_oss_sysinfo_numaudioengines" != xyes -a \
-        "x$with_alsa$with_coreaudio$with_oss" != xnonono
+        "x$with_alsa$with_coreaudio$with_oss$with_pulse" != xnononono
 then
     as_fn_append wine_warnings "|No sound system was found. Windows applications will be silent."
 fi
@@ -15147,10 +15297,12 @@ wine_fn_config_dll wined3d enable_wined3d implib
 wine_fn_config_dll winegstreamer enable_winegstreamer
 wine_fn_config_dll winejoystick.drv enable_winejoystick_drv
 wine_fn_config_dll winemapi enable_winemapi
+wine_fn_config_dll winemmaudio.drv enable_winemmaudio_drv
 wine_fn_config_dll winemp3.acm enable_winemp3_acm
 wine_fn_config_dll wineoss.drv enable_wineoss_drv
 wine_fn_config_dll wineps.drv enable_wineps_drv install-lib
 wine_fn_config_dll wineps16.drv16 enable_win16
+wine_fn_config_dll winepulse.drv enable_winepulse_drv
 wine_fn_config_dll wineqtdecoder enable_wineqtdecoder
 wine_fn_config_dll winequartz.drv enable_winequartz_drv
 wine_fn_config_dll winex11.drv enable_winex11_drv
diff --git a/configure.ac b/configure.ac
index 1401072..7a0e52b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -42,6 +42,7 @@ AC_ARG_WITH(coreaudio, AS_HELP_STRING([--without-coreaudio],[do not use the Core
 AC_ARG_WITH(cups,      AS_HELP_STRING([--without-cups],[do not use CUPS]))
 AC_ARG_WITH(curses,    AS_HELP_STRING([--without-curses],[do not use (n)curses]),
             [if test "x$withval" = "xno"; then ac_cv_header_ncurses_h=no; ac_cv_header_curses_h=no; fi])
+AC_ARG_WITH(dbus,      AS_HELP_STRING([--without-dbus],[do not use dbus (will also disable HAL support)]))
 AC_ARG_WITH(fontconfig,AS_HELP_STRING([--without-fontconfig],[do not use fontconfig]),
             [if test "x$withval" = "xno"; then ac_cv_header_fontconfig_fontconfig_h=no; fi])
 AC_ARG_WITH(freetype,  AS_HELP_STRING([--without-freetype],[do not use the FreeType library]))
@@ -73,6 +74,7 @@ AC_ARG_WITH(png,       AS_HELP_STRING([--without-png],[do not use PNG]),
             [if test "x$withval" = "xno"; then ac_cv_header_png_h=no; fi])
 AC_ARG_WITH(pthread,   AS_HELP_STRING([--without-pthread],[do not use the pthread library]),
             [if test "x$withval" = "xno"; then ac_cv_header_pthread_h=no; fi])
+AC_ARG_WITH(pulse,     AC_HELP_STRING([--without-pulse],[do not use PulseAudio sound support]))
 AC_ARG_WITH(sane,      AS_HELP_STRING([--without-sane],[do not use SANE (scanner support)]))
 AC_ARG_WITH(tiff,       AS_HELP_STRING([--without-tiff],[do not use TIFF]),
             [if test "x$withval" = "xno"; then ac_cv_header_tiffio_h=no; fi])
@@ -1201,9 +1203,32 @@ fi
 WINE_WARNING_WITH(xslt,[test "x$ac_cv_lib_soname_xslt" = "x"],
                  [libxslt ${notice_platform}development files not found, xslt won't be supported.])
 
-dnl **** Check for libhal ****
+dnl **** Check for libdbus-1 and libhal ****
 AC_SUBST(HALINCL,"")
-if test "x$with_hal" != "xno"
+AC_SUBST(DBUSINCL,"")
+
+if test "x$with_dbus" != "xno"
+then
+    ac_save_CPPFLAGS="$CPPFLAGS"
+    if test "$PKG_CONFIG" != "false"
+    then
+        ac_dbus_libs="`$PKG_CONFIG --libs dbus-1 2>/dev/null`"
+        ac_dbus_cflags="`$PKG_CONFIG --cflags dbus-1 2>/dev/null`"
+        CPPFLAGS="$CPPFLAGS $ac_dbus_cflags"
+    fi
+    AC_CHECK_HEADERS([dbus/dbus.h])
+    if test "$ac_cv_header_dbus_dbus_h" = "yes"
+    then
+        WINE_CHECK_SONAME(dbus-1, dbus_connection_close,
+            [DBUSINCL="$ac_dbus_cflags"],,[$ac_dbus_libs])
+    fi
+
+    CPPFLAGS="$ac_save_CPPFLAGS"
+fi
+WINE_NOTICE_WITH(dbus,[test "x$ac_cv_lib_soname_dbus_1" = "x" -a "x$ac_cv_header_DiskArbitration_DiskArbitration_h" != "xyes"],
+                 [libdbus and libhal ${notice_platform}development files not found, HAL and rtkit support disabled])
+
+if test "x$with_hal" != "xno" -a "x$ac_cv_lib_soname_dbus_1" != "x"
 then
     ac_save_CPPFLAGS="$CPPFLAGS"
     if test "$PKG_CONFIG" != "false"
@@ -1212,17 +1237,16 @@ then
         ac_hal_cflags="`$PKG_CONFIG --cflags hal 2>/dev/null`"
         CPPFLAGS="$CPPFLAGS $ac_hal_cflags"
     fi
-    AC_CHECK_HEADERS([dbus/dbus.h hal/libhal.h])
-    if test "$ac_cv_header_dbus_dbus_h" = "yes" -a "$ac_cv_header_hal_libhal_h" = "yes"
+    AC_CHECK_HEADERS([hal/libhal.h])
+    if test "$ac_cv_header_hal_libhal_h" = "yes"
     then
-        AC_CHECK_LIB(dbus-1, dbus_connection_close,
-          [WINE_CHECK_SONAME(hal, libhal_ctx_new,
-            [HALINCL="$ac_hal_cflags"],,[$ac_hal_libs])],,[$ac_hal_libs])
+        WINE_CHECK_SONAME(hal, libhal_ctx_new,
+            [HALINCL="$ac_hal_cflags"],,[$ac_hal_libs])
     fi
     CPPFLAGS="$ac_save_CPPFLAGS"
 fi
-WINE_NOTICE_WITH(hal,[test "x$ac_cv_lib_soname_hal" = "x" -a "x$ac_cv_header_DiskArbitration_DiskArbitration_h" != "xyes"],
-                 [libhal/libdbus ${notice_platform}development files not found, no dynamic device support.])
+WINE_NOTICE_WITH(hal,[test "x$ac_cv_lib_soname_hal" = "x" -a "x$ac_cv_header_DiskArbitration_DiskArbitration_h" != "xyes" -a "x$ac_cv_lib_soname_dbus_1" != "x"],
+                 [libhal ${notice_platform}development files not found, no dynamic device support.])
 
 dnl **** Check for libgnutls ****
 if test "x$with_gnutls" != "xno"
@@ -1440,6 +1464,30 @@ then
     WINE_WARNING_WITH(gettextpo,[test "x$LIBGETTEXTPO" = "x"],[GetText ${notice_platform}development files not found (or too old). Internationalization won't be fully supported.])
 fi
 
+dnl **** Check for PulseAudio ****
+AC_SUBST(PULSELIBS,"")
+AC_SUBST(PULSEINCL,"")
+if test "x$with_pulse" != "xno";
+then
+    ac_save_CPPFLAGS="$CPPFLAGS"
+    if test "$PKG_CONFIG" != "false";
+    then
+        ac_pulse_libs="`$PKG_CONFIG --libs libpulse 2>/dev/null`"
+        ac_pulse_cflags="`$PKG_CONFIG --cflags-only-I libpulse 2>/dev/null`"
+
+        CPPFLAGS="$CPPFLAGS $ac_pulse_cflags"
+        AC_CHECK_HEADERS(pulse/pulseaudio.h,
+            [AC_CHECK_LIB(pulse, pa_stream_is_corked,
+                [AC_DEFINE(HAVE_PULSEAUDIO, 1, [Define if you have pulseaudio])
+                 PULSELIBS="$ac_pulse_libs"
+                 PULSEINCL="$ac_pulse_cflags"],,$ac_pulse_libs)
+        ])
+    fi
+    CPPFLAGS="$ac_save_CPPFLAGS"
+fi
+WINE_WARNING_WITH(pulse, [test "$ac_cv_lib_pulse_pa_stream_is_corked" != "yes"],
+        [libpulse ${notice_platform}development files not found or too old, Pulse won't be supported.])
+
 dnl **** Check for gstreamer ****
 if test "x$with_gstreamer" != "xno"
 then
@@ -1646,13 +1694,14 @@ WINE_CHECK_SONAME(odbc,SQLConnect,,[AC_DEFINE_UNQUOTED(SONAME_LIBODBC,["libodbc.
 dnl **** Disable unsupported winmm drivers ****
 test -n "$ALSALIBS" || enable_winealsa_drv=${enable_winealsa_drv:-no}
 test -n "$COREAUDIO" || enable_winecoreaudio_drv=${enable_winecoreaudio_drv:-no}
+test -n "$PULSELIBS" || enable_winepulse_drv=${enable_winepulse_drv:-no}
 test "x$ac_cv_member_oss_sysinfo_numaudioengines" = xyes || enable_wineoss_drv=${enable_wineoss_drv:-no}
 test "$ac_cv_header_linux_joystick_h" = "yes" || enable_winejoystick_drv=${enable_winejoystick_drv:-no}
 
 dnl **** Check for any sound system ****
-if test "x$ALSALIBS$COREAUDIO" = "x" -a \
+if test "x$ALSALIBS$COREAUDIO$PULSELIBS" = "x" -a \
         "x$ac_cv_member_oss_sysinfo_numaudioengines" != xyes -a \
-        "x$with_alsa$with_coreaudio$with_oss" != xnonono
+        "x$with_alsa$with_coreaudio$with_oss$with_pulse" != xnononono
 then
     WINE_WARNING([No sound system was found. Windows applications will be silent.])
 fi
@@ -2840,10 +2889,12 @@ WINE_CONFIG_DLL(wined3d,,[implib])
 WINE_CONFIG_DLL(winegstreamer)
 WINE_CONFIG_DLL(winejoystick.drv)
 WINE_CONFIG_DLL(winemapi)
+WINE_CONFIG_DLL(winemmaudio.drv)
 WINE_CONFIG_DLL(winemp3.acm)
 WINE_CONFIG_DLL(wineoss.drv)
 WINE_CONFIG_DLL(wineps.drv,,[install-lib])
 WINE_CONFIG_DLL(wineps16.drv16,enable_win16)
+WINE_CONFIG_DLL(winepulse.drv)
 WINE_CONFIG_DLL(wineqtdecoder)
 WINE_CONFIG_DLL(winequartz.drv)
 WINE_CONFIG_DLL(winex11.drv)
diff --git a/dlls/dsound/Makefile.in b/dlls/dsound/Makefile.in
index 58b1998..938b46f 100644
--- a/dlls/dsound/Makefile.in
+++ b/dlls/dsound/Makefile.in
@@ -1,18 +1,16 @@
 MODULE    = dsound.dll
 IMPORTLIB = dsound
-IMPORTS   = dxguid uuid winmm ole32 advapi32
+IMPORTS   = dxguid uuid winmm ole32 advapi32 user32
+EXTRALIBS = @FRAMEWORK_OPENAL@
 
 C_SRCS = \
 	buffer.c \
 	capture.c \
 	dsound.c \
-	dsound_convert.c \
 	dsound_main.c \
 	duplex.c \
-	mixer.c \
 	primary.c \
-	propset.c \
-	sound3d.c
+	propset.c
 
 IDL_R_SRCS = dsound_classes.idl
 
diff --git a/dlls/dsound/alext.h b/dlls/dsound/alext.h
new file mode 100644
index 0000000..ea27071
--- /dev/null
+++ b/dlls/dsound/alext.h
@@ -0,0 +1,183 @@
+/**
+ * OpenAL cross platform audio library
+ * Copyright (C) 2008 by authors.
+ * This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the
+ *  Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ *  Boston, MA  02111-1307, USA.
+ * Or go to http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#ifndef AL_ALEXT_H
+#define AL_ALEXT_H
+
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef AL_LOKI_IMA_ADPCM_format
+#define AL_LOKI_IMA_ADPCM_format 1
+#define AL_FORMAT_IMA_ADPCM_MONO16_EXT           0x10000
+#define AL_FORMAT_IMA_ADPCM_STEREO16_EXT         0x10001
+#endif
+
+#ifndef AL_LOKI_WAVE_format
+#define AL_LOKI_WAVE_format 1
+#define AL_FORMAT_WAVE_EXT                       0x10002
+#endif
+
+#ifndef AL_EXT_vorbis
+#define AL_EXT_vorbis 1
+#define AL_FORMAT_VORBIS_EXT                     0x10003
+#endif
+
+#ifndef AL_LOKI_quadriphonic
+#define AL_LOKI_quadriphonic 1
+#define AL_FORMAT_QUAD8_LOKI                     0x10004
+#define AL_FORMAT_QUAD16_LOKI                    0x10005
+#endif
+
+#ifndef AL_EXT_float32
+#define AL_EXT_float32 1
+#define AL_FORMAT_MONO_FLOAT32                   0x10010
+#define AL_FORMAT_STEREO_FLOAT32                 0x10011
+#endif
+
+#ifndef AL_EXT_double
+#define AL_EXT_double 1
+#define AL_FORMAT_MONO_DOUBLE_EXT                0x10012
+#define AL_FORMAT_STEREO_DOUBLE_EXT              0x10013
+#endif
+
+#ifndef ALC_LOKI_audio_channel
+#define ALC_LOKI_audio_channel 1
+#define ALC_CHAN_MAIN_LOKI                       0x500001
+#define ALC_CHAN_PCM_LOKI                        0x500002
+#define ALC_CHAN_CD_LOKI                         0x500003
+#endif
+
+#ifndef AL_EXT_MCFORMATS
+#define AL_EXT_MCFORMATS 1
+#define AL_FORMAT_QUAD8                          0x1204
+#define AL_FORMAT_QUAD16                         0x1205
+#define AL_FORMAT_QUAD32                         0x1206
+#define AL_FORMAT_REAR8                          0x1207
+#define AL_FORMAT_REAR16                         0x1208
+#define AL_FORMAT_REAR32                         0x1209
+#define AL_FORMAT_51CHN8                         0x120A
+#define AL_FORMAT_51CHN16                        0x120B
+#define AL_FORMAT_51CHN32                        0x120C
+#define AL_FORMAT_61CHN8                         0x120D
+#define AL_FORMAT_61CHN16                        0x120E
+#define AL_FORMAT_61CHN32                        0x120F
+#define AL_FORMAT_71CHN8                         0x1210
+#define AL_FORMAT_71CHN16                        0x1211
+#define AL_FORMAT_71CHN32                        0x1212
+#endif
+
+#ifndef AL_EXT_MULAW_MCFORMATS
+#define AL_EXT_MULAW_MCFORMATS 1
+#define AL_FORMAT_MONO_MULAW                     0x10014
+#define AL_FORMAT_STEREO_MULAW                   0x10015
+#define AL_FORMAT_QUAD_MULAW                     0x10021
+#define AL_FORMAT_REAR_MULAW                     0x10022
+#define AL_FORMAT_51CHN_MULAW                    0x10023
+#define AL_FORMAT_61CHN_MULAW                    0x10024
+#define AL_FORMAT_71CHN_MULAW                    0x10025
+#endif
+
+#ifndef AL_EXT_IMA4
+#define AL_EXT_IMA4 1
+#define AL_FORMAT_MONO_IMA4                      0x1300
+#define AL_FORMAT_STEREO_IMA4                    0x1301
+#endif
+
+#ifndef AL_EXT_STATIC_BUFFER
+#define AL_EXT_STATIC_BUFFER 1
+typedef ALvoid (AL_APIENTRY*PFNALBUFFERDATASTATICPROC)(const ALint,ALenum,ALvoid*,ALsizei,ALsizei);
+#ifdef AL_ALEXT_PROTOTYPES
+AL_API ALvoid AL_APIENTRY alBufferDataStatic(const ALint buffer, ALenum format, ALvoid *data, ALsizei len, ALsizei freq);
+#endif
+#endif
+
+#ifndef ALC_EXT_EFX
+#define ALC_EXT_EFX 1
+#include "efx.h"
+#endif
+
+#ifndef ALC_EXT_disconnect
+#define ALC_EXT_disconnect 1
+#define ALC_CONNECTED                            0x313
+#endif
+
+#ifndef ALC_EXT_thread_local_context
+#define ALC_EXT_thread_local_context 1
+typedef ALCboolean  (ALC_APIENTRY*PFNALCSETTHREADCONTEXTPROC)(ALCcontext *context);
+typedef ALCcontext* (ALC_APIENTRY*PFNALCGETTHREADCONTEXTPROC)(void);
+#ifdef AL_ALEXT_PROTOTYPES
+ALC_API ALCboolean  ALC_APIENTRY alcSetThreadContext(ALCcontext *context);
+ALC_API ALCcontext* ALC_APIENTRY alcGetThreadContext(void);
+#endif
+#endif
+
+#ifndef AL_EXT_source_distance_model
+#define AL_EXT_source_distance_model 1
+#define AL_SOURCE_DISTANCE_MODEL                 0x200
+#endif
+
+#ifndef AL_SOFT_buffer_sub_data
+#define AL_SOFT_buffer_sub_data 1
+#define AL_BYTE_RW_OFFSETS_SOFT                  0x1031
+#define AL_SAMPLE_RW_OFFSETS_SOFT                0x1032
+typedef ALvoid (AL_APIENTRY*PFNALBUFFERSUBDATASOFTPROC)(ALuint,ALenum,const ALvoid*,ALsizei,ALsizei);
+#ifdef AL_ALEXT_PROTOTYPES
+AL_API ALvoid AL_APIENTRY alBufferSubDataSOFT(ALuint buffer,ALenum format,const ALvoid *data,ALsizei offset,ALsizei length);
+#endif
+#endif
+
+#ifndef AL_SOFT_loop_points
+#define AL_SOFT_loop_points 1
+#define AL_LOOP_POINTS_SOFT                      0x2015
+#endif
+
+#ifndef AL_EXT_FOLDBACK
+#define AL_EXT_FOLDBACK 1
+#define AL_EXT_FOLDBACK_NAME                     "AL_EXT_FOLDBACK"
+#define AL_FOLDBACK_EVENT_BLOCK                  0x4112
+#define AL_FOLDBACK_EVENT_START                  0x4111
+#define AL_FOLDBACK_EVENT_STOP                   0x4113
+#define AL_FOLDBACK_MODE_MONO                    0x4101
+#define AL_FOLDBACK_MODE_STEREO                  0x4102
+typedef void (AL_APIENTRY*LPALFOLDBACKCALLBACK)(ALenum,ALsizei);
+typedef void (AL_APIENTRY*LPALREQUESTFOLDBACKSTART)(ALenum,ALsizei,ALsizei,ALfloat*,LPALFOLDBACKCALLBACK);
+typedef void (AL_APIENTRY*LPALREQUESTFOLDBACKSTOP)(void);
+#ifdef AL_ALEXT_PROTOTYPES
+AL_API void AL_APIENTRY alRequestFoldbackStart(ALenum mode,ALsizei count,ALsizei length,ALfloat *mem,LPALFOLDBACKCALLBACK callback);
+AL_API void AL_APIENTRY alRequestFoldbackStop(void);
+#endif
+#endif
+
+#ifndef ALC_EXT_DEDICATED
+#define ALC_EXT_DEDICATED 1
+#define AL_DEDICATED_GAIN                        0x0001
+#define AL_EFFECT_DEDICATED_DIALOGUE             0x9001
+#define AL_EFFECT_DEDICATED_LOW_FREQUENCY_EFFECT 0x9000
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/dlls/dsound/buffer.c b/dlls/dsound/buffer.c
index 6ba6c24..a7925ca 100644
--- a/dlls/dsound/buffer.c
+++ b/dlls/dsound/buffer.c
@@ -1,8 +1,9 @@
-/*  			DirectSound
+/* DirectSound COM interface
  *
- * Copyright 1998 Marcus Meissner
- * Copyright 1998 Rob Riggs
- * Copyright 2000-2002 TransGaming Technologies, Inc.
+ * Copyright 2009 Maarten Lankhorst
+ *
+ * Some code taken from the original dsound-openal implementation
+ *    Copyright 2007-2009 Chris Robinson
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -19,1422 +20,2601 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#ifdef HAVE_OPENAL
 #include <stdarg.h>
 
+#define COBJMACROS
 #define NONAMELESSSTRUCT
 #define NONAMELESSUNION
 #include "windef.h"
 #include "winbase.h"
 #include "winuser.h"
+#include "winnls.h"
+#include "winreg.h"
+#include "vfwmsgs.h"
 #include "mmsystem.h"
 #include "winternl.h"
-#include "vfwmsgs.h"
+#include "mmddk.h"
 #include "wine/debug.h"
 #include "dsound.h"
-#include "dsdriver.h"
 #include "dsound_private.h"
-#include "dsconf.h"
+
+#include "ks.h"
+#include "ksmedia.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(dsound);
 
-/*******************************************************************************
- *		IDirectSoundNotify
+/* TODO: when bufferlost is set, return from all calls except initialize with
+ * DSERR_BUFFERLOST
  */
+static const IDirectSoundBuffer8Vtbl DS8Buffer_Vtbl;
+static const IDirectSound3DBufferVtbl DS8Buffer3d_Vtbl;
+static const IDirectSoundNotifyVtbl DS8BufferNot_Vtbl;
+static const IKsPropertySetVtbl DS8BufferProp_Vtbl;
 
-struct IDirectSoundNotifyImpl
+/* Amount of buffers that have to be queued when
+ * bufferdatastatic and buffersubdata are not available */
+#define QBUFFERS 3
+
+struct DS8Data
 {
-    /* IUnknown fields */
-    const IDirectSoundNotifyVtbl *lpVtbl;
-    LONG                        ref;
-    IDirectSoundBufferImpl*     dsb;
+    LONG ref;
+
+    /* Lock was called and unlock isn't? */
+    BOOL locked;
+
+    WAVEFORMATEX *format;
+
+    ALuint buf_size;
+    ALenum buf_format;
+    DWORD dsbflags;
+    BYTE *data;
+    ALuint *buffers;
+    ALuint numsegs;
+    ALuint segsize;
+    ALuint lastsegsize;
+    ALuint buggy_app_detection;
 };
 
-static HRESULT IDirectSoundNotifyImpl_Create(IDirectSoundBufferImpl *dsb,
-                                             IDirectSoundNotifyImpl **pdsn);
-static HRESULT IDirectSoundNotifyImpl_Destroy(IDirectSoundNotifyImpl *pdsn);
-
-static HRESULT WINAPI IDirectSoundNotifyImpl_QueryInterface(
-	LPDIRECTSOUNDNOTIFY iface,REFIID riid,LPVOID *ppobj
-) {
-	IDirectSoundNotifyImpl *This = (IDirectSoundNotifyImpl *)iface;
-	TRACE("(%p,%s,%p)\n",This,debugstr_guid(riid),ppobj);
-
-	if (This->dsb == NULL) {
-		WARN("invalid parameter\n");
-		return E_INVALIDARG;
-	}
-
-	return IDirectSoundBuffer_QueryInterface((LPDIRECTSOUNDBUFFER)This->dsb, riid, ppobj);
-}
-
-static ULONG WINAPI IDirectSoundNotifyImpl_AddRef(LPDIRECTSOUNDNOTIFY iface)
-{
-    IDirectSoundNotifyImpl *This = (IDirectSoundNotifyImpl *)iface;
-    ULONG ref = InterlockedIncrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref - 1);
-    return ref;
-}
-
-static ULONG WINAPI IDirectSoundNotifyImpl_Release(LPDIRECTSOUNDNOTIFY iface)
-{
-    IDirectSoundNotifyImpl *This = (IDirectSoundNotifyImpl *)iface;
-    ULONG ref = InterlockedDecrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref + 1);
-
-    if (!ref) {
-        This->dsb->notify = NULL;
-        IDirectSoundBuffer_Release((LPDIRECTSOUNDBUFFER)This->dsb);
-        HeapFree(GetProcessHeap(), 0, This);
-        TRACE("(%p) released\n", This);
-    }
-    return ref;
-}
-
-static HRESULT WINAPI IDirectSoundNotifyImpl_SetNotificationPositions(
-	LPDIRECTSOUNDNOTIFY iface,DWORD howmuch,LPCDSBPOSITIONNOTIFY notify
-) {
-	IDirectSoundNotifyImpl *This = (IDirectSoundNotifyImpl *)iface;
-	TRACE("(%p,0x%08x,%p)\n",This,howmuch,notify);
-
-        if (howmuch > 0 && notify == NULL) {
-	    WARN("invalid parameter: notify == NULL\n");
-	    return DSERR_INVALIDPARAM;
-	}
-
-	if (TRACE_ON(dsound)) {
-	    unsigned int	i;
-	    for (i=0;i<howmuch;i++)
-		TRACE("notify at %d to %p\n",
-		    notify[i].dwOffset,notify[i].hEventNotify);
-	}
-
-	if (This->dsb->hwnotify) {
-	    HRESULT hres;
-	    hres = IDsDriverNotify_SetNotificationPositions(This->dsb->hwnotify, howmuch, notify);
-	    if (hres != DS_OK)
-		    WARN("IDsDriverNotify_SetNotificationPositions failed\n");
-	    return hres;
-        } else if (howmuch > 0) {
-	    /* Make an internal copy of the caller-supplied array.
-	     * Replace the existing copy if one is already present. */
-	    HeapFree(GetProcessHeap(), 0, This->dsb->notifies);
-	    This->dsb->notifies = HeapAlloc(GetProcessHeap(), 0,
-			howmuch * sizeof(DSBPOSITIONNOTIFY));
-
-	    if (This->dsb->notifies == NULL) {
-		    WARN("out of memory\n");
-		    return DSERR_OUTOFMEMORY;
-	    }
-	    CopyMemory(This->dsb->notifies, notify, howmuch * sizeof(DSBPOSITIONNOTIFY));
-	    This->dsb->nrofnotifies = howmuch;
-        } else {
-           HeapFree(GetProcessHeap(), 0, This->dsb->notifies);
-           This->dsb->notifies = NULL;
-           This->dsb->nrofnotifies = 0;
+static void trigger_notifies(DS8Buffer *buf, DWORD lastpos, DWORD curpos, BOOL stopping)
+{
+    DWORD i;
+    if (lastpos == curpos && !stopping)
+        return;
+    for (i = 0; i < buf->nnotify; ++i)
+    {
+        DSBPOSITIONNOTIFY *not = &buf->notify[i];
+        HANDLE event = not->hEventNotify;
+        DWORD ofs = not->dwOffset;
+
+        if (ofs == (DWORD)DSBPN_OFFSETSTOP)
+        {
+            if (stopping)
+                SetEvent(event);
+            continue;
         }
 
-	return S_OK;
+        /* Wraparound case */
+        if (curpos < lastpos)
+        {
+            if (ofs < curpos || ofs >= lastpos)
+                SetEvent(event);
+            continue;
+        }
+
+        /* Normal case */
+        if (ofs >= lastpos && ofs < curpos)
+            SetEvent(event);
+    }
 }
 
-static const IDirectSoundNotifyVtbl dsnvt =
+static void CALLBACK DS8Buffer_timer(UINT timerID, UINT msg, DWORD_PTR dwUser,
+                                     DWORD_PTR dw1, DWORD_PTR dw2)
 {
-    IDirectSoundNotifyImpl_QueryInterface,
-    IDirectSoundNotifyImpl_AddRef,
-    IDirectSoundNotifyImpl_Release,
-    IDirectSoundNotifyImpl_SetNotificationPositions,
-};
+    DS8Primary *prim = (DS8Primary*)dwUser;
+    DWORD i;
+    UINT pad;
+    BYTE *data;
+
+    EnterCriticalSection(&prim->crst);
+    setALContext(prim->ctx);
+
+    /* OpenAL doesn't support our lovely buffer extensions
+     * so just make sure enough buffers are queued
+     */
+    if(!prim->ExtAL.BufferSubData && !prim->ExtAL.BufferDataStatic)
+    {
+        /* FIXME: Should probably use this logic to also
+         * call trigger_notifies
+         */
+        for (i = 0; i < prim->nbuffers; ++i)
+        {
+            DS8Buffer *buf = prim->buffers[i];
+            ALint done = 0, queued = QBUFFERS, state = AL_PLAYING;
+            ALuint which, ofs;
+
+            if (buf->buffer->numsegs == 1 || !buf->isplaying)
+                continue;
+
+            palGetSourcei(buf->source, AL_SOURCE_STATE, &state);
+            palGetSourcei(buf->source, AL_BUFFERS_QUEUED, &queued);
+            palGetSourcei(buf->source, AL_BUFFERS_PROCESSED, &done);
+
+            queued -= done;
+            while (done--)
+                palSourceUnqueueBuffers(buf->source, 1, &which);
+            while (queued < QBUFFERS)
+            {
+                which = buf->buffer->buffers[buf->curidx];
+                ofs = buf->curidx*buf->buffer->segsize;
+                if(buf->curidx < buf->buffer->numsegs-1)
+                    palBufferData(which, buf->buffer->buf_format,
+                                  buf->buffer->data + ofs, buf->buffer->segsize,
+                                  buf->buffer->format->nSamplesPerSec);
+                else
+                    palBufferData(which, buf->buffer->buf_format,
+                                  buf->buffer->data + ofs, buf->buffer->lastsegsize,
+                                  buf->buffer->format->nSamplesPerSec);
+
+                palSourceQueueBuffers(buf->source, 1, &which);
+                buf->curidx = (buf->curidx+1)%buf->buffer->numsegs;
+                queued++;
+
+                if (!buf->curidx && !buf->islooping)
+                {
+                    buf->isplaying = FALSE;
+                    break;
+                }
+            }
+            if (state != AL_PLAYING)
+            {
+                if (!queued)
+                {
+                    IDirectSoundBuffer8_Stop(&buf->IDirectSoundBuffer8_iface);
+                    continue;
+                }
+                palSourcePlay(buf->source);
+            }
+            getALError();
+        }
+    }
+
+    IAudioClient_GetCurrentPadding(prim->dev, &pad);
+    pad = 2048 - pad;
+    if(pad && !prim->ExtAL.BufferDataStatic && prim->ExtAL.BufferSubData)
+    {
+        for (i = 0; i < prim->nbuffers; ++i)
+        {
+            DS8Buffer *buf = prim->buffers[i];
+            ALint state;
+            DWORD pos1, pos2, ofs;
+            void *ptr1, *ptr2;
+            if (!buf->buffer->buggy_app_detection)
+                continue;
+            palGetSourcei(buf->source, AL_SOURCE_STATE, &state);
+            if (state != AL_PLAYING)
+                continue;
+            EnterCriticalSection(buf->crst);
+            WARN("Unlock never was called succesfully, doing this manually now\n");
+            IDirectSoundBuffer8_GetCurrentPosition(&buf->IDirectSoundBuffer8_iface, &ofs, NULL);
+            IDirectSoundBuffer8_Lock(&buf->IDirectSoundBuffer8_iface, ofs, pad * buf->buffer->format->nBlockAlign, &ptr1, &pos1, &ptr2, &pos2, 0);
+            IDirectSoundBuffer8_Unlock(&buf->IDirectSoundBuffer8_iface, ptr1, pos1, ptr2, pos2);
+            buf->buffer->buggy_app_detection = 1;
+            LeaveCriticalSection(buf->crst);
+        }
+    }
+    if (pad)
+    {
+        IAudioRenderClient_GetBuffer(prim->render_dev, pad, &data);
+        palcRenderSamplesSOFT(prim->parent->device, data, pad);
+        IAudioRenderClient_ReleaseBuffer(prim->render_dev, pad, 0);
+    }
+
+    for (i = 0; i < prim->nnotifies ; )
+    {
+        DS8Buffer *buf = prim->notifies[i];
+        IDirectSoundBuffer8 *dsb = &buf->IDirectSoundBuffer8_iface;
+        DWORD status, curpos;
+        HRESULT hr;
+
+        hr = IDirectSoundBuffer8_GetStatus(dsb, &status);
+        if (SUCCEEDED(hr))
+        {
+            if (!(status & DSBSTATUS_PLAYING))
+            {
+                /* Stop will remove this buffer from list,
+                 * and put another at the current position
+                 * don't increment i
+                 */
+                IDirectSoundBuffer8_Stop(dsb);
+                continue;
+            }
+            hr = IDirectSoundBuffer8_GetCurrentPosition(dsb, &curpos, NULL);
+            if (SUCCEEDED(hr))
+            {
+                trigger_notifies(buf, buf->lastpos, curpos, FALSE);
+                buf->lastpos = curpos;
+            }
+        }
+        i++;
+    }
+    popALContext();
+    LeaveCriticalSection(&prim->crst);
+}
 
-static HRESULT IDirectSoundNotifyImpl_Create(
-    IDirectSoundBufferImpl * dsb,
-    IDirectSoundNotifyImpl **pdsn)
+static void DS8Buffer_starttimer(DS8Primary *prim)
 {
-    IDirectSoundNotifyImpl * dsn;
-    TRACE("(%p,%p)\n",dsb,pdsn);
+    TIMECAPS time;
+    DWORD triggertime, res = DS_TIME_RES;
+    INT64 default_period, min_period;
+
+    if(prim->timer_id)
+        return;
+
+    timeGetDevCaps(&time, sizeof(TIMECAPS));
+    IAudioClient_GetDevicePeriod(prim->dev, &default_period, &min_period);
+    triggertime = default_period / 10000;
+    getALCError(prim->parent->device);
+    if(triggertime < time.wPeriodMin)
+        triggertime = time.wPeriodMin;
+    TRACE("Calling timer every %u ms\n", triggertime);
+    if (res < time.wPeriodMin)
+        res = time.wPeriodMin;
+    if (timeBeginPeriod(res) == TIMERR_NOCANDO)
+        WARN("Could not set minimum resolution, don't expect sound\n");
+    prim->timer_res = res;
+    prim->timer_id = timeSetEvent(triggertime, res, DS8Buffer_timer, (DWORD_PTR)prim, TIME_PERIODIC | TIME_KILL_SYNCHRONOUS);
+    IAudioClient_Start(prim->dev);
+}
 
-    dsn = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*dsn));
+/* Should be called with critsect held and context set.. */
+static void DS8Buffer_addnotify(DS8Buffer *buf)
+{
+    DS8Buffer **list;
+    DWORD i;
+
+    list = buf->primary->notifies;
+    for(i = 0; i < buf->primary->nnotifies; ++i)
+    {
+        if(buf == list[i])
+        {
+            ERR("Buffer %p already in notification list\n", buf);
+            return;
+        }
+    }
+    if(buf->primary->nnotifies == buf->primary->sizenotifies)
+    {
+        list = HeapReAlloc(GetProcessHeap(), 0, list, (buf->primary->nnotifies + 1) * sizeof(*list));
+        if(!list)
+            return;
+        buf->primary->sizenotifies++;
+    }
+    list[buf->primary->nnotifies++] = buf;
+    buf->primary->notifies = list;
+}
 
-    if (dsn == NULL) {
-        WARN("out of memory\n");
-        return DSERR_OUTOFMEMORY;
+static void DS8Buffer_removenotify(DS8Buffer *buf)
+{
+    DWORD i;
+    for(i = 0; i < buf->primary->nnotifies; ++i)
+    {
+        if(buf == buf->primary->notifies[i])
+        {
+            buf->primary->notifies[i] =
+                buf->primary->notifies[--buf->primary->nnotifies];
+            return;
+        }
     }
+}
 
-    dsn->ref = 0;
-    dsn->lpVtbl = &dsnvt;
-    dsn->dsb = dsb;
-    dsb->notify = dsn;
-    IDirectSoundBuffer_AddRef((LPDIRECTSOUNDBUFFER)dsb);
+static const char *get_fmtstr_PCM(const WAVEFORMATEX *format, WAVEFORMATEX **out)
+{
+    *out = HeapAlloc(GetProcessHeap(), 0, sizeof(*format));
+    if(!*out) return NULL;
+
+    **out = *format;
+    (*out)->cbSize = 0;
+
+    if(format->nChannels > 2 && !palIsExtensionPresent("AL_EXT_MCFORMATS"))
+    {
+        WARN("Extension AL_EXT_MCFORMATS not available, cannot enumerate > 2 channels\n");
+        return NULL;
+    }
 
-    *pdsn = dsn;
-    return DS_OK;
+    if(format->wBitsPerSample == 8)
+    {
+        switch(format->nChannels)
+        {
+        case 1: return "AL_FORMAT_MONO8";
+        case 2: return "AL_FORMAT_STEREO8";
+        case 4: return "AL_FORMAT_QUAD8";
+        case 6: return "AL_FORMAT_51CHN8";
+        case 7: return "AL_FORMAT_61CHN8";
+        case 8: return "AL_FORMAT_71CHN8";
+        default: break;
+        }
+    }
+    else if(format->wBitsPerSample == 16)
+    {
+        switch(format->nChannels)
+        {
+        case 1: return "AL_FORMAT_MONO16";
+        case 2: return "AL_FORMAT_STEREO16";
+        case 4: return "AL_FORMAT_QUAD16";
+        case 6: return "AL_FORMAT_51CHN16";
+        case 7: return "AL_FORMAT_61CHN16";
+        case 8: return "AL_FORMAT_71CHN16";
+        default: break;
+        }
+    }
+    else
+        return NULL;
+
+    if((format->wBitsPerSample%8) == 0)
+        ERR("Could not get OpenAL format (%d-bit, %d channels)\n",
+            format->wBitsPerSample, format->nChannels);
+    return NULL;
 }
 
-static HRESULT IDirectSoundNotifyImpl_Destroy(
-    IDirectSoundNotifyImpl *pdsn)
+/* Speaker configs */
+#define MONO SPEAKER_FRONT_CENTER
+#define STEREO (SPEAKER_FRONT_LEFT|SPEAKER_FRONT_RIGHT)
+#define REAR (SPEAKER_BACK_LEFT|SPEAKER_BACK_RIGHT)
+#define QUAD (SPEAKER_FRONT_LEFT|SPEAKER_FRONT_RIGHT|SPEAKER_BACK_LEFT|SPEAKER_BACK_RIGHT)
+#define X5DOT1 (SPEAKER_FRONT_LEFT|SPEAKER_FRONT_RIGHT|SPEAKER_FRONT_CENTER|SPEAKER_LOW_FREQUENCY|SPEAKER_BACK_LEFT|SPEAKER_BACK_RIGHT)
+#define X6DOT1 (SPEAKER_FRONT_LEFT|SPEAKER_FRONT_RIGHT|SPEAKER_FRONT_CENTER|SPEAKER_LOW_FREQUENCY|SPEAKER_BACK_CENTER|SPEAKER_SIDE_LEFT|SPEAKER_SIDE_RIGHT)
+#define X7DOT1 (SPEAKER_FRONT_LEFT|SPEAKER_FRONT_RIGHT|SPEAKER_FRONT_CENTER|SPEAKER_LOW_FREQUENCY|SPEAKER_BACK_LEFT|SPEAKER_BACK_RIGHT|SPEAKER_SIDE_LEFT|SPEAKER_SIDE_RIGHT)
+
+static const char *get_fmtstr_EXT(const WAVEFORMATEX *format, WAVEFORMATEX **out)
 {
-    TRACE("(%p)\n",pdsn);
+    WAVEFORMATEXTENSIBLE *wfe;
 
-    while (IDirectSoundNotifyImpl_Release((LPDIRECTSOUNDNOTIFY)pdsn) > 0);
+    if(format->cbSize < sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX))
+    {
+        WARN("Invalid cbSize specified for WAVE_FORMAT_EXTENSIBLE (%d)\n", format->cbSize);
+        return NULL;
+    }
+
+    wfe = HeapAlloc(GetProcessHeap(), 0, sizeof(WAVEFORMATEXTENSIBLE));
+    if(!wfe) return NULL;
+
+    *wfe = *(WAVEFORMATEXTENSIBLE*)format;
+    wfe->Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);
+    *out = &wfe->Format;
+
+    TRACE("Extensible values:\n"
+          "    Samples     = %d\n"
+          "    ChannelMask = %#x\n"
+          "    SubFormat   = %s\n",
+          wfe->Samples.wReserved, wfe->dwChannelMask,
+          debugstr_guid(&wfe->SubFormat));
+
+    if(!wfe->Samples.wValidBitsPerSample)
+        wfe->Samples.wValidBitsPerSample = wfe->Format.wBitsPerSample;
+
+    if(wfe->dwChannelMask != MONO && wfe->dwChannelMask != STEREO &&
+       !palIsExtensionPresent("AL_EXT_MCFORMATS"))
+    {
+        /* QUAD PCM might still work, special case */
+        if(palIsExtensionPresent("AL_LOKI_quadriphonic") &&
+           IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM) &&
+           wfe->dwChannelMask == QUAD)
+        {
+            if(wfe->Samples.wValidBitsPerSample == 16)
+                return "AL_FORMAT_QUAD16_LOKI";
+            else if(wfe->Samples.wValidBitsPerSample == 8)
+                return "AL_FORMAT_QUAD8_LOKI";
+        }
+        WARN("Not all formats available\n");
+        return NULL;
+    }
 
-    return DS_OK;
+    if(IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM))
+    {
+        if(wfe->Samples.wValidBitsPerSample == 8)
+        {
+            switch(wfe->dwChannelMask)
+            {
+            case   MONO: return "AL_FORMAT_MONO8";
+            case STEREO: return "AL_FORMAT_STEREO8";
+            case   REAR: return "AL_FORMAT_REAR8";
+            case   QUAD: return "AL_FORMAT_QUAD8";
+            case X5DOT1: return "AL_FORMAT_51CHN8";
+            case X6DOT1: return "AL_FORMAT_61CHN8";
+            case X7DOT1: return "AL_FORMAT_71CHN8";
+            default: break;
+            }
+        }
+        else if(wfe->Samples.wValidBitsPerSample == 16)
+        {
+            switch(wfe->dwChannelMask)
+            {
+            case   MONO: return "AL_FORMAT_MONO16";
+            case STEREO: return "AL_FORMAT_STEREO16";
+            case   REAR: return "AL_FORMAT_REAR16";
+            case   QUAD: return "AL_FORMAT_QUAD16";
+            case X5DOT1: return "AL_FORMAT_51CHN16";
+            case X6DOT1: return "AL_FORMAT_61CHN16";
+            case X7DOT1: return "AL_FORMAT_71CHN16";
+            default: break;
+            }
+        }
+#if 1 /* TODO: Ugly freaky hack just to pass tests */
+        else if(wfe->Samples.wValidBitsPerSample == 24 ||
+                wfe->Samples.wValidBitsPerSample == 32)
+        {
+            switch(wfe->dwChannelMask)
+            {
+            case   MONO: return "AL_FORMAT_MONO_FLOAT32";
+            case STEREO: return "AL_FORMAT_STEREO_FLOAT32";
+            case   REAR: return "AL_FORMAT_REAR32";
+            case   QUAD: return "AL_FORMAT_QUAD32";
+            case X5DOT1: return "AL_FORMAT_51CHN32";
+            case X6DOT1: return "AL_FORMAT_61CHN32";
+            case X7DOT1: return "AL_FORMAT_71CHN32";
+            default: break;
+            }
+        }
+#endif
+        else if((wfe->Samples.wValidBitsPerSample%8) == 0)
+            ERR("Could not get OpenAL PCM format (%d-bit, channelmask %#x)\n",
+                wfe->Samples.wValidBitsPerSample, wfe->dwChannelMask);
+        return NULL;
+    }
+    else if(IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT) &&
+            palIsExtensionPresent("AL_EXT_float32"))
+    {
+        if(wfe->Samples.wValidBitsPerSample != 32)
+        {
+            WARN("Invalid valid bits %u/32\n", wfe->Samples.wValidBitsPerSample);
+            return NULL;
+        }
+        switch(wfe->dwChannelMask)
+        {
+        case   MONO: return "AL_FORMAT_MONO_FLOAT32";
+        case STEREO: return "AL_FORMAT_STEREO_FLOAT32";
+        case   REAR: return "AL_FORMAT_REAR32";
+        case   QUAD: return "AL_FORMAT_QUAD32";
+        case X5DOT1: return "AL_FORMAT_51CHN32";
+        case X6DOT1: return "AL_FORMAT_61CHN32";
+        case X7DOT1: return "AL_FORMAT_71CHN32";
+        default:
+            ERR("Could not get OpenAL float format (%d-bit, channelmask %#x)\n",
+                wfe->Samples.wValidBitsPerSample, wfe->dwChannelMask);
+            return NULL;
+        }
+    }
+    else if(!IsEqualGUID(&wfe->SubFormat, &GUID_NULL))
+        ERR("Unhandled extensible format: %s\n", debugstr_guid(&wfe->SubFormat));
+    return NULL;
 }
 
-/*******************************************************************************
- *		IDirectSoundBuffer
- */
+static const char *get_fmtstr_FLOAT(const WAVEFORMATEX *format, WAVEFORMATEX **out)
+{
+    if (!palIsExtensionPresent("AL_EXT_float32"))
+        return NULL;
+
+    *out = HeapAlloc(GetProcessHeap(), 0, sizeof(*format));
+    if(!*out) return NULL;
 
-static inline IDirectSoundBufferImpl *impl_from_IDirectSoundBuffer8(IDirectSoundBuffer8 *iface)
+    **out = *format;
+    (*out)->cbSize = 0;
+
+    switch(format->nChannels)
+    {
+        case 1: return "AL_FORMAT_MONO_FLOAT32";
+        case 2: return "AL_FORMAT_STEREO_FLOAT32";
+        default:
+            return NULL;
+    }
+}
+
+static HRESULT openal_format(const WAVEFORMATEX *format, WAVEFORMATEX **myformat, ALenum *enumformat)
 {
-    return CONTAINING_RECORD(iface, IDirectSoundBufferImpl, IDirectSoundBuffer8_iface);
+    const char *fmt_str;
+    HRESULT hr = DSERR_INVALIDPARAM;
+    *enumformat = 0;
+    *myformat = 0;
+    if(format->wFormatTag == WAVE_FORMAT_PCM)
+        fmt_str = get_fmtstr_PCM(format, myformat);
+    else if(format->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
+    {
+        WAVEFORMATEXTENSIBLE *wfe = (WAVEFORMATEXTENSIBLE*)format;
+
+        hr = DSERR_CONTROLUNAVAIL;
+        if(format->cbSize > sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX) &&
+           format->cbSize != sizeof(WAVEFORMATEXTENSIBLE))
+            goto fail;
+
+        hr = DSERR_INVALIDPARAM;
+        if(!IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT) &&
+           !IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM))
+            goto fail;
+
+        fmt_str = get_fmtstr_EXT(format, myformat);
+    }
+    else if(format->wFormatTag == WAVE_FORMAT_IEEE_FLOAT)
+    {
+        fmt_str = get_fmtstr_FLOAT(format, myformat);
+    }
+    else
+    {
+        ERR("Unhandled formattag 0x%04x\n", format->wFormatTag);
+        return DSERR_INVALIDPARAM;
+    }
+
+    if(!fmt_str)
+        goto fail;
+
+    *enumformat = palGetEnumValue(fmt_str);
+    if(palGetError() != AL_NO_ERROR || *enumformat == 0 || *enumformat == -1)
+        goto fail2;
+    return S_OK;
+
+fail2:
+    WARN("Could not get OpenAL format from %s\n", fmt_str);
+fail:
+    HeapFree(GetProcessHeap(), 0, *myformat);
+    *myformat = 0;
+    return hr;
 }
 
-static inline BOOL is_primary_buffer(IDirectSoundBufferImpl *This)
+static void DS8Data_Release(DS8Data *This);
+static HRESULT DS8Data_Create(DS8Data **ppv, const DSBUFFERDESC *desc, DS8Primary *prim)
 {
-    return This->dsbd.dwFlags & DSBCAPS_PRIMARYBUFFER ? TRUE : FALSE;
+    HRESULT hr = DSERR_INVALIDPARAM;
+    WAVEFORMATEX *format;
+    DS8Data *pBuffer;
+
+    format = desc->lpwfxFormat;
+    TRACE("Requested buffer format:\n"
+          "    FormatTag      = %#x\n"
+          "    Channels       = %d\n"
+          "    SamplesPerSec  = %u\n"
+          "    AvgBytesPerSec = %u\n"
+          "    BlockAlign     = %d\n"
+          "    BitsPerSample  = %d\n",
+          format->wFormatTag, format->nChannels,
+          format->nSamplesPerSec, format->nAvgBytesPerSec,
+          format->nBlockAlign, format->wBitsPerSample);
+
+    if(format->nBlockAlign == 0)
+    {
+        WARN("Invalid BlockAlign specified\n");
+        return DSERR_INVALIDPARAM;
+    }
+
+    /* Generate a new buffer. Supporting the DSBCAPS_LOC* flags properly
+     * will need the EAX-RAM extension. Currently, we just tell the app it
+     * gets what it wanted. */
+    pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*pBuffer));
+    if(!pBuffer)
+        return E_OUTOFMEMORY;
+    pBuffer->ref = 1;
+
+    pBuffer->dsbflags = desc->dwFlags;
+    if((pBuffer->dsbflags&(DSBCAPS_LOCSOFTWARE|DSBCAPS_LOCHARDWARE)) == (DSBCAPS_LOCSOFTWARE|DSBCAPS_LOCHARDWARE))
+    {
+        WARN("Hardware and software location requested\n");
+        goto fail;
+    }
+    if(!(pBuffer->dsbflags&(DSBCAPS_LOCSOFTWARE|DSBCAPS_LOCHARDWARE|DSBCAPS_LOCDEFER)))
+        pBuffer->dsbflags |= DSBCAPS_LOCHARDWARE;
+
+    pBuffer->buf_size  = desc->dwBufferBytes + format->nBlockAlign - 1;
+    pBuffer->buf_size -= pBuffer->buf_size%format->nBlockAlign;
+
+    hr = DSERR_BUFFERTOOSMALL;
+    if(pBuffer->buf_size < DSBSIZE_MIN)
+        goto fail;
+
+    hr = DSERR_INVALIDPARAM;
+    if(pBuffer->buf_size > DSBSIZE_MAX)
+        goto fail;
+
+    pBuffer->numsegs = 1;
+    pBuffer->segsize = pBuffer->buf_size;
+    pBuffer->lastsegsize = pBuffer->buf_size;
+
+    if(!(pBuffer->dsbflags & DSBCAPS_STATIC) && !prim->ExtAL.BufferSubData
+       && !prim->ExtAL.BufferDataStatic)
+    {
+        ALCint refresh = FAKE_REFRESH_COUNT;
+        ALuint newSize;
+
+        palcGetIntegerv(prim->parent->device, ALC_REFRESH, 1, &refresh);
+        getALCError(prim->parent->device);
+
+        newSize  = format->nAvgBytesPerSec/refresh + format->nBlockAlign - 1;
+        newSize -= newSize%format->nBlockAlign;
+
+        /* Make sure enough buffers are available */
+        if(newSize > pBuffer->buf_size/(QBUFFERS+2))
+            ERR("Buffer segments too large to stream (%u for %u)!\n",
+                newSize, pBuffer->buf_size);
+        else
+        {
+            pBuffer->numsegs = pBuffer->buf_size/newSize;
+            pBuffer->segsize = newSize;
+            pBuffer->lastsegsize = pBuffer->buf_size - (newSize*(pBuffer->numsegs-1));
+            TRACE("New streaming buffer (%u chunks, %u : %u sizes)\n",
+                  pBuffer->numsegs, pBuffer->segsize, pBuffer->lastsegsize);
+        }
+    }
+
+    hr = openal_format(format, &pBuffer->format, &pBuffer->buf_format);
+    if (FAILED(hr))
+        goto fail;
+
+    hr = E_OUTOFMEMORY;
+    pBuffer->buffers = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*pBuffer->buffers)*pBuffer->numsegs);
+    pBuffer->data = HeapAlloc(GetProcessHeap(), 0, pBuffer->buf_size);
+    if(!pBuffer->buffers || !pBuffer->data)
+        goto fail;
+
+    palGenBuffers(pBuffer->numsegs, pBuffer->buffers);
+    getALError();
+
+    *ppv = pBuffer;
+    return S_OK;
+
+fail:
+    DS8Data_Release(pBuffer);
+    return hr;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_SetFormat(IDirectSoundBuffer8 *iface,
-        LPCWAVEFORMATEX wfex)
+static void DS8Data_AddRef(DS8Data *data)
 {
-    IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
+    InterlockedIncrement(&data->ref);
+}
 
-    TRACE("(%p,%p)\n", iface, wfex);
+/* This function is always called with the device lock held */
+static void DS8Data_Release(DS8Data *This)
+{
+    if(InterlockedDecrement(&This->ref)) return;
 
-    if (is_primary_buffer(This))
-        return primarybuffer_SetFormat(This->device, wfex);
-    else {
-        WARN("not available for secondary buffers.\n");
-        return DSERR_INVALIDCALL;
+    TRACE("Deleting %p\n", This);
+    if (This->buffers && This->data && This->buffers[0])
+    {
+        palDeleteBuffers(This->numsegs, This->buffers);
+        getALError();
     }
+    HeapFree(GetProcessHeap(), 0, This->buffers);
+    HeapFree(GetProcessHeap(), 0, This->data);
+    HeapFree(GetProcessHeap(), 0, This->format);
+    HeapFree(GetProcessHeap(), 0, This);
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_SetVolume(IDirectSoundBuffer8 *iface, LONG vol)
+HRESULT DS8Buffer_Create(DS8Buffer **ppv, DS8Primary *parent, DS8Buffer *orig)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
-	LONG oldVol;
+    HRESULT hr = DSERR_OUTOFMEMORY;
+    DS8Buffer *This;
+    DS8Buffer **bufs;
+
+    *ppv = NULL;
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*This));
+    if(!This) return hr;
+
+    This->primary = parent;
+    This->IDirectSoundBuffer8_iface.lpVtbl = &DS8Buffer_Vtbl;
+    This->IDirectSound3DBuffer_iface.lpVtbl = &DS8Buffer3d_Vtbl;
+    This->IDirectSoundNotify_iface.lpVtbl = &DS8BufferNot_Vtbl;
+    This->IKsPropertySet_iface.lpVtbl = &DS8BufferProp_Vtbl;
+    This->ctx = parent->ctx;
+    This->ExtAL = &parent->ExtAL;
+    This->crst = &parent->crst;
+    This->ref = This->all_ref = 1;
+
+    if(orig)
+    {
+        This->buffer = orig->buffer;
+        DS8Data_AddRef(This->buffer);
+    }
 
-	HRESULT hres = DS_OK;
+    /* Append to buffer list */
+    bufs = parent->buffers;
+    if(parent->nbuffers == parent->sizebuffers)
+    {
+        bufs = HeapReAlloc(GetProcessHeap(), 0, parent->buffers, sizeof(This)*(1+parent->nbuffers));
+        if(!bufs) goto fail;
+        parent->sizebuffers++;
+    }
+    parent->buffers = bufs;
+    bufs[parent->nbuffers++] = This;
 
-	TRACE("(%p,%d)\n",This,vol);
+    /* Disable until initialized.. */
+    This->ds3dmode = DS3DMODE_DISABLE;
 
-	if (!(This->dsbd.dwFlags & DSBCAPS_CTRLVOLUME)) {
-		WARN("control unavailable: This->dsbd.dwFlags = 0x%08x\n", This->dsbd.dwFlags);
-		return DSERR_CONTROLUNAVAIL;
-	}
+    *ppv = This;
+    return S_OK;
+
+fail:
+    DS8Buffer_Destroy(This);
+    return hr;
+}
+
+void DS8Buffer_Destroy(DS8Buffer *This)
+{
+    DWORD idx;
+    TRACE("Destroying %p\n", This);
+
+    EnterCriticalSection(&This->primary->crst);
+    setALContext(This->ctx);
+    DS8Buffer_removenotify(This);
+
+    /* Remove from list, if in list */
+    for(idx = 0;idx < This->primary->nbuffers;++idx)
+    {
+        if(This->primary->buffers[idx] == This)
+        {
+            This->primary->buffers[idx] = This->primary->buffers[This->primary->nbuffers-1];
+            This->primary->nbuffers--;
+            break;
+        }
+    }
+    if(This->source)
+    {
+        ALuint *sources;
+
+        palSourceStop(This->source);
+        palSourcei(This->source, AL_BUFFER, 0);
+        getALError();
+
+        sources = This->primary->sources;
+        if(This->primary->nsources == This->primary->sizesources)
+        {
+            sources = HeapReAlloc(GetProcessHeap(), 0, This->primary->sources, sizeof(This->source)*(1+This->primary->nsources));
+            if(!sources)
+                palDeleteSources(1, &This->source);
+            else
+                This->primary->sizesources++;
+        }
+        if(sources)
+        {
+            sources[This->primary->nsources++] = This->source;
+            This->primary->sources = sources;
+        }
+    }
+    HeapFree(GetProcessHeap(), 0, This->notify);
+    This->source = 0;
+    if(This->buffer)
+        DS8Data_Release(This->buffer);
+    popALContext();
+    LeaveCriticalSection(&This->primary->crst);
+    HeapFree(GetProcessHeap(), 0, This);
+}
 
-	if ((vol > DSBVOLUME_MAX) || (vol < DSBVOLUME_MIN)) {
-		WARN("invalid parameter: vol = %d\n", vol);
-		return DSERR_INVALIDPARAM;
-	}
+static inline DS8Buffer *impl_from_IDirectSoundBuffer8(IDirectSoundBuffer8 *iface)
+{
+    return CONTAINING_RECORD(iface, DS8Buffer, IDirectSoundBuffer8_iface);
+}
 
-	/* **** */
-	RtlAcquireResourceExclusive(&This->lock, TRUE);
+static HRESULT WINAPI DS8Buffer_QueryInterface(IDirectSoundBuffer8 *iface, REFIID riid, void **ppv)
+{
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    *ppv = NULL;
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+       IsEqualIID(riid, &IID_IDirectSoundBuffer))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IDirectSoundBuffer8))
+    {
+        if(This->primary->parent->is_8)
+            *ppv = iface;
+    }
+    else if(IsEqualIID(riid, &IID_IDirectSound3DBuffer))
+    {
+        if((This->buffer->dsbflags&DSBCAPS_CTRL3D))
+            *ppv = &This->IDirectSound3DBuffer_iface;
+    }
+    else if(IsEqualIID(riid, &IID_IDirectSoundNotify))
+    {
+        if((This->buffer->dsbflags&DSBCAPS_CTRLPOSITIONNOTIFY))
+            *ppv = &This->IDirectSoundNotify_iface;
+    }
+    else if(IsEqualIID(riid, &IID_IKsPropertySet))
+        *ppv = &This->IKsPropertySet_iface;
+    else
+        FIXME("Unhandled GUID: %s\n", debugstr_guid(riid));
+
+    if(*ppv)
+    {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
 
-	if (This->dsbd.dwFlags & DSBCAPS_CTRL3D) {
-		oldVol = This->ds3db_lVolume;
-		This->ds3db_lVolume = vol;
-		if (vol != oldVol)
-			/* recalc 3d volume, which in turn recalcs the pans */
-			DSOUND_Calc3DBuffer(This);
-	} else {
-		oldVol = This->volpan.lVolume;
-		This->volpan.lVolume = vol;
-		if (vol != oldVol)
-			DSOUND_RecalcVolPan(&(This->volpan));
-	}
+    return E_NOINTERFACE;
+}
 
-	if (vol != oldVol) {
-		if (This->hwbuf) {
-			hres = IDsDriverBuffer_SetVolumePan(This->hwbuf, &(This->volpan));
-	    		if (hres != DS_OK)
-		    		WARN("IDsDriverBuffer_SetVolumePan failed\n");
-		}
-	}
+static ULONG WINAPI DS8Buffer_AddRef(IDirectSoundBuffer8 *iface)
+{
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    LONG ret;
 
-	RtlReleaseResource(&This->lock);
-	/* **** */
+    InterlockedIncrement(&This->all_ref);
+    ret = InterlockedIncrement(&This->ref);
+    TRACE("new refcount %d\n", ret);
 
-	return hres;
+    return ret;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_GetVolume(IDirectSoundBuffer8 *iface, LONG *vol)
+static ULONG WINAPI DS8Buffer_Release(IDirectSoundBuffer8 *iface)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    LONG ret;
+
+    ret = InterlockedDecrement(&This->ref);
+    TRACE("new refcount %d\n", ret);
+    if(InterlockedDecrement(&This->all_ref) == 0)
+        DS8Buffer_Destroy(This);
 
-	TRACE("(%p,%p)\n",This,vol);
+    return ret;
+}
 
-	if (!(This->dsbd.dwFlags & DSBCAPS_CTRLVOLUME)) {
-		WARN("control unavailable\n");
-		return DSERR_CONTROLUNAVAIL;
-	}
+static HRESULT WINAPI DS8Buffer_GetCaps(IDirectSoundBuffer8 *iface, DSBCAPS *caps)
+{
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
 
-	if (vol == NULL) {
-		WARN("invalid parameter: vol == NULL\n");
-		return DSERR_INVALIDPARAM;
-	}
+    TRACE("(%p)->(%p)\n", iface, caps);
 
-	*vol = This->volpan.lVolume;
+    if(!caps || caps->dwSize < sizeof(*caps))
+    {
+        WARN("Invalid DSBCAPS (%p, %u)\n", caps, (caps ? caps->dwSize : 0));
+        return DSERR_INVALIDPARAM;
+    }
 
-	return DS_OK;
+    caps->dwFlags = This->buffer->dsbflags;
+    caps->dwBufferBytes = This->buffer->buf_size;
+    caps->dwUnlockTransferRate = 4096;
+    caps->dwPlayCpuOverhead = 0;
+    return S_OK;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_SetFrequency(IDirectSoundBuffer8 *iface, DWORD freq)
+static HRESULT WINAPI DS8Buffer_GetCurrentPosition(IDirectSoundBuffer8 *iface, DWORD *playpos, DWORD *curpos)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
-	DWORD oldFreq;
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    WAVEFORMATEX *format = This->buffer->format;
+    UINT writecursor, pos;
+
+    TRACE("(%p)->(%p, %p)\n", iface, playpos, curpos);
 
-	TRACE("(%p,%d)\n",This,freq);
+    EnterCriticalSection(This->crst);
+    setALContext(This->ctx);
 
-        if (is_primary_buffer(This)) {
-                WARN("not available for primary buffers.\n");
-                return DSERR_CONTROLUNAVAIL;
+    if(This->buffer->numsegs > 1)
+    {
+        ALint queued = QBUFFERS;
+        palGetSourcei(This->source, AL_BUFFERS_QUEUED, &queued);
+        getALError();
+
+        pos = (This->curidx+This->buffer->numsegs-queued)%This->buffer->numsegs;
+        pos *= This->buffer->segsize;
+        writecursor = This->curidx * This->buffer->segsize;
+    }
+    else if(This->ExtAL->BufferSubData)
+    {
+        ALint rwpos[2] = { 0, 0 };
+
+        palGetSourceiv(This->source, AL_BYTE_RW_OFFSETS_SOFT, rwpos);
+        getALError();
+
+        pos = rwpos[0];
+        writecursor = rwpos[1];
+    }
+    else
+    {
+        ALint status = 0;
+        ALint ofs = 0;
+
+        palGetSourcei(This->source, AL_BYTE_OFFSET, &ofs);
+        palGetSourcei(This->source, AL_SOURCE_STATE, &status);
+        getALError();
+
+        pos = ofs;
+        if(status == AL_PLAYING)
+        {
+            writecursor = format->nSamplesPerSec / 100;
+            writecursor *= format->nBlockAlign;
         }
+        else
+            writecursor = 0;
+        writecursor = (writecursor + pos) % This->buffer->buf_size;
+    }
+    TRACE("%p Play pos = %u, write pos = %u\n", This, pos, writecursor);
+    if(pos >= This->buffer->buf_size)
+    {
+        ERR("playpos >= buf_size\n");
+        pos %= This->buffer->buf_size;
+    }
+    if(writecursor >= This->buffer->buf_size)
+    {
+        ERR("writepos >= buf_size\n");
+        writecursor %= This->buffer->buf_size;
+    }
 
-	if (!(This->dsbd.dwFlags & DSBCAPS_CTRLFREQUENCY)) {
-		WARN("control unavailable\n");
-		return DSERR_CONTROLUNAVAIL;
-	}
+    if(playpos) *playpos = pos;
+    if(curpos)  *curpos = writecursor;
 
-	if (freq == DSBFREQUENCY_ORIGINAL)
-		freq = This->pwfx->nSamplesPerSec;
+    popALContext();
+    LeaveCriticalSection(This->crst);
 
-	if ((freq < DSBFREQUENCY_MIN) || (freq > DSBFREQUENCY_MAX)) {
-		WARN("invalid parameter: freq = %d\n", freq);
-		return DSERR_INVALIDPARAM;
-	}
+    return S_OK;
+}
 
-	/* **** */
-	RtlAcquireResourceExclusive(&This->lock, TRUE);
+static HRESULT WINAPI DS8Buffer_GetFormat(IDirectSoundBuffer8 *iface, WAVEFORMATEX *wfx, DWORD allocated, DWORD *written)
+{
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    HRESULT hr = S_OK;
+    UINT size;
 
-	oldFreq = This->freq;
-	This->freq = freq;
-	if (freq != oldFreq) {
-		This->freqAdjust = ((DWORD64)This->freq << DSOUND_FREQSHIFT) / This->device->pwfx->nSamplesPerSec;
-		This->nAvgBytesPerSec = freq * This->pwfx->nBlockAlign;
-		DSOUND_RecalcFormat(This);
-		DSOUND_MixToTemporary(This, 0, This->buflen, FALSE);
-	}
+    TRACE("(%p)->(%p, %u, %p)\n", iface, wfx, allocated, written);
 
-	RtlReleaseResource(&This->lock);
-	/* **** */
+    if(!wfx && !written)
+    {
+        WARN("Cannot report format or format size\n");
+        return DSERR_INVALIDPARAM;
+    }
 
-	return DS_OK;
+    EnterCriticalSection(This->crst);
+    size = sizeof(*This->buffer->format) + This->buffer->format->cbSize;
+    if(written)
+        *written = size;
+    if(wfx)
+    {
+        if(allocated < size)
+            hr = DSERR_INVALIDPARAM;
+        else
+            memcpy(wfx, This->buffer->format, size);
+    }
+    LeaveCriticalSection(This->crst);
+
+    return hr;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_Play(IDirectSoundBuffer8 *iface, DWORD reserved1,
-        DWORD reserved2, DWORD flags)
+static HRESULT WINAPI DS8Buffer_GetVolume(IDirectSoundBuffer8 *iface, LONG *vol)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
-	HRESULT hres = DS_OK;
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    HRESULT hr = S_OK;
+    ALfloat gain;
 
-	TRACE("(%p,%08x,%08x,%08x)\n",This,reserved1,reserved2,flags);
+    TRACE("(%p)->(%p)\n", iface, vol);
 
-	/* **** */
-	RtlAcquireResourceExclusive(&This->lock, TRUE);
+    if(!vol)
+    {
+        WARN("Invalid pointer\n");
+        return DSERR_INVALIDPARAM;
+    }
 
-	This->playflags = flags;
-	if (This->state == STATE_STOPPED && !This->hwbuf) {
-		This->leadin = TRUE;
-		This->state = STATE_STARTING;
-	} else if (This->state == STATE_STOPPING)
-		This->state = STATE_PLAYING;
-	if (This->hwbuf) {
-		hres = IDsDriverBuffer_Play(This->hwbuf, 0, 0, This->playflags);
-		if (hres != DS_OK)
-			WARN("IDsDriverBuffer_Play failed\n");
-		else
-			This->state = STATE_PLAYING;
-	}
+    EnterCriticalSection(This->crst);
 
-	RtlReleaseResource(&This->lock);
-	/* **** */
+    if(!(This->buffer->dsbflags&DSBCAPS_CTRLVOLUME))
+    {
+        WARN("Volume control not set\n");
+        hr = DSERR_CONTROLUNAVAIL;
+        goto out;
+    }
 
-	return hres;
+    setALContext(This->ctx);
+    palGetSourcef(This->source, AL_GAIN, &gain);
+    getALError();
+    popALContext();
+
+    *vol = gain_to_mB(gain);
+    *vol = min(*vol, DSBVOLUME_MAX);
+    *vol = max(*vol, DSBVOLUME_MIN);
+
+out:
+    LeaveCriticalSection(This->crst);
+    return hr;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_Stop(IDirectSoundBuffer8 *iface)
+static HRESULT WINAPI DS8Buffer_GetPan(IDirectSoundBuffer8 *iface, LONG *pan)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
-	HRESULT hres = DS_OK;
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    HRESULT hr = S_OK;
+    ALfloat pos[3];
+
+    TRACE("(%p)->(%p)\n", iface, pan);
 
-	TRACE("(%p)\n",This);
+    if(!pan)
+    {
+        WARN("Invalid pointer\n");
+        return DSERR_INVALIDPARAM;
+    }
 
-	/* **** */
-	RtlAcquireResourceExclusive(&This->lock, TRUE);
+    EnterCriticalSection(This->crst);
+    if(!(This->buffer->dsbflags&DSBCAPS_CTRLPAN))
+    {
+        WARN("Volume control not set\n");
+        hr = DSERR_CONTROLUNAVAIL;
+        goto out;
+    }
 
-	if (This->state == STATE_PLAYING)
-		This->state = STATE_STOPPING;
-	else if (This->state == STATE_STARTING)
-	{
-		This->state = STATE_STOPPED;
-		DSOUND_CheckEvent(This, 0, 0);
-	}
-	if (This->hwbuf) {
-		hres = IDsDriverBuffer_Stop(This->hwbuf);
-		if (hres != DS_OK)
-			WARN("IDsDriverBuffer_Stop failed\n");
-		else
-			This->state = STATE_STOPPED;
-	}
+    setALContext(This->ctx);
+    palGetSourcefv(This->source, AL_POSITION, pos);
+    getALError();
+    popALContext();
 
-	RtlReleaseResource(&This->lock);
-	/* **** */
+    *pan = (LONG)((pos[0]+1.0) * (DSBPAN_RIGHT-DSBPAN_LEFT) / 2.0 + 0.5) + DSBPAN_LEFT;
+    *pan = min(*pan, DSBPAN_RIGHT);
+    *pan = max(*pan, DSBPAN_LEFT);
 
-	return hres;
+out:
+    LeaveCriticalSection(This->crst);
+    return hr;
 }
 
-static ULONG WINAPI IDirectSoundBufferImpl_AddRef(IDirectSoundBuffer8 *iface)
+static HRESULT WINAPI DS8Buffer_GetFrequency(IDirectSoundBuffer8 *iface, DWORD *freq)
 {
-    IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
-    ULONG ref = InterlockedIncrement(&This->ref);
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    HRESULT hr = S_OK;
+    ALfloat pitch = 1.0f;
 
-    TRACE("(%p) ref was %d\n", This, ref - 1);
+    TRACE("(%p)->(%p)\n", iface, freq);
 
-    if(ref == 1)
-        InterlockedIncrement(&This->numIfaces);
+    if(!freq)
+    {
+        WARN("Invalid pointer\n");
+        return DSERR_INVALIDPARAM;
+    }
 
-    return ref;
+    EnterCriticalSection(This->crst);
+    if(!(This->buffer->dsbflags&DSBCAPS_CTRLFREQUENCY))
+    {
+        WARN("Volume control not set\n");
+        hr = DSERR_CONTROLUNAVAIL;
+        goto out;
+    }
+
+    setALContext(This->ctx);
+    palGetSourcefv(This->source, AL_PITCH, &pitch);
+    getALError();
+    popALContext();
+
+    *freq = (DWORD)(This->buffer->format->nSamplesPerSec * pitch);
+
+out:
+    LeaveCriticalSection(This->crst);
+    return hr;
 }
 
-static ULONG WINAPI IDirectSoundBufferImpl_Release(IDirectSoundBuffer8 *iface)
+static HRESULT WINAPI DS8Buffer_GetStatus(IDirectSoundBuffer8 *iface, DWORD *status)
 {
-    IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
-    ULONG ref = InterlockedDecrement(&This->ref);
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    ALint state, looping;
 
-    TRACE("(%p) ref was %d\n", This, ref + 1);
+    TRACE("(%p)->(%p)\n", iface, status);
 
-    if (!ref && !InterlockedDecrement(&This->numIfaces)) {
-        if (is_primary_buffer(This))
-            primarybuffer_destroy(This);
-        else
-            secondarybuffer_destroy(This);
+    if(!status)
+    {
+        WARN("Invalid pointer\n");
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(This->crst);
+
+    setALContext(This->ctx);
+
+    palGetSourcei(This->source, AL_SOURCE_STATE, &state);
+    looping = This->islooping;
+    if(This->buffer->numsegs == 1)
+        palGetSourcei(This->source, AL_LOOPING, &looping);
+    else if(state != AL_PLAYING)
+        state = This->isplaying ? AL_PLAYING : AL_PAUSED;
+    getALError();
+
+    popALContext();
+
+    *status = 0;
+    if((This->buffer->dsbflags&DSBCAPS_LOCDEFER))
+    {
+        if((This->buffer->dsbflags&DSBCAPS_LOCSOFTWARE))
+            *status |= DSBSTATUS_LOCSOFTWARE;
+        else if((This->buffer->dsbflags&DSBCAPS_LOCHARDWARE))
+            *status |= DSBSTATUS_LOCHARDWARE;
     }
-    return ref;
+    if(state == AL_PLAYING)
+        *status |= DSBSTATUS_PLAYING | (looping ? DSBSTATUS_LOOPING : 0);
+
+    LeaveCriticalSection(This->crst);
+
+    return S_OK;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_GetCurrentPosition(IDirectSoundBuffer8 *iface,
-        DWORD *playpos, DWORD *writepos)
+static HRESULT WINAPI DS8Buffer_Initialize(IDirectSoundBuffer8 *iface, IDirectSound *ds, const DSBUFFERDESC *desc)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
-	HRESULT	hres;
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    HRESULT hr = DSERR_ALREADYINITIALIZED;
+    DS3DBUFFER *ds3dbuffer = &This->ds3dbuffer;
 
-	TRACE("(%p,%p,%p)\n",This,playpos,writepos);
+    TRACE("(%p)->(%p, %p)\n", iface, ds, desc);
 
-	RtlAcquireResourceShared(&This->lock, TRUE);
-	if (This->hwbuf) {
-		hres=IDsDriverBuffer_GetPosition(This->hwbuf,playpos,writepos);
-		if (hres != DS_OK) {
-		    WARN("IDsDriverBuffer_GetPosition failed\n");
-		    return hres;
-		}
-	} else {
-		DWORD pos = This->sec_mixpos;
+    EnterCriticalSection(This->crst);
+    setALContext(This->ctx);
 
-		/* sanity */
-		if (pos >= This->buflen){
-			FIXME("Bad play position. playpos: %d, buflen: %d\n", pos, This->buflen);
-			pos %= This->buflen;
-		}
+    if(This->source)
+        goto out;
 
-		if (playpos)
-			*playpos = pos;
-		if (writepos)
-			*writepos = pos;
-	}
-	if (writepos && This->state != STATE_STOPPED && (!This->hwbuf || !(This->device->drvdesc.dwFlags & DSDDESC_DONTNEEDWRITELEAD))) {
-		/* apply the documented 10ms lead to writepos */
-		*writepos += This->writelead;
-		*writepos %= This->buflen;
-	}
-	RtlReleaseResource(&This->lock);
+    if(!This->buffer)
+    {
+        hr = DSERR_INVALIDPARAM;
+        if(!desc)
+        {
+            WARN("Missing DSound buffer description\n");
+            goto out;
+        }
+        if(!desc->lpwfxFormat)
+        {
+            WARN("Missing buffer format (%p)\n", This);
+            goto out;
+        }
+        if((desc->dwFlags&DSBCAPS_CTRL3D) && desc->lpwfxFormat->nChannels != 1)
+        {
+            if(This->primary->parent->is_8)
+            {
+                /* DirectSoundBuffer8 objects aren't allowed non-mono 3D
+                 * buffers */
+                WARN("Can't create multi-channel 3D buffers\n");
+                goto out;
+            }
+            ERR("Multi-channel 3D sounds are not spatialized\n");
+        }
 
-	TRACE("playpos = %d, writepos = %d, buflen=%d (%p, time=%d)\n",
-		playpos?*playpos:-1, writepos?*writepos:-1, This->buflen, This, GetTickCount());
+        hr = DS8Data_Create(&This->buffer, desc, This->primary);
+        if(FAILED(hr))
+            goto out;
+        else
+        {
+            DS8Data *buf = This->buffer;
+
+            if(buf->format->wBitsPerSample == 8)
+                memset(buf->data, 0x80, buf->buf_size);
+            else
+                memset(buf->data, 0x00, buf->buf_size);
+
+            if(This->ExtAL->BufferDataStatic)
+                This->ExtAL->BufferDataStatic(buf->buffers[0], buf->buf_format,
+                                              buf->data, buf->buf_size,
+                                              buf->format->nSamplesPerSec);
+            else if(This->ExtAL->BufferSubData)
+                palBufferData(buf->buffers[0], buf->buf_format,
+                              buf->data, buf->buf_size,
+                              buf->format->nSamplesPerSec);
+        }
+        getALError();
+    }
+
+    hr = S_OK;
+    if(This->primary->nsources)
+    {
+        This->source = This->primary->sources[--This->primary->nsources];
+        palSourcef(This->source, AL_GAIN, 1.0f);
+        palSourcef(This->source, AL_PITCH, 1.0f);
+        getALError();
+    }
+    else
+    {
+        palGenSources(1, &This->source);
+        if(palGetError() != AL_NO_ERROR)
+        {
+            hr = DSERR_GENERIC;
+            goto out;
+        }
+    }
 
-	return DS_OK;
+    ds3dbuffer->dwSize = sizeof(*ds3dbuffer);
+    ds3dbuffer->vPosition.x = 0.0;
+    ds3dbuffer->vPosition.y = 0.0;
+    ds3dbuffer->vPosition.z = 0.0;
+    ds3dbuffer->vVelocity.x = 0.0;
+    ds3dbuffer->vVelocity.y = 0.0;
+    ds3dbuffer->vVelocity.z = 0.0;
+    ds3dbuffer->dwInsideConeAngle = DS3D_DEFAULTCONEANGLE;
+    ds3dbuffer->dwOutsideConeAngle = DS3D_DEFAULTCONEANGLE;
+    ds3dbuffer->vConeOrientation.x = 0.0;
+    ds3dbuffer->vConeOrientation.y = 0.0;
+    ds3dbuffer->vConeOrientation.z = 1.0;
+    ds3dbuffer->lConeOutsideVolume = DS3D_DEFAULTCONEOUTSIDEVOLUME;
+    ds3dbuffer->flMinDistance = DS3D_DEFAULTMINDISTANCE;
+    ds3dbuffer->flMaxDistance = DS3D_DEFAULTMAXDISTANCE;
+    ds3dbuffer->dwMode = DS3DMODE_NORMAL;
+
+    if((This->buffer->dsbflags&DSBCAPS_CTRL3D))
+    {
+        if(This->primary->auxslot != 0)
+        {
+            palSource3i(This->source, AL_AUXILIARY_SEND_FILTER, This->primary->auxslot, 0, AL_FILTER_NULL);
+            getALError();
+        }
+
+        hr = IDirectSound3DBuffer_SetAllParameters(&This->IDirectSound3DBuffer_iface, ds3dbuffer, DS3D_IMMEDIATE);
+        if(FAILED(hr))
+        {
+            ERR("SetAllParameters failed\n");
+            hr = S_OK;
+        }
+    }
+    else
+    {
+        ALuint source = This->source;
+
+        if(This->primary->auxslot != 0)
+            palSource3i(source, AL_AUXILIARY_SEND_FILTER, 0, 0, AL_FILTER_NULL);
+
+        /* Non-3D sources aren't distance attenuated */
+        This->ds3dmode = DS3DMODE_DISABLE;
+        palSource3f(source, AL_POSITION, 0.0f, 0.0f, 0.0f);
+        palSource3f(source, AL_VELOCITY, 0.0f, 0.0f, 0.0f);
+        palSource3f(source, AL_DIRECTION, 0.0f, 0.0f, 0.0f);
+        palSourcef(source, AL_CONE_OUTER_GAIN, 1.0f);
+        palSourcef(source, AL_REFERENCE_DISTANCE, 1.0f);
+        palSourcef(source, AL_MAX_DISTANCE, 1000.0f);
+        palSourcef(source, AL_ROLLOFF_FACTOR, 0.0f);
+        palSourcei(source, AL_CONE_INNER_ANGLE, 360);
+        palSourcei(source, AL_CONE_OUTER_ANGLE, 360);
+        palSourcei(source, AL_SOURCE_RELATIVE, AL_TRUE);
+        getALError();
+    }
+
+out:
+    popALContext();
+    LeaveCriticalSection(This->crst);
+
+    return hr;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_GetStatus(IDirectSoundBuffer8 *iface, DWORD *status)
+static HRESULT WINAPI DS8Buffer_Lock(IDirectSoundBuffer8 *iface, DWORD ofs, DWORD bytes, void **ptr1, DWORD *len1, void **ptr2, DWORD *len2, DWORD flags)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    HRESULT hr;
+    DWORD remain;
 
-	TRACE("(%p,%p), thread is %04x\n",This,status,GetCurrentThreadId());
+    TRACE("(%p)->(%u, %u, %p, %p, %p, %p, 0x%x)\n", This, ofs, bytes, ptr1, len1, ptr2, len2, flags);
 
-	if (status == NULL) {
-		WARN("invalid parameter: status = NULL\n");
-		return DSERR_INVALIDPARAM;
-	}
+    EnterCriticalSection(This->crst);
+    setALContext(This->ctx);
 
-	*status = 0;
-	RtlAcquireResourceShared(&This->lock, TRUE);
-	if ((This->state == STATE_STARTING) || (This->state == STATE_PLAYING)) {
-		*status |= DSBSTATUS_PLAYING;
-		if (This->playflags & DSBPLAY_LOOPING)
-			*status |= DSBSTATUS_LOOPING;
-	}
-	RtlReleaseResource(&This->lock);
+    if(ptr1) *ptr1 = NULL;
+    if(len1) *len1 = 0;
+    if(ptr2) *ptr2 = NULL;
+    if(len2) *len2 = 0;
 
-	TRACE("status=%x\n", *status);
-	return DS_OK;
-}
+    hr = DSERR_INVALIDPARAM;
+    if(ofs >= This->buffer->buf_size)
+    {
+        WARN("Invalid ofs %u\n", ofs);
+        goto out;
+    }
+    if(!ptr1 || !len1)
+    {
+        WARN("Invalid pointer/len %p %p\n", ptr1, len1);
+        goto out;
+    }
+    if((flags&DSBLOCK_FROMWRITECURSOR))
+        DS8Buffer_GetCurrentPosition(iface, NULL, &ofs);
+    if((flags&DSBLOCK_ENTIREBUFFER))
+        bytes = This->buffer->buf_size;
+    if(bytes > This->buffer->buf_size)
+    {
+        WARN("Invalid size %u\n", bytes);
+        goto out;
+    }
+
+    *ptr1 = This->buffer->data + ofs;
+    if(ofs+bytes >= This->buffer->buf_size)
+    {
+        *len1 = This->buffer->buf_size - ofs;
+        remain = bytes - *len1;
+    }
+    else
+    {
+        *len1 = bytes;
+        remain = 0;
+    }
+
+    This->buffer->locked = TRUE;
 
+    if(ptr2 && len2 && remain)
+    {
+        *ptr2 = This->buffer->data;
+        *len2 = remain;
+    }
+    hr = S_OK;
 
-static HRESULT WINAPI IDirectSoundBufferImpl_GetFormat(IDirectSoundBuffer8 *iface,
-        LPWAVEFORMATEX lpwf, DWORD wfsize, DWORD *wfwritten)
+out:
+    popALContext();
+    LeaveCriticalSection(This->crst);
+    return hr;
+}
+
+static HRESULT WINAPI DS8Buffer_Play(IDirectSoundBuffer8 *iface, DWORD res1, DWORD prio, DWORD flags)
 {
-    IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
-    DWORD size;
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    ALint type, state = AL_STOPPED;
+    HRESULT hr;
 
-    TRACE("(%p,%p,%d,%p)\n",This,lpwf,wfsize,wfwritten);
+    TRACE("%p\n", This);
 
-    size = sizeof(WAVEFORMATEX) + This->pwfx->cbSize;
+    EnterCriticalSection(This->crst);
+    setALContext(This->ctx);
 
-    if (lpwf) { /* NULL is valid */
-        if (wfsize >= size) {
-            CopyMemory(lpwf,This->pwfx,size);
-            if (wfwritten)
-                *wfwritten = size;
-        } else {
-            WARN("invalid parameter: wfsize too small\n");
-            CopyMemory(lpwf,This->pwfx,wfsize);
-            if (wfwritten)
-                *wfwritten = wfsize;
-            return DSERR_INVALIDPARAM;
+    hr = DSERR_BUFFERLOST;
+    if(This->bufferlost)
+    {
+        WARN("Buffer %p lost\n", This);
+        goto out;
+    }
+
+    if((This->buffer->dsbflags&DSBCAPS_LOCDEFER))
+    {
+        if(!(This->buffer->dsbflags&(DSBCAPS_LOCHARDWARE|DSBCAPS_LOCSOFTWARE)))
+        {
+            if(flags & DSBPLAY_LOCSOFTWARE)
+                This->buffer->dsbflags |= DSBCAPS_LOCSOFTWARE;
+            else
+                This->buffer->dsbflags |= DSBCAPS_LOCHARDWARE;
         }
-    } else {
-        if (wfwritten)
-            *wfwritten = sizeof(WAVEFORMATEX) + This->pwfx->cbSize;
-        else {
-            WARN("invalid parameter: wfwritten == NULL\n");
-            return DSERR_INVALIDPARAM;
+    }
+    else if(prio)
+    {
+        ERR("Invalid priority set for non-deferred buffer %p, %u!\n", This->buffer, prio);
+        hr = DSERR_INVALIDPARAM;
+        goto out;
+    }
+
+    palGetSourcei(This->source, AL_SOURCE_STATE, &state);
+    if(This->buffer->numsegs > 1)
+    {
+        This->islooping = !!(flags&DSBPLAY_LOOPING);
+        if(state != AL_PLAYING && This->isplaying)
+            state = AL_PLAYING;
+    }
+    else
+    {
+        palGetSourcei(This->source, AL_SOURCE_TYPE, &type);
+        palSourcei(This->source, AL_LOOPING, (flags&DSBPLAY_LOOPING) ? AL_TRUE : AL_FALSE);
+        if (flags & DSBPLAY_LOOPING)
+            This->buffer->buggy_app_detection = 1;
+    }
+    getALError();
+
+    hr = S_OK;
+    if(state == AL_PLAYING)
+        goto out;
+
+    /* alSourceQueueBuffers will implicitly set type to streaming */
+    if(This->buffer->numsegs == 1)
+    {
+        if(type != AL_STATIC)
+            palSourcei(This->source, AL_BUFFER, This->buffer->buffers[0]);
+        palSourcePlay(This->source);
+    }
+    if(palGetError() != AL_NO_ERROR)
+    {
+        ERR("Couldn't start source\n");
+        This->curidx = (This->buffer->numsegs-1+This->curidx)%This->buffer->numsegs;
+        palSourcei(This->source, AL_BUFFER, 0);
+        getALError();
+        hr = DSERR_GENERIC;
+        goto out;
+    }
+    This->isplaying = TRUE;
+
+    if(This->nnotify)
+        DS8Buffer_addnotify(This);
+    DS8Buffer_starttimer(This->primary);
+
+out:
+    popALContext();
+    LeaveCriticalSection(This->crst);
+    return hr;
+}
+
+static HRESULT WINAPI DS8Buffer_SetCurrentPosition(IDirectSoundBuffer8 *iface, DWORD pos)
+{
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    HRESULT hr;
+    TRACE("%p\n", This);
+
+    EnterCriticalSection(This->crst);
+    setALContext(This->ctx);
+    if(pos >= This->buffer->buf_size)
+    {
+        hr = DSERR_INVALIDPARAM;
+        goto out;
+    }
+    if(This->buffer->numsegs > 1)
+    {
+        DS8Data *buf = This->buffer;
+        This->curidx = pos/buf->segsize;
+        if(This->curidx >= buf->numsegs)
+            This->curidx = buf->numsegs - 1;
+        if(This->isplaying)
+        {
+            palSourceStop(This->source);
+            palSourcei(This->source, AL_BUFFER, 0);
+            getALError();
         }
     }
+    else
+        palSourcei(This->source, AL_BYTE_OFFSET, pos);
+    This->lastpos = pos;
+    hr = S_OK;
+
+out:
+    popALContext();
+    LeaveCriticalSection(This->crst);
+    return hr;
+}
 
-    return DS_OK;
+static HRESULT WINAPI DS8Buffer_SetFormat(IDirectSoundBuffer8 *iface, const WAVEFORMATEX *wfx)
+{
+    /* This call only works on primary buffers */
+    WARN("(%p)->(%p)\n", iface, wfx);
+    return DSERR_INVALIDCALL;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_Lock(IDirectSoundBuffer8 *iface, DWORD writecursor,
-        DWORD writebytes, void **lplpaudioptr1, DWORD *audiobytes1, void **lplpaudioptr2,
-        DWORD *audiobytes2, DWORD flags)
+static HRESULT WINAPI DS8Buffer_SetVolume(IDirectSoundBuffer8 *iface, LONG vol)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
-	HRESULT hres = DS_OK;
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    HRESULT hr = S_OK;
 
-        TRACE("(%p,%d,%d,%p,%p,%p,%p,0x%08x) at %d\n", This, writecursor, writebytes, lplpaudioptr1,
-                audiobytes1, lplpaudioptr2, audiobytes2, flags, GetTickCount());
+    TRACE("(%p)->(%d)\n", iface, vol);
 
-        if (!audiobytes1)
-            return DSERR_INVALIDPARAM;
+    if(vol > DSBVOLUME_MAX || vol < DSBVOLUME_MIN)
+    {
+        WARN("Invalid volume (%d)\n", vol);
+        return DSERR_INVALIDPARAM;
+    }
 
-        /* when this flag is set, writecursor is meaningless and must be calculated */
-	if (flags & DSBLOCK_FROMWRITECURSOR) {
-		/* GetCurrentPosition does too much magic to duplicate here */
-		hres = IDirectSoundBufferImpl_GetCurrentPosition(iface, NULL, &writecursor);
-		if (hres != DS_OK) {
-			WARN("IDirectSoundBufferImpl_GetCurrentPosition failed\n");
-			return hres;
-		}
-	}
-
-        /* when this flag is set, writebytes is meaningless and must be set */
-	if (flags & DSBLOCK_ENTIREBUFFER)
-		writebytes = This->buflen;
-
-	if (writecursor >= This->buflen) {
-		WARN("Invalid parameter, writecursor: %u >= buflen: %u\n",
-		     writecursor, This->buflen);
-		return DSERR_INVALIDPARAM;
-        }
+    EnterCriticalSection(This->crst);
+    if(!(This->buffer->dsbflags&DSBCAPS_CTRLVOLUME))
+        hr = DSERR_CONTROLUNAVAIL;
+    if(SUCCEEDED(hr))
+    {
+        ALfloat fvol = mB_to_gain(vol);
+        setALContext(This->ctx);
+        palSourcef(This->source, AL_GAIN, fvol);
+        popALContext();
+    }
+    LeaveCriticalSection(This->crst);
 
-	if (writebytes > This->buflen) {
-		WARN("Invalid parameter, writebytes: %u > buflen: %u\n",
-		     writebytes, This->buflen);
-		return DSERR_INVALIDPARAM;
-        }
+    return hr;
+}
 
-	/* **** */
-	RtlAcquireResourceShared(&This->lock, TRUE);
-
-	if (!(This->device->drvdesc.dwFlags & DSDDESC_DONTNEEDSECONDARYLOCK) && This->hwbuf) {
-		hres = IDsDriverBuffer_Lock(This->hwbuf,
-				     lplpaudioptr1, audiobytes1,
-				     lplpaudioptr2, audiobytes2,
-				     writecursor, writebytes,
-				     0);
-		if (hres != DS_OK) {
-			WARN("IDsDriverBuffer_Lock failed\n");
-			RtlReleaseResource(&This->lock);
-			return hres;
-		}
-	} else {
-		if (writecursor+writebytes <= This->buflen) {
-			*(LPBYTE*)lplpaudioptr1 = This->buffer->memory+writecursor;
-			if (This->sec_mixpos >= writecursor && This->sec_mixpos < writecursor + writebytes && This->state == STATE_PLAYING)
-				WARN("Overwriting mixing position, case 1\n");
-			*audiobytes1 = writebytes;
-			if (lplpaudioptr2)
-				*(LPBYTE*)lplpaudioptr2 = NULL;
-			if (audiobytes2)
-				*audiobytes2 = 0;
-			TRACE("Locked %p(%i bytes) and %p(%i bytes) writecursor=%d\n",
-			  *(LPBYTE*)lplpaudioptr1, *audiobytes1, lplpaudioptr2 ? *(LPBYTE*)lplpaudioptr2 : NULL, audiobytes2 ? *audiobytes2: 0, writecursor);
-			TRACE("->%d.0\n",writebytes);
-		} else {
-			DWORD remainder = writebytes + writecursor - This->buflen;
-			*(LPBYTE*)lplpaudioptr1 = This->buffer->memory+writecursor;
-			*audiobytes1 = This->buflen-writecursor;
-			if (This->sec_mixpos >= writecursor && This->sec_mixpos < writecursor + writebytes && This->state == STATE_PLAYING)
-				WARN("Overwriting mixing position, case 2\n");
-			if (lplpaudioptr2)
-				*(LPBYTE*)lplpaudioptr2 = This->buffer->memory;
-			if (audiobytes2)
-				*audiobytes2 = writebytes-(This->buflen-writecursor);
-			if (audiobytes2 && This->sec_mixpos < remainder && This->state == STATE_PLAYING)
-				WARN("Overwriting mixing position, case 3\n");
-			TRACE("Locked %p(%i bytes) and %p(%i bytes) writecursor=%d\n", *(LPBYTE*)lplpaudioptr1, *audiobytes1, lplpaudioptr2 ? *(LPBYTE*)lplpaudioptr2 : NULL, audiobytes2 ? *audiobytes2: 0, writecursor);
-		}
-	}
-
-	RtlReleaseResource(&This->lock);
-	/* **** */
-
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSoundBufferImpl_SetCurrentPosition(IDirectSoundBuffer8 *iface,
-        DWORD newpos)
-{
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
-	HRESULT hres = DS_OK;
-	DWORD oldpos;
+static HRESULT WINAPI DS8Buffer_SetPan(IDirectSoundBuffer8 *iface, LONG pan)
+{
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    HRESULT hr = S_OK;
 
-	TRACE("(%p,%d)\n",This,newpos);
+    TRACE("(%p)->(%d)\n", iface, pan);
 
-	/* **** */
-	RtlAcquireResourceExclusive(&This->lock, TRUE);
+    if(pan > DSBPAN_RIGHT || pan < DSBPAN_LEFT)
+    {
+        WARN("invalid parameter: pan = %d\n", pan);
+        return DSERR_INVALIDPARAM;
+    }
 
-	oldpos = This->sec_mixpos;
-
-	/* start mixing from this new location instead */
-	newpos %= This->buflen;
-	newpos -= newpos%This->pwfx->nBlockAlign;
-	This->sec_mixpos = newpos;
+    EnterCriticalSection(This->crst);
+    if(!(This->buffer->dsbflags&DSBCAPS_CTRLPAN))
+        hr = DSERR_CONTROLUNAVAIL;
+    else
+    {
+        ALfloat pos[3];
+        pos[0] = (pan-DSBPAN_LEFT) * 2.0 / (ALfloat)(DSBPAN_RIGHT-DSBPAN_LEFT) - 1.0;
+        /* NOTE: Strict movement along the X plane can cause the sound to jump
+         * between left and right sharply. Using a curved path helps smooth it
+         * out */
+        pos[1] = sqrt(1.0 - pos[0]*pos[0]);
+        pos[2] = 0.0;
+
+        setALContext(This->ctx);
+        palSourcefv(This->source, AL_POSITION, pos);
+        getALError();
+        popALContext();
+    }
+    if(This->buffer->format->nChannels > 1)
+        WARN("Panning for >1 channels not supported!\n");
+    LeaveCriticalSection(This->crst);
+
+    return hr;
+}
 
-	/* at this point, do not attempt to reset buffers, mess with primary mix position,
-           or anything like that to reduce latency. The data already prebuffered cannot be changed */
+static HRESULT WINAPI DS8Buffer_SetFrequency(IDirectSoundBuffer8 *iface, DWORD freq)
+{
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("(%p)->(%u)\n", iface, freq);
 
-	/* position HW buffer if applicable, else just start mixing from new location instead */
-	if (This->hwbuf) {
-		hres = IDsDriverBuffer_SetPosition(This->hwbuf, This->buf_mixpos);
-		if (hres != DS_OK)
-			WARN("IDsDriverBuffer_SetPosition failed\n");
-	}
-	else if (oldpos != newpos)
-		/* FIXME: Perhaps add a call to DSOUND_MixToTemporary here? Not sure it's needed */
-		This->buf_mixpos = DSOUND_secpos_to_bufpos(This, newpos, 0, NULL);
-
-	RtlReleaseResource(&This->lock);
-	/* **** */
-
-	return hres;
-}
-
-static HRESULT WINAPI IDirectSoundBufferImpl_SetPan(IDirectSoundBuffer8 *iface, LONG pan)
-{
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
-	HRESULT hres = DS_OK;
-
-	TRACE("(%p,%d)\n",This,pan);
-
-	if ((pan > DSBPAN_RIGHT) || (pan < DSBPAN_LEFT)) {
-		WARN("invalid parameter: pan = %d\n", pan);
-		return DSERR_INVALIDPARAM;
-	}
-
-	/* You cannot use both pan and 3D controls */
-	if (!(This->dsbd.dwFlags & DSBCAPS_CTRLPAN) ||
-	    (This->dsbd.dwFlags & DSBCAPS_CTRL3D)) {
-		WARN("control unavailable\n");
-		return DSERR_CONTROLUNAVAIL;
-	}
+    if(freq < DSBFREQUENCY_MIN || freq > DSBFREQUENCY_MAX)
+    {
+        WARN("invalid parameter: freq = %d\n", freq);
+        return DSERR_INVALIDPARAM;
+    }
 
-	/* **** */
-	RtlAcquireResourceExclusive(&This->lock, TRUE);
+    EnterCriticalSection(This->crst);
+    if(!(This->buffer->dsbflags&DSBCAPS_CTRLFREQUENCY))
+        hr = DSERR_CONTROLUNAVAIL;
+    else
+    {
+        ALfloat pitch = 1.0f;
+        if(freq != DSBFREQUENCY_ORIGINAL)
+            pitch = freq / (ALfloat)This->buffer->format->nSamplesPerSec;
+
+        setALContext(This->ctx);
+        palSourcef(This->source, AL_PITCH, pitch);
+        getALError();
+        popALContext();
+    }
+    LeaveCriticalSection(This->crst);
+    return hr;
+}
 
-	if (This->volpan.lPan != pan) {
-		This->volpan.lPan = pan;
-		DSOUND_RecalcVolPan(&(This->volpan));
+static HRESULT WINAPI DS8Buffer_Stop(IDirectSoundBuffer8 *iface)
+{
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    ALint state;
+
+    TRACE("(%p)->()\n", iface);
+
+    EnterCriticalSection(This->crst);
+    setALContext(This->ctx);
+
+    palSourcePause(This->source);
+    getALError();
+    /* Mac OS X doesn't immediately report state change
+     * if Play() is immediately called after Stop, this can be fatal,
+     * the buffer would never be restarted
+     */
+    do {
+        state = AL_PAUSED;
+        palGetSourcei(This->source, AL_SOURCE_STATE, &state);
+        if(state != AL_PLAYING)
+            break;
+        Sleep(1);
+    } while(1);
+
+    /* Stopped, remove from notify list */
+    if(This->nnotify)
+    {
+        HRESULT hr;
+        DWORD pos = This->lastpos;
+        hr = IDirectSoundBuffer8_GetCurrentPosition(iface, &pos, NULL);
+        if(FAILED(hr))
+            ERR("Own getcurrentposition failed!\n");
+        trigger_notifies(This, This->lastpos, pos, TRUE);
+        This->lastpos = pos;
+        DS8Buffer_removenotify(This);
+    }
 
-		if (This->hwbuf) {
-			hres = IDsDriverBuffer_SetVolumePan(This->hwbuf, &(This->volpan));
-			if (hres != DS_OK)
-				WARN("IDsDriverBuffer_SetVolumePan failed\n");
-		}
-	}
+    This->isplaying = FALSE;
 
-	RtlReleaseResource(&This->lock);
-	/* **** */
+    popALContext();
+    LeaveCriticalSection(This->crst);
 
-	return hres;
+    return S_OK;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_GetPan(IDirectSoundBuffer8 *iface, LONG *pan)
+static HRESULT WINAPI DS8Buffer_Unlock(IDirectSoundBuffer8 *iface, void *ptr1, DWORD len1, void *ptr2, DWORD len2)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    DS8Data *buf = This->buffer;
+    DWORD bufsize = buf->buf_size;
+    DWORD_PTR ofs1, ofs2;
+    DWORD_PTR boundary = (DWORD_PTR)buf->data;
+    HRESULT hr;
+
+    TRACE("(%p)->(%p, %u, %p, %u)\n", iface, ptr1, len1, ptr2, len2);
+
+    EnterCriticalSection(This->crst);
+    setALContext(This->ctx);
+
+    This->buffer->locked = 0;
+    hr = DSERR_INVALIDPARAM;
+
+    /* Make sure offset is between boundary and boundary + bufsize */
+    ofs1 = (DWORD_PTR)ptr1;
+    ofs2 = (DWORD_PTR)ptr2;
+    if(ofs1 < boundary)
+        goto out;
+    if(ofs2 && ofs2 != boundary)
+        goto out;
+    ofs1 -= boundary;
+    ofs2 = 0;
+    if(bufsize-ofs1 < len1 || len2 > ofs1)
+        goto out;
+    if(!ptr2)
+        len2 = 0;
+
+    hr = S_OK;
+    if(!len1 && !len2)
+        goto out;
+
+    if(This->ExtAL->BufferDataStatic)
+        goto out;
+
+    if(This->ExtAL->BufferSubData)
+    {
+        WAVEFORMATEX *format = buf->format;
+
+        len1 -= len1%format->nBlockAlign;
+        if(len1 > 0)
+            This->ExtAL->BufferSubData(buf->buffers[0], buf->buf_format, ptr1,
+                                       ofs1, len1);
+        len2 -= len2%format->nBlockAlign;
+        if(len2 > 0)
+            This->ExtAL->BufferSubData(buf->buffers[0], buf->buf_format, ptr2,
+                                       ofs2, len2);
+        getALError();
+    }
+    else
+    {
+        palBufferData(buf->buffers[0], buf->buf_format,
+                      buf->data, buf->buf_size,
+                      buf->format->nSamplesPerSec);
+        getALError();
+    }
 
-	TRACE("(%p,%p)\n",This,pan);
+    This->buffer->buggy_app_detection = 0;
+out:
+    if (hr != S_OK) {
+        WARN("Invalid parameters (0x%lx,%u) (%p,%u,%p,%u)\n", boundary, bufsize, ptr1, len1, ptr2, len2);
+        buf->buggy_app_detection = buf->buf_size;
+    }
+    popALContext();
+    LeaveCriticalSection(This->crst);
+    return hr;
+}
 
-	if (!(This->dsbd.dwFlags & DSBCAPS_CTRLPAN)) {
-		WARN("control unavailable\n");
-		return DSERR_CONTROLUNAVAIL;
-	}
+static HRESULT WINAPI DS8Buffer_Restore(IDirectSoundBuffer8 *iface)
+{
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    HRESULT hr;
 
-	if (pan == NULL) {
-		WARN("invalid parameter: pan = NULL\n");
-		return DSERR_INVALIDPARAM;
-	}
+    TRACE("(%p)->()\n", iface);
 
-	*pan = This->volpan.lPan;
+    EnterCriticalSection(This->crst);
+    if(This->primary->parent->prio_level < DSSCL_WRITEPRIMARY ||
+       iface == This->primary->write_emu)
+    {
+        This->bufferlost = 0;
+        hr = S_OK;
+    }
+    else
+        hr = DSERR_BUFFERLOST;
+    LeaveCriticalSection(This->crst);
 
-	return DS_OK;
+    return hr;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_Unlock(IDirectSoundBuffer8 *iface, void *p1, DWORD x1,
-        void *p2, DWORD x2)
+static HRESULT WINAPI DS8Buffer_SetFX(IDirectSoundBuffer8 *iface, DWORD fxcount, DSEFFECTDESC *desc, DWORD *rescodes)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface), *iter;
-	HRESULT hres = DS_OK;
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+    DWORD i;
 
-	TRACE("(%p,%p,%d,%p,%d)\n", This,p1,x1,p2,x2);
+    TRACE("(%p)->(%u, %p, %p)\n", This, fxcount, desc, rescodes);
 
-	/* **** */
-	RtlAcquireResourceShared(&This->lock, TRUE);
+    if(!(This->buffer->dsbflags & DSBCAPS_CTRLFX))
+    {
+        WARN("FX control not set\n");
+        return DSERR_CONTROLUNAVAIL;
+    }
 
-	if (!(This->device->drvdesc.dwFlags & DSDDESC_DONTNEEDSECONDARYLOCK) && This->hwbuf) {
-		hres = IDsDriverBuffer_Unlock(This->hwbuf, p1, x1, p2, x2);
-		if (hres != DS_OK)
-			WARN("IDsDriverBuffer_Unlock failed\n");
-	}
+    if(fxcount == 0)
+    {
+        if(desc || rescodes)
+        {
+            WARN("Non-NULL desc and/or result pointer specified with no effects.\n");
+            return DSERR_INVALIDPARAM;
+        }
 
-	RtlReleaseResource(&This->lock);
-	/* **** */
+        /* No effects; we can handle that */
+        return DS_OK;
+    }
 
-	if (!p2)
-		x2 = 0;
+    if(!desc || !rescodes)
+    {
+        WARN("NULL desc and/or result pointer specified.\n");
+        return DSERR_INVALIDPARAM;
+    }
 
-	if (!This->hwbuf && (x1 || x2))
-	{
-		RtlAcquireResourceShared(&This->device->buffer_list_lock, TRUE);
-		LIST_FOR_EACH_ENTRY(iter, &This->buffer->buffers, IDirectSoundBufferImpl, entry )
-		{
-			RtlAcquireResourceShared(&iter->lock, TRUE);
-			if (x1)
-                        {
-			    if(x1 + (DWORD_PTR)p1 - (DWORD_PTR)iter->buffer->memory > iter->buflen)
-			      hres = DSERR_INVALIDPARAM;
-			    else
-			      DSOUND_MixToTemporary(iter, (DWORD_PTR)p1 - (DWORD_PTR)iter->buffer->memory, x1, FALSE);
-                        }
-			if (x2)
-				DSOUND_MixToTemporary(iter, 0, x2, FALSE);
-			RtlReleaseResource(&iter->lock);
-		}
-		RtlReleaseResource(&This->device->buffer_list_lock);
-	}
+    /* We don't (currently) handle DSound effects */
+    for(i = 0;i < fxcount;++i)
+    {
+        FIXME("Cannot handle effect: %s\n", debugstr_guid(&desc[i].guidDSFXClass));
+        rescodes[i] = DSFXR_FAILED;
+    }
 
-	return hres;
+    return DSERR_INVALIDPARAM;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_Restore(IDirectSoundBuffer8 *iface)
+static HRESULT WINAPI DS8Buffer_AcquireResources(IDirectSoundBuffer8 *iface, DWORD flags, DWORD fxcount, DWORD *rescodes)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
+    DS8Buffer *This = impl_from_IDirectSoundBuffer8(iface);
+
+    TRACE("(%p)->(%u, %u, %p)\n", This, flags, fxcount, rescodes);
+
+    /* effects aren't supported at the moment.. */
+    if(fxcount != 0 || rescodes)
+    {
+        WARN("Non-zero effect count and/or result pointer specified with no effects.\n");
+        return DSERR_INVALIDPARAM;
+    }
 
-	FIXME("(%p):stub\n",This);
-	return DS_OK;
+    EnterCriticalSection(This->crst);
+    if(This->buffer->dsbflags & DSBCAPS_LOCDEFER)
+    {
+        This->buffer->dsbflags &= ~(DSBCAPS_LOCSOFTWARE|DSBCAPS_LOCHARDWARE);
+        if((flags&DSBPLAY_LOCSOFTWARE))
+            This->buffer->dsbflags |= DSBCAPS_LOCSOFTWARE;
+        else
+            This->buffer->dsbflags |= DSBCAPS_LOCHARDWARE;
+    }
+    LeaveCriticalSection(This->crst);
+
+    return S_OK;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_GetFrequency(IDirectSoundBuffer8 *iface, DWORD *freq)
+static HRESULT WINAPI DS8Buffer_GetObjectInPath(IDirectSoundBuffer8 *iface, REFGUID guid, DWORD idx, REFGUID rguidiface, void **ppv)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
+    FIXME("(%p)->(%s, %u, %s, %p) : stub!\n", iface, debugstr_guid(guid), idx, debugstr_guid(rguidiface), ppv);
+    return E_NOTIMPL;
+}
 
-	TRACE("(%p,%p)\n",This,freq);
+static const IDirectSoundBuffer8Vtbl DS8Buffer_Vtbl =
+{
+    DS8Buffer_QueryInterface,
+    DS8Buffer_AddRef,
+    DS8Buffer_Release,
+    DS8Buffer_GetCaps,
+    DS8Buffer_GetCurrentPosition,
+    DS8Buffer_GetFormat,
+    DS8Buffer_GetVolume,
+    DS8Buffer_GetPan,
+    DS8Buffer_GetFrequency,
+    DS8Buffer_GetStatus,
+    DS8Buffer_Initialize,
+    DS8Buffer_Lock,
+    DS8Buffer_Play,
+    DS8Buffer_SetCurrentPosition,
+    DS8Buffer_SetFormat,
+    DS8Buffer_SetVolume,
+    DS8Buffer_SetPan,
+    DS8Buffer_SetFrequency,
+    DS8Buffer_Stop,
+    DS8Buffer_Unlock,
+    DS8Buffer_Restore,
+    DS8Buffer_SetFX,
+    DS8Buffer_AcquireResources,
+    DS8Buffer_GetObjectInPath
+};
+
+static inline DS8Buffer *impl_from_IDirectSound3DBuffer(IDirectSound3DBuffer *iface)
+{
+    return CONTAINING_RECORD(iface, DS8Buffer, IDirectSound3DBuffer_iface);
+}
+
+static HRESULT WINAPI DS8Buffer3D_QueryInterface(IDirectSound3DBuffer *iface, REFIID riid, void **ppv)
+{
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+    return IDirectSoundBuffer8_QueryInterface(&This->IDirectSoundBuffer8_iface, riid, ppv);
+}
 
-	if (freq == NULL) {
-		WARN("invalid parameter: freq = NULL\n");
-		return DSERR_INVALIDPARAM;
-	}
+static ULONG WINAPI DS8Buffer3D_AddRef(IDirectSound3DBuffer *iface)
+{
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+    LONG ret;
 
-	*freq = This->freq;
-	TRACE("-> %d\n", *freq);
+    InterlockedIncrement(&This->all_ref);
+    ret = InterlockedIncrement(&This->ds3d_ref);
+    TRACE("new refcount %d\n", ret);
 
-	return DS_OK;
+    return ret;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_SetFX(IDirectSoundBuffer8 *iface, DWORD dwEffectsCount,
-        LPDSEFFECTDESC pDSFXDesc, DWORD *pdwResultCodes)
+static ULONG WINAPI DS8Buffer3D_Release(IDirectSound3DBuffer *iface)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
-	DWORD u;
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+    LONG ret;
+
+    ret = InterlockedDecrement(&This->ds3d_ref);
+    TRACE("new refcount %d\n", ret);
+    if(InterlockedDecrement(&This->all_ref) == 0)
+        DS8Buffer_Destroy(This);
 
-	FIXME("(%p,%u,%p,%p): stub\n",This,dwEffectsCount,pDSFXDesc,pdwResultCodes);
+    return ret;
+}
+
+static HRESULT WINAPI DS8Buffer3D_GetAllParameters(IDirectSound3DBuffer *iface, DS3DBUFFER *ds3dbuffer)
+{
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+    DS3DBUFFER ds3dbuf;
+    HRESULT hr;
 
-	if (pdwResultCodes)
-		for (u=0; u<dwEffectsCount; u++) pdwResultCodes[u] = DSFXR_UNKNOWN;
+    TRACE("%p\n", This);
 
-	WARN("control unavailable\n");
-	return DSERR_CONTROLUNAVAIL;
+    if(!ds3dbuffer || ds3dbuffer->dwSize < sizeof(*ds3dbuffer))
+    {
+        WARN("Invalid parameters %p %u\n", ds3dbuffer, ds3dbuffer ? ds3dbuffer->dwSize : 0);
+        return DSERR_INVALIDPARAM;
+    }
+    ds3dbuf.dwSize = sizeof(ds3dbuf);
+
+    EnterCriticalSection(This->crst);
+    setALContext(This->ctx);
+
+    hr = IDirectSound3DBuffer_GetPosition(iface, &ds3dbuf.vPosition);
+    if(SUCCEEDED(hr))
+        hr = IDirectSound3DBuffer_GetVelocity(iface, &ds3dbuf.vVelocity);
+    if(SUCCEEDED(hr))
+        hr = IDirectSound3DBuffer_GetConeAngles(iface, &ds3dbuf.dwInsideConeAngle, &ds3dbuf.dwOutsideConeAngle);
+    if(SUCCEEDED(hr))
+        hr = IDirectSound3DBuffer_GetConeOrientation(iface, &ds3dbuf.vConeOrientation);
+    if(SUCCEEDED(hr))
+        hr = IDirectSound3DBuffer_GetConeOutsideVolume(iface, &ds3dbuf.lConeOutsideVolume);
+    if(SUCCEEDED(hr))
+        hr = IDirectSound3DBuffer_GetMinDistance(iface, &ds3dbuf.flMinDistance);
+    if(SUCCEEDED(hr))
+        hr = IDirectSound3DBuffer_GetMaxDistance(iface, &ds3dbuf.flMaxDistance);
+    if(SUCCEEDED(hr))
+        hr = IDirectSound3DBuffer_GetMode(iface, &ds3dbuf.dwMode);
+    if(SUCCEEDED(hr))
+        memcpy(ds3dbuffer, &ds3dbuf, sizeof(ds3dbuf));
+
+    popALContext();
+    LeaveCriticalSection(This->crst);
+
+    return hr;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_AcquireResources(IDirectSoundBuffer8 *iface,
-        DWORD dwFlags, DWORD dwEffectsCount, DWORD *pdwResultCodes)
+static HRESULT WINAPI DS8Buffer3D_GetConeAngles(IDirectSound3DBuffer *iface, DWORD *pdwInsideConeAngle, DWORD *pdwOutsideConeAngle)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
-	DWORD u;
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+    ALint inangle, outangle;
+
+    TRACE("(%p)->(%p, %p)\n", This, pdwInsideConeAngle, pdwOutsideConeAngle);
+    if(!pdwInsideConeAngle || !pdwOutsideConeAngle)
+    {
+        WARN("Invalid pointers (%p, %p)\n", pdwInsideConeAngle, pdwOutsideConeAngle);
+        return DSERR_INVALIDPARAM;
+    }
 
-	FIXME("(%p,%08u,%u,%p): stub, faking success\n",This,dwFlags,dwEffectsCount,pdwResultCodes);
+    EnterCriticalSection(This->crst);
+    setALContext(This->ctx);
 
-	if (pdwResultCodes)
-		for (u=0; u<dwEffectsCount; u++) pdwResultCodes[u] = DSFXR_UNKNOWN;
+    palGetSourcei(This->source, AL_CONE_INNER_ANGLE, &inangle);
+    palGetSourcei(This->source, AL_CONE_OUTER_ANGLE, &outangle);
+    getALError();
+    *pdwInsideConeAngle = inangle;
+    *pdwOutsideConeAngle = outangle;
 
-	WARN("control unavailable\n");
-	return DS_OK;
+    popALContext();
+    LeaveCriticalSection(This->crst);
+
+    return S_OK;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_GetObjectInPath(IDirectSoundBuffer8 *iface,
-        REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, void **ppObject)
+static HRESULT WINAPI DS8Buffer3D_GetConeOrientation(IDirectSound3DBuffer *iface, D3DVECTOR *orient)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+    ALfloat dir[3];
+
+    TRACE("(%p)->(%p)\n", This, orient);
+    if(!orient)
+    {
+        WARN("Invalid pointer\n");
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(This->crst);
+    setALContext(This->ctx);
+
+    palGetSourcefv(This->source, AL_DIRECTION, dir);
+    getALError();
+    orient->x =  dir[0];
+    orient->y =  dir[1];
+    orient->z = -dir[2];
 
-	FIXME("(%p,%s,%u,%s,%p): stub\n",This,debugstr_guid(rguidObject),dwIndex,debugstr_guid(rguidInterface),ppObject);
+    popALContext();
+    LeaveCriticalSection(This->crst);
 
-	WARN("control unavailable\n");
-	return DSERR_CONTROLUNAVAIL;
+    return S_OK;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_Initialize(IDirectSoundBuffer8 *iface,
-        IDirectSound *dsound, LPCDSBUFFERDESC dbsd)
+static HRESULT WINAPI DS8Buffer3D_GetConeOutsideVolume(IDirectSound3DBuffer *iface, LONG *vol)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+    ALfloat gain;
+
+    TRACE("(%p)->(%p)\n", This, vol);
+    if(!vol)
+    {
+        WARN("Invalid pointer\n");
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(This->crst);
+    setALContext(This->ctx);
 
-	WARN("(%p) already initialized\n", This);
-	return DSERR_ALREADYINITIALIZED;
+    palGetSourcef(This->source, AL_CONE_OUTER_GAIN, &gain);
+    getALError();
+    *vol = gain_to_mB(gain);
+    *vol = max(*vol, DSBVOLUME_MIN);
+    *vol = min(*vol, DSBVOLUME_MAX);
+
+    popALContext();
+    LeaveCriticalSection(This->crst);
+    return S_OK;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_GetCaps(IDirectSoundBuffer8 *iface, LPDSBCAPS caps)
+static HRESULT WINAPI DS8Buffer3D_GetMaxDistance(IDirectSound3DBuffer *iface, D3DVALUE *maxdist)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+    ALfloat dist;
+
+    TRACE("(%p)->(%p)\n", This, maxdist);
+    if(!maxdist)
+    {
+        WARN("Invalid pointer\n");
+        return DSERR_INVALIDPARAM;
+    }
 
-  	TRACE("(%p)->(%p)\n",This,caps);
+    EnterCriticalSection(This->crst);
+    setALContext(This->ctx);
 
-	if (caps == NULL) {
-		WARN("invalid parameter: caps == NULL\n");
-		return DSERR_INVALIDPARAM;
-	}
+    palGetSourcef(This->source, AL_MAX_DISTANCE, &dist);
+    getALError();
+    *maxdist = dist;
 
-	if (caps->dwSize < sizeof(*caps)) {
-		WARN("invalid parameter: caps->dwSize = %d\n",caps->dwSize);
-		return DSERR_INVALIDPARAM;
-	}
+    popALContext();
+    LeaveCriticalSection(This->crst);
 
-	caps->dwFlags = This->dsbd.dwFlags;
-	if (This->hwbuf) caps->dwFlags |= DSBCAPS_LOCHARDWARE;
-	else caps->dwFlags |= DSBCAPS_LOCSOFTWARE;
+    return S_OK;
+}
+
+static HRESULT WINAPI DS8Buffer3D_GetMinDistance(IDirectSound3DBuffer *iface, D3DVALUE *mindist)
+{
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+    ALfloat dist;
+
+    TRACE("(%p)->(%p)\n", This, mindist);
+    if (!mindist)
+    {
+        WARN("Invalid pointer\n");
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(This->crst);
+    setALContext(This->ctx);
 
-	caps->dwBufferBytes = This->buflen;
+    palGetSourcef(This->source, AL_REFERENCE_DISTANCE, &dist);
+    getALError();
+    *mindist = dist;
 
-	/* According to windows, this is zero*/
-	caps->dwUnlockTransferRate = 0;
-	caps->dwPlayCpuOverhead = 0;
+    popALContext();
+    LeaveCriticalSection(This->crst);
 
-	return DS_OK;
+    return S_OK;
 }
 
-static HRESULT WINAPI IDirectSoundBufferImpl_QueryInterface(IDirectSoundBuffer8 *iface, REFIID riid,
-        void **ppobj)
+static HRESULT WINAPI DS8Buffer3D_GetMode(IDirectSound3DBuffer *iface, DWORD *mode)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer8(iface);
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+
+    TRACE("(%p)->(%p)\n", This, mode);
+    if(!mode)
+    {
+        WARN("Invalid pointer\n");
+        return DSERR_INVALIDPARAM;
+    }
 
-	TRACE("(%p,%s,%p)\n",This,debugstr_guid(riid),ppobj);
+    EnterCriticalSection(This->crst);
+    *mode = This->ds3dmode;
+    LeaveCriticalSection(This->crst);
+
+    return S_OK;
+}
 
-	if (ppobj == NULL) {
-		WARN("invalid parameter\n");
-		return E_INVALIDARG;
-	}
+static HRESULT WINAPI DS8Buffer3D_GetPosition(IDirectSound3DBuffer *iface, D3DVECTOR *pos)
+{
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+    ALfloat alpos[3];
+
+    TRACE("(%p)->(%p)\n", This, pos);
+    if(!pos)
+    {
+        WARN("Invalid pointer\n");
+        return DSERR_INVALIDPARAM;
+    }
 
-	*ppobj = NULL;	/* assume failure */
+    EnterCriticalSection(This->crst);
+    setALContext(This->ctx);
 
-	if ( IsEqualGUID(riid, &IID_IUnknown) ||
-	     IsEqualGUID(riid, &IID_IDirectSoundBuffer) ||
-	     IsEqualGUID(riid, &IID_IDirectSoundBuffer8) ) {
-                IDirectSoundBuffer8_AddRef(iface);
-                *ppobj = iface;
-                return S_OK;
-	}
+    palGetSourcefv(This->source, AL_POSITION, alpos);
+    getALError();
+    pos->x =  alpos[0];
+    pos->y =  alpos[1];
+    pos->z = -alpos[2];
 
-	if ( IsEqualGUID( &IID_IDirectSoundNotify, riid ) ) {
-		if (!This->notify)
-			IDirectSoundNotifyImpl_Create(This, &(This->notify));
-		if (This->notify) {
-			IDirectSoundNotify_AddRef((LPDIRECTSOUNDNOTIFY)This->notify);
-			*ppobj = This->notify;
-			return S_OK;
-		}
-		WARN("IID_IDirectSoundNotify\n");
-		return E_NOINTERFACE;
-	}
+    popALContext();
+    LeaveCriticalSection(This->crst);
 
-	if ( IsEqualGUID( &IID_IDirectSound3DBuffer, riid ) ) {
-		if (!This->ds3db)
-			IDirectSound3DBufferImpl_Create(This, &(This->ds3db));
-		if (This->ds3db) {
-			IDirectSound3DBuffer_AddRef((LPDIRECTSOUND3DBUFFER)This->ds3db);
-			*ppobj = This->ds3db;
-			return S_OK;
-		}
-		WARN("IID_IDirectSound3DBuffer\n");
-		return E_NOINTERFACE;
-	}
-
-	if ( IsEqualGUID( &IID_IDirectSound3DListener, riid ) ) {
-		ERR("app requested IDirectSound3DListener on secondary buffer\n");
-		return E_NOINTERFACE;
-	}
-
-	if ( IsEqualGUID( &IID_IKsPropertySet, riid ) ) {
-		if (!This->iks)
-			IKsBufferPropertySetImpl_Create(This, &(This->iks));
-		if (This->iks) {
-			IKsPropertySet_AddRef((LPKSPROPERTYSET)This->iks);
-	    		*ppobj = This->iks;
-			return S_OK;
-		}
-		WARN("IID_IKsPropertySet\n");
-		return E_NOINTERFACE;
-	}
-
-	FIXME( "Unknown IID %s\n", debugstr_guid( riid ) );
-
-	return E_NOINTERFACE;
-}
-
-static const IDirectSoundBuffer8Vtbl dsbvt =
-{
-	IDirectSoundBufferImpl_QueryInterface,
-	IDirectSoundBufferImpl_AddRef,
-	IDirectSoundBufferImpl_Release,
-	IDirectSoundBufferImpl_GetCaps,
-	IDirectSoundBufferImpl_GetCurrentPosition,
-	IDirectSoundBufferImpl_GetFormat,
-	IDirectSoundBufferImpl_GetVolume,
-	IDirectSoundBufferImpl_GetPan,
-	IDirectSoundBufferImpl_GetFrequency,
-	IDirectSoundBufferImpl_GetStatus,
-	IDirectSoundBufferImpl_Initialize,
-	IDirectSoundBufferImpl_Lock,
-	IDirectSoundBufferImpl_Play,
-	IDirectSoundBufferImpl_SetCurrentPosition,
-	IDirectSoundBufferImpl_SetFormat,
-	IDirectSoundBufferImpl_SetVolume,
-	IDirectSoundBufferImpl_SetPan,
-	IDirectSoundBufferImpl_SetFrequency,
-	IDirectSoundBufferImpl_Stop,
-	IDirectSoundBufferImpl_Unlock,
-	IDirectSoundBufferImpl_Restore,
-	IDirectSoundBufferImpl_SetFX,
-	IDirectSoundBufferImpl_AcquireResources,
-	IDirectSoundBufferImpl_GetObjectInPath
-};
+    return S_OK;
+}
 
-HRESULT IDirectSoundBufferImpl_Create(
-	DirectSoundDevice * device,
-	IDirectSoundBufferImpl **pdsb,
-	LPCDSBUFFERDESC dsbd)
-{
-	IDirectSoundBufferImpl *dsb;
-	LPWAVEFORMATEX wfex = dsbd->lpwfxFormat;
-	HRESULT err = DS_OK;
-	DWORD capf = 0;
-	int use_hw;
-	TRACE("(%p,%p,%p)\n",device,pdsb,dsbd);
-
-	if (dsbd->dwBufferBytes < DSBSIZE_MIN || dsbd->dwBufferBytes > DSBSIZE_MAX) {
-		WARN("invalid parameter: dsbd->dwBufferBytes = %d\n", dsbd->dwBufferBytes);
-		*pdsb = NULL;
-		return DSERR_INVALIDPARAM; /* FIXME: which error? */
-	}
-
-	dsb = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(*dsb));
-
-	if (dsb == 0) {
-		WARN("out of memory\n");
-		*pdsb = NULL;
-		return DSERR_OUTOFMEMORY;
-	}
-
-	TRACE("Created buffer at %p\n", dsb);
-
-        dsb->ref = 1;
-        dsb->numIfaces = 1;
-	dsb->device = device;
-        dsb->IDirectSoundBuffer8_iface.lpVtbl = &dsbvt;
-	dsb->iks = NULL;
-
-	/* size depends on version */
-	CopyMemory(&dsb->dsbd, dsbd, dsbd->dwSize);
-
-	dsb->pwfx = DSOUND_CopyFormat(wfex);
-	if (dsb->pwfx == NULL) {
-		HeapFree(GetProcessHeap(),0,dsb);
-		*pdsb = NULL;
-		return DSERR_OUTOFMEMORY;
-	}
-
-	if (dsbd->dwBufferBytes % dsbd->lpwfxFormat->nBlockAlign)
-		dsb->buflen = dsbd->dwBufferBytes + 
-			(dsbd->lpwfxFormat->nBlockAlign - 
-			(dsbd->dwBufferBytes % dsbd->lpwfxFormat->nBlockAlign));
-	else
-		dsb->buflen = dsbd->dwBufferBytes;
-
-	dsb->freq = dsbd->lpwfxFormat->nSamplesPerSec;
-	dsb->notify = NULL;
-	dsb->notifies = NULL;
-	dsb->nrofnotifies = 0;
-	dsb->hwnotify = 0;
-
-	/* Check necessary hardware mixing capabilities */
-	if (wfex->nChannels==2) capf |= DSCAPS_SECONDARYSTEREO;
-	else capf |= DSCAPS_SECONDARYMONO;
-	if (wfex->wBitsPerSample==16) capf |= DSCAPS_SECONDARY16BIT;
-	else capf |= DSCAPS_SECONDARY8BIT;
-
-	use_hw = !!(dsbd->dwFlags & DSBCAPS_LOCHARDWARE);
-	TRACE("use_hw = %d, capf = 0x%08x, device->drvcaps.dwFlags = 0x%08x\n", use_hw, capf, device->drvcaps.dwFlags);
-	if (use_hw && ((device->drvcaps.dwFlags & capf) != capf || !device->driver))
-	{
-		if (device->driver)
-			WARN("Format not supported for hardware buffer\n");
-		HeapFree(GetProcessHeap(),0,dsb->pwfx);
-		HeapFree(GetProcessHeap(),0,dsb);
-		*pdsb = NULL;
-		if ((device->drvcaps.dwFlags & capf) != capf)
-			return DSERR_BADFORMAT;
-		return DSERR_GENERIC;
-	}
-
-	/* FIXME: check hardware sample rate mixing capabilities */
-	/* FIXME: check app hints for software/hardware buffer (STATIC, LOCHARDWARE, etc) */
-	/* FIXME: check whether any hardware buffers are left */
-	/* FIXME: handle DSDHEAP_CREATEHEAP for hardware buffers */
-
-	/* Allocate an empty buffer */
-	dsb->buffer = HeapAlloc(GetProcessHeap(),0,sizeof(*(dsb->buffer)));
-	if (dsb->buffer == NULL) {
-		WARN("out of memory\n");
-		HeapFree(GetProcessHeap(),0,dsb->pwfx);
-		HeapFree(GetProcessHeap(),0,dsb);
-		*pdsb = NULL;
-		return DSERR_OUTOFMEMORY;
-	}
-
-	/* Allocate system memory for buffer if applicable */
-	if ((device->drvdesc.dwFlags & DSDDESC_USESYSTEMMEMORY) || !use_hw) {
-		dsb->buffer->memory = HeapAlloc(GetProcessHeap(),0,dsb->buflen);
-		if (dsb->buffer->memory == NULL) {
-			WARN("out of memory\n");
-			HeapFree(GetProcessHeap(),0,dsb->pwfx);
-			HeapFree(GetProcessHeap(),0,dsb->buffer);
-			HeapFree(GetProcessHeap(),0,dsb);
-			*pdsb = NULL;
-			return DSERR_OUTOFMEMORY;
-		}
-	}
-
-	/* Allocate the hardware buffer */
-	if (use_hw) {
-		err = IDsDriver_CreateSoundBuffer(device->driver,wfex,dsbd->dwFlags,0,
-						  &(dsb->buflen),&(dsb->buffer->memory),
-						  (LPVOID*)&(dsb->hwbuf));
-		if (FAILED(err))
-		{
-			WARN("Failed to create hardware secondary buffer: %08x\n", err);
-			if (device->drvdesc.dwFlags & DSDDESC_USESYSTEMMEMORY)
-				HeapFree(GetProcessHeap(),0,dsb->buffer->memory);
-			HeapFree(GetProcessHeap(),0,dsb->buffer);
-			HeapFree(GetProcessHeap(),0,dsb->pwfx);
-			HeapFree(GetProcessHeap(),0,dsb);
-			*pdsb = NULL;
-			return DSERR_GENERIC;
-		}
-	}
-
-	dsb->buffer->ref = 1;
-	list_init(&dsb->buffer->buffers);
-	list_add_head(&dsb->buffer->buffers, &dsb->entry);
-	FillMemory(dsb->buffer->memory, dsb->buflen, dsbd->lpwfxFormat->wBitsPerSample == 8 ? 128 : 0);
-
-	/* It's not necessary to initialize values to zero since */
-	/* we allocated this structure with HEAP_ZERO_MEMORY... */
-	dsb->buf_mixpos = dsb->sec_mixpos = 0;
-	dsb->state = STATE_STOPPED;
-
-	dsb->freqAdjust = ((DWORD64)dsb->freq << DSOUND_FREQSHIFT) / device->pwfx->nSamplesPerSec;
-	dsb->nAvgBytesPerSec = dsb->freq *
-		dsbd->lpwfxFormat->nBlockAlign;
-
-	/* calculate fragment size and write lead */
-	DSOUND_RecalcFormat(dsb);
-
-	if (dsb->dsbd.dwFlags & DSBCAPS_CTRL3D) {
-		dsb->ds3db_ds3db.dwSize = sizeof(DS3DBUFFER);
-		dsb->ds3db_ds3db.vPosition.x = 0.0;
-		dsb->ds3db_ds3db.vPosition.y = 0.0;
-		dsb->ds3db_ds3db.vPosition.z = 0.0;
-		dsb->ds3db_ds3db.vVelocity.x = 0.0;
-		dsb->ds3db_ds3db.vVelocity.y = 0.0;
-		dsb->ds3db_ds3db.vVelocity.z = 0.0;
-		dsb->ds3db_ds3db.dwInsideConeAngle = DS3D_DEFAULTCONEANGLE;
-		dsb->ds3db_ds3db.dwOutsideConeAngle = DS3D_DEFAULTCONEANGLE;
-		dsb->ds3db_ds3db.vConeOrientation.x = 0.0;
-		dsb->ds3db_ds3db.vConeOrientation.y = 0.0;
-		dsb->ds3db_ds3db.vConeOrientation.z = 0.0;
-		dsb->ds3db_ds3db.lConeOutsideVolume = DS3D_DEFAULTCONEOUTSIDEVOLUME;
-		dsb->ds3db_ds3db.flMinDistance = DS3D_DEFAULTMINDISTANCE;
-		dsb->ds3db_ds3db.flMaxDistance = DS3D_DEFAULTMAXDISTANCE;
-		dsb->ds3db_ds3db.dwMode = DS3DMODE_NORMAL;
-
-		dsb->ds3db_need_recalc = FALSE;
-		DSOUND_Calc3DBuffer(dsb);
-	} else
-		DSOUND_RecalcVolPan(&(dsb->volpan));
-
-	RtlInitializeResource(&dsb->lock);
-
-	/* register buffer if not primary */
-	if (!(dsbd->dwFlags & DSBCAPS_PRIMARYBUFFER)) {
-		err = DirectSoundDevice_AddBuffer(device, dsb);
-		if (err != DS_OK) {
-			HeapFree(GetProcessHeap(),0,dsb->buffer->memory);
-			HeapFree(GetProcessHeap(),0,dsb->buffer);
-			RtlDeleteResource(&dsb->lock);
-			HeapFree(GetProcessHeap(),0,dsb->pwfx);
-			HeapFree(GetProcessHeap(),0,dsb);
-			dsb = NULL;
-		}
-	}
-
-	*pdsb = dsb;
-	return err;
-}
-
-void secondarybuffer_destroy(IDirectSoundBufferImpl *This)
-{
-    DirectSoundDevice_RemoveBuffer(This->device, This);
-    RtlDeleteResource(&This->lock);
-
-    if (This->hwbuf)
-        IDsDriverBuffer_Release(This->hwbuf);
-    if (!This->hwbuf || (This->device->drvdesc.dwFlags & DSDDESC_USESYSTEMMEMORY)) {
-        This->buffer->ref--;
-        list_remove(&This->entry);
-        if (This->buffer->ref == 0) {
-            HeapFree(GetProcessHeap(), 0, This->buffer->memory);
-            HeapFree(GetProcessHeap(), 0, This->buffer);
-        }
+static HRESULT WINAPI DS8Buffer3D_GetVelocity(IDirectSound3DBuffer *iface, D3DVECTOR *vel)
+{
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+    ALfloat alvel[3];
+
+    TRACE("(%p)->(%p)\n", This, vel);
+    if(!vel)
+    {
+        WARN("Invalid pointer\n");
+        return DSERR_INVALIDPARAM;
     }
 
-    HeapFree(GetProcessHeap(), 0, This->tmp_buffer);
-    HeapFree(GetProcessHeap(), 0, This->notifies);
-    HeapFree(GetProcessHeap(), 0, This->pwfx);
-    HeapFree(GetProcessHeap(), 0, This);
+    EnterCriticalSection(This->crst);
+    setALContext(This->ctx);
+
+    palGetSourcefv(This->source, AL_POSITION, alvel);
+    getALError();
+    vel->x =  alvel[0];
+    vel->y =  alvel[1];
+    vel->z = -alvel[2];
+
+    popALContext();
+    LeaveCriticalSection(This->crst);
 
-    TRACE("(%p) released\n", This);
+    return S_OK;
 }
 
-HRESULT IDirectSoundBufferImpl_Destroy(
-    IDirectSoundBufferImpl *pdsb)
+static HRESULT WINAPI DS8Buffer3D_SetAllParameters(IDirectSound3DBuffer *iface, const DS3DBUFFER *ds3dbuffer, DWORD apply)
 {
-    TRACE("(%p)\n",pdsb);
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+    TRACE("(%p)->(%p, %u)\n", This, ds3dbuffer, apply);
 
-    /* This keeps the *_Destroy functions from possibly deleting
-     * this object until it is ready to be deleted */
-    InterlockedIncrement(&pdsb->numIfaces);
+    if(!ds3dbuffer || ds3dbuffer->dwSize < sizeof(*ds3dbuffer))
+    {
+        WARN("Invalid DS3DBUFFER (%p, %u)\n", ds3dbuffer, ds3dbuffer ? ds3dbuffer->dwSize : 0);
+        return DSERR_INVALIDPARAM;
+    }
 
-    if (pdsb->iks) {
-        WARN("iks not NULL\n");
-        IKsBufferPropertySetImpl_Destroy(pdsb->iks);
-        pdsb->iks = NULL;
+    if(ds3dbuffer->dwInsideConeAngle > DS3D_MAXCONEANGLE ||
+       ds3dbuffer->dwOutsideConeAngle > DS3D_MAXCONEANGLE)
+    {
+        WARN("Invalid cone angles (%u, %u)\n", ds3dbuffer->dwInsideConeAngle,
+                                               ds3dbuffer->dwOutsideConeAngle);
+        return DSERR_INVALIDPARAM;
     }
 
-    if (pdsb->ds3db) {
-        WARN("ds3db not NULL\n");
-        IDirectSound3DBufferImpl_Destroy(pdsb->ds3db);
-        pdsb->ds3db = NULL;
+    if(ds3dbuffer->lConeOutsideVolume > DSBVOLUME_MAX ||
+       ds3dbuffer->lConeOutsideVolume < DSBVOLUME_MIN)
+    {
+        WARN("Invalid cone outside volume (%d)\n", ds3dbuffer->lConeOutsideVolume);
+        return DSERR_INVALIDPARAM;
     }
 
-    if (pdsb->notify) {
-        WARN("notify not NULL\n");
-        IDirectSoundNotifyImpl_Destroy(pdsb->notify);
-        pdsb->notify = NULL;
+    if(ds3dbuffer->flMaxDistance < 0.0f)
+    {
+        WARN("Invalid max distance (%f)\n", ds3dbuffer->flMaxDistance);
+        return DSERR_INVALIDPARAM;
     }
 
-    secondarybuffer_destroy(pdsb);
+    if(ds3dbuffer->flMinDistance < 0.0f)
+    {
+        WARN("Invalid min distance (%f)\n", ds3dbuffer->flMinDistance);
+        return DSERR_INVALIDPARAM;
+    }
+
+    if(ds3dbuffer->dwMode != DS3DMODE_NORMAL &&
+       ds3dbuffer->dwMode != DS3DMODE_HEADRELATIVE &&
+       ds3dbuffer->dwMode != DS3DMODE_DISABLE)
+    {
+        WARN("Invalid mode (%u)\n", ds3dbuffer->dwMode);
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(This->crst);
+    setALContext(This->ctx);
+    IDirectSound3DBuffer_SetPosition(iface, ds3dbuffer->vPosition.x, ds3dbuffer->vPosition.y, ds3dbuffer->vPosition.z, apply);
+    IDirectSound3DBuffer_SetVelocity(iface, ds3dbuffer->vVelocity.x, ds3dbuffer->vVelocity.y, ds3dbuffer->vVelocity.z, apply);
+    IDirectSound3DBuffer_SetConeAngles(iface, ds3dbuffer->dwInsideConeAngle, ds3dbuffer->dwOutsideConeAngle, apply);
+    IDirectSound3DBuffer_SetConeOrientation(iface, ds3dbuffer->vConeOrientation.x, ds3dbuffer->vConeOrientation.y, ds3dbuffer->vConeOrientation.z, apply);
+    IDirectSound3DBuffer_SetConeOutsideVolume(iface, ds3dbuffer->lConeOutsideVolume, apply);
+    IDirectSound3DBuffer_SetMinDistance(iface, ds3dbuffer->flMinDistance, apply);
+    IDirectSound3DBuffer_SetMaxDistance(iface, ds3dbuffer->flMaxDistance, apply);
+    IDirectSound3DBuffer_SetMode(iface, ds3dbuffer->dwMode, apply);
+    popALContext();
+    LeaveCriticalSection(This->crst);
 
     return S_OK;
 }
 
-HRESULT IDirectSoundBufferImpl_Duplicate(
-    DirectSoundDevice *device,
-    IDirectSoundBufferImpl **ppdsb,
-    IDirectSoundBufferImpl *pdsb)
+static HRESULT WINAPI DS8Buffer3D_SetConeAngles(IDirectSound3DBuffer *iface, DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD apply)
 {
-    IDirectSoundBufferImpl *dsb;
-    HRESULT hres = DS_OK;
-    TRACE("(%p,%p,%p)\n", device, ppdsb, pdsb);
-
-    dsb = HeapAlloc(GetProcessHeap(),0,sizeof(*dsb));
-    if (dsb == NULL) {
-        WARN("out of memory\n");
-        *ppdsb = NULL;
-        return DSERR_OUTOFMEMORY;
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+
+    TRACE("(%p)->(%u, %u, %u)\n", This, dwInsideConeAngle, dwOutsideConeAngle, apply);
+    if(dwInsideConeAngle > DS3D_MAXCONEANGLE ||
+       dwOutsideConeAngle > DS3D_MAXCONEANGLE)
+    {
+        WARN("Invalid cone angles (%u, %u)\n", dwInsideConeAngle, dwOutsideConeAngle);
+        return DSERR_INVALIDPARAM;
     }
-    CopyMemory(dsb, pdsb, sizeof(*dsb));
 
-    dsb->pwfx = DSOUND_CopyFormat(pdsb->pwfx);
-    if (dsb->pwfx == NULL) {
-        HeapFree(GetProcessHeap(),0,dsb);
-        *ppdsb = NULL;
-        return DSERR_OUTOFMEMORY;
+    EnterCriticalSection(This->crst);
+    if(apply == DS3D_DEFERRED)
+    {
+        This->ds3dbuffer.dwInsideConeAngle = dwInsideConeAngle;
+        This->ds3dbuffer.dwOutsideConeAngle = dwOutsideConeAngle;
+        This->dirty.bit.cone_angles = 1;
     }
-
-    if (pdsb->hwbuf) {
-        TRACE("duplicating hardware buffer\n");
-
-        hres = IDsDriver_DuplicateSoundBuffer(device->driver, pdsb->hwbuf,
-                                              (LPVOID *)&dsb->hwbuf);
-        if (FAILED(hres)) {
-            WARN("IDsDriver_DuplicateSoundBuffer failed (%08x)\n", hres);
-            HeapFree(GetProcessHeap(),0,dsb->pwfx);
-            HeapFree(GetProcessHeap(),0,dsb);
-            *ppdsb = NULL;
-            return hres;
-        }
+    else
+    {
+        setALContext(This->ctx);
+        palSourcei(This->source, AL_CONE_INNER_ANGLE, dwInsideConeAngle);
+        palSourcei(This->source, AL_CONE_OUTER_ANGLE, dwOutsideConeAngle);
+        getALError();
+        popALContext();
     }
+    LeaveCriticalSection(This->crst);
 
-    dsb->buffer->ref++;
-    list_add_head(&dsb->buffer->buffers, &dsb->entry);
-    dsb->ref = 1;
-    dsb->numIfaces = 1;
-    dsb->state = STATE_STOPPED;
-    dsb->buf_mixpos = dsb->sec_mixpos = 0;
-    dsb->notify = NULL;
-    dsb->notifies = NULL;
-    dsb->nrofnotifies = 0;
-    dsb->device = device;
-    dsb->ds3db = NULL;
-    dsb->iks = NULL; /* FIXME? */
-    dsb->tmp_buffer = NULL;
-    DSOUND_RecalcFormat(dsb);
-    DSOUND_MixToTemporary(dsb, 0, dsb->buflen, FALSE);
-
-    RtlInitializeResource(&dsb->lock);
-
-    /* register buffer */
-    hres = DirectSoundDevice_AddBuffer(device, dsb);
-    if (hres != DS_OK) {
-        RtlDeleteResource(&dsb->lock);
-        HeapFree(GetProcessHeap(),0,dsb->tmp_buffer);
-        list_remove(&dsb->entry);
-        dsb->buffer->ref--;
-        HeapFree(GetProcessHeap(),0,dsb->pwfx);
-        HeapFree(GetProcessHeap(),0,dsb);
-        dsb = NULL;
-    }
-
-    *ppdsb = dsb;
-    return hres;
-}
-
-/*******************************************************************************
- *              IKsBufferPropertySet
- */
+    return S_OK;
+}
 
-/* IUnknown methods */
-static HRESULT WINAPI IKsBufferPropertySetImpl_QueryInterface(
-    LPKSPROPERTYSET iface,
-    REFIID riid,
-    LPVOID *ppobj )
+static HRESULT WINAPI DS8Buffer3D_SetConeOrientation(IDirectSound3DBuffer *iface, D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD apply)
 {
-    IKsBufferPropertySetImpl *This = (IKsBufferPropertySetImpl *)iface;
-    TRACE("(%p,%s,%p)\n",This,debugstr_guid(riid),ppobj);
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+
+    TRACE("(%p)->(%f, %f, %f, %u)\n", This, x, y, z, apply);
+
+    EnterCriticalSection(This->crst);
+    if(apply == DS3D_DEFERRED)
+    {
+        This->ds3dbuffer.vConeOrientation.x = x;
+        This->ds3dbuffer.vConeOrientation.y = y;
+        This->ds3dbuffer.vConeOrientation.z = z;
+        This->dirty.bit.cone_orient = 1;
+    }
+    else
+    {
+        setALContext(This->ctx);
+        palSource3f(This->source, AL_DIRECTION, x, y, -z);
+        getALError();
+        popALContext();
+    }
+    LeaveCriticalSection(This->crst);
 
-    return IDirectSoundBuffer_QueryInterface((LPDIRECTSOUNDBUFFER8)This->dsb, riid, ppobj);
+    return S_OK;
 }
 
-static ULONG WINAPI IKsBufferPropertySetImpl_AddRef(LPKSPROPERTYSET iface)
+static HRESULT WINAPI DS8Buffer3D_SetConeOutsideVolume(IDirectSound3DBuffer *iface, LONG vol, DWORD apply)
 {
-    IKsBufferPropertySetImpl *This = (IKsBufferPropertySetImpl *)iface;
-    ULONG ref = InterlockedIncrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref - 1);
-    return ref;
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+
+    TRACE("(%p)->(%u, %u)\n", This, vol, apply);
+    if(vol < DSBVOLUME_MIN || vol > DSBVOLUME_MAX)
+    {
+        WARN("Invalid volume (%u)\n", vol);
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(This->crst);
+    if(apply == DS3D_DEFERRED)
+    {
+        This->ds3dbuffer.lConeOutsideVolume = vol;
+        This->dirty.bit.cone_outsidevolume = 1;
+    }
+    else
+    {
+        setALContext(This->ctx);
+        palSourcef(This->source, AL_CONE_OUTER_GAIN, mB_to_gain(vol));
+        getALError();
+        popALContext();
+    }
+    LeaveCriticalSection(This->crst);
+
+    return S_OK;
 }
 
-static ULONG WINAPI IKsBufferPropertySetImpl_Release(LPKSPROPERTYSET iface)
+static HRESULT WINAPI DS8Buffer3D_SetMaxDistance(IDirectSound3DBuffer *iface, D3DVALUE maxdist, DWORD apply)
 {
-    IKsBufferPropertySetImpl *This = (IKsBufferPropertySetImpl *)iface;
-    ULONG ref = InterlockedDecrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref + 1);
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
 
-    if (!ref) {
-    This->dsb->iks = 0;
-    IDirectSoundBuffer_Release((LPDIRECTSOUND3DBUFFER)This->dsb);
-    HeapFree(GetProcessHeap(), 0, This);
-    TRACE("(%p) released\n", This);
+    TRACE("(%p)->(%f, %u)\n", This, maxdist, apply);
+    if(maxdist < 0.0f)
+    {
+        WARN("Invalid max distance (%f)\n", maxdist);
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(This->crst);
+    if(apply == DS3D_DEFERRED)
+    {
+        This->ds3dbuffer.flMaxDistance = maxdist;
+        This->dirty.bit.max_distance = 1;
     }
-    return ref;
+    else
+    {
+        setALContext(This->ctx);
+        palSourcef(This->source, AL_MAX_DISTANCE, maxdist);
+        getALError();
+        popALContext();
+    }
+    LeaveCriticalSection(This->crst);
+
+    return S_OK;
 }
 
-static HRESULT WINAPI IKsBufferPropertySetImpl_Get(
-    LPKSPROPERTYSET iface,
-    REFGUID guidPropSet,
-    ULONG dwPropID,
-    LPVOID pInstanceData,
-    ULONG cbInstanceData,
-    LPVOID pPropData,
-    ULONG cbPropData,
-    PULONG pcbReturned )
+static HRESULT WINAPI DS8Buffer3D_SetMinDistance(IDirectSound3DBuffer *iface, D3DVALUE mindist, DWORD apply)
 {
-    IKsBufferPropertySetImpl *This = (IKsBufferPropertySetImpl *)iface;
-    PIDSDRIVERPROPERTYSET ps;
-    TRACE("(iface=%p,guidPropSet=%s,dwPropID=%d,pInstanceData=%p,cbInstanceData=%d,pPropData=%p,cbPropData=%d,pcbReturned=%p)\n",
-    This,debugstr_guid(guidPropSet),dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData,pcbReturned);
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
 
-    if (This->dsb->hwbuf) {
-        IDsDriver_QueryInterface(This->dsb->hwbuf, &IID_IDsDriverPropertySet, (void **)&ps);
+    TRACE("(%p)->(%f, %u)\n", This, mindist, apply);
+    if(mindist < 0.0f)
+    {
+        WARN("Invalid min distance (%f)\n", mindist);
+        return DSERR_INVALIDPARAM;
+    }
 
-        if (ps) {
-        DSPROPERTY prop;
-        HRESULT hres;
+    EnterCriticalSection(This->crst);
+    if(apply == DS3D_DEFERRED)
+    {
+        This->ds3dbuffer.flMinDistance = mindist;
+        This->dirty.bit.min_distance = 1;
+    }
+    else
+    {
+        setALContext(This->ctx);
+        palSourcef(This->source, AL_REFERENCE_DISTANCE, mindist);
+        getALError();
+        popALContext();
+    }
+    LeaveCriticalSection(This->crst);
 
-        prop.s.Set = *guidPropSet;
-        prop.s.Id = dwPropID;
-        prop.s.Flags = 0;  /* unused */
-        prop.s.InstanceId = (ULONG)This->dsb->device;
+    return S_OK;
+}
 
+static HRESULT WINAPI DS8Buffer3D_SetMode(IDirectSound3DBuffer *iface, DWORD mode, DWORD apply)
+{
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+
+    TRACE("(%p)->(%u, %u)\n", This, mode, apply);
+    if(mode != DS3DMODE_NORMAL && mode != DS3DMODE_HEADRELATIVE &&
+       mode != DS3DMODE_DISABLE)
+    {
+        WARN("Invalid mode (%u)\n", mode);
+        return DSERR_INVALIDPARAM;
+    }
 
-        hres = IDsDriverPropertySet_Get(ps, &prop, pInstanceData, cbInstanceData, pPropData, cbPropData, pcbReturned);
+    EnterCriticalSection(This->crst);
+    if(apply == DS3D_DEFERRED)
+    {
+        This->ds3dbuffer.dwMode = mode;
+        This->dirty.bit.mode = 1;
+    }
+    else
+    {
+        setALContext(This->ctx);
+        palSourcei(This->source, AL_SOURCE_RELATIVE,
+                   mode != DS3DMODE_NORMAL ? AL_TRUE : AL_FALSE);
+        palSourcef(This->source, AL_ROLLOFF_FACTOR,
+                   mode == DS3DMODE_DISABLE ? 0.0f : This->primary->rollofffactor);
+        This->ds3dmode = mode;
+        getALError();
+        popALContext();
+    }
+    LeaveCriticalSection(This->crst);
 
-        IDsDriverPropertySet_Release(ps);
+    return S_OK;
+}
 
-        return hres;
-        }
+static HRESULT WINAPI DS8Buffer3D_SetPosition(IDirectSound3DBuffer *iface, D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD apply)
+{
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
+
+    TRACE("(%p)->(%f, %f, %f, %u)\n", This, x, y, z, apply);
+
+    EnterCriticalSection(This->crst);
+    if(apply == DS3D_DEFERRED)
+    {
+        This->ds3dbuffer.vPosition.x = x;
+        This->ds3dbuffer.vPosition.y = y;
+        This->ds3dbuffer.vPosition.z = z;
+        This->dirty.bit.pos = 1;
     }
+    else
+    {
+        setALContext(This->ctx);
+        palSource3f(This->source, AL_POSITION, x, y, -z);
+        getALError();
+        popALContext();
+    }
+    LeaveCriticalSection(This->crst);
 
-    return E_PROP_ID_UNSUPPORTED;
+    return S_OK;
 }
 
-static HRESULT WINAPI IKsBufferPropertySetImpl_Set(
-    LPKSPROPERTYSET iface,
-    REFGUID guidPropSet,
-    ULONG dwPropID,
-    LPVOID pInstanceData,
-    ULONG cbInstanceData,
-    LPVOID pPropData,
-    ULONG cbPropData )
+static HRESULT WINAPI DS8Buffer3D_SetVelocity(IDirectSound3DBuffer *iface, D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD apply)
 {
-    IKsBufferPropertySetImpl *This = (IKsBufferPropertySetImpl *)iface;
-    PIDSDRIVERPROPERTYSET ps;
-    TRACE("(%p,%s,%d,%p,%d,%p,%d)\n",This,debugstr_guid(guidPropSet),dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData);
+    DS8Buffer *This = impl_from_IDirectSound3DBuffer(iface);
 
-    if (This->dsb->hwbuf) {
-        IDsDriver_QueryInterface(This->dsb->hwbuf, &IID_IDsDriverPropertySet, (void **)&ps);
+    TRACE("(%p)->(%f, %f, %f, %u)\n", This, x, y, z, apply);
 
-        if (ps) {
-        DSPROPERTY prop;
-        HRESULT hres;
+    EnterCriticalSection(This->crst);
+    if(apply == DS3D_DEFERRED)
+    {
+        This->ds3dbuffer.vVelocity.x = x;
+        This->ds3dbuffer.vVelocity.y = y;
+        This->ds3dbuffer.vVelocity.z = z;
+        This->dirty.bit.vel = 1;
+    }
+    else
+    {
+        setALContext(This->ctx);
+        palSource3f(This->source, AL_VELOCITY, x, y, -z);
+        getALError();
+        popALContext();
+    }
+    LeaveCriticalSection(This->crst);
 
-        prop.s.Set = *guidPropSet;
-        prop.s.Id = dwPropID;
-        prop.s.Flags = 0;  /* unused */
-        prop.s.InstanceId = (ULONG)This->dsb->device;
-        hres = IDsDriverPropertySet_Set(ps,&prop,pInstanceData,cbInstanceData,pPropData,cbPropData);
+    return S_OK;
+}
 
-        IDsDriverPropertySet_Release(ps);
+static const IDirectSound3DBufferVtbl DS8Buffer3d_Vtbl =
+{
+    DS8Buffer3D_QueryInterface,
+    DS8Buffer3D_AddRef,
+    DS8Buffer3D_Release,
+    DS8Buffer3D_GetAllParameters,
+    DS8Buffer3D_GetConeAngles,
+    DS8Buffer3D_GetConeOrientation,
+    DS8Buffer3D_GetConeOutsideVolume,
+    DS8Buffer3D_GetMaxDistance,
+    DS8Buffer3D_GetMinDistance,
+    DS8Buffer3D_GetMode,
+    DS8Buffer3D_GetPosition,
+    DS8Buffer3D_GetVelocity,
+    DS8Buffer3D_SetAllParameters,
+    DS8Buffer3D_SetConeAngles,
+    DS8Buffer3D_SetConeOrientation,
+    DS8Buffer3D_SetConeOutsideVolume,
+    DS8Buffer3D_SetMaxDistance,
+    DS8Buffer3D_SetMinDistance,
+    DS8Buffer3D_SetMode,
+    DS8Buffer3D_SetPosition,
+    DS8Buffer3D_SetVelocity
+};
 
-        return hres;
-        }
-    }
+static inline DS8Buffer *impl_from_IDirectSoundNotify(IDirectSoundNotify *iface)
+{
+    return CONTAINING_RECORD(iface, DS8Buffer, IDirectSoundNotify_iface);
+}
 
-    return E_PROP_ID_UNSUPPORTED;
+static HRESULT WINAPI DS8BufferNot_QueryInterface(IDirectSoundNotify *iface, REFIID riid, void **ppv)
+{
+    DS8Buffer *This = impl_from_IDirectSoundNotify(iface);
+    return IDirectSoundBuffer8_QueryInterface(&This->IDirectSoundBuffer8_iface, riid, ppv);
 }
 
-static HRESULT WINAPI IKsBufferPropertySetImpl_QuerySupport(
-    LPKSPROPERTYSET iface,
-    REFGUID guidPropSet,
-    ULONG dwPropID,
-    PULONG pTypeSupport )
+static ULONG WINAPI DS8BufferNot_AddRef(IDirectSoundNotify *iface)
 {
-    IKsBufferPropertySetImpl *This = (IKsBufferPropertySetImpl *)iface;
-    PIDSDRIVERPROPERTYSET ps;
-    TRACE("(%p,%s,%d,%p)\n",This,debugstr_guid(guidPropSet),dwPropID,pTypeSupport);
+    DS8Buffer *This = impl_from_IDirectSoundNotify(iface);
+    LONG ret;
 
-    if (This->dsb->hwbuf) {
-        IDsDriver_QueryInterface(This->dsb->hwbuf, &IID_IDsDriverPropertySet, (void **)&ps);
+    InterlockedIncrement(&This->all_ref);
+    ret = InterlockedIncrement(&This->not_ref);
+    TRACE("new refcount %d\n", ret);
 
-        if (ps) {
-            HRESULT hres;
+    return ret;
+}
 
-            hres = IDsDriverPropertySet_QuerySupport(ps,guidPropSet, dwPropID,pTypeSupport);
+static ULONG WINAPI DS8BufferNot_Release(IDirectSoundNotify *iface)
+{
+    DS8Buffer *This = impl_from_IDirectSoundNotify(iface);
+    LONG ret;
+
+    ret = InterlockedDecrement(&This->not_ref);
+    TRACE("new refcount %d\n", ret);
+    if(InterlockedDecrement(&This->all_ref) == 0)
+        DS8Buffer_Destroy(This);
 
-            IDsDriverPropertySet_Release(ps);
+    return ret;
+}
 
-            return hres;
+static HRESULT WINAPI DS8BufferNot_SetNotificationPositions(IDirectSoundNotify *iface, DWORD count, const DSBPOSITIONNOTIFY *notifications)
+{
+    DS8Buffer *This = impl_from_IDirectSoundNotify(iface);
+    DSBPOSITIONNOTIFY *nots;
+    HRESULT hr;
+    DWORD state;
+
+    EnterCriticalSection(This->crst);
+    hr = DSERR_INVALIDPARAM;
+    if (count && !notifications)
+        goto out;
+
+    hr = IDirectSoundBuffer8_GetStatus(&This->IDirectSoundBuffer8_iface, &state);
+    if(FAILED(hr))
+        goto out;
+
+    hr = DSERR_INVALIDCALL;
+    if((state&DSBSTATUS_PLAYING))
+        goto out;
+
+    hr = DSERR_INVALIDPARAM;
+    if(!count)
+    {
+        HeapFree(GetProcessHeap(), 0, This->notify);
+        This->notify = 0;
+        This->nnotify = 0;
+    }
+    else
+    {
+        DWORD i;
+
+        for(i = 0;i < count;++i)
+        {
+            if(notifications[i].dwOffset >= This->buffer->buf_size &&
+               notifications[i].dwOffset != (DWORD)DSBPN_OFFSETSTOP)
+                goto out;
         }
+
+        hr = E_OUTOFMEMORY;
+        nots = HeapAlloc(GetProcessHeap(), 0, count*sizeof(*nots));
+        if(!nots)
+            goto out;
+        memcpy(nots, notifications, count*sizeof(*nots));
+
+        HeapFree(GetProcessHeap(), 0, This->notify);
+        This->notify = nots;
+        This->nnotify = count;
+
+        hr = S_OK;
     }
 
-    return E_PROP_ID_UNSUPPORTED;
+out:
+    LeaveCriticalSection(This->crst);
+    return hr;
 }
 
-static const IKsPropertySetVtbl iksbvt = {
-    IKsBufferPropertySetImpl_QueryInterface,
-    IKsBufferPropertySetImpl_AddRef,
-    IKsBufferPropertySetImpl_Release,
-    IKsBufferPropertySetImpl_Get,
-    IKsBufferPropertySetImpl_Set,
-    IKsBufferPropertySetImpl_QuerySupport
+static const IDirectSoundNotifyVtbl DS8BufferNot_Vtbl =
+{
+    DS8BufferNot_QueryInterface,
+    DS8BufferNot_AddRef,
+    DS8BufferNot_Release,
+    DS8BufferNot_SetNotificationPositions
 };
 
-HRESULT IKsBufferPropertySetImpl_Create(
-    IDirectSoundBufferImpl *dsb,
-    IKsBufferPropertySetImpl **piks)
+/* NOTE: Due to some apparent quirks in DSound, the listener properties are
+         handled through secondary buffers. */
+static inline DS8Buffer *impl_from_IKsPropertySet(IKsPropertySet *iface)
 {
-    IKsBufferPropertySetImpl *iks;
-    TRACE("(%p,%p)\n",dsb,piks);
-    *piks = NULL;
+    return CONTAINING_RECORD(iface, DS8Buffer, IKsPropertySet_iface);
+}
+
+static HRESULT WINAPI DS8BufferProp_QueryInterface(IKsPropertySet *iface, REFIID riid, void **ppv)
+{
+    DS8Buffer *This = impl_from_IKsPropertySet(iface);
+    return IDirectSoundBuffer8_QueryInterface(&This->IDirectSoundBuffer8_iface, riid, ppv);
+}
+
+static ULONG WINAPI DS8BufferProp_AddRef(IKsPropertySet *iface)
+{
+    DS8Buffer *This = impl_from_IKsPropertySet(iface);
+    LONG ret;
+
+    InterlockedIncrement(&This->all_ref);
+    ret = InterlockedIncrement(&This->prop_ref);
+    TRACE("new refcount %d\n", ret);
+
+    return ret;
+}
+
+static ULONG WINAPI DS8BufferProp_Release(IKsPropertySet *iface)
+{
+    DS8Buffer *This = impl_from_IKsPropertySet(iface);
+    LONG ret;
+
+    ret = InterlockedDecrement(&This->prop_ref);
+    TRACE("new refcount %d\n", ret);
+    if(InterlockedDecrement(&This->all_ref) == 0)
+        DS8Buffer_Destroy(This);
 
-    iks = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(*iks));
-    if (iks == 0) {
-        WARN("out of memory\n");
-        *piks = NULL;
-        return DSERR_OUTOFMEMORY;
+    return ret;
+}
+
+static HRESULT WINAPI DS8BufferProp_Get(IKsPropertySet *iface, REFGUID guidPropSet,
+    ULONG dwPropID,
+    LPVOID pInstanceData,
+    ULONG cbInstanceData,
+    LPVOID pPropData,
+    ULONG cbPropData,
+    PULONG pcbReturned)
+{
+    DS8Buffer *This = impl_from_IKsPropertySet(iface);
+    HRESULT hr = E_PROP_ID_UNSUPPORTED;
+
+    WARN("(%p)->(%s, %u, %p, %u, %p, %u, %p) : semi-stub!\n", iface, debugstr_guid(guidPropSet),
+          dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData, pcbReturned);
+
+    if(IsEqualIID(guidPropSet, &DSPROPSETID_EAX20_ListenerProperties))
+    {
+        if((This->buffer->dsbflags&DSBCAPS_CTRL3D))
+            hr = IKsPropertySet_Get(&This->primary->IKsPropertySet_iface, guidPropSet,
+                                    dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData,
+                                    pcbReturned);
     }
+    else
+        FIXME("Unhandled propset: %s\n", debugstr_guid(guidPropSet));
 
-    iks->ref = 0;
-    iks->dsb = dsb;
-    dsb->iks = iks;
-    iks->lpVtbl = &iksbvt;
+    return hr;
+}
 
-    IDirectSoundBuffer_AddRef((LPDIRECTSOUNDBUFFER)dsb);
+static HRESULT WINAPI DS8BufferProp_Set(IKsPropertySet *iface, REFGUID guidPropSet,
+    ULONG dwPropID,
+    LPVOID pInstanceData,
+    ULONG cbInstanceData,
+    LPVOID pPropData,
+    ULONG cbPropData)
+{
+    DS8Buffer *This = impl_from_IKsPropertySet(iface);
+    HRESULT hr = E_PROP_ID_UNSUPPORTED;
+
+    WARN("(%p)->(%s, %u, %p, %u, %p, %u) : semi-stub!\n", iface, debugstr_guid(guidPropSet),
+          dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData);
+
+    if(IsEqualIID(guidPropSet, &DSPROPSETID_EAX20_ListenerProperties))
+    {
+        if((This->buffer->dsbflags&DSBCAPS_CTRL3D))
+            hr = IKsPropertySet_Set(&This->primary->IKsPropertySet_iface, guidPropSet,
+                                    dwPropID, pInstanceData, cbInstanceData, pPropData,
+                                    cbPropData);
+    }
+    else
+        FIXME("Unhandled propset: %s\n", debugstr_guid(guidPropSet));
 
-    *piks = iks;
-    return S_OK;
+    return hr;
 }
 
-HRESULT IKsBufferPropertySetImpl_Destroy(
-    IKsBufferPropertySetImpl *piks)
+static HRESULT WINAPI DS8BufferProp_QuerySupport(IKsPropertySet *iface, REFGUID guidPropSet,
+    ULONG dwPropID,
+    PULONG pTypeSupport)
 {
-    TRACE("(%p)\n",piks);
+    DS8Buffer *This = impl_from_IKsPropertySet(iface);
+    HRESULT hr = E_PROP_ID_UNSUPPORTED;
 
-    while (IKsBufferPropertySetImpl_Release((LPKSPROPERTYSET)piks) > 0);
+    WARN("(%p)->(%s, %u, %p) : semi-stub!\n", iface, debugstr_guid(guidPropSet), dwPropID, pTypeSupport);
 
-    return S_OK;
+    if(!pTypeSupport)
+        return E_POINTER;
+    *pTypeSupport = 0;
+
+    if(IsEqualIID(guidPropSet, &DSPROPSETID_EAX20_ListenerProperties))
+    {
+        if((This->buffer->dsbflags&DSBCAPS_CTRL3D))
+            hr = IKsPropertySet_QuerySupport(&This->primary->IKsPropertySet_iface,
+                                             guidPropSet, dwPropID, pTypeSupport);
+    }
+    else
+        FIXME("Unhandled propset: %s\n", debugstr_guid(guidPropSet));
+
+    return hr;
 }
+
+static const IKsPropertySetVtbl DS8BufferProp_Vtbl =
+{
+    DS8BufferProp_QueryInterface,
+    DS8BufferProp_AddRef,
+    DS8BufferProp_Release,
+    DS8BufferProp_Get,
+    DS8BufferProp_Set,
+    DS8BufferProp_QuerySupport
+};
+
+#endif /*HAVE_OPENAL*/
diff --git a/dlls/dsound/capture.c b/dlls/dsound/capture.c
index 174355a..a9906c2 100644
--- a/dlls/dsound/capture.c
+++ b/dlls/dsound/capture.c
@@ -21,17 +21,17 @@
 /*
  * TODO:
  *	Implement FX support.
- *	Implement both IDirectSoundCaptureBuffer and IDirectSoundCaptureBuffer8
- *	Make DirectSoundCaptureCreate and DirectSoundCaptureCreate8 behave differently
  */
 
 #include <stdarg.h>
 
+#define COBJMACROS
 #define NONAMELESSSTRUCT
 #define NONAMELESSUNION
 #include "windef.h"
 #include "winbase.h"
 #include "winuser.h"
+#include "wingdi.h"
 #include "mmsystem.h"
 #include "mmddk.h"
 #include "winternl.h"
@@ -43,701 +43,499 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(dsound);
 
-
-/*****************************************************************************
- * IDirectSoundCaptureNotify implementation structure
- */
-struct IDirectSoundCaptureNotifyImpl
-{
-    /* IUnknown fields */
-    const IDirectSoundNotifyVtbl       *lpVtbl;
-    LONG                                ref;
-    IDirectSoundCaptureBufferImpl*      dscb;
+typedef struct IDirectSoundCaptureBufferImpl IDirectSoundCaptureBufferImpl;
+
+typedef struct IDirectSoundCaptureImpl
+{
+    IDirectSoundCapture IDirectSoundCapture_iface;
+    LONG ref;
+
+    GUID device;
+    IDirectSoundCaptureBufferImpl *buf;
+    CRITICAL_SECTION crst;
+    BOOL is_8, voice;
+    UINT timer_id;
+    DWORD timer_res;
+} IDirectSoundCaptureImpl;
+
+struct IDirectSoundCaptureBufferImpl
+{
+    IDirectSoundCaptureBuffer8 IDirectSoundCaptureBuffer8_iface;
+    IDirectSoundNotify IDirectSoundNotify_iface;
+    LONG ref, notify_ref;
+    IDirectSoundCaptureImpl *parent;
+    IAudioClient *dev;
+    IAudioCaptureClient *cap_dev;
+    DWORD buf_size;
+    BYTE *buf;
+    WAVEFORMATEX *format;
+    DSBPOSITIONNOTIFY *notify;
+    DWORD nnotify;
+
+    DWORD pos;
+    BOOL playing, looping;
 };
 
-/*******************************************************************************
- *		IDirectSoundCaptureNotify
- */
-static HRESULT WINAPI IDirectSoundCaptureNotifyImpl_QueryInterface(
-    LPDIRECTSOUNDNOTIFY iface,
-    REFIID riid,
-    LPVOID *ppobj)
-{
-    IDirectSoundCaptureNotifyImpl *This = (IDirectSoundCaptureNotifyImpl *)iface;
-    TRACE("(%p,%s,%p)\n",This,debugstr_guid(riid),ppobj);
-
-    if (This->dscb == NULL) {
-	WARN("invalid parameter\n");
-	return E_INVALIDARG;
-    }
+static void IDirectSoundCaptureBufferImpl_Destroy(IDirectSoundCaptureBufferImpl *This);
 
-    return IDirectSoundCaptureBuffer_QueryInterface((LPDIRECTSOUNDCAPTUREBUFFER)This->dscb, riid, ppobj);
+static IDirectSoundCaptureBufferImpl *impl_from_IDirectSoundCaptureBuffer8(IDirectSoundCaptureBuffer8 *iface)
+{
+    return CONTAINING_RECORD(iface, IDirectSoundCaptureBufferImpl, IDirectSoundCaptureBuffer8_iface);
 }
 
-static ULONG WINAPI IDirectSoundCaptureNotifyImpl_AddRef(LPDIRECTSOUNDNOTIFY iface)
+static IDirectSoundCaptureBufferImpl *impl_from_IDirectSoundNotify(IDirectSoundNotify *iface)
 {
-    IDirectSoundCaptureNotifyImpl *This = (IDirectSoundCaptureNotifyImpl *)iface;
-    ULONG ref = InterlockedIncrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref - 1);
-    return ref;
+    return CONTAINING_RECORD(iface, IDirectSoundCaptureBufferImpl, IDirectSoundNotify_iface);
 }
 
-static ULONG WINAPI IDirectSoundCaptureNotifyImpl_Release(LPDIRECTSOUNDNOTIFY iface)
-{
-    IDirectSoundCaptureNotifyImpl *This = (IDirectSoundCaptureNotifyImpl *)iface;
-    ULONG ref = InterlockedDecrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref + 1);
+static void IDirectSoundCaptureImpl_Destroy(IDirectSoundCaptureImpl *This);
 
-    if (!ref) {
-        if (This->dscb->hwnotify)
-            IDsDriverNotify_Release(This->dscb->hwnotify);
-	This->dscb->notify=NULL;
-	IDirectSoundCaptureBuffer_Release((LPDIRECTSOUNDCAPTUREBUFFER)This->dscb);
-	HeapFree(GetProcessHeap(),0,This);
-	TRACE("(%p) released\n", This);
-    }
-    return ref;
+static IDirectSoundCaptureImpl *impl_from_IDirectSoundCapture(IDirectSoundCapture *iface)
+{
+    return CONTAINING_RECORD(iface, IDirectSoundCaptureImpl, IDirectSoundCapture_iface);
 }
 
-static HRESULT WINAPI IDirectSoundCaptureNotifyImpl_SetNotificationPositions(
-    LPDIRECTSOUNDNOTIFY iface,
-    DWORD howmuch,
-    LPCDSBPOSITIONNOTIFY notify)
+static void trigger_notifies(IDirectSoundCaptureBufferImpl *buf, DWORD lastpos, DWORD curpos)
 {
-    IDirectSoundCaptureNotifyImpl *This = (IDirectSoundCaptureNotifyImpl *)iface;
-    TRACE("(%p,0x%08x,%p)\n",This,howmuch,notify);
+    DWORD i;
+    if (lastpos == curpos)
+        return;
+    for (i = 0; i < buf->nnotify; ++i)
+    {
+        DSBPOSITIONNOTIFY *not = &buf->notify[i];
+        HANDLE event = not->hEventNotify;
+        DWORD ofs = not->dwOffset;
 
-    if (howmuch > 0 && notify == NULL) {
-	WARN("invalid parameter: notify == NULL\n");
-	return DSERR_INVALIDPARAM;
-    }
+        if (ofs == DSCBPN_OFFSET_STOP)
+            continue;
 
-    if (TRACE_ON(dsound)) {
-	unsigned int i;
-	for (i=0;i<howmuch;i++)
-            TRACE("notify at %d to %p\n",
-	    notify[i].dwOffset,notify[i].hEventNotify);
-    }
+        /* Wraparound case */
+        if (curpos < lastpos)
+        {
+            if (ofs < curpos
+                || ofs >= lastpos)
+                SetEvent(event);
+            continue;
+        }
 
-    if (This->dscb->hwnotify) {
-	HRESULT hres;
-	hres = IDsDriverNotify_SetNotificationPositions(This->dscb->hwnotify, howmuch, notify);
-	if (hres != DS_OK)
-	    WARN("IDsDriverNotify_SetNotificationPositions failed\n");
-	return hres;
-    } else if (howmuch > 0) {
-	/* Make an internal copy of the caller-supplied array.
-	 * Replace the existing copy if one is already present. */
-	if (This->dscb->notifies)
-	    This->dscb->notifies = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-		This->dscb->notifies, howmuch * sizeof(DSBPOSITIONNOTIFY));
-	else
-	    This->dscb->notifies = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-		howmuch * sizeof(DSBPOSITIONNOTIFY));
-
-	if (This->dscb->notifies == NULL) {
-	    WARN("out of memory\n");
-	    return DSERR_OUTOFMEMORY;
-	}
-	CopyMemory(This->dscb->notifies, notify, howmuch * sizeof(DSBPOSITIONNOTIFY));
-	This->dscb->nrofnotifies = howmuch;
-    } else {
-        HeapFree(GetProcessHeap(), 0, This->dscb->notifies);
-        This->dscb->notifies = NULL;
-        This->dscb->nrofnotifies = 0;
+        /* Normal case */
+        if (ofs >= lastpos
+            && ofs < curpos)
+            SetEvent(event);
     }
-
-    return S_OK;
 }
 
-static const IDirectSoundNotifyVtbl dscnvt =
-{
-    IDirectSoundCaptureNotifyImpl_QueryInterface,
-    IDirectSoundCaptureNotifyImpl_AddRef,
-    IDirectSoundCaptureNotifyImpl_Release,
-    IDirectSoundCaptureNotifyImpl_SetNotificationPositions,
-};
-
-static HRESULT IDirectSoundCaptureNotifyImpl_Create(
-    IDirectSoundCaptureBufferImpl *dscb,
-    IDirectSoundCaptureNotifyImpl **pdscn)
+static void CALLBACK IDirectSoundCaptureBufferImpl_timer(UINT timerID, UINT msg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2)
 {
-    IDirectSoundCaptureNotifyImpl * dscn;
-    TRACE("(%p,%p)\n",dscb,pdscn);
+    IDirectSoundCaptureImpl *This = (IDirectSoundCaptureImpl*)dwUser;
+    IDirectSoundCaptureBufferImpl *buf;
+    UINT32 avail = 0;
 
-    dscn = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*dscn));
+    EnterCriticalSection(&This->crst);
+    buf = This->buf;
+    if (!buf || !buf->dev || !buf->playing)
+        goto out;
 
-    if (dscn == NULL) {
-	WARN("out of memory\n");
-	return DSERR_OUTOFMEMORY;
+    IAudioCaptureClient_GetNextPacketSize(buf->cap_dev, &avail);
+    if (avail)
+    {
+        BYTE *data = 0;
+        UINT32 read = 0;
+        DWORD flags = 0;
+        UINT64 pos = 0;
+        DWORD block = buf->format->nBlockAlign;
+
+        IAudioCaptureClient_GetBuffer(buf->cap_dev, &data, &read, &flags, &pos, 0);
+        if (read * block + buf->pos >= buf->buf_size)
+        {
+            if (!buf->looping)
+            {
+                trigger_notifies(buf, buf->pos, 0);
+                memcpy(buf->buf + buf->pos, data, buf->buf_size - buf->pos);
+                buf->pos = 0;
+                IAudioCaptureClient_ReleaseBuffer(buf->cap_dev, read);
+                IDirectSoundCaptureBuffer8_Stop(&buf->IDirectSoundCaptureBuffer8_iface);
+            }
+            else
+            {
+                DWORD firstpart = buf->buf_size - buf->pos, oldpos = buf->pos;
+                memcpy(buf->buf + buf->pos, data, firstpart);
+                buf->pos = read * block - firstpart;
+                memcpy(buf->buf, data + firstpart, buf->pos);
+                trigger_notifies(buf, oldpos, buf->pos);
+                IAudioCaptureClient_ReleaseBuffer(buf->cap_dev, read);
+            }
+        } else {
+            memcpy(buf->buf + buf->pos, data, read * block);
+            trigger_notifies(buf, buf->pos, buf->pos + read * block);
+            buf->pos += read * block;
+            IAudioCaptureClient_ReleaseBuffer(buf->cap_dev, read);
+        }
     }
 
-    dscn->ref = 0;
-    dscn->lpVtbl = &dscnvt;
-    dscn->dscb = dscb;
-    dscb->notify = dscn;
-    IDirectSoundCaptureBuffer_AddRef((LPDIRECTSOUNDCAPTUREBUFFER)dscb);
-
-    *pdscn = dscn;
-    return DS_OK;
+out:
+    LeaveCriticalSection(&This->crst);
+    return;
 }
 
-
-static const char * const captureStateString[] = {
-    "STATE_STOPPED",
-    "STATE_STARTING",
-    "STATE_CAPTURING",
-    "STATE_STOPPING"
-};
-
-
-/*******************************************************************************
- *		IDirectSoundCaptureBuffer
- */
-static HRESULT WINAPI
-IDirectSoundCaptureBufferImpl_QueryInterface(
-    LPDIRECTSOUNDCAPTUREBUFFER8 iface,
-    REFIID riid,
-    LPVOID* ppobj )
+static HRESULT WINAPI IDirectSoundCaptureBufferImpl_QueryInterface(IDirectSoundCaptureBuffer8 *iface, REFIID riid, void **ppv)
 {
-    IDirectSoundCaptureBufferImpl *This = (IDirectSoundCaptureBufferImpl *)iface;
-    HRESULT hres;
-    TRACE( "(%p,%s,%p)\n", This, debugstr_guid(riid), ppobj );
-
-    if (ppobj == NULL) {
-	WARN("invalid parameter\n");
-	return E_INVALIDARG;
-    }
-
-    *ppobj = NULL;
-
-    if ( IsEqualGUID( &IID_IDirectSoundNotify, riid ) ) {
-	if (!This->notify)
-	    hres = IDirectSoundCaptureNotifyImpl_Create(This, &This->notify);
-	if (This->notify) {
-	    IDirectSoundNotify_AddRef((LPDIRECTSOUNDNOTIFY)This->notify);
-	    if (This->device->hwbuf && !This->hwnotify) {
-		hres = IDsCaptureDriverBuffer_QueryInterface(This->device->hwbuf,
-		    &IID_IDsDriverNotify, (LPVOID*)&(This->hwnotify));
-		if (hres != DS_OK) {
-		    WARN("IDsCaptureDriverBuffer_QueryInterface failed\n");
-		    IDirectSoundNotify_Release((LPDIRECTSOUNDNOTIFY)This->notify);
-		    *ppobj = 0;
-		    return hres;
-	        }
-	    }
-
-            *ppobj = This->notify;
-	    return DS_OK;
-	}
-
-	WARN("IID_IDirectSoundNotify\n");
-	return E_FAIL;
-    }
-
-    if ( IsEqualGUID( &IID_IDirectSoundCaptureBuffer, riid ) ||
-         IsEqualGUID( &IID_IDirectSoundCaptureBuffer8, riid ) ) {
-	IDirectSoundCaptureBuffer8_AddRef(iface);
-	*ppobj = This;
-	return NO_ERROR;
-    }
-
-    FIXME("(%p,%s,%p) unsupported GUID\n", This, debugstr_guid(riid), ppobj);
-    return E_NOINTERFACE;
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundCaptureBuffer8(iface);
+    if (!ppv)
+        return E_POINTER;
+    TRACE("(%p)->(%s,%p)\n", This, debugstr_guid(riid), ppv);
+    *ppv = NULL;
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IDirectSoundCaptureBuffer) ||
+        (This->parent->is_8 && IsEqualIID(riid, &IID_IDirectSoundCaptureBuffer8)))
+        *ppv = &This->IDirectSoundCaptureBuffer8_iface;
+    else if (IsEqualIID(riid, &IID_IDirectSoundNotify))
+        *ppv = &This->IDirectSoundNotify_iface;
+    if (!*ppv)
+        return E_NOINTERFACE;
+    IUnknown_AddRef((IUnknown*)*ppv);
+    return S_OK;
 }
 
-static ULONG WINAPI
-IDirectSoundCaptureBufferImpl_AddRef( LPDIRECTSOUNDCAPTUREBUFFER8 iface )
+static ULONG WINAPI IDirectSoundCaptureBufferImpl_AddRef(IDirectSoundCaptureBuffer8 *iface)
 {
-    IDirectSoundCaptureBufferImpl *This = (IDirectSoundCaptureBufferImpl *)iface;
-    ULONG ref = InterlockedIncrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref - 1);
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundCaptureBuffer8(iface);
+    LONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("Reference count incremented to %i\n", ref);
     return ref;
 }
 
-static ULONG WINAPI
-IDirectSoundCaptureBufferImpl_Release( LPDIRECTSOUNDCAPTUREBUFFER8 iface )
+static ULONG WINAPI IDirectSoundCaptureBufferImpl_Release(IDirectSoundCaptureBuffer8 *iface)
 {
-    IDirectSoundCaptureBufferImpl *This = (IDirectSoundCaptureBufferImpl *)iface;
-    ULONG ref = InterlockedDecrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref + 1);
-
-    if (!ref) {
-        TRACE("deleting object\n");
-	if (This->device->state == STATE_CAPTURING)
-	    This->device->state = STATE_STOPPING;
-
-        HeapFree(GetProcessHeap(),0, This->pdscbd);
-
-	if (This->device->hwi) {
-	    waveInReset(This->device->hwi);
-	    waveInClose(This->device->hwi);
-            HeapFree(GetProcessHeap(),0, This->device->pwave);
-            This->device->pwave = 0;
-	    This->device->hwi = 0;
-	}
-
-	if (This->device->hwbuf)
-	    IDsCaptureDriverBuffer_Release(This->device->hwbuf);
-
-        /* remove from DirectSoundCaptureDevice */
-        This->device->capture_buffer = NULL;
-
-        if (This->notify)
-	    IDirectSoundNotify_Release((LPDIRECTSOUNDNOTIFY)This->notify);
-
-        /* If driver manages its own buffer, IDsCaptureDriverBuffer_Release
-           should have freed the buffer. Prevent freeing it again in
-           IDirectSoundCaptureBufferImpl_Create */
-        if (!(This->device->drvdesc.dwFlags & DSDDESC_USESYSTEMMEMORY))
-	    This->device->buffer = NULL;
-
-	HeapFree(GetProcessHeap(), 0, This->notifies);
-        HeapFree( GetProcessHeap(), 0, This );
-	TRACE("(%p) released\n", This);
-    }
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundCaptureBuffer8(iface);
+    LONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("Reference count decremented to %i\n", ref);
+    if (!ref)
+        IDirectSoundCaptureBufferImpl_Destroy(This);
     return ref;
 }
 
-static HRESULT WINAPI
-IDirectSoundCaptureBufferImpl_GetCaps(
-    LPDIRECTSOUNDCAPTUREBUFFER8 iface,
-    LPDSCBCAPS lpDSCBCaps )
+static HRESULT WINAPI IDirectSoundCaptureBufferImpl_GetCaps(IDirectSoundCaptureBuffer8 *iface, DSCBCAPS *caps)
 {
-    IDirectSoundCaptureBufferImpl *This = (IDirectSoundCaptureBufferImpl *)iface;
-    TRACE( "(%p,%p)\n", This, lpDSCBCaps );
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundCaptureBuffer8(iface);
 
-    if (lpDSCBCaps == NULL) {
-        WARN("invalid parameter: lpDSCBCaps == NULL\n");
+    if (!caps || caps->dwSize < sizeof(*caps))
         return DSERR_INVALIDPARAM;
-    }
-
-    if (lpDSCBCaps->dwSize < sizeof(DSCBCAPS)) {
-        WARN("invalid parameter: lpDSCBCaps->dwSize = %d\n", lpDSCBCaps->dwSize);
-        return DSERR_INVALIDPARAM;
-    }
-
-    if (This->device == NULL) {
-        WARN("invalid parameter: This->device == NULL\n");
-        return DSERR_INVALIDPARAM;
-    }
-
-    lpDSCBCaps->dwSize = sizeof(DSCBCAPS);
-    lpDSCBCaps->dwFlags = This->flags;
-    lpDSCBCaps->dwBufferBytes = This->pdscbd->dwBufferBytes;
-    lpDSCBCaps->dwReserved = 0;
+    caps->dwSize = sizeof(*caps);
+    caps->dwFlags = 0;
+    caps->dwBufferBytes = This->buf_size;
+    return S_OK;
+}
 
-    TRACE("returning DS_OK\n");
-    return DS_OK;
+static HRESULT WINAPI IDirectSoundCaptureBufferImpl_GetCurrentPosition(IDirectSoundCaptureBuffer8 *iface, DWORD *cappos, DWORD *readpos)
+{
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundCaptureBuffer8(iface);
+    DWORD pos1, pos2;
+    TRACE("(%p)->(%p, %p)\n", This, cappos, readpos);
+    EnterCriticalSection(&This->parent->crst);
+    pos1 = This->pos;
+    if (This->playing)
+    {
+        pos2 = This->format->nSamplesPerSec / 100;
+        pos2 *= This->format->nBlockAlign;
+        pos2 += pos1;
+        if (!This->looping && pos2 > This->buf_size)
+            pos2 = 0;
+        else
+            pos2 %= This->buf_size;
+    }
+    else
+        pos2 = pos1;
+    pos2 %= This->buf_size;
+    LeaveCriticalSection(&This->parent->crst);
+    TRACE("Reporting %u %u\n", pos1, pos2);
+    if (readpos)
+        *readpos = pos1;
+    if (cappos)
+        *cappos = pos2;
+    return S_OK;
 }
 
-static HRESULT WINAPI
-IDirectSoundCaptureBufferImpl_GetCurrentPosition(
-    LPDIRECTSOUNDCAPTUREBUFFER8 iface,
-    LPDWORD lpdwCapturePosition,
-    LPDWORD lpdwReadPosition )
+static HRESULT WINAPI IDirectSoundCaptureBufferImpl_GetFormat(IDirectSoundCaptureBuffer8 *iface, WAVEFORMATEX *wfx, DWORD size, DWORD *written)
 {
-    IDirectSoundCaptureBufferImpl *This = (IDirectSoundCaptureBufferImpl *)iface;
-    HRESULT hres = DS_OK;
-    TRACE( "(%p,%p,%p)\n", This, lpdwCapturePosition, lpdwReadPosition );
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundCaptureBuffer8(iface);
+    TRACE("(%p,%p,%u,%p)\n", This, wfx, size, written);
 
-    if (This->device == NULL) {
-        WARN("invalid parameter: This->device == NULL\n");
-        return DSERR_INVALIDPARAM;
-    }
+    if (size > sizeof(WAVEFORMATEX) + This->format->cbSize)
+        size = sizeof(WAVEFORMATEX) + This->format->cbSize;
 
-    if (This->device->driver) {
-        hres = IDsCaptureDriverBuffer_GetPosition(This->device->hwbuf, lpdwCapturePosition, lpdwReadPosition );
-	if (hres != DS_OK)
-	    WARN("IDsCaptureDriverBuffer_GetPosition failed\n");
-    } else if (This->device->hwi) {
-        DWORD pos;
-
-        EnterCriticalSection(&This->device->lock);
-        pos = (DWORD_PTR)This->device->pwave[This->device->index].lpData - (DWORD_PTR)This->device->buffer;
-        if (lpdwCapturePosition)
-            *lpdwCapturePosition = (This->device->pwave[This->device->index].dwBufferLength + pos) % This->device->buflen;
-        if (lpdwReadPosition)
-            *lpdwReadPosition = pos;
-        LeaveCriticalSection(&This->device->lock);
-
-    } else {
-        WARN("no driver\n");
-        hres = DSERR_NODRIVER;
-    }
+    if (wfx)
+    {
+        CopyMemory(wfx, This->format, size);
+        if (written)
+            *written = size;
+    } else if (written)
+        *written = sizeof(WAVEFORMATEX) + This->format->cbSize;
+    else
+        return DSERR_INVALIDPARAM;
 
-    TRACE("cappos=%d readpos=%d\n", (lpdwCapturePosition?*lpdwCapturePosition:-1), (lpdwReadPosition?*lpdwReadPosition:-1));
-    TRACE("returning %08x\n", hres);
-    return hres;
+    return S_OK;
 }
 
-static HRESULT WINAPI
-IDirectSoundCaptureBufferImpl_GetFormat(
-    LPDIRECTSOUNDCAPTUREBUFFER8 iface,
-    LPWAVEFORMATEX lpwfxFormat,
-    DWORD dwSizeAllocated,
-    LPDWORD lpdwSizeWritten )
+static HRESULT WINAPI IDirectSoundCaptureBufferImpl_GetStatus(IDirectSoundCaptureBuffer8 *iface, DWORD *status)
 {
-    IDirectSoundCaptureBufferImpl *This = (IDirectSoundCaptureBufferImpl *)iface;
-    HRESULT hres = DS_OK;
-    TRACE( "(%p,%p,0x%08x,%p)\n", This, lpwfxFormat, dwSizeAllocated,
-        lpdwSizeWritten );
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundCaptureBuffer8(iface);
+    TRACE("(%p)->(%p)\n", This, status);
 
-    if (This->device == NULL) {
-        WARN("invalid parameter: This->device == NULL\n");
+    if (!status)
         return DSERR_INVALIDPARAM;
+    EnterCriticalSection(&This->parent->crst);
+    *status = 0;
+    if (This->playing)
+    {
+        *status |= DSCBSTATUS_CAPTURING;
+        if (This->looping)
+            *status |= DSCBSTATUS_LOOPING;
     }
+    LeaveCriticalSection(&This->parent->crst);
 
-    if (dwSizeAllocated > (sizeof(WAVEFORMATEX) + This->device->pwfx->cbSize))
-        dwSizeAllocated = sizeof(WAVEFORMATEX) + This->device->pwfx->cbSize;
-
-    if (lpwfxFormat) { /* NULL is valid (just want size) */
-        CopyMemory(lpwfxFormat, This->device->pwfx, dwSizeAllocated);
-        if (lpdwSizeWritten)
-            *lpdwSizeWritten = dwSizeAllocated;
-    } else {
-        if (lpdwSizeWritten)
-            *lpdwSizeWritten = sizeof(WAVEFORMATEX) + This->device->pwfx->cbSize;
-        else {
-            TRACE("invalid parameter: lpdwSizeWritten = NULL\n");
-            hres = DSERR_INVALIDPARAM;
-        }
-    }
-
-    TRACE("returning %08x\n", hres);
-    return hres;
+    return S_OK;
 }
 
-static HRESULT WINAPI
-IDirectSoundCaptureBufferImpl_GetStatus(
-    LPDIRECTSOUNDCAPTUREBUFFER8 iface,
-    LPDWORD lpdwStatus )
+static HRESULT WINAPI IDirectSoundCaptureBufferImpl_Initialize(IDirectSoundCaptureBuffer8 *iface, IDirectSoundCapture *parent, const DSCBUFFERDESC *desc)
 {
-    IDirectSoundCaptureBufferImpl *This = (IDirectSoundCaptureBufferImpl *)iface;
-    TRACE( "(%p, %p), thread is %04x\n", This, lpdwStatus, GetCurrentThreadId() );
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundCaptureBuffer8(iface);
+    WAVEFORMATEX *format;
+    HRESULT hr;
+    IMMDevice *dev = NULL;
 
-    if (This->device == NULL) {
-        WARN("invalid parameter: This->device == NULL\n");
+    if (This->parent)
+        return DSERR_ALREADYINITIALIZED;
+    This->parent = impl_from_IDirectSoundCapture(parent);
+    if (!desc->lpwfxFormat || !desc->dwBufferBytes)
         return DSERR_INVALIDPARAM;
-    }
 
-    if (lpdwStatus == NULL) {
-        WARN("invalid parameter: lpdwStatus == NULL\n");
+    format = desc->lpwfxFormat;
+    if (format->nChannels > 2)
+    {
+        WARN("nChannels > 2 not supported for recording\n");
         return DSERR_INVALIDPARAM;
     }
 
-    *lpdwStatus = 0;
-    EnterCriticalSection(&(This->device->lock));
-
-    TRACE("old This->device->state=%s, old lpdwStatus=%08x\n",
-	captureStateString[This->device->state],*lpdwStatus);
-    if ((This->device->state == STATE_STARTING) ||
-        (This->device->state == STATE_CAPTURING)) {
-        *lpdwStatus |= DSCBSTATUS_CAPTURING;
-        if (This->flags & DSCBSTART_LOOPING)
-            *lpdwStatus |= DSCBSTATUS_LOOPING;
-    }
-    TRACE("new This->device->state=%s, new lpdwStatus=%08x\n",
-	captureStateString[This->device->state],*lpdwStatus);
-    LeaveCriticalSection(&(This->device->lock));
-
-    TRACE("status=%x\n", *lpdwStatus);
-    TRACE("returning DS_OK\n");
-    return DS_OK;
-}
+    if (!This->format)
+        This->format = HeapAlloc(GetProcessHeap(), 0, sizeof(WAVEFORMATEXTENSIBLE));
+    if (!This->format)
+        return DSERR_OUTOFMEMORY;
 
-static HRESULT WINAPI
-IDirectSoundCaptureBufferImpl_Initialize(
-    LPDIRECTSOUNDCAPTUREBUFFER8 iface,
-    LPDIRECTSOUNDCAPTURE lpDSC,
-    LPCDSCBUFFERDESC lpcDSCBDesc )
-{
-    IDirectSoundCaptureBufferImpl *This = (IDirectSoundCaptureBufferImpl *)iface;
+    if (format->wFormatTag == WAVE_FORMAT_PCM
+        || format->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
+    {
+        if (format->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
+        {
+            if (format->cbSize < sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX))
+                return DSERR_INVALIDPARAM;
+            else if (format->cbSize > sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX)
+                && format->cbSize != sizeof(WAVEFORMATEXTENSIBLE))
+                return DSERR_CONTROLUNAVAIL;
+
+            memcpy(This->format, format, sizeof(WAVEFORMATEXTENSIBLE));
+            This->format->cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
+        }
+        else
+        {
+            memcpy(This->format, format, sizeof(WAVEFORMATEX));
+            This->format->cbSize = 0;
+        }
 
-    FIXME( "(%p,%p,%p): stub\n", This, lpDSC, lpcDSCBDesc );
+        This->format->nBlockAlign = This->format->wBitsPerSample * This->format->nChannels / 8;
+        This->format->nAvgBytesPerSec = This->format->nSamplesPerSec * This->format->nBlockAlign;
+    }
+    else if (format->wFormatTag)
+        WARN("Unhandled formattag %x\n", format->wFormatTag);
+
+    This->buf_size = desc->dwBufferBytes;
+    hr = DSOUND_obtain_immdevice(eCapture, &This->parent->device, This->parent->voice ? eCommunications : eMultimedia, &dev);
+    if (SUCCEEDED(hr))
+        hr = IMMDevice_Activate(dev, &IID_IAudioClient, CLSCTX_ALL, NULL, (void**)&This->dev);
+    if (SUCCEEDED(hr))
+        hr = IAudioClient_Initialize(This->dev, AUDCLNT_SHAREMODE_SHARED, 0, 5000000, 0, This->format, NULL);
+    if (SUCCEEDED(hr))
+        hr = IAudioClient_GetService(This->dev, &IID_IAudioCaptureClient, (void**)&This->cap_dev);
+    if (FAILED(hr))
+    {
+        if (This->dev)
+            IUnknown_Release(This->dev);
+        This->dev = NULL;
+        if (dev)
+            IUnknown_Release(dev);
+        if (hr == AUDCLNT_E_UNSUPPORTED_FORMAT)
+        {
+            WARN("Couldn't open device: bad format\n");
+            return DSERR_BADFORMAT;
+        }
+        ERR("couldn't open device %s %i: %08x\n", debugstr_guid(&This->parent->device), This->format->nSamplesPerSec, hr);
+        return hr == DSERR_INVALIDPARAM;
+    }
+    This->buf = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, This->buf_size);
+    if (!This->buf)
+    {
+        IAudioCaptureClient_Release(This->cap_dev);
+        IAudioClient_Release(This->dev);
+        WARN("Out of memory\n");
+        return DSERR_INVALIDPARAM;
+    }
 
-    return DS_OK;
+    return S_OK;
 }
 
-static HRESULT WINAPI
-IDirectSoundCaptureBufferImpl_Lock(
-    LPDIRECTSOUNDCAPTUREBUFFER8 iface,
-    DWORD dwReadCusor,
-    DWORD dwReadBytes,
-    LPVOID* lplpvAudioPtr1,
-    LPDWORD lpdwAudioBytes1,
-    LPVOID* lplpvAudioPtr2,
-    LPDWORD lpdwAudioBytes2,
-    DWORD dwFlags )
+static HRESULT WINAPI IDirectSoundCaptureBufferImpl_Lock(IDirectSoundCaptureBuffer8 *iface, DWORD ofs, DWORD bytes, void **ptr1, DWORD *len1, void **ptr2, DWORD *len2, DWORD flags)
 {
-    HRESULT hres = DS_OK;
-    IDirectSoundCaptureBufferImpl *This = (IDirectSoundCaptureBufferImpl *)iface;
-    TRACE( "(%p,%08u,%08u,%p,%p,%p,%p,0x%08x) at %d\n", This, dwReadCusor,
-        dwReadBytes, lplpvAudioPtr1, lpdwAudioBytes1, lplpvAudioPtr2,
-        lpdwAudioBytes2, dwFlags, GetTickCount() );
-
-    if (This->device == NULL) {
-        WARN("invalid parameter: This->device == NULL\n");
-        return DSERR_INVALIDPARAM;
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundCaptureBuffer8(iface);
+    HRESULT hr;
+    DWORD remain;
+    TRACE("(%p)->(%u, %u, %p, %p, %p, %p, %#x)\n", This, ofs, bytes, ptr1, len1, ptr2, len2, flags);
+
+    EnterCriticalSection(&This->parent->crst);
+    hr = DSERR_INVALIDPARAM;
+    if (ptr1)
+        *ptr1 = NULL;
+    if (len1)
+        *len1 = 0;
+    if (ptr2)
+        *ptr2 = NULL;
+    if (len2)
+        *len2 = 0;
+    if (ofs >= This->buf_size)
+    {
+        WARN("Invalid ofs %u\n", ofs);
+        goto out;
     }
-
-    if (lplpvAudioPtr1 == NULL) {
-        WARN("invalid parameter: lplpvAudioPtr1 == NULL\n");
-        return DSERR_INVALIDPARAM;
+    if (!ptr1 || !len1)
+    {
+        WARN("Invalid pointer/len %p %p\n", ptr1, len1);
+        goto out;
     }
-
-    if (lpdwAudioBytes1 == NULL) {
-        WARN("invalid parameter: lpdwAudioBytes1 == NULL\n");
-        return DSERR_INVALIDPARAM;
+    if (flags & DSCBLOCK_ENTIREBUFFER)
+        bytes = This->buf_size;
+    if (bytes > This->buf_size)
+    {
+        WARN("Invalid size %u\n", bytes);
+        goto out;
     }
 
-    EnterCriticalSection(&(This->device->lock));
-
-    if (This->device->driver) {
-        hres = IDsCaptureDriverBuffer_Lock(This->device->hwbuf, lplpvAudioPtr1,
-                                           lpdwAudioBytes1, lplpvAudioPtr2,
-                                           lpdwAudioBytes2, dwReadCusor,
-                                           dwReadBytes, dwFlags);
-	if (hres != DS_OK)
-	    WARN("IDsCaptureDriverBuffer_Lock failed\n");
-    } else if (This->device->hwi) {
-        *lplpvAudioPtr1 = This->device->buffer + dwReadCusor;
-        if ( (dwReadCusor + dwReadBytes) > This->device->buflen) {
-            *lpdwAudioBytes1 = This->device->buflen - dwReadCusor;
-	    if (lplpvAudioPtr2)
-            	*lplpvAudioPtr2 = This->device->buffer;
-	    if (lpdwAudioBytes2)
-		*lpdwAudioBytes2 = dwReadBytes - *lpdwAudioBytes1;
-        } else {
-            *lpdwAudioBytes1 = dwReadBytes;
-	    if (lplpvAudioPtr2)
-            	*lplpvAudioPtr2 = 0;
-	    if (lpdwAudioBytes2)
-            	*lpdwAudioBytes2 = 0;
-        }
-    } else {
-        TRACE("invalid call\n");
-        hres = DSERR_INVALIDCALL;   /* DSERR_NODRIVER ? */
+    if (ofs + bytes >= This->buf_size)
+    {
+        *len1 = This->buf_size - ofs;
+        remain = bytes - *len1;
     }
+    else
+    {
+        *len1 = bytes;
+        remain = 0;
+    }
+    *ptr1 = This->buf + ofs;
 
-    LeaveCriticalSection(&(This->device->lock));
+    if (ptr2 && len2 && remain)
+    {
+        *ptr2 = This->buf;
+        *len2 = remain;
+    }
+    hr = S_OK;
 
-    TRACE("returning %08x\n", hres);
-    return hres;
+out:
+    LeaveCriticalSection(&This->parent->crst);
+    return hr;
 }
 
-static HRESULT WINAPI
-IDirectSoundCaptureBufferImpl_Start(
-    LPDIRECTSOUNDCAPTUREBUFFER8 iface,
-    DWORD dwFlags )
+static void IDirectSoundCaptureBufferImpl_starttimer(IDirectSoundCaptureBufferImpl *This)
 {
-    HRESULT hres = DS_OK;
-    IDirectSoundCaptureBufferImpl *This = (IDirectSoundCaptureBufferImpl *)iface;
-    TRACE( "(%p,0x%08x)\n", This, dwFlags );
-
-    if (This->device == NULL) {
-        WARN("invalid parameter: This->device == NULL\n");
-        return DSERR_INVALIDPARAM;
-    }
-
-    if ( (This->device->driver == 0) && (This->device->hwi == 0) ) {
-        WARN("no driver\n");
-        return DSERR_NODRIVER;
-    }
-
-    EnterCriticalSection(&(This->device->lock));
-
-    This->flags = dwFlags;
-    TRACE("old This->state=%s\n",captureStateString[This->device->state]);
-    if (This->device->state == STATE_STOPPED)
-        This->device->state = STATE_STARTING;
-    else if (This->device->state == STATE_STOPPING)
-        This->device->state = STATE_CAPTURING;
-    TRACE("new This->device->state=%s\n",captureStateString[This->device->state]);
-
-    LeaveCriticalSection(&(This->device->lock));
-
-    if (This->device->driver) {
-        hres = IDsCaptureDriverBuffer_Start(This->device->hwbuf, dwFlags);
-	if (hres != DS_OK)
-	    WARN("IDsCaptureDriverBuffer_Start failed\n");
-    } else if (This->device->hwi) {
-        DirectSoundCaptureDevice *device = This->device;
-
-        if (device->buffer) {
-            int c;
-            DWORD blocksize = DSOUND_fraglen(device->pwfx->nSamplesPerSec, device->pwfx->nBlockAlign);
-            device->nrofpwaves = device->buflen / blocksize + !!(device->buflen % blocksize);
-            TRACE("nrofpwaves=%d\n", device->nrofpwaves);
-
-            /* prepare headers */
-            if (device->pwave)
-                device->pwave = HeapReAlloc(GetProcessHeap(), 0,device->pwave, device->nrofpwaves*sizeof(WAVEHDR));
-            else
-                device->pwave = HeapAlloc(GetProcessHeap(), 0, device->nrofpwaves*sizeof(WAVEHDR));
-
-            for (c = 0; c < device->nrofpwaves; ++c) {
-                device->pwave[c].lpData = (char *)device->buffer + c * blocksize;
-                if (c + 1 == device->nrofpwaves)
-                    device->pwave[c].dwBufferLength = device->buflen - c * blocksize;
-                else
-                    device->pwave[c].dwBufferLength = blocksize;
-                device->pwave[c].dwBytesRecorded = 0;
-                device->pwave[c].dwUser = (DWORD_PTR)device;
-                device->pwave[c].dwFlags = 0;
-                device->pwave[c].dwLoops = 0;
-                hres = mmErr(waveInPrepareHeader(device->hwi, &(device->pwave[c]),sizeof(WAVEHDR)));
-                if (hres != DS_OK) {
-                    WARN("waveInPrepareHeader failed\n");
-                    while (c--)
-                        waveInUnprepareHeader(device->hwi, &(device->pwave[c]),sizeof(WAVEHDR));
-                    break;
-                }
-
-                hres = mmErr(waveInAddBuffer(device->hwi, &(device->pwave[c]), sizeof(WAVEHDR)));
-                if (hres != DS_OK) {
-                    WARN("waveInAddBuffer failed\n");
-                    while (c--)
-                        waveInUnprepareHeader(device->hwi, &(device->pwave[c]),sizeof(WAVEHDR));
-                    break;
-                }
-            }
+    TIMECAPS time;
+    REFERENCE_TIME min_period, default_period;
+    DWORD triggertime, res = DS_TIME_RES;
 
-            FillMemory(device->buffer, device->buflen, (device->pwfx->wBitsPerSample == 8) ? 128 : 0);
-        }
+    if (This->parent->timer_id)
+        return;
 
-        device->index = 0;
+    timeGetDevCaps(&time, sizeof(TIMECAPS));
+    IAudioClient_GetDevicePeriod(This->dev, &default_period, &min_period);
+    triggertime = default_period / 10000;
+    if (triggertime < time.wPeriodMin)
+        triggertime = time.wPeriodMin;
+    TRACE("Calling timer every %u ms\n", triggertime);
+    if (res < time.wPeriodMin)
+        res = time.wPeriodMin;
+    if (timeBeginPeriod(res) == TIMERR_NOCANDO)
+        WARN("Could not set minimum resolution, don't expect sound\n");
+    This->parent->timer_res = res;
+    This->parent->timer_id = timeSetEvent(triggertime, res, IDirectSoundCaptureBufferImpl_timer, (DWORD_PTR)This->parent, TIME_PERIODIC | TIME_KILL_SYNCHRONOUS);
+}
 
-	if (hres == DS_OK) {
-	    /* start filling the first buffer */
-	    hres = mmErr(waveInStart(device->hwi));
-            if (hres != DS_OK)
-                WARN("waveInStart failed\n");
-        }
+static HRESULT WINAPI IDirectSoundCaptureBufferImpl_Start(IDirectSoundCaptureBuffer8 *iface, DWORD flags)
+{
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundCaptureBuffer8(iface);
+    TRACE("(%p)->(%08x)\n", This, flags);
 
-        if (hres != DS_OK) {
-            WARN("calling waveInClose because of error\n");
-            waveInClose(device->hwi);
-            device->hwi = 0;
-        }
-    } else {
-        WARN("no driver\n");
-        hres = DSERR_NODRIVER;
+    EnterCriticalSection(&This->parent->crst);
+    if (!This->playing)
+    {
+        IDirectSoundCaptureBufferImpl_starttimer(This);
+        This->playing = 1;
+        IAudioClient_Start(This->dev);
     }
-
-    TRACE("returning %08x\n", hres);
-    return hres;
+    This->looping = !!(flags & DSCBSTART_LOOPING);
+    LeaveCriticalSection(&This->parent->crst);
+    return S_OK;
 }
 
-static HRESULT WINAPI
-IDirectSoundCaptureBufferImpl_Stop( LPDIRECTSOUNDCAPTUREBUFFER8 iface )
+static HRESULT WINAPI IDirectSoundCaptureBufferImpl_Stop(IDirectSoundCaptureBuffer8 *iface)
 {
-    HRESULT hres = DS_OK;
-    IDirectSoundCaptureBufferImpl *This = (IDirectSoundCaptureBufferImpl *)iface;
-    TRACE( "(%p)\n", This );
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundCaptureBuffer8(iface);
+    TRACE("(%p)\n", This);
 
-    if (This->device == NULL) {
-        WARN("invalid parameter: This->device == NULL\n");
-        return DSERR_INVALIDPARAM;
-    }
+    EnterCriticalSection(&This->parent->crst);
+    if (This->playing)
+    {
+        DWORD i;
 
-    EnterCriticalSection(&(This->device->lock));
-
-    TRACE("old This->device->state=%s\n",captureStateString[This->device->state]);
-    if (This->device->state == STATE_CAPTURING)
-	This->device->state = STATE_STOPPING;
-    else if (This->device->state == STATE_STARTING)
-	This->device->state = STATE_STOPPED;
-    TRACE("new This->device->state=%s\n",captureStateString[This->device->state]);
-
-    LeaveCriticalSection(&(This->device->lock));
-
-    if (This->device->driver) {
-        hres = IDsCaptureDriverBuffer_Stop(This->device->hwbuf);
-        if (hres != DS_OK)
-            WARN("IDsCaptureDriverBuffer_Stop() failed\n");
-    } else if (This->device->hwi) {
-        hres = mmErr(waveInReset(This->device->hwi));
-        if (hres != DS_OK)
-            WARN("waveInReset() failed\n");
-    } else {
-	WARN("no driver\n");
-        hres = DSERR_NODRIVER;
+        for (i = 0; i < This->nnotify; ++i)
+            if (This->notify[i].dwOffset == DSCBPN_OFFSET_STOP)
+            {
+                SetEvent(This->notify[i].hEventNotify);
+                break;
+            }
+        This->playing = This->looping = 0;
+        IAudioClient_Stop(This->dev);
+        IAudioClient_Reset(This->dev);
     }
-
-    TRACE("returning %08x\n", hres);
-    return hres;
+    LeaveCriticalSection(&This->parent->crst);
+    return S_OK;
 }
 
-static HRESULT WINAPI
-IDirectSoundCaptureBufferImpl_Unlock(
-    LPDIRECTSOUNDCAPTUREBUFFER8 iface,
-    LPVOID lpvAudioPtr1,
-    DWORD dwAudioBytes1,
-    LPVOID lpvAudioPtr2,
-    DWORD dwAudioBytes2 )
+static HRESULT WINAPI IDirectSoundCaptureBufferImpl_Unlock(IDirectSoundCaptureBuffer8 *iface, void *ptr1, DWORD len1, void *ptr2, DWORD len2)
 {
-    HRESULT hres = DS_OK;
-    IDirectSoundCaptureBufferImpl *This = (IDirectSoundCaptureBufferImpl *)iface;
-    TRACE( "(%p,%p,%08u,%p,%08u)\n", This, lpvAudioPtr1, dwAudioBytes1,
-        lpvAudioPtr2, dwAudioBytes2 );
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundCaptureBuffer8(iface);
+    TRACE("(%p)->(%p,%u,%p,%u)\n", This, ptr1, len2, ptr2, len2);
 
-    if (lpvAudioPtr1 == NULL) {
-        WARN("invalid parameter: lpvAudioPtr1 == NULL\n");
+    if (!ptr1)
         return DSERR_INVALIDPARAM;
-    }
-
-    if (This->device->driver) {
-        hres = IDsCaptureDriverBuffer_Unlock(This->device->hwbuf, lpvAudioPtr1,
-                                             dwAudioBytes1, lpvAudioPtr2, dwAudioBytes2);
-	if (hres != DS_OK)
-	    WARN("IDsCaptureDriverBuffer_Unlock failed\n");
-    } else if (!This->device->hwi) {
-        WARN("invalid call\n");
-        hres = DSERR_INVALIDCALL;
-    }
-
-    TRACE("returning %08x\n", hres);
-    return hres;
+    return S_OK;
 }
 
-static HRESULT WINAPI
-IDirectSoundCaptureBufferImpl_GetObjectInPath(
-    LPDIRECTSOUNDCAPTUREBUFFER8 iface,
-    REFGUID rguidObject,
-    DWORD dwIndex,
-    REFGUID rguidInterface,
-    LPVOID* ppObject )
+static HRESULT WINAPI IDirectSoundCaptureBufferImpl_GetObjectInPath(IDirectSoundCaptureBuffer8 *iface, REFGUID guid, DWORD num, REFGUID riid, void **ppv)
 {
-    IDirectSoundCaptureBufferImpl *This = (IDirectSoundCaptureBufferImpl *)iface;
-
-    FIXME( "(%p,%s,%u,%s,%p): stub\n", This, debugstr_guid(rguidObject),
-        dwIndex, debugstr_guid(rguidInterface), ppObject );
-
-    return DS_OK;
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundCaptureBuffer8(iface);
+    FIXME("(%p)->(%s %u %s %p) stub\n", This, debugstr_guid(guid), num, debugstr_guid(riid), ppv);
+    return E_NOTIMPL;
 }
 
-static HRESULT WINAPI
-IDirectSoundCaptureBufferImpl_GetFXStatus(
-    LPDIRECTSOUNDCAPTUREBUFFER8 iface,
-    DWORD dwFXCount,
-    LPDWORD pdwFXStatus )
+static HRESULT WINAPI IDirectSoundCaptureBufferImpl_GetFXStatus(IDirectSoundCaptureBuffer8 *iface, DWORD count, DWORD *status)
 {
-    IDirectSoundCaptureBufferImpl *This = (IDirectSoundCaptureBufferImpl *)iface;
-
-    FIXME( "(%p,%u,%p): stub\n", This, dwFXCount, pdwFXStatus );
-
-    return DS_OK;
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundCaptureBuffer8(iface);
+    FIXME("(%p)->(%u %p) stub\n", This, count, status);
+    return E_NOTIMPL;
 }
 
-static const IDirectSoundCaptureBuffer8Vtbl dscbvt =
-{
-    /* IUnknown methods */
+static const IDirectSoundCaptureBuffer8Vtbl IDirectSoundCaptureBufferImpl_Vtbl = {
     IDirectSoundCaptureBufferImpl_QueryInterface,
     IDirectSoundCaptureBufferImpl_AddRef,
     IDirectSoundCaptureBufferImpl_Release,
-
-    /* IDirectSoundCaptureBuffer methods */
     IDirectSoundCaptureBufferImpl_GetCaps,
     IDirectSoundCaptureBufferImpl_GetCurrentPosition,
     IDirectSoundCaptureBufferImpl_GetFormat,
@@ -747,432 +545,135 @@ static const IDirectSoundCaptureBuffer8Vtbl dscbvt =
     IDirectSoundCaptureBufferImpl_Start,
     IDirectSoundCaptureBufferImpl_Stop,
     IDirectSoundCaptureBufferImpl_Unlock,
-
-    /* IDirectSoundCaptureBuffer methods */
     IDirectSoundCaptureBufferImpl_GetObjectInPath,
     IDirectSoundCaptureBufferImpl_GetFXStatus
 };
 
-static void capture_CheckNotify(IDirectSoundCaptureBufferImpl *This, DWORD from, DWORD len)
+static HRESULT WINAPI IDirectSoundNotifyImpl_QueryInterface(IDirectSoundNotify *iface, REFIID riid, void **ppv)
 {
-    int i;
-    for (i = 0; i < This->nrofnotifies; ++i) {
-        LPDSBPOSITIONNOTIFY event = This->notifies + i;
-        DWORD offset = event->dwOffset;
-        TRACE("checking %d, position %d, event = %p\n", i, offset, event->hEventNotify);
-
-        if (offset == DSBPN_OFFSETSTOP) {
-            if (!from && !len) {
-                SetEvent(event->hEventNotify);
-                TRACE("signalled event %p (%d)\n", event->hEventNotify, i);
-                return;
-            }
-            else return;
-        }
-
-        if (offset >= from && offset < (from + len))
-        {
-            TRACE("signalled event %p (%d)\n", event->hEventNotify, i);
-            SetEvent(event->hEventNotify);
-        }
-    }
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundNotify(iface);
+    return IDirectSoundCaptureBuffer_QueryInterface((IDirectSoundCaptureBuffer*)This, riid, ppv);
 }
 
-static void CALLBACK
-DSOUND_capture_callback(HWAVEIN hwi, UINT msg, DWORD_PTR dwUser, DWORD_PTR dw1,
-                        DWORD_PTR dw2)
+static ULONG WINAPI IDirectSoundNotifyImpl_AddRef(IDirectSoundNotify *iface)
 {
-    DirectSoundCaptureDevice * This = (DirectSoundCaptureDevice*)dwUser;
-    IDirectSoundCaptureBufferImpl * Moi = This->capture_buffer;
-    TRACE("(%p,%08x(%s),%08lx,%08lx,%08lx) entering at %d\n",hwi,msg,
-	msg == MM_WIM_OPEN ? "MM_WIM_OPEN" : msg == MM_WIM_CLOSE ? "MM_WIM_CLOSE" :
-	msg == MM_WIM_DATA ? "MM_WIM_DATA" : "UNKNOWN",dwUser,dw1,dw2,GetTickCount());
-
-    if (msg == MM_WIM_DATA) {
-	EnterCriticalSection( &(This->lock) );
-	TRACE("DirectSoundCapture msg=MM_WIM_DATA, old This->state=%s, old This->index=%d\n",
-	    captureStateString[This->state],This->index);
-	if (This->state != STATE_STOPPED) {
-	    int index = This->index;
-	    if (This->state == STATE_STARTING)
-		This->state = STATE_CAPTURING;
-	    capture_CheckNotify(Moi, (DWORD_PTR)This->pwave[index].lpData - (DWORD_PTR)This->buffer, This->pwave[index].dwBufferLength);
-	    This->index = (This->index + 1) % This->nrofpwaves;
-	    if ( (This->index == 0) && !(This->capture_buffer->flags & DSCBSTART_LOOPING) ) {
-		TRACE("end of buffer\n");
-		This->state = STATE_STOPPED;
-		capture_CheckNotify(Moi, 0, 0);
-	    } else {
-		if (This->state == STATE_CAPTURING) {
-		    waveInUnprepareHeader(hwi, &(This->pwave[index]), sizeof(WAVEHDR));
-		    waveInPrepareHeader(hwi, &(This->pwave[index]), sizeof(WAVEHDR));
-		    waveInAddBuffer(hwi, &(This->pwave[index]), sizeof(WAVEHDR));
-	        } else if (This->state == STATE_STOPPING) {
-		    TRACE("stopping\n");
-		    This->state = STATE_STOPPED;
-		}
-	    }
-	}
-	TRACE("DirectSoundCapture new This->state=%s, new This->index=%d\n",
-	    captureStateString[This->state],This->index);
-	LeaveCriticalSection( &(This->lock) );
-    }
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundNotify(iface);
+    LONG ret;
 
-    TRACE("completed\n");
+    ret = InterlockedIncrement(&This->notify_ref);
+    if (ret == 1)
+        IUnknown_AddRef(&This->IDirectSoundCaptureBuffer8_iface);
+    TRACE("new refcount %d\n", ret);
+    return ret;
 }
 
-static HRESULT IDirectSoundCaptureBufferImpl_Create(
-    DirectSoundCaptureDevice *device,
-    IDirectSoundCaptureBufferImpl ** ppobj,
-    LPCDSCBUFFERDESC lpcDSCBufferDesc)
+static ULONG WINAPI IDirectSoundNotifyImpl_Release(IDirectSoundNotify *iface)
 {
-    LPWAVEFORMATEX  wfex;
-    TRACE( "(%p,%p,%p)\n", device, ppobj, lpcDSCBufferDesc);
-
-    if (ppobj == NULL) {
-	WARN("invalid parameter: ppobj == NULL\n");
-	return DSERR_INVALIDPARAM;
-    }
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundNotify(iface);
+    LONG ret;
 
-    if (!device) {
-	WARN("not initialized\n");
-        *ppobj = NULL;
-	return DSERR_UNINITIALIZED;
-    }
+    ret = InterlockedDecrement(&This->notify_ref);
+    TRACE("new refcount %d\n", ret);
+    if (!ret)
+        IUnknown_Release(&This->IDirectSoundCaptureBuffer8_iface);
+    return ret;
+}
 
-    if (lpcDSCBufferDesc == NULL) {
-	WARN("invalid parameter: lpcDSCBufferDesc == NULL\n");
-        *ppobj = NULL;
-	return DSERR_INVALIDPARAM;
-    }
+static HRESULT WINAPI IDirectSoundNotifyImpl_SetNotificationPositions(IDirectSoundNotify *iface, DWORD count, const DSBPOSITIONNOTIFY *notifications)
+{
+    IDirectSoundCaptureBufferImpl *This = impl_from_IDirectSoundNotify(iface);
+    DSBPOSITIONNOTIFY *nots;
+    HRESULT hr;
+    DWORD state;
 
-    if ( ((lpcDSCBufferDesc->dwSize != sizeof(DSCBUFFERDESC)) &&
-          (lpcDSCBufferDesc->dwSize != sizeof(DSCBUFFERDESC1))) ||
-        (lpcDSCBufferDesc->dwBufferBytes == 0) ||
-        (lpcDSCBufferDesc->lpwfxFormat == NULL) ) { /* FIXME: DSERR_BADFORMAT ? */
-	WARN("invalid lpcDSCBufferDesc\n");
-	*ppobj = NULL;
-	return DSERR_INVALIDPARAM;
-    }
+    EnterCriticalSection(&This->parent->crst);
+    hr = DSERR_INVALIDPARAM;
+    if (count && !notifications)
+        goto out;
 
-    wfex = lpcDSCBufferDesc->lpwfxFormat;
+    hr = IDirectSoundCaptureBuffer_GetStatus(&This->IDirectSoundCaptureBuffer8_iface, &state);
+    if (FAILED(hr))
+        goto out;
 
-    TRACE("(formattag=0x%04x,chans=%d,samplerate=%d,"
-        "bytespersec=%d,blockalign=%d,bitspersamp=%d,cbSize=%d)\n",
-        wfex->wFormatTag, wfex->nChannels, wfex->nSamplesPerSec,
-        wfex->nAvgBytesPerSec, wfex->nBlockAlign,
-        wfex->wBitsPerSample, wfex->cbSize);
+    hr = DSERR_INVALIDCALL;
+    if (state & DSCBSTATUS_CAPTURING)
+        goto out;
 
-    device->pwfx = DSOUND_CopyFormat(wfex);
-    if ( device->pwfx == NULL ) {
-	*ppobj = NULL;
-	return DSERR_OUTOFMEMORY;
+    if (!count)
+    {
+        HeapFree(GetProcessHeap(), 0, This->notify);
+        This->notify = 0;
+        This->nnotify = 0;
     }
-
-    *ppobj = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,
-        sizeof(IDirectSoundCaptureBufferImpl));
-
-    if ( *ppobj == NULL ) {
-	WARN("out of memory\n");
-	*ppobj = NULL;
-	return DSERR_OUTOFMEMORY;
-    } else {
-    	HRESULT err = DS_OK;
-        LPBYTE newbuf;
-        DWORD buflen;
-        IDirectSoundCaptureBufferImpl *This = *ppobj;
-
-        This->ref = 1;
-        This->device = device;
-        This->device->capture_buffer = This;
-	This->notify = NULL;
-	This->nrofnotifies = 0;
-	This->hwnotify = NULL;
-
-        This->pdscbd = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,
-            lpcDSCBufferDesc->dwSize);
-        if (This->pdscbd)
-            CopyMemory(This->pdscbd, lpcDSCBufferDesc, lpcDSCBufferDesc->dwSize);
-        else {
-            WARN("no memory\n");
-            This->device->capture_buffer = 0;
-            HeapFree( GetProcessHeap(), 0, This );
-            *ppobj = NULL;
-            return DSERR_OUTOFMEMORY;
+    else
+    {
+        DWORD i;
+        hr = DSERR_INVALIDPARAM;
+        for (i = 0; i < count; ++i)
+        {
+            if (notifications[i].dwOffset >= This->buf_size
+                && notifications[i].dwOffset != DSCBPN_OFFSET_STOP)
+                goto out;
+            TRACE("ofs: %u/%x with event %p\n", notifications[i].dwOffset, notifications[i].dwOffset, notifications[i].hEventNotify);
         }
-
-        This->lpVtbl = &dscbvt;
-
-	if (device->driver) {
-            if (This->device->drvdesc.dwFlags & DSDDESC_DOMMSYSTEMOPEN)
-                FIXME("DSDDESC_DOMMSYSTEMOPEN not supported\n");
-
-            if (This->device->drvdesc.dwFlags & DSDDESC_USESYSTEMMEMORY) {
-                /* allocate buffer from system memory */
-                buflen = lpcDSCBufferDesc->dwBufferBytes;
-                TRACE("desired buflen=%d, old buffer=%p\n", buflen, device->buffer);
-                if (device->buffer)
-                    newbuf = HeapReAlloc(GetProcessHeap(),0,device->buffer,buflen);
-                else
-                    newbuf = HeapAlloc(GetProcessHeap(),0,buflen);
-
-                if (newbuf == NULL) {
-                    WARN("failed to allocate capture buffer\n");
-                    err = DSERR_OUTOFMEMORY;
-                    /* but the old buffer might still exist and must be re-prepared */
-                } else {
-                    device->buffer = newbuf;
-                    device->buflen = buflen;
-                }
-            } else {
-                /* let driver allocate memory */
-                device->buflen = lpcDSCBufferDesc->dwBufferBytes;
-                /* FIXME: */
-                HeapFree( GetProcessHeap(), 0, device->buffer);
-                device->buffer = NULL;
-            }
-
-	    err = IDsCaptureDriver_CreateCaptureBuffer(device->driver,
-		device->pwfx,0,0,&(device->buflen),&(device->buffer),(LPVOID*)&(device->hwbuf));
-	    if (err != DS_OK) {
-		WARN("IDsCaptureDriver_CreateCaptureBuffer failed\n");
-		This->device->capture_buffer = 0;
-		HeapFree( GetProcessHeap(), 0, This );
-		*ppobj = NULL;
-		return err;
-	    }
-	} else {
-	    DWORD flags = CALLBACK_FUNCTION | WAVE_MAPPED;
-            err = mmErr(waveInOpen(&(device->hwi),
-                device->drvdesc.dnDevNode, device->pwfx,
-                (DWORD_PTR)DSOUND_capture_callback, (DWORD_PTR)device, flags));
-            if (err != DS_OK) {
-                WARN("waveInOpen failed\n");
-		This->device->capture_buffer = 0;
-		HeapFree( GetProcessHeap(), 0, This );
-		*ppobj = NULL;
-		return err;
-            }
-
-	    buflen = lpcDSCBufferDesc->dwBufferBytes;
-            TRACE("desired buflen=%d, old buffer=%p\n", buflen, device->buffer);
-	    if (device->buffer)
-                newbuf = HeapReAlloc(GetProcessHeap(),0,device->buffer,buflen);
-	    else
-		newbuf = HeapAlloc(GetProcessHeap(),0,buflen);
-            if (newbuf == NULL) {
-                WARN("failed to allocate capture buffer\n");
-                err = DSERR_OUTOFMEMORY;
-                /* but the old buffer might still exist and must be re-prepared */
-            } else {
-                device->buffer = newbuf;
-                device->buflen = buflen;
-            }
-	}
-    }
-
-    TRACE("returning DS_OK\n");
-    return DS_OK;
+        hr = E_OUTOFMEMORY;
+        nots = HeapAlloc(GetProcessHeap(), 0, count*sizeof(*nots));
+        if (!nots)
+            goto out;
+        memcpy(nots, notifications, count*sizeof(*nots));
+        HeapFree(GetProcessHeap(), 0, This->notify);
+        This->notify = nots;
+        This->nnotify = count;
+        hr = S_OK;
+    }
+
+out:
+    LeaveCriticalSection(&This->parent->crst);
+    return hr;
 }
 
-
-/*******************************************************************************
- * DirectSoundCaptureDevice
- */
-DirectSoundCaptureDevice * DSOUND_capture[MAXWAVEDRIVERS];
-
-static HRESULT DirectSoundCaptureDevice_Create(
-    DirectSoundCaptureDevice ** ppDevice)
+static const IDirectSoundNotifyVtbl DSCNot_Vtbl =
 {
-    DirectSoundCaptureDevice * device;
-    TRACE("(%p)\n", ppDevice);
-
-    /* Allocate memory */
-    device = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(DirectSoundCaptureDevice));
-
-    if (device == NULL) {
-	WARN("out of memory\n");
-        return DSERR_OUTOFMEMORY;
-    }
-
-    device->ref = 1;
-    device->state = STATE_STOPPED;
-
-    InitializeCriticalSection( &(device->lock) );
-    device->lock.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": DirectSoundCaptureDevice.lock");
-
-    *ppDevice = device;
-
-    return DS_OK;
-}
+    IDirectSoundNotifyImpl_QueryInterface,
+    IDirectSoundNotifyImpl_AddRef,
+    IDirectSoundNotifyImpl_Release,
+    IDirectSoundNotifyImpl_SetNotificationPositions
+};
 
-static ULONG DirectSoundCaptureDevice_Release(
-    DirectSoundCaptureDevice * device)
+static HRESULT IDirectSoundCaptureBufferImpl_Create(IDirectSoundCaptureBufferImpl **buf)
 {
-    ULONG ref = InterlockedDecrement(&(device->ref));
-    TRACE("(%p) ref was %d\n", device, ref + 1);
-
-    if (!ref) {
-        TRACE("deleting object\n");
-        if (device->capture_buffer)
-            IDirectSoundCaptureBufferImpl_Release(
-		(LPDIRECTSOUNDCAPTUREBUFFER8) device->capture_buffer);
-
-        if (device->driver) {
-            IDsCaptureDriver_Close(device->driver);
-            IDsCaptureDriver_Release(device->driver);
-        }
-
-        HeapFree(GetProcessHeap(), 0, device->pwfx);
-        device->lock.DebugInfo->Spare[0] = 0;
-        DeleteCriticalSection( &(device->lock) );
-        DSOUND_capture[device->drvdesc.dnDevNode] = NULL;
-        HeapFree(GetProcessHeap(), 0, device);
-	TRACE("(%p) released\n", device);
-    }
-    return ref;
+    IDirectSoundCaptureBufferImpl *This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*This));
+    if (!This)
+        return E_OUTOFMEMORY;
+    This->IDirectSoundCaptureBuffer8_iface.lpVtbl = &IDirectSoundCaptureBufferImpl_Vtbl;
+    This->IDirectSoundNotify_iface.lpVtbl = &DSCNot_Vtbl;
+    This->ref = 1;
+    *buf = This;
+    return S_OK;
 }
 
-static HRESULT DirectSoundCaptureDevice_Initialize(
-    DirectSoundCaptureDevice ** ppDevice,
-    LPCGUID lpcGUID)
+static void IDirectSoundCaptureBufferImpl_Destroy(IDirectSoundCaptureBufferImpl *This)
 {
-    HRESULT err = DSERR_INVALIDPARAM;
-    unsigned wid, widn;
-    BOOLEAN found = FALSE;
-    GUID devGUID;
-    DirectSoundCaptureDevice *device = *ppDevice;
-    TRACE("(%p, %s)\n", ppDevice, debugstr_guid(lpcGUID));
-
-    /* Default device? */
-    if ( !lpcGUID || IsEqualGUID(lpcGUID, &GUID_NULL) )
-	lpcGUID = &DSDEVID_DefaultCapture;
-
-    if (GetDeviceID(lpcGUID, &devGUID) != DS_OK) {
-        WARN("invalid parameter: lpcGUID\n");
-        return DSERR_INVALIDPARAM;
-    }
-
-    widn = waveInGetNumDevs();
-    if (!widn) {
-	WARN("no audio devices found\n");
-	return DSERR_NODRIVER;
-    }
-
-    /* enumerate WINMM audio devices and find the one we want */
-    for (wid=0; wid<widn; wid++) {
-	if (IsEqualGUID( &devGUID, &DSOUND_capture_guids[wid]) ) {
-	    found = TRUE;
-	    break;
-	}
-    }
-
-    if (found == FALSE) {
-	WARN("No device found matching given ID!\n");
-	return DSERR_NODRIVER;
-    }
-
-    if (DSOUND_capture[wid]) {
-        WARN("already in use\n");
-        return DSERR_ALLOCATED;
-    }
-
-    err = DirectSoundCaptureDevice_Create(&(device));
-    if (err != DS_OK) {
-        WARN("DirectSoundCaptureDevice_Create failed\n");
-        return err;
-    }
-
-    *ppDevice = device;
-    device->guid = devGUID;
-
-    /* Disable the direct sound driver to force emulation if requested. */
-    device->driver = NULL;
-    if (ds_hw_accel != DS_HW_ACCEL_EMULATION)
+    if (This->dev)
     {
-        err = mmErr(waveInMessage(UlongToHandle(wid),DRV_QUERYDSOUNDIFACE,(DWORD_PTR)&device->driver,0));
-        if ( (err != DS_OK) && (err != DSERR_UNSUPPORTED) ) {
-            WARN("waveInMessage failed; err=%x\n",err);
-            return err;
-        }
-    }
-    err = DS_OK;
-
-    /* Get driver description */
-    if (device->driver) {
-        TRACE("using DirectSound driver\n");
-        err = IDsCaptureDriver_GetDriverDesc(device->driver, &(device->drvdesc));
-	if (err != DS_OK) {
-	    WARN("IDsCaptureDriver_GetDriverDesc failed\n");
-	    return err;
-	}
-    } else {
-        TRACE("using WINMM\n");
-        /* if no DirectSound interface available, use WINMM API instead */
-        device->drvdesc.dwFlags = DSDDESC_DOMMSYSTEMOPEN |
-            DSDDESC_DOMMSYSTEMSETFORMAT;
-    }
-
-    device->drvdesc.dnDevNode = wid;
-
-    /* open the DirectSound driver if available */
-    if (device->driver && (err == DS_OK))
-        err = IDsCaptureDriver_Open(device->driver);
-
-    if (err == DS_OK) {
-        *ppDevice = device;
-
-        /* the driver is now open, so it's now allowed to call GetCaps */
-        if (device->driver) {
-	    device->drvcaps.dwSize = sizeof(device->drvcaps);
-            err = IDsCaptureDriver_GetCaps(device->driver,&(device->drvcaps));
-	    if (err != DS_OK) {
-		WARN("IDsCaptureDriver_GetCaps failed\n");
-		return err;
-	    }
-        } else /*if (device->hwi)*/ {
-            WAVEINCAPSA    wic;
-            err = mmErr(waveInGetDevCapsA((UINT)device->drvdesc.dnDevNode, &wic, sizeof(wic)));
-
-            if (err == DS_OK) {
-                device->drvcaps.dwFlags = 0;
-                lstrcpynA(device->drvdesc.szDrvname, wic.szPname,
-                          sizeof(device->drvdesc.szDrvname));
-
-                device->drvcaps.dwFlags |= DSCCAPS_EMULDRIVER;
-                device->drvcaps.dwFormats = wic.dwFormats;
-                device->drvcaps.dwChannels = wic.wChannels;
-            }
-        }
+        if (This->playing)
+            IAudioClient_Stop(This->dev);
+        IAudioCaptureClient_Release(This->cap_dev);
+        IAudioClient_Release(This->dev);
     }
-
-    return err;
+    if (This->parent)
+        This->parent->buf = NULL;
+    HeapFree(GetProcessHeap(), 0, This->notify);
+    HeapFree(GetProcessHeap(), 0, This->format);
+    HeapFree(GetProcessHeap(), 0, This->buf);
+    HeapFree(GetProcessHeap(), 0, This);
 }
 
 
-/*****************************************************************************
- * IDirectSoundCapture implementation structure
- */
-struct IDirectSoundCaptureImpl
+static HRESULT WINAPI IDirectSoundCaptureImpl_QueryInterface(IDirectSoundCapture *iface, REFIID riid, void **ppobj)
 {
-    /* IUnknown fields */
-    const IDirectSoundCaptureVtbl     *lpVtbl;
-    LONG                               ref;
-
-    DirectSoundCaptureDevice          *device;
-};
-
-/***************************************************************************
- * IDirectSoundCaptureImpl
- */
-static HRESULT WINAPI
-IDirectSoundCaptureImpl_QueryInterface(
-    LPDIRECTSOUNDCAPTURE iface,
-    REFIID riid,
-    LPVOID* ppobj )
-{
-    IDirectSoundCaptureImpl *This = (IDirectSoundCaptureImpl *)iface;
-    TRACE( "(%p,%s,%p)\n", This, debugstr_guid(riid), ppobj );
+    IDirectSoundCaptureImpl *This = impl_from_IDirectSoundCapture(iface);
+    TRACE("(%p,%s,%p)\n", This, debugstr_guid(riid), ppobj);
 
     if (ppobj == NULL) {
 	WARN("invalid parameter\n");
@@ -1195,211 +696,191 @@ IDirectSoundCaptureImpl_QueryInterface(
     return E_NOINTERFACE;
 }
 
-static ULONG WINAPI
-IDirectSoundCaptureImpl_AddRef( LPDIRECTSOUNDCAPTURE iface )
+static ULONG WINAPI IDirectSoundCaptureImpl_AddRef(IDirectSoundCapture *iface)
 {
-    IDirectSoundCaptureImpl *This = (IDirectSoundCaptureImpl *)iface;
+    IDirectSoundCaptureImpl *This = impl_from_IDirectSoundCapture(iface);
     ULONG ref = InterlockedIncrement(&(This->ref));
     TRACE("(%p) ref was %d\n", This, ref - 1);
     return ref;
 }
 
-static ULONG WINAPI
-IDirectSoundCaptureImpl_Release( LPDIRECTSOUNDCAPTURE iface )
+static ULONG WINAPI IDirectSoundCaptureImpl_Release(IDirectSoundCapture *iface)
 {
-    IDirectSoundCaptureImpl *This = (IDirectSoundCaptureImpl *)iface;
+    IDirectSoundCaptureImpl *This = impl_from_IDirectSoundCapture(iface);
     ULONG ref = InterlockedDecrement(&(This->ref));
     TRACE("(%p) ref was %d\n", This, ref + 1);
 
     if (!ref) {
-        if (This->device)
-            DirectSoundCaptureDevice_Release(This->device);
-
-        HeapFree( GetProcessHeap(), 0, This );
+        IDirectSoundCaptureImpl_Destroy(This);
         TRACE("(%p) released\n", This);
     }
     return ref;
 }
 
-static HRESULT WINAPI IDirectSoundCaptureImpl_CreateCaptureBuffer(
-    LPDIRECTSOUNDCAPTURE iface,
-    LPCDSCBUFFERDESC lpcDSCBufferDesc,
-    LPDIRECTSOUNDCAPTUREBUFFER* lplpDSCaptureBuffer,
-    LPUNKNOWN pUnk )
+static HRESULT WINAPI IDirectSoundCaptureImpl_CreateCaptureBuffer(IDirectSoundCapture *iface, const DSCBUFFERDESC *desc, IDirectSoundCaptureBuffer **ppv, IUnknown *unk)
 {
+    IDirectSoundCaptureImpl *This = impl_from_IDirectSoundCapture(iface);
     HRESULT hr;
-    IDirectSoundCaptureImpl *This = (IDirectSoundCaptureImpl *)iface;
+    TRACE("(%p)->(%p,%p,%p)\n", This, desc, ppv, unk);
 
-    TRACE( "(%p,%p,%p,%p)\n",iface,lpcDSCBufferDesc,lplpDSCaptureBuffer,pUnk);
-
-    if (lpcDSCBufferDesc == NULL) {
-	WARN("invalid parameter: lpcDSCBufferDesc == NULL)\n");
-	return DSERR_INVALIDPARAM;
+    if (unk)
+    {
+        WARN("Aggregation isn't supported\n");
+        return DSERR_NOAGGREGATION;
     }
 
-    if (lplpDSCaptureBuffer == NULL) {
-	WARN("invalid parameter: lplpDSCaptureBuffer == NULL\n");
-	return DSERR_INVALIDPARAM;
+    if (!desc || desc->dwSize < sizeof(DSCBUFFERDESC1))
+    {
+        WARN("Passed invalid description %p %u\n", desc, desc?desc->dwSize:0);
+        return DSERR_INVALIDPARAM;
     }
-
-    if (pUnk != NULL) {
-	WARN("invalid parameter: pUnk != NULL\n");
-	return DSERR_INVALIDPARAM;
+    if (!ppv)
+    {
+        WARN("Passed null pointer\n");
+        return DSERR_INVALIDPARAM;
     }
+    *ppv = NULL;
 
-    /* FIXME: We can only have one buffer so what do we do here? */
-    if (This->device->capture_buffer) {
-	WARN("invalid parameter: already has buffer\n");
-	return DSERR_INVALIDPARAM;    /* DSERR_GENERIC ? */
+    EnterCriticalSection(&This->crst);
+    if (IsEqualIID(&This->device, &GUID_NULL))
+    {
+        hr = DSERR_UNINITIALIZED;
+        WARN("Not initialized\n");
+        goto out;
     }
 
-    hr = IDirectSoundCaptureBufferImpl_Create(This->device,
-        (IDirectSoundCaptureBufferImpl **)lplpDSCaptureBuffer, lpcDSCBufferDesc);
-
-    if (hr != DS_OK)
-	WARN("IDirectSoundCaptureBufferImpl_Create failed\n");
-
+    hr = IDirectSoundCaptureBufferImpl_Create(&This->buf);
+    if (SUCCEEDED(hr))
+    {
+        hr = IDirectSoundCaptureBuffer_Initialize((IDirectSoundCaptureBuffer*)This->buf, iface, desc);
+        if (FAILED(hr))
+        {
+            IDirectSoundCaptureBufferImpl_Destroy(This->buf);
+            This->buf = NULL;
+        }
+    }
+    *ppv = (IDirectSoundCaptureBuffer*)&This->buf->IDirectSoundCaptureBuffer8_iface;
+out:
+    LeaveCriticalSection(&This->crst);
     return hr;
 }
 
-static HRESULT WINAPI IDirectSoundCaptureImpl_GetCaps(
-    LPDIRECTSOUNDCAPTURE iface,
-    LPDSCCAPS lpDSCCaps )
+static HRESULT WINAPI IDirectSoundCaptureImpl_GetCaps(IDirectSoundCapture *iface, DSCCAPS *caps)
 {
-    IDirectSoundCaptureImpl *This = (IDirectSoundCaptureImpl *)iface;
-    TRACE("(%p,%p)\n",This,lpDSCCaps);
+    IDirectSoundCaptureImpl *This = impl_from_IDirectSoundCapture(iface);
+    TRACE("(%p,%p)\n", This, caps);
 
-    if (This->device == NULL) {
-	WARN("not initialized\n");
-	return DSERR_UNINITIALIZED;
+    if (IsEqualIID(&This->device, &GUID_NULL)) {
+        WARN("Not initialized\n");
+        return DSERR_UNINITIALIZED;
     }
 
-    if (lpDSCCaps== NULL) {
-	WARN("invalid parameter: lpDSCCaps== NULL\n");
-	return DSERR_INVALIDPARAM;
+    if (!caps) {
+        WARN("Caps is null\n");
+        return DSERR_INVALIDPARAM;
     }
 
-    if (lpDSCCaps->dwSize < sizeof(*lpDSCCaps)) {
-	WARN("invalid parameter: lpDSCCaps->dwSize = %d\n", lpDSCCaps->dwSize);
-	return DSERR_INVALIDPARAM;
+    if (caps->dwSize < sizeof(*caps)) {
+        WARN("Invalid size %d\n", caps->dwSize);
+        return DSERR_INVALIDPARAM;
     }
 
-    lpDSCCaps->dwFlags = This->device->drvcaps.dwFlags;
-    lpDSCCaps->dwFormats = This->device->drvcaps.dwFormats;
-    lpDSCCaps->dwChannels = This->device->drvcaps.dwChannels;
-
-    TRACE("(flags=0x%08x,format=0x%08x,channels=%d)\n",lpDSCCaps->dwFlags,
-        lpDSCCaps->dwFormats, lpDSCCaps->dwChannels);
+    caps->dwFlags = 0;
+    /* Support all WAVE_FORMAT formats specified in mmsystem.h */
+    caps->dwFormats = 0x000fffff;
+    caps->dwChannels = 2;
 
     return DS_OK;
 }
 
-static HRESULT WINAPI IDirectSoundCaptureImpl_Initialize(
-    LPDIRECTSOUNDCAPTURE iface,
-    LPCGUID lpcGUID )
+static HRESULT WINAPI IDirectSoundCaptureImpl_Initialize(IDirectSoundCapture *iface, const GUID *devguid)
 {
-    IDirectSoundCaptureImpl *This = (IDirectSoundCaptureImpl *)iface;
-    TRACE("(%p,%s)\n", This, debugstr_guid(lpcGUID));
+    IDirectSoundCaptureImpl *This = impl_from_IDirectSoundCapture(iface);
+    HRESULT hr;
+    GUID guid;
+    BOOL voice = devguid && IsEqualIID(devguid, &DSDEVID_DefaultVoiceCapture);
+    IMMDevice *dev;
 
-    if (This->device != NULL) {
-	WARN("already initialized\n");
-	return DSERR_ALREADYINITIALIZED;
+    TRACE("(%p,%p)\n", This, devguid);
+
+    if (!IsEqualIID(&This->device, &GUID_NULL)) {
+        WARN("Already initialized\n");
+        return DSERR_ALREADYINITIALIZED;
     }
-    return DirectSoundCaptureDevice_Initialize(&This->device, lpcGUID);
+
+    if (!devguid)
+        devguid = &DSDEVID_DefaultCapture;
+    guid = *devguid;
+
+    EnterCriticalSection(&This->crst);
+    hr = DSOUND_obtain_immdevice(eCapture, &guid, voice ? eCommunications : eMultimedia, &dev);
+    if (FAILED(hr))
+    {
+        WARN("Failed to create device for %s: %08x\n", debugstr_guid(&guid), hr);
+        hr = DSERR_NODRIVER;
+        goto out;
+    }
+    IMMDevice_Release(dev);
+    This->device = guid;
+    This->voice = voice;
+    hr = S_OK;
+out:
+    LeaveCriticalSection(&This->crst);
+    return hr;
 }
 
 static const IDirectSoundCaptureVtbl dscvt =
 {
-    /* IUnknown methods */
     IDirectSoundCaptureImpl_QueryInterface,
     IDirectSoundCaptureImpl_AddRef,
     IDirectSoundCaptureImpl_Release,
-
-    /* IDirectSoundCapture methods */
     IDirectSoundCaptureImpl_CreateCaptureBuffer,
     IDirectSoundCaptureImpl_GetCaps,
     IDirectSoundCaptureImpl_Initialize
 };
 
-static HRESULT IDirectSoundCaptureImpl_Create(
-    LPDIRECTSOUNDCAPTURE8 * ppDSC)
+HRESULT DSOUND_CaptureCreate(REFIID riid, LPDIRECTSOUNDCAPTURE *ppDSC)
 {
-    IDirectSoundCaptureImpl *pDSC;
-    TRACE("(%p)\n", ppDSC);
-
-    /* Allocate memory */
-    pDSC = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(IDirectSoundCaptureImpl));
-    if (pDSC == NULL) {
-        WARN("out of memory\n");
-        *ppDSC = NULL;
-        return DSERR_OUTOFMEMORY;
-    }
-
-    pDSC->lpVtbl = &dscvt;
-    pDSC->ref    = 0;
-    pDSC->device = NULL;
-
-    *ppDSC = (LPDIRECTSOUNDCAPTURE8)pDSC;
-
-    return DS_OK;
-}
-
-HRESULT DSOUND_CaptureCreate(
-    REFIID riid,
-    LPDIRECTSOUNDCAPTURE *ppDSC)
-{
-    LPDIRECTSOUNDCAPTURE pDSC;
     HRESULT hr;
-    TRACE("(%s, %p)\n", debugstr_guid(riid), ppDSC);
-
-    if (!IsEqualIID(riid, &IID_IUnknown) &&
-        !IsEqualIID(riid, &IID_IDirectSoundCapture)) {
-        *ppDSC = 0;
-        return E_NOINTERFACE;
-    }
-
-    /* Get dsound configuration */
-    setup_dsound_options();
-
-    hr = IDirectSoundCaptureImpl_Create(&pDSC);
-    if (hr == DS_OK) {
-        IDirectSoundCapture_AddRef(pDSC);
-        *ppDSC = pDSC;
-    } else {
-        WARN("IDirectSoundCaptureImpl_Create failed\n");
-        *ppDSC = 0;
-    }
-
+    hr = DSOUND_CaptureCreate8(riid, ppDSC);
+    if (SUCCEEDED(hr))
+        impl_from_IDirectSoundCapture(*ppDSC)->is_8 = 0;
     return hr;
 }
 
-HRESULT DSOUND_CaptureCreate8(
-    REFIID riid,
-    LPDIRECTSOUNDCAPTURE8 *ppDSC8)
+HRESULT DSOUND_CaptureCreate8(REFIID riid, LPDIRECTSOUNDCAPTURE8 *cap)
 {
-    LPDIRECTSOUNDCAPTURE8 pDSC8;
-    HRESULT hr;
-    TRACE("(%s, %p)\n", debugstr_guid(riid), ppDSC8);
+    IDirectSoundCaptureImpl *This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*This));
+    *cap = NULL;
+    if (!This)
+        return DSERR_OUTOFMEMORY;
+    This->IDirectSoundCapture_iface.lpVtbl = &dscvt;
+    This->is_8 = 1;
 
-    if (!IsEqualIID(riid, &IID_IUnknown) &&
-        !IsEqualIID(riid, &IID_IDirectSoundCapture8)) {
-        *ppDSC8 = 0;
+    InitializeCriticalSection(&This->crst);
+    This->crst.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": DSCImpl.crst");
+    if (FAILED(IUnknown_QueryInterface((IUnknown*)This, riid, (void**)cap)))
+    {
+        IDirectSoundCaptureImpl_Destroy(This);
         return E_NOINTERFACE;
     }
+    return S_OK;
+}
 
-    /* Get dsound configuration */
-    setup_dsound_options();
-
-    hr = IDirectSoundCaptureImpl_Create(&pDSC8);
-    if (hr == DS_OK) {
-        IDirectSoundCapture_AddRef(pDSC8);
-        *ppDSC8 = pDSC8;
-    } else {
-        WARN("IDirectSoundCaptureImpl_Create failed\n");
-        *ppDSC8 = 0;
+static void IDirectSoundCaptureImpl_Destroy(IDirectSoundCaptureImpl *This)
+{
+    if (This->timer_id)
+    {
+        timeKillEvent(This->timer_id);
+        timeEndPeriod(This->timer_res);
     }
-
-    return hr;
+    EnterCriticalSection(&This->crst);
+    if (This->buf)
+        IDirectSoundCaptureBufferImpl_Destroy(This->buf);
+    LeaveCriticalSection(&This->crst);
+    This->crst.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection(&This->crst);
+    HeapFree(GetProcessHeap(), 0, This);
 }
 
 /***************************************************************************
@@ -1500,7 +981,7 @@ HRESULT WINAPI DirectSoundCaptureCreate8(
         return DSERR_NOAGGREGATION;
     }
 
-    hr = DSOUND_CaptureCreate8(&IID_IDirectSoundCapture8, &pDSC8);
+    hr = DSOUND_CaptureCreate8(&IID_IDirectSoundCapture, &pDSC8);
     if (hr == DS_OK) {
         hr = IDirectSoundCapture_Initialize(pDSC8, lpcGUID);
         if (hr != DS_OK) {
diff --git a/dlls/dsound/dsound.c b/dlls/dsound/dsound.c
index cc27699..6f5fdc6 100644
--- a/dlls/dsound/dsound.c
+++ b/dlls/dsound/dsound.c
@@ -20,13 +20,17 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+
 #include <stdarg.h>
 #include <stdio.h>
 
+#define COBJMACROS
 #define NONAMELESSSTRUCT
 #define NONAMELESSUNION
 #include "windef.h"
 #include "winbase.h"
+#include "winreg.h"
 #include "winuser.h"
 #include "mmsystem.h"
 #include "winternl.h"
@@ -42,980 +46,716 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(dsound);
 
-/*****************************************************************************
- * IDirectSound COM components
- */
-struct IDirectSound_IUnknown {
-    const IUnknownVtbl         *lpVtbl;
-    LONG                        ref;
-    LPDIRECTSOUND8              pds;
-};
-
-static HRESULT IDirectSound_IUnknown_Create(LPDIRECTSOUND8 pds, LPUNKNOWN * ppunk);
+#ifdef HAVE_OPENAL
 
-struct IDirectSound_IDirectSound {
-    const IDirectSoundVtbl     *lpVtbl;
-    LONG                        ref;
-    LPDIRECTSOUND8              pds;
-};
+static DS8Impl **devicelist;
+static UINT devicelistsize;
 
-static HRESULT IDirectSound_IDirectSound_Create(LPDIRECTSOUND8 pds, LPDIRECTSOUND * ppds);
+static const IDirectSound8Vtbl DS8_Vtbl;
 
-/*****************************************************************************
- * IDirectSound8 COM components
- */
-struct IDirectSound8_IUnknown {
-    const IUnknownVtbl         *lpVtbl;
-    LONG                        ref;
-    LPDIRECTSOUND8              pds;
-};
+static inline DS8Impl *impl_from_IDirectSound8(IDirectSound8 *iface)
+{
+    return CONTAINING_RECORD(iface, DS8Impl, IDirectSound8_iface);
+}
 
-static HRESULT IDirectSound8_IUnknown_Create(LPDIRECTSOUND8 pds, LPUNKNOWN * ppunk);
-static ULONG WINAPI IDirectSound8_IUnknown_AddRef(LPUNKNOWN iface);
+HRESULT DSOUND_Create(REFIID riid, IDirectSound **ds)
+{
+    HRESULT hr;
 
-struct IDirectSound8_IDirectSound {
-    const IDirectSoundVtbl     *lpVtbl;
-    LONG                        ref;
-    LPDIRECTSOUND8              pds;
-};
+    if(IsEqualIID(riid, &IID_IDirectSound8))
+        return E_NOINTERFACE;
+    hr = DSOUND_Create8(riid, (IDirectSound8**)ds);
+    if(hr == S_OK)
+        impl_from_IDirectSound8((IDirectSound8*)*ds)->is_8 = FALSE;
+    return hr;
+}
 
-static HRESULT IDirectSound8_IDirectSound_Create(LPDIRECTSOUND8 pds, LPDIRECTSOUND * ppds);
-static ULONG WINAPI IDirectSound8_IDirectSound_AddRef(LPDIRECTSOUND iface);
+static void DS8Impl_Destroy(DS8Impl *This);
 
-struct IDirectSound8_IDirectSound8 {
-    const IDirectSound8Vtbl    *lpVtbl;
-    LONG                        ref;
-    LPDIRECTSOUND8              pds;
+static const WCHAR speakerconfigkey[] = {
+    'S','Y','S','T','E','M','\\',
+    'C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t','\\',
+    'C','o','n','t','r','o','l','\\',
+    'M','e','d','i','a','R','e','s','o','u','r','c','e','s','\\',
+    'D','i','r','e','c','t','S','o','u','n','d','\\',
+    'S','p','e','a','k','e','r',' ','C','o','n','f','i','g','u','r','a','t','i','o','n',0
 };
 
-static HRESULT IDirectSound8_IDirectSound8_Create(LPDIRECTSOUND8 pds, LPDIRECTSOUND8 * ppds);
-static ULONG WINAPI IDirectSound8_IDirectSound8_AddRef(LPDIRECTSOUND8 iface);
-
-/*****************************************************************************
- * IDirectSound implementation structure
- */
-struct IDirectSoundImpl
-{
-    LONG                        ref;
-
-    DirectSoundDevice          *device;
-    LPUNKNOWN                   pUnknown;
-    LPDIRECTSOUND               pDS;
-    LPDIRECTSOUND8              pDS8;
+static const WCHAR speakerconfig[] = {
+    'S','p','e','a','k','e','r',' ','C','o','n','f','i','g','u','r','a','t','i','o','n',0
 };
 
-static HRESULT IDirectSoundImpl_Create(LPDIRECTSOUND8 * ppds);
-
-static ULONG WINAPI IDirectSound_IUnknown_AddRef(LPUNKNOWN iface);
-static ULONG WINAPI IDirectSound_IDirectSound_AddRef(LPDIRECTSOUND iface);
-
-const char * dumpCooperativeLevel(DWORD level)
+HRESULT DSOUND_Create8(REFIID riid, IDirectSound8 **ds)
 {
-#define LE(x) case x: return #x
-    switch (level) {
-        LE(DSSCL_NORMAL);
-        LE(DSSCL_PRIORITY);
-        LE(DSSCL_EXCLUSIVE);
-        LE(DSSCL_WRITEPRIMARY);
-    }
-#undef LE
-    return wine_dbg_sprintf("Unknown(%08x)", level);
-}
+    DS8Impl *This;
+    HRESULT hr;
 
-static void _dump_DSCAPS(DWORD xmask) {
-    struct {
-        DWORD   mask;
-        const char    *name;
-    } flags[] = {
-#define FE(x) { x, #x },
-        FE(DSCAPS_PRIMARYMONO)
-        FE(DSCAPS_PRIMARYSTEREO)
-        FE(DSCAPS_PRIMARY8BIT)
-        FE(DSCAPS_PRIMARY16BIT)
-        FE(DSCAPS_CONTINUOUSRATE)
-        FE(DSCAPS_EMULDRIVER)
-        FE(DSCAPS_CERTIFIED)
-        FE(DSCAPS_SECONDARYMONO)
-        FE(DSCAPS_SECONDARYSTEREO)
-        FE(DSCAPS_SECONDARY8BIT)
-        FE(DSCAPS_SECONDARY16BIT)
-#undef FE
-    };
-    unsigned int     i;
-
-    for (i=0;i<sizeof(flags)/sizeof(flags[0]);i++)
-        if ((flags[i].mask & xmask) == flags[i].mask)
-            TRACE("%s ",flags[i].name);
-}
+    *ds = NULL;
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*This));
+    if(!This)
+        return E_OUTOFMEMORY;
+    This->is_8 = TRUE;
+    This->IDirectSound8_iface.lpVtbl = &DS8_Vtbl;
+    This->speaker_config = DSSPEAKER_COMBINED(DSSPEAKER_5POINT1, DSSPEAKER_GEOMETRY_WIDE);
+    RegGetValueW(HKEY_LOCAL_MACHINE, speakerconfigkey, speakerconfig, RRF_RT_REG_DWORD, NULL, &This->speaker_config, NULL);
+
+    hr = IUnknown_QueryInterface(&This->IDirectSound8_iface, riid, (void**)ds);
+    if(FAILED(hr))
+        DS8Impl_Destroy(This);
+    else
+    {
+        void *temp;
 
-static void _dump_DSBCAPS(DWORD xmask) {
-    struct {
-        DWORD   mask;
-        const char    *name;
-    } flags[] = {
-#define FE(x) { x, #x },
-        FE(DSBCAPS_PRIMARYBUFFER)
-        FE(DSBCAPS_STATIC)
-        FE(DSBCAPS_LOCHARDWARE)
-        FE(DSBCAPS_LOCSOFTWARE)
-        FE(DSBCAPS_CTRL3D)
-        FE(DSBCAPS_CTRLFREQUENCY)
-        FE(DSBCAPS_CTRLPAN)
-        FE(DSBCAPS_CTRLVOLUME)
-        FE(DSBCAPS_CTRLPOSITIONNOTIFY)
-        FE(DSBCAPS_STICKYFOCUS)
-        FE(DSBCAPS_GLOBALFOCUS)
-        FE(DSBCAPS_GETCURRENTPOSITION2)
-        FE(DSBCAPS_MUTE3DATMAXDISTANCE)
-#undef FE
-    };
-    unsigned int     i;
-
-    for (i=0;i<sizeof(flags)/sizeof(flags[0]);i++)
-        if ((flags[i].mask & xmask) == flags[i].mask)
-            TRACE("%s ",flags[i].name);
+        EnterCriticalSection(&openal_crst);
+        if(devicelist)
+            temp = HeapReAlloc(GetProcessHeap(), 0, devicelist, sizeof(*devicelist)*(devicelistsize+1));
+        else
+            temp = HeapAlloc(GetProcessHeap(), 0, sizeof(*devicelist)*(devicelistsize+1));
+        if(temp)
+        {
+            devicelist = temp;
+            devicelist[devicelistsize++] = This;
+        }
+        LeaveCriticalSection(&openal_crst);
+    }
+    return hr;
 }
 
-/*******************************************************************************
- *		IDirectSoundImpl_DirectSound
- */
-static HRESULT DSOUND_QueryInterface(
-    LPDIRECTSOUND8 iface,
-    REFIID riid,
-    LPVOID * ppobj)
+static void DS8Impl_Destroy(DS8Impl *This)
 {
-    IDirectSoundImpl *This = (IDirectSoundImpl *)iface;
-    TRACE("(%p,%s,%p)\n",This,debugstr_guid(riid),ppobj);
+    UINT i;
 
-    if (ppobj == NULL) {
-        WARN("invalid parameter\n");
-        return E_INVALIDARG;
+    EnterCriticalSection(&openal_crst);
+    for(i = 0;i < devicelistsize;i++)
+    {
+        if(devicelist[i] == This)
+        {
+            devicelist[i] = devicelist[--devicelistsize];
+            break;
+        }
     }
 
-    if (IsEqualIID(riid, &IID_IUnknown)) {
-        if (!This->pUnknown) {
-            IDirectSound_IUnknown_Create(iface, &This->pUnknown);
-            if (!This->pUnknown) {
-                WARN("IDirectSound_IUnknown_Create() failed\n");
-                *ppobj = NULL;
-                return E_NOINTERFACE;
-            }
-        }
-        IDirectSound_IUnknown_AddRef(This->pUnknown);
-        *ppobj = This->pUnknown;
-        return S_OK;
-    } else if (IsEqualIID(riid, &IID_IDirectSound)) {
-        if (!This->pDS) {
-            IDirectSound_IDirectSound_Create(iface, &This->pDS);
-            if (!This->pDS) {
-                WARN("IDirectSound_IDirectSound_Create() failed\n");
-                *ppobj = NULL;
-                return E_NOINTERFACE;
+    if(This->deviceref && InterlockedDecrement(This->deviceref) == 0)
+    {
+        if(This->primary)
+            DS8Primary_Destroy(This->primary);
+        if(This->device)
+            palcCloseDevice(This->device);
+
+        HeapFree(GetProcessHeap(), 0, This->deviceref);
+    }
+    else if(This->deviceref && This->primary->parent == This)
+    {
+        /* If the primary is referencing this as its parent, update it to
+         * reference another handle for the device */
+        for(i = 0;i < devicelistsize;i++)
+        {
+            if(devicelist[i]->primary == This->primary)
+            {
+                This->primary->parent = devicelist[i];
+                break;
             }
         }
-        IDirectSound_IDirectSound_AddRef(This->pDS);
-        *ppobj = This->pDS;
-        return S_OK;
     }
+    LeaveCriticalSection(&openal_crst);
 
-    *ppobj = NULL;
-    WARN("Unknown IID %s\n",debugstr_guid(riid));
-    return E_NOINTERFACE;
+    HeapFree(GetProcessHeap(), 0, This);
 }
 
-static HRESULT DSOUND_QueryInterface8(
-    LPDIRECTSOUND8 iface,
-    REFIID riid,
-    LPVOID * ppobj)
+static HRESULT WINAPI DS8_QueryInterface(IDirectSound8 *iface, REFIID riid, LPVOID *ppv)
 {
-    IDirectSoundImpl *This = (IDirectSoundImpl *)iface;
-    TRACE("(%p,%s,%p)\n",This,debugstr_guid(riid),ppobj);
+    DS8Impl *This = impl_from_IDirectSound8(iface);
+
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
 
-    if (ppobj == NULL) {
-        WARN("invalid parameter\n");
-        return E_INVALIDARG;
+    *ppv = NULL;
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+       IsEqualIID(riid, &IID_IDirectSound))
+        *ppv = &This->IDirectSound8_iface;
+    else if((IsEqualIID(riid, &IID_IDirectSound8)))
+    {
+        if(This->is_8)
+            *ppv = &This->IDirectSound8_iface;
     }
+    else
+        FIXME("Unhandled GUID: %s\n", debugstr_guid(riid));
 
-    if (IsEqualIID(riid, &IID_IUnknown)) {
-        if (!This->pUnknown) {
-            IDirectSound8_IUnknown_Create(iface, &This->pUnknown);
-            if (!This->pUnknown) {
-                WARN("IDirectSound8_IUnknown_Create() failed\n");
-                *ppobj = NULL;
-                return E_NOINTERFACE;
-            }
-        }
-        IDirectSound8_IUnknown_AddRef(This->pUnknown);
-        *ppobj = This->pUnknown;
-        return S_OK;
-    } else if (IsEqualIID(riid, &IID_IDirectSound)) {
-        if (!This->pDS) {
-            IDirectSound8_IDirectSound_Create(iface, &This->pDS);
-            if (!This->pDS) {
-                WARN("IDirectSound8_IDirectSound_Create() failed\n");
-                *ppobj = NULL;
-                return E_NOINTERFACE;
-            }
-        }
-        IDirectSound8_IDirectSound_AddRef(This->pDS);
-        *ppobj = This->pDS;
-        return S_OK;
-    } else if (IsEqualIID(riid, &IID_IDirectSound8)) {
-        if (!This->pDS8) {
-            IDirectSound8_IDirectSound8_Create(iface, &This->pDS8);
-            if (!This->pDS8) {
-                WARN("IDirectSound8_IDirectSound8_Create() failed\n");
-                *ppobj = NULL;
-                return E_NOINTERFACE;
-            }
-        }
-        IDirectSound8_IDirectSound8_AddRef(This->pDS8);
-        *ppobj = This->pDS8;
+    if(*ppv)
+    {
+        IUnknown_AddRef((IUnknown*)*ppv);
         return S_OK;
     }
 
-    *ppobj = NULL;
-    WARN("Unknown IID %s\n",debugstr_guid(riid));
     return E_NOINTERFACE;
 }
 
-static ULONG IDirectSoundImpl_AddRef(
-    LPDIRECTSOUND8 iface)
-{
-    IDirectSoundImpl *This = (IDirectSoundImpl *)iface;
-    ULONG ref = InterlockedIncrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref - 1);
-    return ref;
-}
-
-static ULONG IDirectSoundImpl_Release(
-    LPDIRECTSOUND8 iface)
-{
-    IDirectSoundImpl *This = (IDirectSoundImpl *)iface;
-    ULONG ref = InterlockedDecrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref + 1);
-
-    if (!ref) {
-        if (This->device)
-            DirectSoundDevice_Release(This->device);
-        HeapFree(GetProcessHeap(),0,This);
-        TRACE("(%p) released\n", This);
-    }
-    return ref;
-}
-
-static HRESULT IDirectSoundImpl_Create(
-    LPDIRECTSOUND8 * ppDS)
+static ULONG WINAPI DS8_AddRef(IDirectSound8 *iface)
 {
-    IDirectSoundImpl* pDS;
-    TRACE("(%p)\n",ppDS);
-
-    /* Allocate memory */
-    pDS = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(IDirectSoundImpl));
-    if (pDS == NULL) {
-        WARN("out of memory\n");
-        *ppDS = NULL;
-        return DSERR_OUTOFMEMORY;
-    }
-
-    pDS->ref    = 0;
-    pDS->device = NULL;
+    DS8Impl *This = impl_from_IDirectSound8(iface);
+    LONG ref;
 
-    *ppDS = (LPDIRECTSOUND8)pDS;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("Reference count incremented to %d\n", ref);
 
-    return DS_OK;
+    return ref;
 }
 
-/*******************************************************************************
- *		IDirectSound_IUnknown
- */
-static HRESULT WINAPI IDirectSound_IUnknown_QueryInterface(
-    LPUNKNOWN iface,
-    REFIID riid,
-    LPVOID * ppobj)
+static ULONG WINAPI DS8_Release(IDirectSound8 *iface)
 {
-    IDirectSound_IUnknown *This = (IDirectSound_IUnknown *)iface;
-    TRACE("(%p,%s,%p)\n",This,debugstr_guid(riid),ppobj);
-    return DSOUND_QueryInterface(This->pds, riid, ppobj);
-}
+    DS8Impl *This = impl_from_IDirectSound8(iface);
+    LONG ref;
 
-static ULONG WINAPI IDirectSound_IUnknown_AddRef(
-    LPUNKNOWN iface)
-{
-    IDirectSound_IUnknown *This = (IDirectSound_IUnknown *)iface;
-    ULONG ref = InterlockedIncrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref - 1);
-    return ref;
-}
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("Reference count decremented to %d\n", ref);
+    if(!ref)
+        DS8Impl_Destroy(This);
 
-static ULONG WINAPI IDirectSound_IUnknown_Release(
-    LPUNKNOWN iface)
-{
-    IDirectSound_IUnknown *This = (IDirectSound_IUnknown *)iface;
-    ULONG ref = InterlockedDecrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref + 1);
-    if (!ref) {
-        ((IDirectSoundImpl*)This->pds)->pUnknown = NULL;
-        IDirectSoundImpl_Release(This->pds);
-        HeapFree(GetProcessHeap(), 0, This);
-        TRACE("(%p) released\n", This);
-    }
     return ref;
 }
 
-static const IUnknownVtbl DirectSound_Unknown_Vtbl =
+static HRESULT WINAPI DS8_CreateSoundBuffer(IDirectSound8 *iface, LPCDSBUFFERDESC desc, LPLPDIRECTSOUNDBUFFER buf, IUnknown *pUnkOuter)
 {
-    IDirectSound_IUnknown_QueryInterface,
-    IDirectSound_IUnknown_AddRef,
-    IDirectSound_IUnknown_Release
-};
+    DS8Impl *This = impl_from_IDirectSound8(iface);
+    HRESULT hr;
 
-static HRESULT IDirectSound_IUnknown_Create(
-    LPDIRECTSOUND8 pds,
-    LPUNKNOWN * ppunk)
-{
-    IDirectSound_IUnknown * pdsunk;
-    TRACE("(%p,%p)\n",pds,ppunk);
+    TRACE("(%p)->(%p, %p, %p)\n", iface, desc, buf, pUnkOuter);
 
-    if (ppunk == NULL) {
-        ERR("invalid parameter: ppunk == NULL\n");
+    if(!buf)
+    {
+        WARN("buf is null\n");
         return DSERR_INVALIDPARAM;
     }
+    *buf = NULL;
 
-    if (pds == NULL) {
-        ERR("invalid parameter: pds == NULL\n");
-        *ppunk = NULL;
+    if(pUnkOuter)
+    {
+        WARN("Aggregation isn't supported\n");
+        return DSERR_NOAGGREGATION;
+    }
+    if(!desc || desc->dwSize < sizeof(DSBUFFERDESC1))
+    {
+        WARN("Invalid buffer %p/%u\n", desc, desc?desc->dwSize:0);
         return DSERR_INVALIDPARAM;
     }
+    if(desc->dwSize >= sizeof(DSBUFFERDESC))
+    {
+        if(!(desc->dwFlags&DSBCAPS_CTRL3D))
+        {
+            if(!IsEqualGUID(&desc->guid3DAlgorithm, &GUID_NULL))
+            {
+                WARN("Invalid 3D algorithm GUID specified for non-3D buffer: %s\n", debugstr_guid(&desc->guid3DAlgorithm));
+                return DSERR_INVALIDPARAM;
+            }
+        }
+        else
+            TRACE("Requested 3D algorithm GUID: %s\n", debugstr_guid(&desc->guid3DAlgorithm));
+    }
 
-    pdsunk = HeapAlloc(GetProcessHeap(),0,sizeof(*pdsunk));
-    if (pdsunk == NULL) {
-        WARN("out of memory\n");
-        *ppunk = NULL;
-        return DSERR_OUTOFMEMORY;
+    /* OpenAL doesn't support playing with 3d and panning at same time.. */
+    if((desc->dwFlags&(DSBCAPS_CTRL3D|DSBCAPS_CTRLPAN)) == (DSBCAPS_CTRL3D|DSBCAPS_CTRLPAN))
+    {
+        if(!This->is_8)
+            ERR("Cannot create buffers with 3D and panning control\n");
+        else
+            WARN("Cannot create buffers with 3D and panning control\n");
+        return DSERR_INVALIDPARAM;
     }
 
-    pdsunk->lpVtbl = &DirectSound_Unknown_Vtbl;
-    pdsunk->ref = 0;
-    pdsunk->pds = pds;
+    EnterCriticalSection(&openal_crst);
+    if(!This->device)
+        hr = DSERR_UNINITIALIZED;
+    else if((desc->dwFlags&DSBCAPS_PRIMARYBUFFER))
+    {
+        IDirectSoundBuffer *prim = &This->primary->IDirectSoundBuffer_iface;
 
-    IDirectSoundImpl_AddRef(pds);
-    *ppunk = (LPUNKNOWN)pdsunk;
+        hr = S_OK;
+        if(IDirectSoundBuffer_AddRef(prim) == 1)
+        {
+            hr = IDirectSoundBuffer_Initialize(prim, (IDirectSound*)&This->IDirectSound8_iface, desc);
+            if(FAILED(hr))
+            {
+                IDirectSoundBuffer_Release(prim);
+                prim = NULL;
+            }
+        }
+        *buf = prim;
+    }
+    else
+    {
+        DS8Buffer *dsb;
 
-    return DS_OK;
-}
+        hr = DS8Buffer_Create(&dsb, This->primary, NULL);
+        if(SUCCEEDED(hr))
+        {
+            hr = IDirectSoundBuffer8_Initialize(&dsb->IDirectSoundBuffer8_iface, (IDirectSound*)&This->IDirectSound8_iface, desc);
+            if(FAILED(hr))
+                IDirectSoundBuffer8_Release(&dsb->IDirectSoundBuffer8_iface);
+            else
+            {
+                dsb->bufferlost = (This->prio_level == DSSCL_WRITEPRIMARY);
+                *buf = (IDirectSoundBuffer*)&dsb->IDirectSoundBuffer8_iface;
+            }
+        }
+    }
+    LeaveCriticalSection(&openal_crst);
 
-/*******************************************************************************
- *		IDirectSound_IDirectSound
- */
-static HRESULT WINAPI IDirectSound_IDirectSound_QueryInterface(
-    LPDIRECTSOUND iface,
-    REFIID riid,
-    LPVOID * ppobj)
-{
-    IDirectSound_IDirectSound *This = (IDirectSound_IDirectSound *)iface;
-    TRACE("(%p,%s,%p)\n",This,debugstr_guid(riid),ppobj);
-    return DSOUND_QueryInterface(This->pds, riid, ppobj);
+    TRACE("%08x\n", hr);
+    return hr;
 }
 
-static ULONG WINAPI IDirectSound_IDirectSound_AddRef(
-    LPDIRECTSOUND iface)
+static HRESULT WINAPI DS8_GetCaps(IDirectSound8 *iface, LPDSCAPS caps)
 {
-    IDirectSound_IDirectSound *This = (IDirectSound_IDirectSound *)iface;
-    ULONG ref = InterlockedIncrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref - 1);
-    return ref;
-}
+    DS8Impl *This = impl_from_IDirectSound8(iface);
+    HRESULT hr = S_OK;
+    TRACE("\n");
 
-static ULONG WINAPI IDirectSound_IDirectSound_Release(
-    LPDIRECTSOUND iface)
-{
-    IDirectSound_IDirectSound *This = (IDirectSound_IDirectSound *)iface;
-    ULONG ref = InterlockedDecrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref + 1);
-    if (!ref) {
-        ((IDirectSoundImpl*)This->pds)->pDS = NULL;
-        IDirectSoundImpl_Release(This->pds);
-        HeapFree(GetProcessHeap(), 0, This);
-        TRACE("(%p) released\n", This);
+    EnterCriticalSection(&openal_crst);
+    if(!This->device)
+        hr = DSERR_UNINITIALIZED;
+    else if(!caps || caps->dwSize < sizeof(*caps))
+        hr = DSERR_INVALIDPARAM;
+    else
+    {
+        LONG count = This->primary->max_sources;
+
+        setALContext(This->primary->ctx);
+        caps->dwFlags = DSCAPS_CONTINUOUSRATE |
+                        DSCAPS_PRIMARY16BIT | DSCAPS_PRIMARYSTEREO |
+                        DSCAPS_PRIMARY8BIT | DSCAPS_PRIMARYMONO |
+                        DSCAPS_SECONDARY16BIT | DSCAPS_SECONDARY8BIT |
+                        DSCAPS_SECONDARYMONO | DSCAPS_SECONDARYSTEREO;
+        caps->dwPrimaryBuffers = 1;
+        caps->dwMinSecondarySampleRate = DSBFREQUENCY_MIN;
+        caps->dwMaxSecondarySampleRate = DSBFREQUENCY_MAX;
+        caps->dwMaxHwMixingAllBuffers =
+            caps->dwMaxHwMixingStaticBuffers =
+            caps->dwMaxHwMixingStreamingBuffers =
+            caps->dwMaxHw3DAllBuffers =
+            caps->dwMaxHw3DStaticBuffers =
+            caps->dwMaxHw3DStreamingBuffers = count;
+        count -= This->primary->nbuffers;
+        if(count < 0)
+        {
+            ERR("How did the count drop below 0?\n");
+            count = 0;
+        }
+        caps->dwFreeHwMixingAllBuffers =
+            caps->dwFreeHwMixingStaticBuffers =
+            caps->dwFreeHwMixingStreamingBuffers =
+            caps->dwFreeHw3DAllBuffers =
+            caps->dwFreeHw3DStaticBuffers =
+            caps->dwFreeHw3DStreamingBuffers = count;
+        if(palIsExtensionPresent("EAX-RAM"))
+        {
+            caps->dwTotalHwMemBytes = palGetInteger(palGetEnumValue("AL_EAX_RAM_SIZE"));
+            caps->dwFreeHwMemBytes = palGetInteger(palGetEnumValue("AL_EAX_RAM_FREE"));
+        }
+        else
+        {
+            caps->dwTotalHwMemBytes =
+                caps->dwFreeHwMemBytes = 64 * 1024 * 1024;
+        }
+        caps->dwMaxContigFreeHwMemBytes = caps->dwFreeHwMemBytes;
+        caps->dwUnlockTransferRateHwBuffers = 4096;
+        caps->dwPlayCpuOverheadSwBuffers = 0;
+        popALContext();
     }
-    return ref;
-}
+    LeaveCriticalSection(&openal_crst);
 
-static HRESULT WINAPI IDirectSound_IDirectSound_CreateSoundBuffer(
-    LPDIRECTSOUND iface,
-    LPCDSBUFFERDESC dsbd,
-    LPLPDIRECTSOUNDBUFFER ppdsb,
-    LPUNKNOWN lpunk)
-{
-    IDirectSound_IDirectSound *This = (IDirectSound_IDirectSound *)iface;
-    TRACE("(%p,%p,%p,%p)\n",This,dsbd,ppdsb,lpunk);
-    return DirectSoundDevice_CreateSoundBuffer(((IDirectSoundImpl *)This->pds)->device,dsbd,ppdsb,lpunk,FALSE);
+    return hr;
 }
-
-static HRESULT WINAPI IDirectSound_IDirectSound_GetCaps(
-    LPDIRECTSOUND iface,
-    LPDSCAPS lpDSCaps)
+static HRESULT WINAPI DS8_DuplicateSoundBuffer(IDirectSound8 *iface, IDirectSoundBuffer *in, IDirectSoundBuffer **out)
 {
-    IDirectSound_IDirectSound *This = (IDirectSound_IDirectSound *)iface;
-    TRACE("(%p,%p)\n",This,lpDSCaps);
-    return DirectSoundDevice_GetCaps(((IDirectSoundImpl *)This->pds)->device, lpDSCaps);
-}
+    DS8Impl *This = impl_from_IDirectSound8(iface);
+    HRESULT hr = S_OK;
 
-static HRESULT WINAPI IDirectSound_IDirectSound_DuplicateSoundBuffer(
-    LPDIRECTSOUND iface,
-    LPDIRECTSOUNDBUFFER psb,
-    LPLPDIRECTSOUNDBUFFER ppdsb)
-{
-    IDirectSound_IDirectSound *This = (IDirectSound_IDirectSound *)iface;
-    TRACE("(%p,%p,%p)\n",This,psb,ppdsb);
-    return DirectSoundDevice_DuplicateSoundBuffer(((IDirectSoundImpl *)This->pds)->device,psb,ppdsb);
-}
+    TRACE("(%p)->(%p, %p)\n", iface, in, out);
 
-static HRESULT WINAPI IDirectSound_IDirectSound_SetCooperativeLevel(
-    LPDIRECTSOUND iface,
-    HWND hwnd,
-    DWORD level)
-{
-    IDirectSound_IDirectSound *This = (IDirectSound_IDirectSound *)iface;
-    TRACE("(%p,%p,%s)\n",This,hwnd,dumpCooperativeLevel(level));
-    return DirectSoundDevice_SetCooperativeLevel(((IDirectSoundImpl *)This->pds)->device, hwnd, level);
-}
+    EnterCriticalSection(&openal_crst);
+    if(!This->device)
+        hr = DSERR_UNINITIALIZED;
+    else if(!in || !out)
+        hr = DSERR_INVALIDPARAM;
+    else
+    {
+        DWORD i;
+        DSBCAPS caps;
+        DS8Buffer *buf;
 
-static HRESULT WINAPI IDirectSound_IDirectSound_Compact(
-    LPDIRECTSOUND iface)
-{
-    IDirectSound_IDirectSound *This = (IDirectSound_IDirectSound *)iface;
-    TRACE("(%p)\n", This);
-    return DirectSoundDevice_Compact(((IDirectSoundImpl *)This->pds)->device);
-}
+        *out = NULL;
 
-static HRESULT WINAPI IDirectSound_IDirectSound_GetSpeakerConfig(
-    LPDIRECTSOUND iface,
-    LPDWORD lpdwSpeakerConfig)
-{
-    IDirectSound_IDirectSound *This = (IDirectSound_IDirectSound *)iface;
-    TRACE("(%p, %p)\n", This, lpdwSpeakerConfig);
-    return DirectSoundDevice_GetSpeakerConfig(((IDirectSoundImpl *)This->pds)->device,lpdwSpeakerConfig);
-}
+        for(i = 0; i < This->primary->nbuffers; ++i)
+        {
+            if(This->primary->buffers[i] == (DS8Buffer*)in)
+                break;
+        }
+        if(i == This->primary->nbuffers)
+        {
+            hr = DSERR_INVALIDPARAM;
+            WARN("Buffer %p not found\n", in);
+            goto out;
+        }
 
-static HRESULT WINAPI IDirectSound_IDirectSound_SetSpeakerConfig(
-    LPDIRECTSOUND iface,
-    DWORD config)
-{
-    IDirectSound_IDirectSound *This = (IDirectSound_IDirectSound *)iface;
-    TRACE("(%p,0x%08x)\n",This,config);
-    return DirectSoundDevice_SetSpeakerConfig(((IDirectSoundImpl *)This->pds)->device,config);
+        caps.dwSize = sizeof(caps);
+        hr = IDirectSoundBuffer_GetCaps(in, &caps);
+        if(SUCCEEDED(hr) && (caps.dwFlags&DSBCAPS_CTRLFX))
+        {
+            WARN("Cannot duplicate buffer %p, which has DSBCAPS_CTRLFX\n", in);
+            hr = DSERR_INVALIDPARAM;
+        }
+        if(SUCCEEDED(hr))
+            hr = DS8Buffer_Create(&buf, This->primary, (DS8Buffer*)in);
+        if(SUCCEEDED(hr))
+        {
+            *out = (IDirectSoundBuffer*)&buf->IDirectSoundBuffer8_iface;
+            hr = IDirectSoundBuffer_Initialize(*out, NULL, NULL);
+        }
+        if(SUCCEEDED(hr))
+        {
+            DWORD savelost = ((DS8Buffer*)in)->bufferlost;
+            ((DS8Buffer*)in)->bufferlost = 0;
+            /* According to MSDN volume isn't copied
+             */
+            if((caps.dwFlags&DSBCAPS_CTRLPAN))
+            {
+                LONG pan;
+                if(SUCCEEDED(IDirectSoundBuffer_GetPan(in, &pan)))
+                    IDirectSoundBuffer_SetPan(*out, pan);
+            }
+            if((caps.dwFlags&DSBCAPS_CTRLFREQUENCY))
+            {
+                DWORD freq;
+                if(SUCCEEDED(IDirectSoundBuffer_GetFrequency(in, &freq)))
+                    IDirectSoundBuffer_SetFrequency(*out, freq);
+            }
+            if((caps.dwFlags&DSBCAPS_CTRL3D))
+            {
+                DS3DBUFFER DS3DBuffer;
+                IDirectSound3DBuffer *buf3d;
+                HRESULT subhr;
+
+                subhr = IDirectSound_QueryInterface(in, &IID_IDirectSound3DBuffer, (void**)&buf3d);
+                if(SUCCEEDED(subhr))
+                {
+                    DS3DBuffer.dwSize = sizeof(DS3DBuffer);
+                    subhr = IDirectSound3DBuffer_GetAllParameters(buf3d, &DS3DBuffer);
+                    IDirectSound3DBuffer_Release(buf3d);
+                }
+                if(SUCCEEDED(subhr))
+                    subhr = IUnknown_QueryInterface(*out, &IID_IDirectSound3DBuffer, (void**)&buf3d);
+                if(SUCCEEDED(subhr))
+                {
+                    subhr = IDirectSound3DBuffer_SetAllParameters(buf3d, &DS3DBuffer, DS3D_IMMEDIATE);
+                    IDirectSound3DBuffer_Release(buf3d);
+                }
+            }
+            ((DS8Buffer*)in)->bufferlost = buf->bufferlost = savelost;
+        }
+        if(FAILED(hr))
+        {
+            if(*out)
+                IDirectSoundBuffer_Release(*out);
+            *out = NULL;
+            goto out;
+        }
+    }
+out:
+    LeaveCriticalSection(&openal_crst);
+    return hr;
 }
 
-static HRESULT WINAPI IDirectSound_IDirectSound_Initialize(
-    LPDIRECTSOUND iface,
-    LPCGUID lpcGuid)
+static HRESULT WINAPI DS8_SetCooperativeLevel(IDirectSound8 *iface, HWND hwnd, DWORD level)
 {
-    IDirectSound_IDirectSound *This = (IDirectSound_IDirectSound *)iface;
-    TRACE("(%p, %s)\n", This, debugstr_guid(lpcGuid));
-    return DirectSoundDevice_Initialize(&((IDirectSoundImpl *)This->pds)->device,lpcGuid);
-}
+    DS8Impl *This = impl_from_IDirectSound8(iface);
+    HRESULT hr = S_OK;
 
-static const IDirectSoundVtbl DirectSound_DirectSound_Vtbl =
-{
-    IDirectSound_IDirectSound_QueryInterface,
-    IDirectSound_IDirectSound_AddRef,
-    IDirectSound_IDirectSound_Release,
-    IDirectSound_IDirectSound_CreateSoundBuffer,
-    IDirectSound_IDirectSound_GetCaps,
-    IDirectSound_IDirectSound_DuplicateSoundBuffer,
-    IDirectSound_IDirectSound_SetCooperativeLevel,
-    IDirectSound_IDirectSound_Compact,
-    IDirectSound_IDirectSound_GetSpeakerConfig,
-    IDirectSound_IDirectSound_SetSpeakerConfig,
-    IDirectSound_IDirectSound_Initialize
-};
+    TRACE("(%p)->(%p, %u)\n", iface, hwnd, level);
 
-static HRESULT IDirectSound_IDirectSound_Create(
-    LPDIRECTSOUND8  pds,
-    LPDIRECTSOUND * ppds)
-{
-    IDirectSound_IDirectSound * pdsds;
-    TRACE("(%p,%p)\n",pds,ppds);
+    EnterCriticalSection(&openal_crst);
+    if(!This->device)
+        hr = DSERR_UNINITIALIZED;
+    else if(level > DSSCL_WRITEPRIMARY || level < DSSCL_NORMAL)
+        hr = E_INVALIDARG;
+    else if(level == DSSCL_WRITEPRIMARY && (This->prio_level != DSSCL_WRITEPRIMARY))
+    {
+        DWORD i, state;
 
-    if (ppds == NULL) {
-        ERR("invalid parameter: ppds == NULL\n");
-        return DSERR_INVALIDPARAM;
+        for(i = 0; i < This->primary->nbuffers; ++i)
+        {
+            DS8Buffer *buf = This->primary->buffers[i];
+            if(FAILED(IDirectSoundBuffer_GetStatus(&buf->IDirectSoundBuffer8_iface, &state)) ||
+               (state&DSBSTATUS_PLAYING))
+            {
+                WARN("DSSCL_WRITEPRIMARY set with playing buffers!\n");
+                hr = DSERR_INVALIDCALL;
+                goto out;
+            }
+            /* Mark buffer as lost */
+            buf->bufferlost = 1;
+        }
+        if(This->primary->write_emu)
+        {
+            ERR("Why was there a write_emu?\n");
+            /* Delete it */
+            IDirectSoundBuffer8_Release(This->primary->write_emu);
+            This->primary->write_emu = NULL;
+        }
+        if(This->primary->flags)
+        {
+            /* Primary has open references.. create write_emu */
+            DSBUFFERDESC desc;
+            DS8Buffer *emu;
+
+            memset(&desc, 0, sizeof(desc));
+            desc.dwSize = sizeof(desc);
+            desc.dwFlags = DSBCAPS_LOCHARDWARE | (This->primary->flags&DSBCAPS_CTRLPAN);
+            desc.dwBufferBytes = This->primary->buf_size;
+            desc.lpwfxFormat = This->primary->format;
+
+            hr = DS8Buffer_Create(&emu, This->primary, NULL);
+            if(SUCCEEDED(hr))
+            {
+                This->primary->write_emu = &emu->IDirectSoundBuffer8_iface;
+                hr = IDirectSoundBuffer8_Initialize(This->primary->write_emu, (IDirectSound*)&This->IDirectSound8_iface, &desc);
+                if(FAILED(hr))
+                {
+                    IDirectSoundBuffer8_Release(This->primary->write_emu);
+                    This->primary->write_emu = NULL;
+                }
+            }
+        }
     }
-
-    if (pds == NULL) {
-        ERR("invalid parameter: pds == NULL\n");
-        *ppds = NULL;
-        return DSERR_INVALIDPARAM;
+    else if(This->prio_level == DSSCL_WRITEPRIMARY && level != DSSCL_WRITEPRIMARY && This->primary->write_emu)
+    {
+        TRACE("Nuking write_emu\n");
+        /* Delete it */
+        IDirectSoundBuffer8_Release(This->primary->write_emu);
+        This->primary->write_emu = NULL;
     }
+    if(SUCCEEDED(hr))
+        This->prio_level = level;
+out:
+    LeaveCriticalSection(&openal_crst);
 
-    pdsds = HeapAlloc(GetProcessHeap(),0,sizeof(*pdsds));
-    if (pdsds == NULL) {
-        WARN("out of memory\n");
-        *ppds = NULL;
-        return DSERR_OUTOFMEMORY;
-    }
+    return hr;
+}
 
-    pdsds->lpVtbl = &DirectSound_DirectSound_Vtbl;
-    pdsds->ref = 0;
-    pdsds->pds = pds;
+static HRESULT WINAPI DS8_Compact(IDirectSound8 *iface)
+{
+    DS8Impl *This = impl_from_IDirectSound8(iface);
+    HRESULT hr = S_OK;
 
-    IDirectSoundImpl_AddRef(pds);
-    *ppds = (LPDIRECTSOUND)pdsds;
+    TRACE("(%p)->()\n", iface);
 
-    return DS_OK;
-}
+    EnterCriticalSection(&openal_crst);
+    if(!This->device)
+        hr = DSERR_UNINITIALIZED;
+    else if(This->prio_level < DSSCL_PRIORITY)
+        hr = DSERR_PRIOLEVELNEEDED;
+    LeaveCriticalSection(&openal_crst);
 
-/*******************************************************************************
- *		IDirectSound8_IUnknown
- */
-static HRESULT WINAPI IDirectSound8_IUnknown_QueryInterface(
-    LPUNKNOWN iface,
-    REFIID riid,
-    LPVOID * ppobj)
-{
-    IDirectSound_IUnknown *This = (IDirectSound_IUnknown *)iface;
-    TRACE("(%p,%s,%p)\n",This,debugstr_guid(riid),ppobj);
-    return DSOUND_QueryInterface8(This->pds, riid, ppobj);
+    return hr;
 }
 
-static ULONG WINAPI IDirectSound8_IUnknown_AddRef(
-    LPUNKNOWN iface)
+static HRESULT WINAPI DS8_GetSpeakerConfig(IDirectSound8 *iface, DWORD *config)
 {
-    IDirectSound_IUnknown *This = (IDirectSound_IUnknown *)iface;
-    ULONG ref = InterlockedIncrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref - 1);
-    return ref;
+    DS8Impl *This = impl_from_IDirectSound8(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("(%p)->(%p)\n", iface, config);
+
+    if(!config)
+        return DSERR_INVALIDPARAM;
+
+    EnterCriticalSection(&openal_crst);
+    if(!This->device)
+        hr = DSERR_UNINITIALIZED;
+    else
+        *config = This->speaker_config;
+    LeaveCriticalSection(&openal_crst);
+
+    return hr;
 }
 
-static ULONG WINAPI IDirectSound8_IUnknown_Release(
-    LPUNKNOWN iface)
+static HRESULT WINAPI DS8_SetSpeakerConfig(IDirectSound8 *iface, DWORD config)
 {
-    IDirectSound_IUnknown *This = (IDirectSound_IUnknown *)iface;
-    ULONG ref = InterlockedDecrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref + 1);
-    if (!ref) {
-        ((IDirectSoundImpl*)This->pds)->pUnknown = NULL;
-        IDirectSoundImpl_Release(This->pds);
-        HeapFree(GetProcessHeap(), 0, This);
-        TRACE("(%p) released\n", This);
+    DS8Impl *This = impl_from_IDirectSound8(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(0x%08x)\n", iface, config);
+
+    EnterCriticalSection(&openal_crst);
+    if(!This->device)
+        hr = DSERR_UNINITIALIZED;
+    else
+    {
+        HKEY key;
+        DWORD geo, speaker;
+
+        geo = DSSPEAKER_GEOMETRY(config);
+        speaker = DSSPEAKER_CONFIG(config);
+
+        hr = DSERR_INVALIDPARAM;
+        if(geo && (geo < DSSPEAKER_GEOMETRY_MIN || geo > DSSPEAKER_GEOMETRY_MAX))
+        {
+            WARN("Invalid speaker angle %u\n", geo);
+            goto out;
+        }
+        if(speaker < DSSPEAKER_HEADPHONE || speaker > DSSPEAKER_7POINT1)
+        {
+            WARN("Invalid speaker config %u\n", speaker);
+            goto out;
+        }
+
+        hr = DSERR_GENERIC;
+        if(!RegCreateKeyExW(HKEY_LOCAL_MACHINE, speakerconfigkey, 0, NULL, 0, KEY_WRITE, NULL, &key, NULL))
+        {
+            RegSetValueExW(key, speakerconfig, 0, REG_DWORD, (const BYTE*)&config, sizeof(DWORD));
+            This->speaker_config = config;
+            RegCloseKey(key);
+            hr = S_OK;
+        }
     }
-    return ref;
+out:
+    LeaveCriticalSection(&openal_crst);
+
+    return hr;
 }
 
-static const IUnknownVtbl DirectSound8_Unknown_Vtbl =
+static HRESULT WINAPI DS8_Initialize(IDirectSound8 *iface, const GUID *devguid)
 {
-    IDirectSound8_IUnknown_QueryInterface,
-    IDirectSound8_IUnknown_AddRef,
-    IDirectSound8_IUnknown_Release
-};
+    DS8Impl *This = impl_from_IDirectSound8(iface);
+    const ALCchar *drv_name = "loopback";
+    HRESULT hr;
+    UINT n;
 
-static HRESULT IDirectSound8_IUnknown_Create(
-    LPDIRECTSOUND8 pds,
-    LPUNKNOWN * ppunk)
-{
-    IDirectSound8_IUnknown * pdsunk;
-    TRACE("(%p,%p)\n",pds,ppunk);
+    TRACE("(%p)->(%s)\n", iface, debugstr_guid(devguid));
 
-    if (ppunk == NULL) {
-        ERR("invalid parameter: ppunk == NULL\n");
-        return DSERR_INVALIDPARAM;
+    if(!openal_loaded || !DSOUND_obtain_mme())
+        return DSERR_NODRIVER;
+
+    if(!devguid)
+        devguid = &DSDEVID_DefaultPlayback;
+
+    EnterCriticalSection(&openal_crst);
+
+    hr = DSERR_ALREADYINITIALIZED;
+    if(This->device)
+        goto out;
+    hr = GetDeviceID(devguid, &This->guid);
+    if (FAILED(hr))
+        goto out;
+    TRACE("Resolved %s to %s\n", debugstr_guid(devguid), debugstr_guid(&This->guid));
+
+    for(n = 0;n < devicelistsize;n++)
+    {
+        if(devicelist[n]->device && devicelist[n]->is_8 == This->is_8 &&
+           IsEqualGUID(&devicelist[n]->guid, &This->guid))
+        {
+            TRACE("Matched already open device %p\n", devicelist[n]);
+
+            This->device = devicelist[n]->device;
+            This->primary = devicelist[n]->primary;
+            This->deviceref = devicelist[n]->deviceref;
+            InterlockedIncrement(This->deviceref);
+
+            hr = DS_OK;
+            goto out;
+        }
     }
 
-    if (pds == NULL) {
-        ERR("invalid parameter: pds == NULL\n");
-        *ppunk = NULL;
-        return DSERR_INVALIDPARAM;
+    if(!This->deviceref)
+    {
+        hr = DSERR_OUTOFMEMORY;
+        if(!(This->deviceref=HeapAlloc(GetProcessHeap(), 0, sizeof(LONG))))
+            goto out;
+        This->deviceref[0] = 1;
     }
 
-    pdsunk = HeapAlloc(GetProcessHeap(),0,sizeof(*pdsunk));
-    if (pdsunk == NULL) {
-        WARN("out of memory\n");
-        *ppunk = NULL;
-        return DSERR_OUTOFMEMORY;
+    This->device = palcLoopbackOpenDeviceSOFT();
+    if(!This->device)
+    {
+        getALCError(NULL);
+        ERR("Couldn't open device %s\n", drv_name);
+        goto out;
     }
+    TRACE("Opened device: %s\n", palcGetString(This->device, ALC_DEVICE_SPECIFIER));
 
-    pdsunk->lpVtbl = &DirectSound8_Unknown_Vtbl;
-    pdsunk->ref = 0;
-    pdsunk->pds = pds;
+    hr = DS8Primary_Create(&This->primary, This);
+    if(FAILED(hr))
+    {
+        palcCloseDevice(This->device);
+        This->device = NULL;
+    }
 
-    IDirectSoundImpl_AddRef(pds);
-    *ppunk = (LPUNKNOWN)pdsunk;
+out:
+    LeaveCriticalSection(&openal_crst);
 
-    return DS_OK;
+    return hr;
 }
 
-/*******************************************************************************
- *		IDirectSound8_IDirectSound
+/* I, Maarten Lankhorst, hereby declare this driver certified
+ * What this means.. ? An extra bit set
  */
-static HRESULT WINAPI IDirectSound8_IDirectSound_QueryInterface(
-    LPDIRECTSOUND iface,
-    REFIID riid,
-    LPVOID * ppobj)
+static HRESULT WINAPI DS8_VerifyCertification(IDirectSound8 *iface, DWORD *certified)
 {
-    IDirectSound8_IDirectSound *This = (IDirectSound8_IDirectSound *)iface;
-    TRACE("(%p,%s,%p)\n",This,debugstr_guid(riid),ppobj);
-    return DSOUND_QueryInterface8(This->pds, riid, ppobj);
+    DS8Impl *This = impl_from_IDirectSound8(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", iface, certified);
+
+    if(!certified)
+        return DSERR_INVALIDPARAM;
+
+    EnterCriticalSection(&openal_crst);
+    hr = S_OK;
+    if(!This->device)
+        hr = DSERR_UNINITIALIZED;
+    else
+        *certified = DS_CERTIFIED;
+    LeaveCriticalSection(&openal_crst);
+
+    return hr;
 }
 
-static ULONG WINAPI IDirectSound8_IDirectSound_AddRef(
-    LPDIRECTSOUND iface)
+static const IDirectSound8Vtbl DS8_Vtbl =
+{
+    DS8_QueryInterface,
+    DS8_AddRef,
+    DS8_Release,
+    DS8_CreateSoundBuffer,
+    DS8_GetCaps,
+    DS8_DuplicateSoundBuffer,
+    DS8_SetCooperativeLevel,
+    DS8_Compact,
+    DS8_GetSpeakerConfig,
+    DS8_SetSpeakerConfig,
+    DS8_Initialize,
+    DS8_VerifyCertification
+};
+
+#else
+
+HRESULT DSOUND_Create(REFIID riid, IDirectSound **ds)
 {
-    IDirectSound8_IDirectSound *This = (IDirectSound8_IDirectSound *)iface;
-    ULONG ref = InterlockedIncrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref - 1);
-    return ref;
+    return DSOUND_Create8(riid, (IDirectSound8**)ds);
 }
 
-static ULONG WINAPI IDirectSound8_IDirectSound_Release(
-    LPDIRECTSOUND iface)
+HRESULT DSOUND_Create8(REFIID riid, IDirectSound8 **ds)
 {
-    IDirectSound8_IDirectSound *This = (IDirectSound8_IDirectSound *)iface;
-    ULONG ref = InterlockedDecrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref + 1);
-    if (!ref) {
-        ((IDirectSoundImpl*)This->pds)->pDS = NULL;
-        IDirectSoundImpl_Release(This->pds);
-        HeapFree(GetProcessHeap(), 0, This);
-        TRACE("(%p) released\n", This);
-    }
-    return ref;
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound_CreateSoundBuffer(
-    LPDIRECTSOUND iface,
-    LPCDSBUFFERDESC dsbd,
-    LPLPDIRECTSOUNDBUFFER ppdsb,
-    LPUNKNOWN lpunk)
-{
-    IDirectSound8_IDirectSound *This = (IDirectSound8_IDirectSound *)iface;
-    TRACE("(%p,%p,%p,%p)\n",This,dsbd,ppdsb,lpunk);
-    return DirectSoundDevice_CreateSoundBuffer(((IDirectSoundImpl *)This->pds)->device,dsbd,ppdsb,lpunk,TRUE);
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound_GetCaps(
-    LPDIRECTSOUND iface,
-    LPDSCAPS lpDSCaps)
-{
-    IDirectSound8_IDirectSound *This = (IDirectSound8_IDirectSound *)iface;
-    TRACE("(%p,%p)\n",This,lpDSCaps);
-    return DirectSoundDevice_GetCaps(((IDirectSoundImpl *)This->pds)->device, lpDSCaps);
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound_DuplicateSoundBuffer(
-    LPDIRECTSOUND iface,
-    LPDIRECTSOUNDBUFFER psb,
-    LPLPDIRECTSOUNDBUFFER ppdsb)
-{
-    IDirectSound8_IDirectSound *This = (IDirectSound8_IDirectSound *)iface;
-    TRACE("(%p,%p,%p)\n",This,psb,ppdsb);
-    return DirectSoundDevice_DuplicateSoundBuffer(((IDirectSoundImpl *)This->pds)->device,psb,ppdsb);
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound_SetCooperativeLevel(
-    LPDIRECTSOUND iface,
-    HWND hwnd,
-    DWORD level)
-{
-    IDirectSound8_IDirectSound *This = (IDirectSound8_IDirectSound *)iface;
-    TRACE("(%p,%p,%s)\n",This,hwnd,dumpCooperativeLevel(level));
-    return DirectSoundDevice_SetCooperativeLevel(((IDirectSoundImpl *)This->pds)->device, hwnd, level);
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound_Compact(
-    LPDIRECTSOUND iface)
-{
-    IDirectSound8_IDirectSound *This = (IDirectSound8_IDirectSound *)iface;
-    TRACE("(%p)\n", This);
-    return DirectSoundDevice_Compact(((IDirectSoundImpl *)This->pds)->device);
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound_GetSpeakerConfig(
-    LPDIRECTSOUND iface,
-    LPDWORD lpdwSpeakerConfig)
-{
-    IDirectSound8_IDirectSound *This = (IDirectSound8_IDirectSound *)iface;
-    TRACE("(%p, %p)\n", This, lpdwSpeakerConfig);
-    return DirectSoundDevice_GetSpeakerConfig(((IDirectSoundImpl *)This->pds)->device,lpdwSpeakerConfig);
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound_SetSpeakerConfig(
-    LPDIRECTSOUND iface,
-    DWORD config)
-{
-    IDirectSound8_IDirectSound *This = (IDirectSound8_IDirectSound *)iface;
-    TRACE("(%p,0x%08x)\n",This,config);
-    return DirectSoundDevice_SetSpeakerConfig(((IDirectSoundImpl *)This->pds)->device,config);
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound_Initialize(
-    LPDIRECTSOUND iface,
-    LPCGUID lpcGuid)
-{
-    IDirectSound8_IDirectSound *This = (IDirectSound8_IDirectSound *)iface;
-    TRACE("(%p, %s)\n", This, debugstr_guid(lpcGuid));
-    return DirectSoundDevice_Initialize(&((IDirectSoundImpl *)This->pds)->device,lpcGuid);
-}
-
-static const IDirectSoundVtbl DirectSound8_DirectSound_Vtbl =
-{
-    IDirectSound8_IDirectSound_QueryInterface,
-    IDirectSound8_IDirectSound_AddRef,
-    IDirectSound8_IDirectSound_Release,
-    IDirectSound8_IDirectSound_CreateSoundBuffer,
-    IDirectSound8_IDirectSound_GetCaps,
-    IDirectSound8_IDirectSound_DuplicateSoundBuffer,
-    IDirectSound8_IDirectSound_SetCooperativeLevel,
-    IDirectSound8_IDirectSound_Compact,
-    IDirectSound8_IDirectSound_GetSpeakerConfig,
-    IDirectSound8_IDirectSound_SetSpeakerConfig,
-    IDirectSound8_IDirectSound_Initialize
-};
-
-static HRESULT IDirectSound8_IDirectSound_Create(
-    LPDIRECTSOUND8 pds,
-    LPDIRECTSOUND * ppds)
-{
-    IDirectSound8_IDirectSound * pdsds;
-    TRACE("(%p,%p)\n",pds,ppds);
-
-    if (ppds == NULL) {
-        ERR("invalid parameter: ppds == NULL\n");
-        return DSERR_INVALIDPARAM;
-    }
-
-    if (pds == NULL) {
-        ERR("invalid parameter: pds == NULL\n");
-        *ppds = NULL;
-        return DSERR_INVALIDPARAM;
-    }
-
-    pdsds = HeapAlloc(GetProcessHeap(),0,sizeof(*pdsds));
-    if (pdsds == NULL) {
-        WARN("out of memory\n");
-        *ppds = NULL;
-        return DSERR_OUTOFMEMORY;
-    }
-
-    pdsds->lpVtbl = &DirectSound8_DirectSound_Vtbl;
-    pdsds->ref = 0;
-    pdsds->pds = pds;
-
-    IDirectSoundImpl_AddRef(pds);
-    *ppds = (LPDIRECTSOUND)pdsds;
-
-    return DS_OK;
-}
-
-/*******************************************************************************
- *		IDirectSound8_IDirectSound8
- */
-static HRESULT WINAPI IDirectSound8_IDirectSound8_QueryInterface(
-    LPDIRECTSOUND8 iface,
-    REFIID riid,
-    LPVOID * ppobj)
-{
-    IDirectSound8_IDirectSound8 *This = (IDirectSound8_IDirectSound8 *)iface;
-    TRACE("(%p,%s,%p)\n",This,debugstr_guid(riid),ppobj);
-    return DSOUND_QueryInterface8(This->pds, riid, ppobj);
-}
-
-static ULONG WINAPI IDirectSound8_IDirectSound8_AddRef(
-    LPDIRECTSOUND8 iface)
-{
-    IDirectSound8_IDirectSound8 *This = (IDirectSound8_IDirectSound8 *)iface;
-    ULONG ref = InterlockedIncrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref - 1);
-    return ref;
-}
-
-static ULONG WINAPI IDirectSound8_IDirectSound8_Release(
-    LPDIRECTSOUND8 iface)
-{
-    IDirectSound8_IDirectSound8 *This = (IDirectSound8_IDirectSound8 *)iface;
-    ULONG ref = InterlockedDecrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref + 1);
-    if (!ref) {
-        ((IDirectSoundImpl*)This->pds)->pDS8 = NULL;
-        IDirectSoundImpl_Release(This->pds);
-        HeapFree(GetProcessHeap(), 0, This);
-        TRACE("(%p) released\n", This);
-    }
-    return ref;
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound8_CreateSoundBuffer(
-    LPDIRECTSOUND8 iface,
-    LPCDSBUFFERDESC dsbd,
-    LPLPDIRECTSOUNDBUFFER ppdsb,
-    LPUNKNOWN lpunk)
-{
-    IDirectSound8_IDirectSound8 *This = (IDirectSound8_IDirectSound8 *)iface;
-    TRACE("(%p,%p,%p,%p)\n",This,dsbd,ppdsb,lpunk);
-    return DirectSoundDevice_CreateSoundBuffer(((IDirectSoundImpl *)This->pds)->device,dsbd,ppdsb,lpunk,TRUE);
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound8_GetCaps(
-    LPDIRECTSOUND8 iface,
-    LPDSCAPS lpDSCaps)
-{
-    IDirectSound8_IDirectSound *This = (IDirectSound8_IDirectSound *)iface;
-    TRACE("(%p,%p)\n",This,lpDSCaps);
-    return DirectSoundDevice_GetCaps(((IDirectSoundImpl *)This->pds)->device, lpDSCaps);
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound8_DuplicateSoundBuffer(
-    LPDIRECTSOUND8 iface,
-    LPDIRECTSOUNDBUFFER psb,
-    LPLPDIRECTSOUNDBUFFER ppdsb)
-{
-    IDirectSound8_IDirectSound8 *This = (IDirectSound8_IDirectSound8 *)iface;
-    TRACE("(%p,%p,%p)\n",This,psb,ppdsb);
-    return DirectSoundDevice_DuplicateSoundBuffer(((IDirectSoundImpl *)This->pds)->device,psb,ppdsb);
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound8_SetCooperativeLevel(
-    LPDIRECTSOUND8 iface,
-    HWND hwnd,
-    DWORD level)
-{
-    IDirectSound8_IDirectSound8 *This = (IDirectSound8_IDirectSound8 *)iface;
-    TRACE("(%p,%p,%s)\n",This,hwnd,dumpCooperativeLevel(level));
-    return DirectSoundDevice_SetCooperativeLevel(((IDirectSoundImpl *)This->pds)->device, hwnd, level);
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound8_Compact(
-    LPDIRECTSOUND8 iface)
-{
-    IDirectSound8_IDirectSound8 *This = (IDirectSound8_IDirectSound8 *)iface;
-    TRACE("(%p)\n", This);
-    return DirectSoundDevice_Compact(((IDirectSoundImpl *)This->pds)->device);
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound8_GetSpeakerConfig(
-    LPDIRECTSOUND8 iface,
-    LPDWORD lpdwSpeakerConfig)
-{
-    IDirectSound8_IDirectSound8 *This = (IDirectSound8_IDirectSound8 *)iface;
-    TRACE("(%p, %p)\n", This, lpdwSpeakerConfig);
-    return DirectSoundDevice_GetSpeakerConfig(((IDirectSoundImpl *)This->pds)->device,lpdwSpeakerConfig);
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound8_SetSpeakerConfig(
-    LPDIRECTSOUND8 iface,
-    DWORD config)
-{
-    IDirectSound8_IDirectSound8 *This = (IDirectSound8_IDirectSound8 *)iface;
-    TRACE("(%p,0x%08x)\n",This,config);
-    return DirectSoundDevice_SetSpeakerConfig(((IDirectSoundImpl *)This->pds)->device,config);
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound8_Initialize(
-    LPDIRECTSOUND8 iface,
-    LPCGUID lpcGuid)
-{
-    IDirectSound8_IDirectSound8 *This = (IDirectSound8_IDirectSound8 *)iface;
-    TRACE("(%p, %s)\n", This, debugstr_guid(lpcGuid));
-    return DirectSoundDevice_Initialize(&((IDirectSoundImpl *)This->pds)->device,lpcGuid);
-}
-
-static HRESULT WINAPI IDirectSound8_IDirectSound8_VerifyCertification(
-    LPDIRECTSOUND8 iface,
-    LPDWORD pdwCertified)
-{
-    IDirectSound8_IDirectSound8 *This = (IDirectSound8_IDirectSound8 *)iface;
-    TRACE("(%p, %p)\n", This, pdwCertified);
-    return DirectSoundDevice_VerifyCertification(((IDirectSoundImpl *)This->pds)->device,pdwCertified);
-}
-
-static const IDirectSound8Vtbl DirectSound8_DirectSound8_Vtbl =
-{
-    IDirectSound8_IDirectSound8_QueryInterface,
-    IDirectSound8_IDirectSound8_AddRef,
-    IDirectSound8_IDirectSound8_Release,
-    IDirectSound8_IDirectSound8_CreateSoundBuffer,
-    IDirectSound8_IDirectSound8_GetCaps,
-    IDirectSound8_IDirectSound8_DuplicateSoundBuffer,
-    IDirectSound8_IDirectSound8_SetCooperativeLevel,
-    IDirectSound8_IDirectSound8_Compact,
-    IDirectSound8_IDirectSound8_GetSpeakerConfig,
-    IDirectSound8_IDirectSound8_SetSpeakerConfig,
-    IDirectSound8_IDirectSound8_Initialize,
-    IDirectSound8_IDirectSound8_VerifyCertification
-};
-
-static HRESULT IDirectSound8_IDirectSound8_Create(
-    LPDIRECTSOUND8 pds,
-    LPDIRECTSOUND8 * ppds)
-{
-    IDirectSound8_IDirectSound8 * pdsds;
-    TRACE("(%p,%p)\n",pds,ppds);
-
-    if (ppds == NULL) {
-        ERR("invalid parameter: ppds == NULL\n");
-        return DSERR_INVALIDPARAM;
-    }
-
-    if (pds == NULL) {
-        ERR("invalid parameter: pds == NULL\n");
-        *ppds = NULL;
-        return DSERR_INVALIDPARAM;
-    }
-
-    pdsds = HeapAlloc(GetProcessHeap(),0,sizeof(*pdsds));
-    if (pdsds == NULL) {
-        WARN("out of memory\n");
-        *ppds = NULL;
-        return DSERR_OUTOFMEMORY;
-    }
+    *ds = NULL;
 
-    pdsds->lpVtbl = &DirectSound8_DirectSound8_Vtbl;
-    pdsds->ref = 0;
-    pdsds->pds = pds;
+    ERR("Attempting to create a sound device without OpenAL support\n");
+    ERR("Please recompile Wine with OpenAL\n");
 
-    IDirectSoundImpl_AddRef(pds);
-    *ppds = (LPDIRECTSOUND8)pdsds;
-
-    return DS_OK;
+    return DSERR_NODRIVER;
 }
 
-HRESULT DSOUND_Create(
-    REFIID riid,
-    LPDIRECTSOUND *ppDS)
-{
-    LPDIRECTSOUND8 pDS;
-    HRESULT hr;
-    TRACE("(%s, %p)\n", debugstr_guid(riid), ppDS);
+#endif
 
-    if (!IsEqualIID(riid, &IID_IUnknown) &&
-        !IsEqualIID(riid, &IID_IDirectSound)) {
-        *ppDS = 0;
-        return E_NOINTERFACE;
-    }
-
-    /* Get dsound configuration */
-    setup_dsound_options();
-
-    hr = IDirectSoundImpl_Create(&pDS);
-    if (hr == DS_OK) {
-        hr = IDirectSound_IDirectSound_Create(pDS, ppDS);
-        if (*ppDS)
-            IDirectSound_IDirectSound_AddRef(*ppDS);
-        else {
-            WARN("IDirectSound_IDirectSound_Create failed\n");
-            IDirectSound8_Release(pDS);
-        }
-    } else {
-        WARN("IDirectSoundImpl_Create failed\n");
-        *ppDS = 0;
-    }
-
-    return hr;
-}
 
 /*******************************************************************************
- *		DirectSoundCreate (DSOUND.1)
+ *      DirectSoundCreate (DSOUND.1)
  *
  *  Creates and initializes a DirectSound interface.
  *
@@ -1029,10 +769,7 @@ HRESULT DSOUND_Create(
  *     Failure: DSERR_ALLOCATED, DSERR_INVALIDPARAM, DSERR_NOAGGREGATION,
  *              DSERR_NODRIVER, DSERR_OUTOFMEMORY
  */
-HRESULT WINAPI DirectSoundCreate(
-    LPCGUID lpcGUID,
-    LPDIRECTSOUND *ppDS,
-    IUnknown *pUnkOuter)
+HRESULT WINAPI DirectSoundCreate(LPCGUID lpcGUID, LPDIRECTSOUND *ppDS, IUnknown *pUnkOuter)
 {
     HRESULT hr;
     LPDIRECTSOUND pDS;
@@ -1067,60 +804,7 @@ HRESULT WINAPI DirectSoundCreate(
     return hr;
 }
 
-HRESULT DSOUND_Create8(
-    REFIID riid,
-    LPDIRECTSOUND8 *ppDS)
-{
-    LPDIRECTSOUND8 pDS;
-    HRESULT hr;
-    TRACE("(%s, %p)\n", debugstr_guid(riid), ppDS);
-
-    if (!IsEqualIID(riid, &IID_IUnknown) &&
-        !IsEqualIID(riid, &IID_IDirectSound) &&
-        !IsEqualIID(riid, &IID_IDirectSound8)) {
-        *ppDS = 0;
-        return E_NOINTERFACE;
-    }
-
-    /* Get dsound configuration */
-    setup_dsound_options();
-
-    hr = IDirectSoundImpl_Create(&pDS);
-    if (hr == DS_OK) {
-        hr = IDirectSound8_IDirectSound8_Create(pDS, ppDS);
-        if (*ppDS)
-            IDirectSound8_IDirectSound8_AddRef(*ppDS);
-        else {
-            WARN("IDirectSound8_IDirectSound8_Create failed\n");
-            IDirectSound8_Release(pDS);
-        }
-    } else {
-        WARN("IDirectSoundImpl_Create failed\n");
-        *ppDS = 0;
-    }
-
-    return hr;
-}
-
-/*******************************************************************************
- *        DirectSoundCreate8 (DSOUND.11)
- *
- *  Creates and initializes a DirectSound8 interface.
- *
- *  PARAMS
- *     lpcGUID   [I] Address of the GUID that identifies the sound device.
- *     ppDS      [O] Address of a variable to receive the interface pointer.
- *     pUnkOuter [I] Must be NULL.
- *
- *  RETURNS
- *     Success: DS_OK
- *     Failure: DSERR_ALLOCATED, DSERR_INVALIDPARAM, DSERR_NOAGGREGATION,
- *              DSERR_NODRIVER, DSERR_OUTOFMEMORY
- */
-HRESULT WINAPI DirectSoundCreate8(
-    LPCGUID lpcGUID,
-    LPDIRECTSOUND8 *ppDS,
-    IUnknown *pUnkOuter)
+HRESULT WINAPI DirectSoundCreate8(LPCGUID lpcGUID, LPDIRECTSOUND8 *ppDS, IUnknown *pUnkOuter)
 {
     HRESULT hr;
     LPDIRECTSOUND8 pDS;
@@ -1155,693 +839,3 @@ HRESULT WINAPI DirectSoundCreate8(
     return hr;
 }
 
-/*******************************************************************************
- *        DirectSoundDevice
- */
-static HRESULT DirectSoundDevice_Create(DirectSoundDevice ** ppDevice)
-{
-    DirectSoundDevice * device;
-    TRACE("(%p)\n", ppDevice);
-
-    /* Allocate memory */
-    device = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(DirectSoundDevice));
-    if (device == NULL) {
-        WARN("out of memory\n");
-        return DSERR_OUTOFMEMORY;
-    }
-
-    device->ref            = 1;
-    device->priolevel      = DSSCL_NORMAL;
-    device->state          = STATE_STOPPED;
-    device->speaker_config = DSSPEAKER_STEREO | (DSSPEAKER_GEOMETRY_NARROW << 16);
-
-    /* 3D listener initial parameters */
-    device->ds3dl.dwSize   = sizeof(DS3DLISTENER);
-    device->ds3dl.vPosition.x = 0.0;
-    device->ds3dl.vPosition.y = 0.0;
-    device->ds3dl.vPosition.z = 0.0;
-    device->ds3dl.vVelocity.x = 0.0;
-    device->ds3dl.vVelocity.y = 0.0;
-    device->ds3dl.vVelocity.z = 0.0;
-    device->ds3dl.vOrientFront.x = 0.0;
-    device->ds3dl.vOrientFront.y = 0.0;
-    device->ds3dl.vOrientFront.z = 1.0;
-    device->ds3dl.vOrientTop.x = 0.0;
-    device->ds3dl.vOrientTop.y = 1.0;
-    device->ds3dl.vOrientTop.z = 0.0;
-    device->ds3dl.flDistanceFactor = DS3D_DEFAULTDISTANCEFACTOR;
-    device->ds3dl.flRolloffFactor = DS3D_DEFAULTROLLOFFFACTOR;
-    device->ds3dl.flDopplerFactor = DS3D_DEFAULTDOPPLERFACTOR;
-
-    device->prebuf = ds_snd_queue_max;
-    device->guid = GUID_NULL;
-
-    /* Set default wave format (may need it for waveOutOpen) */
-    device->pwfx = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(WAVEFORMATEX));
-    if (device->pwfx == NULL) {
-        WARN("out of memory\n");
-        HeapFree(GetProcessHeap(),0,device);
-        return DSERR_OUTOFMEMORY;
-    }
-
-    /* We rely on the sound driver to return the actual sound format of
-     * the device if it does not support 22050x8x2 and is given the
-     * WAVE_DIRECTSOUND flag.
-     */
-    device->pwfx->wFormatTag = WAVE_FORMAT_PCM;
-    device->pwfx->nSamplesPerSec = ds_default_sample_rate;
-    device->pwfx->wBitsPerSample = ds_default_bits_per_sample;
-    device->pwfx->nChannels = 2;
-    device->pwfx->nBlockAlign = device->pwfx->wBitsPerSample * device->pwfx->nChannels / 8;
-    device->pwfx->nAvgBytesPerSec = device->pwfx->nSamplesPerSec * device->pwfx->nBlockAlign;
-    device->pwfx->cbSize = 0;
-
-    InitializeCriticalSection(&(device->mixlock));
-    device->mixlock.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": DirectSoundDevice.mixlock");
-
-    RtlInitializeResource(&(device->buffer_list_lock));
-
-   *ppDevice = device;
-
-    return DS_OK;
-}
-
-static ULONG DirectSoundDevice_AddRef(DirectSoundDevice * device)
-{
-    ULONG ref = InterlockedIncrement(&(device->ref));
-    TRACE("(%p) ref was %d\n", device, ref - 1);
-    return ref;
-}
-
-ULONG DirectSoundDevice_Release(DirectSoundDevice * device)
-{
-    HRESULT hr;
-    ULONG ref = InterlockedDecrement(&(device->ref));
-    TRACE("(%p) ref was %u\n", device, ref + 1);
-    if (!ref) {
-        int i;
-        timeKillEvent(device->timerID);
-        timeEndPeriod(DS_TIME_RES);
-
-        /* The kill event should have allowed the timer process to expire
-         * but try to grab the lock just in case. Can't hold lock because
-         * IDirectSoundBufferImpl_Destroy also grabs the lock */
-        RtlAcquireResourceShared(&(device->buffer_list_lock), TRUE);
-        RtlReleaseResource(&(device->buffer_list_lock));
-
-        /* It is allowed to release this object even when buffers are playing */
-        if (device->buffers) {
-            WARN("%d secondary buffers not released\n", device->nrofbuffers);
-            for( i=0;i<device->nrofbuffers;i++)
-                IDirectSoundBufferImpl_Destroy(device->buffers[i]);
-        }
-
-        if (device->primary) {
-            WARN("primary buffer not released\n");
-            IDirectSoundBuffer8_Release((LPDIRECTSOUNDBUFFER8)device->primary);
-        }
-
-        hr = DSOUND_PrimaryDestroy(device);
-        if (hr != DS_OK)
-            WARN("DSOUND_PrimaryDestroy failed\n");
-
-        if (device->driver)
-            IDsDriver_Close(device->driver);
-
-        if (device->drvdesc.dwFlags & DSDDESC_DOMMSYSTEMOPEN)
-            waveOutClose(device->hwo);
-
-        if (device->driver)
-            IDsDriver_Release(device->driver);
-
-        DSOUND_renderer[device->drvdesc.dnDevNode] = NULL;
-
-        HeapFree(GetProcessHeap(), 0, device->tmp_buffer);
-        HeapFree(GetProcessHeap(), 0, device->mix_buffer);
-        if (device->drvdesc.dwFlags & DSDDESC_USESYSTEMMEMORY)
-            HeapFree(GetProcessHeap(), 0, device->buffer);
-        RtlDeleteResource(&device->buffer_list_lock);
-        device->mixlock.DebugInfo->Spare[0] = 0;
-        DeleteCriticalSection(&device->mixlock);
-        HeapFree(GetProcessHeap(),0,device);
-        TRACE("(%p) released\n", device);
-    }
-    return ref;
-}
-
-HRESULT DirectSoundDevice_GetCaps(
-    DirectSoundDevice * device,
-    LPDSCAPS lpDSCaps)
-{
-    TRACE("(%p,%p)\n",device,lpDSCaps);
-
-    if (device == NULL) {
-        WARN("not initialized\n");
-        return DSERR_UNINITIALIZED;
-    }
-
-    if (lpDSCaps == NULL) {
-        WARN("invalid parameter: lpDSCaps = NULL\n");
-        return DSERR_INVALIDPARAM;
-    }
-
-    /* check if there is enough room */
-    if (lpDSCaps->dwSize < sizeof(*lpDSCaps)) {
-        WARN("invalid parameter: lpDSCaps->dwSize = %d\n", lpDSCaps->dwSize);
-        return DSERR_INVALIDPARAM;
-    }
-
-    lpDSCaps->dwFlags                           = device->drvcaps.dwFlags;
-    if (TRACE_ON(dsound)) {
-        TRACE("(flags=0x%08x:\n",lpDSCaps->dwFlags);
-        _dump_DSCAPS(lpDSCaps->dwFlags);
-        TRACE(")\n");
-    }
-    lpDSCaps->dwMinSecondarySampleRate          = device->drvcaps.dwMinSecondarySampleRate;
-    lpDSCaps->dwMaxSecondarySampleRate          = device->drvcaps.dwMaxSecondarySampleRate;
-    lpDSCaps->dwPrimaryBuffers                  = device->drvcaps.dwPrimaryBuffers;
-    lpDSCaps->dwMaxHwMixingAllBuffers           = device->drvcaps.dwMaxHwMixingAllBuffers;
-    lpDSCaps->dwMaxHwMixingStaticBuffers        = device->drvcaps.dwMaxHwMixingStaticBuffers;
-    lpDSCaps->dwMaxHwMixingStreamingBuffers     = device->drvcaps.dwMaxHwMixingStreamingBuffers;
-    lpDSCaps->dwFreeHwMixingAllBuffers          = device->drvcaps.dwFreeHwMixingAllBuffers;
-    lpDSCaps->dwFreeHwMixingStaticBuffers       = device->drvcaps.dwFreeHwMixingStaticBuffers;
-    lpDSCaps->dwFreeHwMixingStreamingBuffers    = device->drvcaps.dwFreeHwMixingStreamingBuffers;
-    lpDSCaps->dwMaxHw3DAllBuffers               = device->drvcaps.dwMaxHw3DAllBuffers;
-    lpDSCaps->dwMaxHw3DStaticBuffers            = device->drvcaps.dwMaxHw3DStaticBuffers;
-    lpDSCaps->dwMaxHw3DStreamingBuffers         = device->drvcaps.dwMaxHw3DStreamingBuffers;
-    lpDSCaps->dwFreeHw3DAllBuffers              = device->drvcaps.dwFreeHw3DAllBuffers;
-    lpDSCaps->dwFreeHw3DStaticBuffers           = device->drvcaps.dwFreeHw3DStaticBuffers;
-    lpDSCaps->dwFreeHw3DStreamingBuffers        = device->drvcaps.dwFreeHw3DStreamingBuffers;
-    lpDSCaps->dwTotalHwMemBytes                 = device->drvcaps.dwTotalHwMemBytes;
-    lpDSCaps->dwFreeHwMemBytes                  = device->drvcaps.dwFreeHwMemBytes;
-    lpDSCaps->dwMaxContigFreeHwMemBytes         = device->drvcaps.dwMaxContigFreeHwMemBytes;
-
-    /* driver doesn't have these */
-    lpDSCaps->dwUnlockTransferRateHwBuffers     = 4096; /* But we have none... */
-    lpDSCaps->dwPlayCpuOverheadSwBuffers        = 1;    /* 1% */
-
-    return DS_OK;
-}
-
-HRESULT DirectSoundDevice_Initialize(DirectSoundDevice ** ppDevice, LPCGUID lpcGUID)
-{
-    HRESULT hr = DS_OK;
-    unsigned wod, wodn;
-    BOOLEAN found = FALSE;
-    GUID devGUID;
-    DirectSoundDevice * device = *ppDevice;
-    TRACE("(%p,%s)\n",ppDevice,debugstr_guid(lpcGUID));
-
-    if (*ppDevice != NULL) {
-        WARN("already initialized\n");
-        return DSERR_ALREADYINITIALIZED;
-    }
-
-    /* Default device? */
-    if (!lpcGUID || IsEqualGUID(lpcGUID, &GUID_NULL))
-        lpcGUID = &DSDEVID_DefaultPlayback;
-
-    if (GetDeviceID(lpcGUID, &devGUID) != DS_OK) {
-        WARN("invalid parameter: lpcGUID\n");
-        return DSERR_INVALIDPARAM;
-    }
-
-    /* Enumerate WINMM audio devices and find the one we want */
-    wodn = waveOutGetNumDevs();
-    if (!wodn) {
-        WARN("no driver\n");
-        return DSERR_NODRIVER;
-    }
-
-    for (wod=0; wod<wodn; wod++) {
-        if (IsEqualGUID( &devGUID, &DSOUND_renderer_guids[wod])) {
-            found = TRUE;
-            break;
-        }
-    }
-
-    if (found == FALSE) {
-        WARN("No device found matching given ID!\n");
-        return DSERR_NODRIVER;
-    }
-
-    if (DSOUND_renderer[wod]) {
-        if (IsEqualGUID(&devGUID, &DSOUND_renderer[wod]->guid)) {
-            device = DSOUND_renderer[wod];
-            DirectSoundDevice_AddRef(device);
-            *ppDevice = device;
-            return DS_OK;
-        } else {
-            ERR("device GUID doesn't match\n");
-            hr = DSERR_GENERIC;
-            return hr;
-        }
-    } else {
-        hr = DirectSoundDevice_Create(&device);
-        if (hr != DS_OK) {
-            WARN("DirectSoundDevice_Create failed\n");
-            return hr;
-        }
-    }
-
-    *ppDevice = device;
-    device->guid = devGUID;
-    device->driver = NULL;
-
-    device->drvdesc.dnDevNode = wod;
-    hr = DSOUND_ReopenDevice(device, FALSE);
-    if (FAILED(hr))
-    {
-        WARN("DSOUND_ReopenDevice failed: %08x\n", hr);
-        return hr;
-    }
-
-    if (device->driver) {
-        /* the driver is now open, so it's now allowed to call GetCaps */
-        hr = IDsDriver_GetCaps(device->driver,&(device->drvcaps));
-        if (hr != DS_OK) {
-            WARN("IDsDriver_GetCaps failed\n");
-            return hr;
-        }
-    } else {
-        WAVEOUTCAPSA woc;
-        hr = mmErr(waveOutGetDevCapsA(device->drvdesc.dnDevNode, &woc, sizeof(woc)));
-        if (hr != DS_OK) {
-            WARN("waveOutGetDevCaps failed\n");
-            return hr;
-        }
-        ZeroMemory(&device->drvcaps, sizeof(device->drvcaps));
-        if ((woc.dwFormats & WAVE_FORMAT_1M08) ||
-            (woc.dwFormats & WAVE_FORMAT_2M08) ||
-            (woc.dwFormats & WAVE_FORMAT_4M08) ||
-            (woc.dwFormats & WAVE_FORMAT_48M08) ||
-            (woc.dwFormats & WAVE_FORMAT_96M08)) {
-            device->drvcaps.dwFlags |= DSCAPS_PRIMARY8BIT;
-            device->drvcaps.dwFlags |= DSCAPS_PRIMARYMONO;
-        }
-        if ((woc.dwFormats & WAVE_FORMAT_1M16) ||
-            (woc.dwFormats & WAVE_FORMAT_2M16) ||
-            (woc.dwFormats & WAVE_FORMAT_4M16) ||
-            (woc.dwFormats & WAVE_FORMAT_48M16) ||
-            (woc.dwFormats & WAVE_FORMAT_96M16)) {
-            device->drvcaps.dwFlags |= DSCAPS_PRIMARY16BIT;
-            device->drvcaps.dwFlags |= DSCAPS_PRIMARYMONO;
-        }
-        if ((woc.dwFormats & WAVE_FORMAT_1S08) ||
-            (woc.dwFormats & WAVE_FORMAT_2S08) ||
-            (woc.dwFormats & WAVE_FORMAT_4S08) ||
-            (woc.dwFormats & WAVE_FORMAT_48S08) ||
-            (woc.dwFormats & WAVE_FORMAT_96S08)) {
-            device->drvcaps.dwFlags |= DSCAPS_PRIMARY8BIT;
-            device->drvcaps.dwFlags |= DSCAPS_PRIMARYSTEREO;
-        }
-        if ((woc.dwFormats & WAVE_FORMAT_1S16) ||
-            (woc.dwFormats & WAVE_FORMAT_2S16) ||
-            (woc.dwFormats & WAVE_FORMAT_4S16) ||
-            (woc.dwFormats & WAVE_FORMAT_48S16) ||
-            (woc.dwFormats & WAVE_FORMAT_96S16)) {
-            device->drvcaps.dwFlags |= DSCAPS_PRIMARY16BIT;
-            device->drvcaps.dwFlags |= DSCAPS_PRIMARYSTEREO;
-        }
-        if (ds_emuldriver)
-            device->drvcaps.dwFlags |= DSCAPS_EMULDRIVER;
-        device->drvcaps.dwMinSecondarySampleRate = DSBFREQUENCY_MIN;
-        device->drvcaps.dwMaxSecondarySampleRate = DSBFREQUENCY_MAX;
-        ZeroMemory(&device->volpan, sizeof(device->volpan));
-    }
-
-    hr = DSOUND_PrimaryCreate(device);
-    if (hr == DS_OK) {
-        UINT triggertime = DS_TIME_DEL, res = DS_TIME_RES, id;
-        TIMECAPS time;
-
-        DSOUND_renderer[device->drvdesc.dnDevNode] = device;
-        timeGetDevCaps(&time, sizeof(TIMECAPS));
-        TRACE("Minimum timer resolution: %u, max timer: %u\n", time.wPeriodMin, time.wPeriodMax);
-        if (triggertime < time.wPeriodMin)
-            triggertime = time.wPeriodMin;
-        if (res < time.wPeriodMin)
-            res = time.wPeriodMin;
-        if (timeBeginPeriod(res) == TIMERR_NOCANDO)
-            WARN("Could not set minimum resolution, don't expect sound\n");
-        id = timeSetEvent(triggertime, res, DSOUND_timer, (DWORD_PTR)device, TIME_PERIODIC | TIME_KILL_SYNCHRONOUS);
-        if (!id)
-        {
-            WARN("Timer not created! Retrying without TIME_KILL_SYNCHRONOUS\n");
-            id = timeSetEvent(triggertime, res, DSOUND_timer, (DWORD_PTR)device, TIME_PERIODIC);
-            if (!id) ERR("Could not create timer, sound playback will not occur\n");
-        }
-        DSOUND_renderer[device->drvdesc.dnDevNode]->timerID = id;
-    } else {
-        WARN("DSOUND_PrimaryCreate failed\n");
-    }
-
-    return hr;
-}
-
-HRESULT DirectSoundDevice_CreateSoundBuffer(
-    DirectSoundDevice * device,
-    LPCDSBUFFERDESC dsbd,
-    LPLPDIRECTSOUNDBUFFER ppdsb,
-    LPUNKNOWN lpunk,
-    BOOL from8)
-{
-    HRESULT hres = DS_OK;
-    TRACE("(%p,%p,%p,%p)\n",device,dsbd,ppdsb,lpunk);
-
-    if (device == NULL) {
-        WARN("not initialized\n");
-        return DSERR_UNINITIALIZED;
-    }
-
-    if (dsbd == NULL) {
-        WARN("invalid parameter: dsbd == NULL\n");
-        return DSERR_INVALIDPARAM;
-    }
-
-    if (dsbd->dwSize != sizeof(DSBUFFERDESC) &&
-        dsbd->dwSize != sizeof(DSBUFFERDESC1)) {
-        WARN("invalid parameter: dsbd\n");
-        return DSERR_INVALIDPARAM;
-    }
-
-    if (ppdsb == NULL) {
-        WARN("invalid parameter: ppdsb == NULL\n");
-        return DSERR_INVALIDPARAM;
-    }
-    *ppdsb = NULL;
-
-    if (TRACE_ON(dsound)) {
-        TRACE("(structsize=%d)\n",dsbd->dwSize);
-        TRACE("(flags=0x%08x:\n",dsbd->dwFlags);
-        _dump_DSBCAPS(dsbd->dwFlags);
-        TRACE(")\n");
-        TRACE("(bufferbytes=%d)\n",dsbd->dwBufferBytes);
-        TRACE("(lpwfxFormat=%p)\n",dsbd->lpwfxFormat);
-    }
-
-    if (dsbd->dwFlags & DSBCAPS_PRIMARYBUFFER) {
-        if (dsbd->lpwfxFormat != NULL) {
-            WARN("invalid parameter: dsbd->lpwfxFormat must be NULL for "
-                 "primary buffer\n");
-            return DSERR_INVALIDPARAM;
-        }
-
-        if (device->primary) {
-            WARN("Primary Buffer already created\n");
-            IDirectSoundBuffer_AddRef((LPDIRECTSOUNDBUFFER8)(device->primary));
-            *ppdsb = (LPDIRECTSOUNDBUFFER)(device->primary);
-        } else {
-            hres = primarybuffer_create(device, &device->primary, dsbd);
-            if (device->primary) {
-                *ppdsb = (IDirectSoundBuffer*)&device->primary->IDirectSoundBuffer8_iface;
-                device->primary->dsbd.dwFlags &= ~(DSBCAPS_LOCHARDWARE | DSBCAPS_LOCSOFTWARE);
-                if (device->hwbuf)
-                    device->primary->dsbd.dwFlags |= DSBCAPS_LOCHARDWARE;
-                else
-                    device->primary->dsbd.dwFlags |= DSBCAPS_LOCSOFTWARE;
-            } else
-                WARN("primarybuffer_create() failed\n");
-        }
-    } else {
-        IDirectSoundBufferImpl * dsb;
-        WAVEFORMATEXTENSIBLE *pwfxe;
-
-        if (dsbd->lpwfxFormat == NULL) {
-            WARN("invalid parameter: dsbd->lpwfxFormat can't be NULL for "
-                 "secondary buffer\n");
-            return DSERR_INVALIDPARAM;
-        }
-        pwfxe = (WAVEFORMATEXTENSIBLE*)dsbd->lpwfxFormat;
-
-        if (pwfxe->Format.wBitsPerSample != 16 && pwfxe->Format.wBitsPerSample != 8 && pwfxe->Format.wFormatTag != WAVE_FORMAT_EXTENSIBLE)
-        {
-            WARN("wBitsPerSample=%d needs a WAVEFORMATEXTENSIBLE\n", dsbd->lpwfxFormat->wBitsPerSample);
-            return DSERR_CONTROLUNAVAIL;
-        }
-        if (pwfxe->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE)
-        {
-            /* check if cbSize is at least 22 bytes */
-            if (pwfxe->Format.cbSize < (sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX)))
-            {
-                WARN("Too small a cbSize %u\n", pwfxe->Format.cbSize);
-                return DSERR_INVALIDPARAM;
-            }
-
-            /* cbSize should be 22 bytes, with one possible exception */
-            if (pwfxe->Format.cbSize > (sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX)) &&
-                !((IsEqualGUID(&pwfxe->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM) || IsEqualGUID(&pwfxe->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)) &&
-                pwfxe->Format.cbSize == sizeof(WAVEFORMATEXTENSIBLE)))
-            {
-                WARN("Too big a cbSize %u\n", pwfxe->Format.cbSize);
-                return DSERR_CONTROLUNAVAIL;
-            }
-
-            if ((!IsEqualGUID(&pwfxe->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM)) && (!IsEqualGUID(&pwfxe->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)))
-            {
-                if (!IsEqualGUID(&pwfxe->SubFormat, &GUID_NULL))
-                    FIXME("SubFormat %s not supported right now.\n", debugstr_guid(&pwfxe->SubFormat));
-                return DSERR_INVALIDPARAM;
-            }
-            if (pwfxe->Samples.wValidBitsPerSample > dsbd->lpwfxFormat->wBitsPerSample)
-            {
-                WARN("Samples.wValidBitsPerSample(%d) > Format.wBitsPerSample (%d)\n", pwfxe->Samples.wValidBitsPerSample, pwfxe->Format.wBitsPerSample);
-                return DSERR_INVALIDPARAM;
-            }
-            if (pwfxe->Samples.wValidBitsPerSample && pwfxe->Samples.wValidBitsPerSample < dsbd->lpwfxFormat->wBitsPerSample)
-            {
-                FIXME("Non-packed formats not supported right now: %d/%d\n", pwfxe->Samples.wValidBitsPerSample, dsbd->lpwfxFormat->wBitsPerSample);
-                return DSERR_CONTROLUNAVAIL;
-            }
-        }
-
-        TRACE("(formattag=0x%04x,chans=%d,samplerate=%d,"
-              "bytespersec=%d,blockalign=%d,bitspersamp=%d,cbSize=%d)\n",
-              dsbd->lpwfxFormat->wFormatTag, dsbd->lpwfxFormat->nChannels,
-              dsbd->lpwfxFormat->nSamplesPerSec,
-              dsbd->lpwfxFormat->nAvgBytesPerSec,
-              dsbd->lpwfxFormat->nBlockAlign,
-              dsbd->lpwfxFormat->wBitsPerSample, dsbd->lpwfxFormat->cbSize);
-
-        if (from8 && (dsbd->dwFlags & DSBCAPS_CTRL3D) && (dsbd->lpwfxFormat->nChannels != 1)) {
-            WARN("invalid parameter: 3D buffer format must be mono\n");
-            return DSERR_INVALIDPARAM;
-        }
-
-        hres = IDirectSoundBufferImpl_Create(device, &dsb, dsbd);
-        if (dsb)
-            *ppdsb = (IDirectSoundBuffer*)&dsb->IDirectSoundBuffer8_iface;
-        else
-            WARN("IDirectSoundBufferImpl_Create failed\n");
-   }
-
-   return hres;
-}
-
-HRESULT DirectSoundDevice_DuplicateSoundBuffer(
-    DirectSoundDevice * device,
-    LPDIRECTSOUNDBUFFER psb,
-    LPLPDIRECTSOUNDBUFFER ppdsb)
-{
-    HRESULT hres = DS_OK;
-    IDirectSoundBufferImpl* dsb;
-    TRACE("(%p,%p,%p)\n",device,psb,ppdsb);
-
-    if (device == NULL) {
-        WARN("not initialized\n");
-        return DSERR_UNINITIALIZED;
-    }
-
-    if (psb == NULL) {
-        WARN("invalid parameter: psb == NULL\n");
-        return DSERR_INVALIDPARAM;
-    }
-
-    if (ppdsb == NULL) {
-        WARN("invalid parameter: ppdsb == NULL\n");
-        return DSERR_INVALIDPARAM;
-    }
-
-    /* make sure we have a secondary buffer */
-    if (psb == (IDirectSoundBuffer *)&device->primary->IDirectSoundBuffer8_iface) {
-        WARN("trying to duplicate primary buffer\n");
-        *ppdsb = NULL;
-        return DSERR_INVALIDCALL;
-    }
-
-    /* duplicate the actual buffer implementation */
-    hres = IDirectSoundBufferImpl_Duplicate(device, &dsb, (IDirectSoundBufferImpl*)psb);
-    if (hres == DS_OK)
-        *ppdsb = (IDirectSoundBuffer*)&dsb->IDirectSoundBuffer8_iface;
-    else
-        WARN("IDirectSoundBufferImpl_Duplicate failed\n");
-
-    return hres;
-}
-
-HRESULT DirectSoundDevice_SetCooperativeLevel(
-    DirectSoundDevice * device,
-    HWND hwnd,
-    DWORD level)
-{
-    TRACE("(%p,%p,%s)\n",device,hwnd,dumpCooperativeLevel(level));
-
-    if (device == NULL) {
-        WARN("not initialized\n");
-        return DSERR_UNINITIALIZED;
-    }
-
-    if (level==DSSCL_PRIORITY || level==DSSCL_EXCLUSIVE) {
-        WARN("level=%s not fully supported\n",
-             level==DSSCL_PRIORITY ? "DSSCL_PRIORITY" : "DSSCL_EXCLUSIVE");
-    }
-
-    device->priolevel = level;
-    return DS_OK;
-}
-
-HRESULT DirectSoundDevice_Compact(
-    DirectSoundDevice * device)
-{
-    TRACE("(%p)\n", device);
-
-    if (device == NULL) {
-        WARN("not initialized\n");
-        return DSERR_UNINITIALIZED;
-    }
-
-    if (device->priolevel < DSSCL_PRIORITY) {
-        WARN("incorrect priority level\n");
-        return DSERR_PRIOLEVELNEEDED;
-    }
-
-    return DS_OK;
-}
-
-HRESULT DirectSoundDevice_GetSpeakerConfig(
-    DirectSoundDevice * device,
-    LPDWORD lpdwSpeakerConfig)
-{
-    TRACE("(%p, %p)\n", device, lpdwSpeakerConfig);
-
-    if (device == NULL) {
-        WARN("not initialized\n");
-        return DSERR_UNINITIALIZED;
-    }
-
-    if (lpdwSpeakerConfig == NULL) {
-        WARN("invalid parameter: lpdwSpeakerConfig == NULL\n");
-        return DSERR_INVALIDPARAM;
-    }
-
-    WARN("not fully functional\n");
-    *lpdwSpeakerConfig = device->speaker_config;
-    return DS_OK;
-}
-
-HRESULT DirectSoundDevice_SetSpeakerConfig(
-    DirectSoundDevice * device,
-    DWORD config)
-{
-    TRACE("(%p,0x%08x)\n",device,config);
-
-    if (device == NULL) {
-        WARN("not initialized\n");
-        return DSERR_UNINITIALIZED;
-    }
-
-    device->speaker_config = config;
-    WARN("not fully functional\n");
-    return DS_OK;
-}
-
-HRESULT DirectSoundDevice_VerifyCertification(
-    DirectSoundDevice * device,
-    LPDWORD pdwCertified)
-{
-    TRACE("(%p, %p)\n",device,pdwCertified);
-
-    if (device == NULL) {
-        WARN("not initialized\n");
-        return DSERR_UNINITIALIZED;
-    }
-
-    if (device->drvcaps.dwFlags & DSCAPS_CERTIFIED)
-        *pdwCertified = DS_CERTIFIED;
-    else
-        *pdwCertified = DS_UNCERTIFIED;
-
-    return DS_OK;
-}
-
-/*
- * Add secondary buffer to buffer list.
- * Gets exclusive access to buffer for writing.
- */
-HRESULT DirectSoundDevice_AddBuffer(
-    DirectSoundDevice * device,
-    IDirectSoundBufferImpl * pDSB)
-{
-    IDirectSoundBufferImpl **newbuffers;
-    HRESULT hr = DS_OK;
-
-    TRACE("(%p, %p)\n", device, pDSB);
-
-    RtlAcquireResourceExclusive(&(device->buffer_list_lock), TRUE);
-
-    if (device->buffers)
-        newbuffers = HeapReAlloc(GetProcessHeap(),0,device->buffers,sizeof(IDirectSoundBufferImpl*)*(device->nrofbuffers+1));
-    else
-        newbuffers = HeapAlloc(GetProcessHeap(),0,sizeof(IDirectSoundBufferImpl*)*(device->nrofbuffers+1));
-
-    if (newbuffers) {
-        device->buffers = newbuffers;
-        device->buffers[device->nrofbuffers] = pDSB;
-        device->nrofbuffers++;
-        TRACE("buffer count is now %d\n", device->nrofbuffers);
-    } else {
-        ERR("out of memory for buffer list! Current buffer count is %d\n", device->nrofbuffers);
-        hr = DSERR_OUTOFMEMORY;
-    }
-
-    RtlReleaseResource(&(device->buffer_list_lock));
-
-    return hr;
-}
-
-/*
- * Remove secondary buffer from buffer list.
- * Gets exclusive access to buffer for writing.
- */
-HRESULT DirectSoundDevice_RemoveBuffer(
-    DirectSoundDevice * device,
-    IDirectSoundBufferImpl * pDSB)
-{
-    int i;
-    HRESULT hr = DS_OK;
-
-    TRACE("(%p, %p)\n", device, pDSB);
-
-    RtlAcquireResourceExclusive(&(device->buffer_list_lock), TRUE);
-
-    for (i = 0; i < device->nrofbuffers; i++)
-        if (device->buffers[i] == pDSB)
-            break;
-
-    if (i < device->nrofbuffers) {
-        /* Put the last buffer of the list in the (now empty) position */
-        device->buffers[i] = device->buffers[device->nrofbuffers - 1];
-        device->nrofbuffers--;
-        device->buffers = HeapReAlloc(GetProcessHeap(),0,device->buffers,sizeof(LPDIRECTSOUNDBUFFER8)*device->nrofbuffers);
-        TRACE("buffer count is now %d\n", device->nrofbuffers);
-    }
-
-    if (device->nrofbuffers == 0) {
-        HeapFree(GetProcessHeap(),0,device->buffers);
-        device->buffers = NULL;
-    }
-
-    RtlReleaseResource(&(device->buffer_list_lock));
-
-    return hr;
-}
diff --git a/dlls/dsound/dsound_convert.c b/dlls/dsound/dsound_convert.c
deleted file mode 100644
index 057ae16..0000000
--- a/dlls/dsound/dsound_convert.c
+++ /dev/null
@@ -1,546 +0,0 @@
-/* DirectSound format conversion and mixing routines
- *
- * Copyright 2007 Maarten Lankhorst
- * Copyright 2011 Owen Rudge for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-/* 8 bits is unsigned, the rest is signed.
- * First I tried to reuse existing stuff from alsa-lib, after that
- * didn't work, I gave up and just went for individual hacks.
- *
- * 24 bit is expensive to do, due to unaligned access.
- * In dlls/winex11.drv/dib_convert.c convert_888_to_0888_asis there is a way
- * around it, but I'm happy current code works, maybe something for later.
- *
- * The ^ 0x80 flips the signed bit, this is the conversion from
- * signed (-128.. 0.. 127) to unsigned (0...255)
- * This is only temporary: All 8 bit data should be converted to signed.
- * then when fed to the sound card, it should be converted to unsigned again.
- *
- * Sound is LITTLE endian
- */
-
-#include "config.h"
-
-#include <stdarg.h>
-
-#define NONAMELESSSTRUCT
-#define NONAMELESSUNION
-#include "windef.h"
-#include "winbase.h"
-#include "mmsystem.h"
-#include "winternl.h"
-#include "wine/debug.h"
-#include "dsound.h"
-#include "dsdriver.h"
-#include "dsound_private.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(dsound);
-
-#ifdef WORDS_BIGENDIAN
-#define le16(x) RtlUshortByteSwap((x))
-#define le32(x) RtlUlongByteSwap((x))
-#else
-#define le16(x) (x)
-#define le32(x) (x)
-#endif
-
-static inline void src_advance(const void **src, UINT stride, INT *count, UINT *freqAcc, UINT adj)
-{
-    *freqAcc += adj;
-    if (*freqAcc >= (1 << DSOUND_FREQSHIFT))
-    {
-        ULONG adv = (*freqAcc >> DSOUND_FREQSHIFT);
-        *freqAcc &= (1 << DSOUND_FREQSHIFT) - 1;
-        *(const char **)src += adv * stride;
-        *count -= adv;
-    }
-}
-
-static void convert_8_to_8 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        *(BYTE *)dst = *(const BYTE *)src;
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_8_to_16 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        WORD dest = *(const BYTE *)src, *dest16 = dst;
-        *dest16 = le16(dest * 257 - 32768);
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_8_to_24 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        BYTE dest = *(const BYTE *)src;
-        BYTE *dest24 = dst;
-        dest24[0] = dest;
-        dest24[1] = dest;
-        dest24[2] = dest - 0x80;
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_8_to_32 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        DWORD dest = *(const BYTE *)src, *dest32 = dst;
-        *dest32 = le32(dest * 16843009 - 2147483648U);
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_16_to_8 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        BYTE *dst8 = dst;
-        *dst8 = (le16(*(const WORD *)src)) / 256;
-        *dst8 -= 0x80;
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_16_to_16 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        *(WORD *)dst = *(const WORD *)src;
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_16_to_24 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        WORD dest = le16(*(const WORD *)src);
-        BYTE *dest24 = dst;
-
-        dest24[0] = dest / 256;
-        dest24[1] = dest;
-        dest24[2] = dest / 256;
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_16_to_32 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        DWORD dest = *(const WORD *)src, *dest32 = dst;
-        *dest32 = dest * 65537;
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_24_to_8 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        BYTE *dst8 = dst;
-        *dst8 = ((const BYTE *)src)[2];
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_24_to_16 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        WORD *dest16 = dst;
-        const BYTE *source = src;
-        *dest16 = le16(source[2] * 256 + source[1]);
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_24_to_24 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        BYTE *dest24 = dst;
-        const BYTE *src24 = src;
-
-        dest24[0] = src24[0];
-        dest24[1] = src24[1];
-        dest24[2] = src24[2];
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_24_to_32 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        DWORD *dest32 = dst;
-        const BYTE *source = src;
-        *dest32 = le32(source[2] * 16777217 + source[1] * 65536 + source[0] * 256);
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_32_to_8 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        BYTE *dst8 = dst;
-        *dst8 = (le32(*(const DWORD *)src) / 16777216);
-        *dst8 -= 0x80;
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_32_to_16 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        WORD *dest16 = dst;
-        *dest16 = le16(le32(*(const DWORD *)src) / 65536);
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_32_to_24 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        DWORD dest = le32(*(const DWORD *)src);
-        BYTE *dest24 = dst;
-
-        dest24[0] = dest / 256;
-        dest24[1] = dest / 65536;
-        dest24[2] = dest / 16777216;
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_32_to_32 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        DWORD *dest = dst;
-        *dest = *(const DWORD *)src;
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_ieee_32_to_8 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        DWORD src_le = le32(*(DWORD *) src);
-        float v = *((float *) &src_le);
-        INT8 d = 0;
-
-        if (v < -1.0f)
-            d = -128;
-        else if (v >  1.0f)
-            d = 127;
-        else
-            d = v * 127.5f - 0.5f;
-
-        *(BYTE *) dst = d ^ 0x80;
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_ieee_32_to_16 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        DWORD src_le = le32(*(DWORD *) src);
-        float v = *((float *) &src_le);
-
-        INT16 *d = (INT16 *) dst;
-
-        if (v < -1.0f)
-            *d = -32768;
-        else if (v >  1.0f)
-            *d = 32767;
-        else
-            *d = v * 32767.5f - 0.5f;
-
-        *d = le16(*d);
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_ieee_32_to_24 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        DWORD src_le = le32(*(DWORD *) src);
-        float v = *((float *) &src_le);
-        BYTE *dest24 = dst;
-
-        if (v < -1.0f)
-        {
-            dest24[0] = 0;
-            dest24[1] = 0;
-            dest24[2] = 0x80;
-        }
-        else if (v > 1.0f)
-        {
-            dest24[0] = 0xff;
-            dest24[1] = 0xff;
-            dest24[2] = 0x7f;
-        }
-        else if (v < 0.0f)
-        {
-            dest24[0] = v * 8388608.0f;
-            dest24[1] = v * 32768.0f;
-            dest24[2] = v * 128.0f;
-        }
-        else if (v >= 0.0f)
-        {
-            dest24[0] = v * 8388608.0f;
-            dest24[1] = v * 32768.0f;
-            dest24[2] = v * 127.0f;
-        }
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-static void convert_ieee_32_to_32 (const void *src, void *dst, UINT src_stride,
-        UINT dst_stride, INT count, UINT freqAcc, UINT adj)
-{
-    while (count > 0)
-    {
-        DWORD src_le = le32(*(DWORD *) src);
-        float v = *((float *) &src_le);
-        INT32 *d = (INT32 *) dst;
-
-        if (v < -1.0f)
-            *d = -2147483647 - 1; /* silence warning */
-        else if (v >  1.0f)
-            *d = 2147483647;
-        else
-            *d = v * 2147483647.5f - 0.5f;
-
-        *d = le32(*d);
-
-        dst = (char *)dst + dst_stride;
-        src_advance(&src, src_stride, &count, &freqAcc, adj);
-    }
-}
-
-const bitsconvertfunc convertbpp[5][4] = {
-    { convert_8_to_8, convert_8_to_16, convert_8_to_24, convert_8_to_32 },
-    { convert_16_to_8, convert_16_to_16, convert_16_to_24, convert_16_to_32 },
-    { convert_24_to_8, convert_24_to_16, convert_24_to_24, convert_24_to_32 },
-    { convert_32_to_8, convert_32_to_16, convert_32_to_24, convert_32_to_32 },
-    { convert_ieee_32_to_8, convert_ieee_32_to_16, convert_ieee_32_to_24, convert_ieee_32_to_32 },
-};
-
-static void mix8(signed char *src, INT *dst, unsigned len)
-{
-    TRACE("%p - %p %d\n", src, dst, len);
-    while (len--)
-        /* 8-bit WAV is unsigned, it's here converted to signed, normalize function will convert it back again */
-        *(dst++) += (signed char)((BYTE)*(src++) - (BYTE)0x80);
-}
-
-static void mix16(SHORT *src, INT *dst, unsigned len)
-{
-    TRACE("%p - %p %d\n", src, dst, len);
-    len /= 2;
-    while (len--)
-    {
-        *dst += le16(*src);
-        ++dst; ++src;
-    }
-}
-
-static void mix24(BYTE *src, INT *dst, unsigned len)
-{
-    TRACE("%p - %p %d\n", src, dst, len);
-    len /= 3;
-    while (len--)
-    {
-        DWORD field;
-        field = ((DWORD)src[2] << 16) + ((DWORD)src[1] << 8) + (DWORD)src[0];
-        if (src[2] & 0x80)
-            field |= 0xFF000000U;
-        *(dst++) += field;
-        ++src;
-    }
-}
-
-static void mix32(INT *src, LONGLONG *dst, unsigned len)
-{
-    TRACE("%p - %p %d\n", src, dst, len);
-    len /= 4;
-    while (len--)
-        *(dst++) += le32(*(src++));
-}
-
-const mixfunc mixfunctions[4] = {
-    (mixfunc)mix8,
-    (mixfunc)mix16,
-    (mixfunc)mix24,
-    (mixfunc)mix32
-};
-
-static void norm8(INT *src, signed char *dst, unsigned len)
-{
-    TRACE("%p - %p %d\n", src, dst, len);
-    while (len--)
-    {
-        *dst = (*src) + 0x80;
-        if (*src < -0x80)
-            *dst = 0;
-        else if (*src > 0x7f)
-            *dst = 0xff;
-        ++dst;
-        ++src;
-    }
-}
-
-static void norm16(INT *src, SHORT *dst, unsigned len)
-{
-    TRACE("%p - %p %d\n", src, dst, len);
-    len /= 2;
-    while (len--)
-    {
-        *dst = le16(*src);
-        if (*src <= -0x8000)
-            *dst = le16(0x8000);
-        else if (*src > 0x7fff)
-            *dst = le16(0x7fff);
-        ++dst;
-        ++src;
-    }
-}
-
-static void norm24(INT *src, BYTE *dst, unsigned len)
-{
-    TRACE("%p - %p %d\n", src, dst, len);
-    len /= 3;
-    while (len--)
-    {
-        if (*src <= -0x800000)
-        {
-            dst[0] = 0;
-            dst[1] = 0;
-            dst[2] = 0x80;
-        }
-        else if (*src > 0x7fffff)
-        {
-            dst[0] = 0xff;
-            dst[1] = 0xff;
-            dst[2] = 0x7f;
-        }
-        else
-        {
-            dst[0] = *src;
-            dst[1] = *src >> 8;
-            dst[2] = *src >> 16;
-        }
-        ++dst;
-        ++src;
-    }
-}
-
-static void norm32(LONGLONG *src, INT *dst, unsigned len)
-{
-    TRACE("%p - %p %d\n", src, dst, len);
-    len /= 4;
-    while (len--)
-    {
-        *dst = le32(*src);
-        if (*src <= -(LONGLONG)0x80000000)
-            *dst = le32(0x80000000);
-        else if (*src > 0x7fffffff)
-            *dst = le32(0x7fffffff);
-        ++dst;
-        ++src;
-    }
-}
-
-const normfunc normfunctions[4] = {
-    (normfunc)norm8,
-    (normfunc)norm16,
-    (normfunc)norm24,
-    (normfunc)norm32,
-};
diff --git a/dlls/dsound/dsound_main.c b/dlls/dsound/dsound_main.c
index 81dd7dd..b95f1a0 100644
--- a/dlls/dsound/dsound_main.c
+++ b/dlls/dsound/dsound_main.c
@@ -32,11 +32,14 @@
  *      Remove DS_HEL_FRAGS and use mixer fragment length for it
  */
 
-#include <stdarg.h>
-
 #define COBJMACROS
 #define NONAMELESSSTRUCT
 #define NONAMELESSUNION
+#include "config.h"
+#include "wine/port.h"
+#include <stdarg.h>
+#include "wine/library.h"
+
 #include "windef.h"
 #include "winbase.h"
 #include "winuser.h"
@@ -50,175 +53,444 @@
 #include "dsconf.h"
 #include "ks.h"
 #include "rpcproxy.h"
+#include "rpc.h"
+#include "rpcndr.h"
+#include "unknwn.h"
+#include "oleidl.h"
+#include "shobjidl.h"
+
 #include "initguid.h"
 #include "ksmedia.h"
 #include "dsdriver.h"
+#include "propkey.h"
+#include "devpkey.h"
 
 #include "dsound_private.h"
+#include "eax.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(dsound);
 
-DirectSoundDevice*	DSOUND_renderer[MAXWAVEDRIVERS];
-GUID                    DSOUND_renderer_guids[MAXWAVEDRIVERS];
-GUID                    DSOUND_capture_guids[MAXWAVEDRIVERS];
+IID DSPROPSETID_EAX20_ListenerProperties = {
+    0x0306a6a8, 0xb224, 0x11d2, { 0x99, 0xe5, 0x00, 0x00, 0xe8, 0xd8, 0xc7, 0x22 }
+};
 
-HRESULT mmErr(UINT err)
+const EAXLISTENERPROPERTIES EnvironmentDefaults[EAX_ENVIRONMENT_COUNT] =
 {
-	switch(err) {
-	case MMSYSERR_NOERROR:
-		return DS_OK;
-	case MMSYSERR_ALLOCATED:
-		return DSERR_ALLOCATED;
-	case MMSYSERR_ERROR:
-	case MMSYSERR_INVALHANDLE:
-	case WAVERR_STILLPLAYING:
-		return DSERR_GENERIC; /* FIXME */
-	case MMSYSERR_NODRIVER:
-		return DSERR_NODRIVER;
-	case MMSYSERR_NOMEM:
-		return DSERR_OUTOFMEMORY;
-	case MMSYSERR_INVALPARAM:
-	case WAVERR_BADFORMAT:
-	case WAVERR_UNPREPARED:
-		return DSERR_INVALIDPARAM;
-	case MMSYSERR_NOTSUPPORTED:
-		return DSERR_UNSUPPORTED;
-	default:
-		FIXME("Unknown MMSYS error %d\n",err);
-		return DSERR_GENERIC;
-	}
-}
+    REVERB_PRESET_GENERIC,
+    REVERB_PRESET_PADDEDCELL,
+    REVERB_PRESET_ROOM,
+    REVERB_PRESET_BATHROOM,
+    REVERB_PRESET_LIVINGROOM,
+    REVERB_PRESET_STONEROOM,
+    REVERB_PRESET_AUDITORIUM,
+    REVERB_PRESET_CONCERTHALL,
+    REVERB_PRESET_CAVE,
+    REVERB_PRESET_ARENA,
+    REVERB_PRESET_HANGAR,
+    REVERB_PRESET_CARPETEDHALLWAY,
+    REVERB_PRESET_HALLWAY,
+    REVERB_PRESET_STONECORRIDOR,
+    REVERB_PRESET_ALLEY,
+    REVERB_PRESET_FOREST,
+    REVERB_PRESET_CITY,
+    REVERB_PRESET_MOUNTAINS,
+    REVERB_PRESET_QUARRY,
+    REVERB_PRESET_PLAIN,
+    REVERB_PRESET_PARKINGLOT,
+    REVERB_PRESET_SEWERPIPE,
+    REVERB_PRESET_UNDERWATER,
+    REVERB_PRESET_DRUGGED,
+    REVERB_PRESET_DIZZY,
+    REVERB_PRESET_PSYCHOTIC
+};
 
-/* All default settings, you most likely don't want to touch these, see wiki on UsefulRegistryKeys */
-int ds_emuldriver = 0;
-int ds_hel_buflen = 32768 * 2;
-int ds_snd_queue_max = 10;
-int ds_snd_queue_min = 6;
-int ds_snd_shadow_maxsize = 2;
-int ds_hw_accel = DS_HW_ACCEL_FULL;
-int ds_default_sample_rate = 44100;
-int ds_default_bits_per_sample = 16;
-static int ds_default_playback;
-static int ds_default_capture;
-static HINSTANCE instance;
+static IMMDeviceEnumerator *mme = NULL;
 
-/*
- * Get a config key from either the app-specific or the default config
- */
-
-static inline DWORD get_config_key( HKEY defkey, HKEY appkey, const char *name,
-                                    char *buffer, DWORD size )
+static CALLBACK DWORD DSOUND_mmdevapi_thread(void *data)
 {
-    if (appkey && !RegQueryValueExA( appkey, name, 0, NULL, (LPBYTE)buffer, &size )) return 0;
-    if (defkey && !RegQueryValueExA( defkey, name, 0, NULL, (LPBYTE)buffer, &size )) return 0;
-    return ERROR_FILE_NOT_FOUND;
+    MSG msg;
+    HRESULT hr;
+    IMMDeviceEnumerator *mymme = NULL;
+    CoInitializeEx(NULL, COINIT_MULTITHREADED);
+    PeekMessageW(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);
+    hr = CoCreateInstance(&CLSID_MMDeviceEnumerator, NULL, CLSCTX_INPROC_SERVER, &IID_IMMDeviceEnumerator, (void**)&mymme);
+    if (SUCCEEDED(hr))
+        mme = mymme;
+    SetEvent((HANDLE)data);
+    if (FAILED(hr))
+    {
+        ERR("Cannot use mmdevapi: %08x\n", hr);
+        goto out;
+    }
+    while (GetMessageW(&msg, NULL, 0, 0))
+    {
+        if (msg.hwnd)
+        {
+            DispatchMessageW(&msg);
+            continue;
+        }
+        ERR("Unknown message: %04x\n", msg.message);
+    }
+out:
+    if (mme)
+        IMMDeviceEnumerator_Release(mme);
+    mme = NULL;
+    CoUninitialize();
+    return 0;
 }
 
+static HANDLE DSOUND_mmdevapi_thread_handle;
+static DWORD DSOUND_mmdevapi_id;
 
-/*
- * Setup the dsound options.
- */
-
-void setup_dsound_options(void)
+CRITICAL_SECTION mme_crst;
+static CRITICAL_SECTION_DEBUG mme_crst_debug =
 {
-    char buffer[MAX_PATH+16];
-    HKEY hkey, appkey = 0;
-    DWORD len;
-
-    buffer[MAX_PATH]='\0';
+    0, 0, &mme_crst,
+    { &mme_crst_debug.ProcessLocksList,
+      &mme_crst_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": mme_crst_debug") }
+};
+CRITICAL_SECTION mme_crst = { &mme_crst_debug, -1, 0, 0, 0, 0 };
 
-    /* @@ Wine registry key: HKCU\Software\Wine\DirectSound */
-    if (RegOpenKeyA( HKEY_CURRENT_USER, "Software\\Wine\\DirectSound", &hkey )) hkey = 0;
+IMMDeviceEnumerator *DSOUND_obtain_mme(void)
+{
+    EnterCriticalSection(&mme_crst);
+    if (!DSOUND_mmdevapi_id)
+    {
+        HANDLE ev = CreateEventW(0, 0, 0, 0);
+        DSOUND_mmdevapi_thread_handle = CreateThread(0, 0, DSOUND_mmdevapi_thread, ev, 0, &DSOUND_mmdevapi_id);
+        WaitForSingleObject(ev, INFINITE);
+        CloseHandle(ev);
+    }
+    LeaveCriticalSection(&mme_crst);
+    return mme;
+}
 
-    len = GetModuleFileNameA( 0, buffer, MAX_PATH );
-    if (len && len < MAX_PATH)
+HRESULT DSOUND_obtain_immdevice(EDataFlow flow, const GUID *guid, ERole role, IMMDevice **dev)
+{
+    IMMDeviceCollection *col;
+    HRESULT hr;
+    GUID curguid;
+    int i = 0;
+    if (!DSOUND_obtain_mme())
+        return DSERR_NODRIVER;
+    if (flow == eCapture && (IsEqualGUID(guid, &DSDEVID_DefaultVoiceCapture) ||
+                             IsEqualGUID(guid, &DSDEVID_DefaultCapture)))
+        return IMMDeviceEnumerator_GetDefaultAudioEndpoint(mme, flow, role, dev);
+    if (flow == eRender && (IsEqualGUID(guid, &DSDEVID_DefaultVoicePlayback) ||
+                             IsEqualGUID(guid, &DSDEVID_DefaultPlayback)))
+        return IMMDeviceEnumerator_GetDefaultAudioEndpoint(mme, flow, role, dev);
+    hr = IMMDeviceEnumerator_EnumAudioEndpoints(mme, flow, DEVICE_STATE_ACTIVE, &col);
+    if (FAILED(hr))
+        return E_NOTFOUND;
+    while (SUCCEEDED(IMMDeviceCollection_Item(col, i++, dev)))
     {
-        HKEY tmpkey;
-        /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\DirectSound */
-        if (!RegOpenKeyA( HKEY_CURRENT_USER, "Software\\Wine\\AppDefaults", &tmpkey ))
+        hr = DSOUND_immdevice_getguid(*dev, &curguid);
+        if (SUCCEEDED(hr) && IsEqualGUID(&curguid, guid))
         {
-            char *p, *appname = buffer;
-            if ((p = strrchr( appname, '/' ))) appname = p + 1;
-            if ((p = strrchr( appname, '\\' ))) appname = p + 1;
-            strcat( appname, "\\DirectSound" );
-            TRACE("appname = [%s]\n", appname);
-            if (RegOpenKeyA( tmpkey, appname, &appkey )) appkey = 0;
-            RegCloseKey( tmpkey );
+            IMMDeviceCollection_Release(col);
+            return S_OK;
         }
+        IMMDevice_Release(*dev);
     }
+    IMMDeviceCollection_Release(col);
+    *dev = NULL;
+    return E_NOTFOUND;
+}
 
-    /* get options */
-
-    if (!get_config_key( hkey, appkey, "EmulDriver", buffer, MAX_PATH ))
-        ds_emuldriver = strcmp(buffer, "N");
+HRESULT DSOUND_enumerate_immdevice(EDataFlow flow, IMMDeviceCollection **collection)
+{
+    if (!DSOUND_obtain_mme())
+        return DSERR_NODRIVER;
+    return IMMDeviceEnumerator_EnumAudioEndpoints(mme, flow, DEVICE_STATE_ACTIVE, collection);
+}
 
-    if (!get_config_key( hkey, appkey, "HelBuflen", buffer, MAX_PATH ))
-        ds_hel_buflen = atoi(buffer);
+HRESULT DSOUND_immdevice_getguid(IMMDevice *dev, GUID *guid)
+{
+    IPropertyStore *store;
+    PROPVARIANT pv = { VT_EMPTY };
+    HRESULT hr;
+    hr = IMMDevice_OpenPropertyStore(dev, STGM_READ, &store);
+    if (FAILED(hr))
+        return hr;
+    hr = IPropertyStore_GetValue(store, &PKEY_AudioEndpoint_GUID, &pv);
+    if (FAILED(hr))
+    {
+        IPropertyStore_Release(store);
+        return hr;
+    }
+    CLSIDFromString(pv.u.pwszVal, guid);
+    PropVariantClear(&pv);
+    IPropertyStore_Release(store);
+    return S_OK;
+}
 
-    if (!get_config_key( hkey, appkey, "SndQueueMax", buffer, MAX_PATH ))
-        ds_snd_queue_max = atoi(buffer);
+/* Some games keep a pointer to the guid instead of copying the guid itself, so keep a copy here */
+static GUID DSOUND_capture_guids[MAXWAVEDRIVERS];
+static GUID DSOUND_renderer_guids[MAXWAVEDRIVERS];
 
-    if (!get_config_key( hkey, appkey, "SndQueueMin", buffer, MAX_PATH ))
-        ds_snd_queue_min = atoi(buffer);
+#ifdef HAVE_OPENAL
 
-    if (!get_config_key( hkey, appkey, "HardwareAcceleration", buffer, MAX_PATH )) {
-	if (strcmp(buffer, "Full") == 0)
-	    ds_hw_accel = DS_HW_ACCEL_FULL;
-	else if (strcmp(buffer, "Standard") == 0)
-	    ds_hw_accel = DS_HW_ACCEL_STANDARD;
-	else if (strcmp(buffer, "Basic") == 0)
-	    ds_hw_accel = DS_HW_ACCEL_BASIC;
-	else if (strcmp(buffer, "Emulation") == 0)
-	    ds_hw_accel = DS_HW_ACCEL_EMULATION;
+static CRITICAL_SECTION_DEBUG openal_crst_debug =
+{
+    0, 0, &openal_crst,
+    { &openal_crst_debug.ProcessLocksList,
+      &openal_crst_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": openal_crst_debug") }
+};
+CRITICAL_SECTION openal_crst = { &openal_crst_debug, -1, 0, 0, 0, 0 };
+
+static void *openal_handle = RTLD_DEFAULT;
+int openal_loaded = 0;
+#ifdef SONAME_LIBOPENAL
+LPALCCREATECONTEXT palcCreateContext = NULL;
+LPALCMAKECONTEXTCURRENT palcMakeContextCurrent = NULL;
+LPALCPROCESSCONTEXT palcProcessContext = NULL;
+LPALCSUSPENDCONTEXT palcSuspendContext = NULL;
+LPALCDESTROYCONTEXT palcDestroyContext = NULL;
+LPALCGETCURRENTCONTEXT palcGetCurrentContext = NULL;
+LPALCGETCONTEXTSDEVICE palcGetContextsDevice = NULL;
+LPALCOPENDEVICE palcOpenDevice = NULL;
+LPALCCLOSEDEVICE palcCloseDevice = NULL;
+LPALCGETERROR palcGetError = NULL;
+LPALCISEXTENSIONPRESENT palcIsExtensionPresent = NULL;
+LPALCGETPROCADDRESS palcGetProcAddress = NULL;
+LPALCGETENUMVALUE palcGetEnumValue = NULL;
+LPALCGETSTRING palcGetString = NULL;
+LPALCGETINTEGERV palcGetIntegerv = NULL;
+LPALCCAPTUREOPENDEVICE palcCaptureOpenDevice = NULL;
+LPALCCAPTURECLOSEDEVICE palcCaptureCloseDevice = NULL;
+LPALCCAPTURESTART palcCaptureStart = NULL;
+LPALCCAPTURESTOP palcCaptureStop = NULL;
+LPALCCAPTURESAMPLES palcCaptureSamples = NULL;
+LPALENABLE palEnable = NULL;
+LPALDISABLE palDisable = NULL;
+LPALISENABLED palIsEnabled = NULL;
+LPALGETSTRING palGetString = NULL;
+LPALGETBOOLEANV palGetBooleanv = NULL;
+LPALGETINTEGERV palGetIntegerv = NULL;
+LPALGETFLOATV palGetFloatv = NULL;
+LPALGETDOUBLEV palGetDoublev = NULL;
+LPALGETBOOLEAN palGetBoolean = NULL;
+LPALGETINTEGER palGetInteger = NULL;
+LPALGETFLOAT palGetFloat = NULL;
+LPALGETDOUBLE palGetDouble = NULL;
+LPALGETERROR palGetError = NULL;
+LPALISEXTENSIONPRESENT palIsExtensionPresent = NULL;
+LPALGETPROCADDRESS palGetProcAddress = NULL;
+LPALGETENUMVALUE palGetEnumValue = NULL;
+LPALLISTENERF palListenerf = NULL;
+LPALLISTENER3F palListener3f = NULL;
+LPALLISTENERFV palListenerfv = NULL;
+LPALLISTENERI palListeneri = NULL;
+LPALLISTENER3I palListener3i = NULL;
+LPALLISTENERIV palListeneriv = NULL;
+LPALGETLISTENERF palGetListenerf = NULL;
+LPALGETLISTENER3F palGetListener3f = NULL;
+LPALGETLISTENERFV palGetListenerfv = NULL;
+LPALGETLISTENERI palGetListeneri = NULL;
+LPALGETLISTENER3I palGetListener3i = NULL;
+LPALGETLISTENERIV palGetListeneriv = NULL;
+LPALGENSOURCES palGenSources = NULL;
+LPALDELETESOURCES palDeleteSources = NULL;
+LPALISSOURCE palIsSource = NULL;
+LPALSOURCEF palSourcef = NULL;
+LPALSOURCE3F palSource3f = NULL;
+LPALSOURCEFV palSourcefv = NULL;
+LPALSOURCEI palSourcei = NULL;
+LPALSOURCE3I palSource3i = NULL;
+LPALSOURCEIV palSourceiv = NULL;
+LPALGETSOURCEF palGetSourcef = NULL;
+LPALGETSOURCE3F palGetSource3f = NULL;
+LPALGETSOURCEFV palGetSourcefv = NULL;
+LPALGETSOURCEI palGetSourcei = NULL;
+LPALGETSOURCE3I palGetSource3i = NULL;
+LPALGETSOURCEIV palGetSourceiv = NULL;
+LPALSOURCEPLAYV palSourcePlayv = NULL;
+LPALSOURCESTOPV palSourceStopv = NULL;
+LPALSOURCEREWINDV palSourceRewindv = NULL;
+LPALSOURCEPAUSEV palSourcePausev = NULL;
+LPALSOURCEPLAY palSourcePlay = NULL;
+LPALSOURCESTOP palSourceStop = NULL;
+LPALSOURCEREWIND palSourceRewind = NULL;
+LPALSOURCEPAUSE palSourcePause = NULL;
+LPALSOURCEQUEUEBUFFERS palSourceQueueBuffers = NULL;
+LPALSOURCEUNQUEUEBUFFERS palSourceUnqueueBuffers = NULL;
+LPALGENBUFFERS palGenBuffers = NULL;
+LPALDELETEBUFFERS palDeleteBuffers = NULL;
+LPALISBUFFER palIsBuffer = NULL;
+LPALBUFFERF palBufferf = NULL;
+LPALBUFFER3F palBuffer3f = NULL;
+LPALBUFFERFV palBufferfv = NULL;
+LPALBUFFERI palBufferi = NULL;
+LPALBUFFER3I palBuffer3i = NULL;
+LPALBUFFERIV palBufferiv = NULL;
+LPALGETBUFFERF palGetBufferf = NULL;
+LPALGETBUFFER3F palGetBuffer3f = NULL;
+LPALGETBUFFERFV palGetBufferfv = NULL;
+LPALGETBUFFERI palGetBufferi = NULL;
+LPALGETBUFFER3I palGetBuffer3i = NULL;
+LPALGETBUFFERIV palGetBufferiv = NULL;
+LPALBUFFERDATA palBufferData = NULL;
+LPALDOPPLERFACTOR palDopplerFactor = NULL;
+LPALDOPPLERVELOCITY palDopplerVelocity = NULL;
+LPALDISTANCEMODEL palDistanceModel = NULL;
+LPALSPEEDOFSOUND palSpeedOfSound = NULL;
+LPALCLOOPBACKOPENDEVICESOFT palcLoopbackOpenDeviceSOFT = NULL;
+LPALCISRENDERFORMATSUPPORTEDSOFT palcIsRenderFormatSupportedSOFT = NULL;
+LPALCRENDERSAMPLESSOFT palcRenderSamplesSOFT = NULL;
+#endif
+
+LPALCMAKECONTEXTCURRENT set_context;
+LPALCGETCURRENTCONTEXT get_context;
+BOOL local_contexts;
+
+static void load_libopenal(void)
+{
+    DWORD failed = 0;
+
+#ifdef SONAME_LIBOPENAL
+    char error[128];
+    openal_handle = wine_dlopen(SONAME_LIBOPENAL, RTLD_NOW, error, sizeof(error));
+    if (!openal_handle)
+        ERR("Couldn't load " SONAME_LIBOPENAL ": %s\n", error);
+#define LOAD_FUNCPTR(f) \
+    if((p##f = wine_dlsym(openal_handle, #f, NULL, 0)) == NULL) { \
+        ERR("Couldn't lookup %s in libopenal\n", #f); \
+        failed = 1; \
     }
 
-    if (!get_config_key( hkey, appkey, "DefaultPlayback", buffer, MAX_PATH ))
-        ds_default_playback = atoi(buffer);
-
-    if (!get_config_key( hkey, appkey, "MaxShadowSize", buffer, MAX_PATH ))
-        ds_snd_shadow_maxsize = atoi(buffer);
-
-    if (!get_config_key( hkey, appkey, "DefaultCapture", buffer, MAX_PATH ))
-        ds_default_capture = atoi(buffer);
-
-    if (!get_config_key( hkey, appkey, "DefaultSampleRate", buffer, MAX_PATH ))
-        ds_default_sample_rate = atoi(buffer);
-
-    if (!get_config_key( hkey, appkey, "DefaultBitsPerSample", buffer, MAX_PATH ))
-        ds_default_bits_per_sample = atoi(buffer);
-
-    if (appkey) RegCloseKey( appkey );
-    if (hkey) RegCloseKey( hkey );
-
-    TRACE("ds_emuldriver = %d\n", ds_emuldriver);
-    TRACE("ds_hel_buflen = %d\n", ds_hel_buflen);
-    TRACE("ds_snd_queue_max = %d\n", ds_snd_queue_max);
-    TRACE("ds_snd_queue_min = %d\n", ds_snd_queue_min);
-    TRACE("ds_hw_accel = %s\n",
-        ds_hw_accel==DS_HW_ACCEL_FULL ? "Full" :
-        ds_hw_accel==DS_HW_ACCEL_STANDARD ? "Standard" :
-        ds_hw_accel==DS_HW_ACCEL_BASIC ? "Basic" :
-        ds_hw_accel==DS_HW_ACCEL_EMULATION ? "Emulation" :
-        "Unknown");
-    TRACE("ds_default_playback = %d\n", ds_default_playback);
-    TRACE("ds_default_capture = %d\n", ds_default_playback);
-    TRACE("ds_default_sample_rate = %d\n", ds_default_sample_rate);
-    TRACE("ds_default_bits_per_sample = %d\n", ds_default_bits_per_sample);
-    TRACE("ds_snd_shadow_maxsize = %d\n", ds_snd_shadow_maxsize);
+    LOAD_FUNCPTR(alcCreateContext);
+    LOAD_FUNCPTR(alcMakeContextCurrent);
+    LOAD_FUNCPTR(alcProcessContext);
+    LOAD_FUNCPTR(alcSuspendContext);
+    LOAD_FUNCPTR(alcDestroyContext);
+    LOAD_FUNCPTR(alcGetCurrentContext);
+    LOAD_FUNCPTR(alcGetContextsDevice);
+    LOAD_FUNCPTR(alcOpenDevice);
+    LOAD_FUNCPTR(alcCloseDevice);
+    LOAD_FUNCPTR(alcGetError);
+    LOAD_FUNCPTR(alcIsExtensionPresent);
+    LOAD_FUNCPTR(alcGetProcAddress);
+    LOAD_FUNCPTR(alcGetEnumValue);
+    LOAD_FUNCPTR(alcGetString);
+    LOAD_FUNCPTR(alcGetIntegerv);
+    LOAD_FUNCPTR(alcCaptureOpenDevice);
+    LOAD_FUNCPTR(alcCaptureCloseDevice);
+    LOAD_FUNCPTR(alcCaptureStart);
+    LOAD_FUNCPTR(alcCaptureStop);
+    LOAD_FUNCPTR(alcCaptureSamples);
+    LOAD_FUNCPTR(alEnable);
+    LOAD_FUNCPTR(alDisable);
+    LOAD_FUNCPTR(alIsEnabled);
+    LOAD_FUNCPTR(alGetString);
+    LOAD_FUNCPTR(alGetBooleanv);
+    LOAD_FUNCPTR(alGetIntegerv);
+    LOAD_FUNCPTR(alGetFloatv);
+    LOAD_FUNCPTR(alGetDoublev);
+    LOAD_FUNCPTR(alGetBoolean);
+    LOAD_FUNCPTR(alGetInteger);
+    LOAD_FUNCPTR(alGetFloat);
+    LOAD_FUNCPTR(alGetDouble);
+    LOAD_FUNCPTR(alGetError);
+    LOAD_FUNCPTR(alIsExtensionPresent);
+    LOAD_FUNCPTR(alGetProcAddress);
+    LOAD_FUNCPTR(alGetEnumValue);
+    LOAD_FUNCPTR(alListenerf);
+    LOAD_FUNCPTR(alListener3f);
+    LOAD_FUNCPTR(alListenerfv);
+    LOAD_FUNCPTR(alListeneri);
+    LOAD_FUNCPTR(alListener3i);
+    LOAD_FUNCPTR(alListeneriv);
+    LOAD_FUNCPTR(alGetListenerf);
+    LOAD_FUNCPTR(alGetListener3f);
+    LOAD_FUNCPTR(alGetListenerfv);
+    LOAD_FUNCPTR(alGetListeneri);
+    LOAD_FUNCPTR(alGetListener3i);
+    LOAD_FUNCPTR(alGetListeneriv);
+    LOAD_FUNCPTR(alGenSources);
+    LOAD_FUNCPTR(alDeleteSources);
+    LOAD_FUNCPTR(alIsSource);
+    LOAD_FUNCPTR(alSourcef);
+    LOAD_FUNCPTR(alSource3f);
+    LOAD_FUNCPTR(alSourcefv);
+    LOAD_FUNCPTR(alSourcei);
+    LOAD_FUNCPTR(alSource3i);
+    LOAD_FUNCPTR(alSourceiv);
+    LOAD_FUNCPTR(alGetSourcef);
+    LOAD_FUNCPTR(alGetSource3f);
+    LOAD_FUNCPTR(alGetSourcefv);
+    LOAD_FUNCPTR(alGetSourcei);
+    LOAD_FUNCPTR(alGetSource3i);
+    LOAD_FUNCPTR(alGetSourceiv);
+    LOAD_FUNCPTR(alSourcePlayv);
+    LOAD_FUNCPTR(alSourceStopv);
+    LOAD_FUNCPTR(alSourceRewindv);
+    LOAD_FUNCPTR(alSourcePausev);
+    LOAD_FUNCPTR(alSourcePlay);
+    LOAD_FUNCPTR(alSourceStop);
+    LOAD_FUNCPTR(alSourceRewind);
+    LOAD_FUNCPTR(alSourcePause);
+    LOAD_FUNCPTR(alSourceQueueBuffers);
+    LOAD_FUNCPTR(alSourceUnqueueBuffers);
+    LOAD_FUNCPTR(alGenBuffers);
+    LOAD_FUNCPTR(alDeleteBuffers);
+    LOAD_FUNCPTR(alIsBuffer);
+    LOAD_FUNCPTR(alBufferf);
+    LOAD_FUNCPTR(alBuffer3f);
+    LOAD_FUNCPTR(alBufferfv);
+    LOAD_FUNCPTR(alBufferi);
+    LOAD_FUNCPTR(alBuffer3i);
+    LOAD_FUNCPTR(alBufferiv);
+    LOAD_FUNCPTR(alGetBufferf);
+    LOAD_FUNCPTR(alGetBuffer3f);
+    LOAD_FUNCPTR(alGetBufferfv);
+    LOAD_FUNCPTR(alGetBufferi);
+    LOAD_FUNCPTR(alGetBuffer3i);
+    LOAD_FUNCPTR(alGetBufferiv);
+    LOAD_FUNCPTR(alBufferData);
+    LOAD_FUNCPTR(alDopplerFactor);
+    LOAD_FUNCPTR(alDopplerVelocity);
+    LOAD_FUNCPTR(alDistanceModel);
+    LOAD_FUNCPTR(alSpeedOfSound);
+    LOAD_FUNCPTR(alcLoopbackOpenDeviceSOFT);
+    LOAD_FUNCPTR(alcIsRenderFormatSupportedSOFT);
+    LOAD_FUNCPTR(alcRenderSamplesSOFT);
+#undef LOAD_FUNCPTR
+#endif
+
+    if (failed)
+    {
+        WARN("Unloading openal\n");
+        if (openal_handle != RTLD_DEFAULT)
+            wine_dlclose(openal_handle, NULL, 0);
+        openal_handle = NULL;
+    }
+    else
+    {
+        local_contexts = palcIsExtensionPresent(NULL, "ALC_EXT_thread_local_context");
+        if(local_contexts)
+        {
+            set_context = palcGetProcAddress(NULL, "alcSetThreadContext");
+            get_context = palcGetProcAddress(NULL, "alcGetThreadContext");
+            if(!set_context || !get_context)
+            {
+                ERR("TLS advertised but functions not found, disabling thread local context\n");
+                local_contexts = 0;
+            }
+        }
+        if(!local_contexts)
+        {
+            set_context = palcMakeContextCurrent;
+            get_context = palcGetCurrentContext;
+        }
+        openal_loaded = 1;
+    }
 }
 
-static const char * get_device_id(LPCGUID pGuid)
-{
-    if (IsEqualGUID(&DSDEVID_DefaultPlayback, pGuid))
-        return "DSDEVID_DefaultPlayback";
-    else if (IsEqualGUID(&DSDEVID_DefaultVoicePlayback, pGuid))
-        return "DSDEVID_DefaultVoicePlayback";
-    else if (IsEqualGUID(&DSDEVID_DefaultCapture, pGuid))
-        return "DSDEVID_DefaultCapture";
-    else if (IsEqualGUID(&DSDEVID_DefaultVoiceCapture, pGuid))
-        return "DSDEVID_DefaultVoiceCapture";
-    return debugstr_guid(pGuid);
-}
+#endif /*HAVE_OPENAL*/
+
+static HINSTANCE instance;
 
 /***************************************************************************
  * GetDeviceID	[DSOUND.9]
@@ -242,7 +514,11 @@ static const char * get_device_id(LPCGUID pGuid)
  */
 HRESULT WINAPI GetDeviceID(LPCGUID pGuidSrc, LPGUID pGuidDest)
 {
-    TRACE("(%s,%p)\n", get_device_id(pGuidSrc),pGuidDest);
+    IMMDevice *dev = NULL;
+    EDataFlow flow = eAll;
+    ERole role = eMultimedia;
+    HRESULT hr;
+    TRACE("(%s,%p)\n", debugstr_guid(pGuidSrc),pGuidDest);
 
     if ( pGuidSrc == NULL) {
 	WARN("invalid parameter: pGuidSrc == NULL\n");
@@ -255,22 +531,30 @@ HRESULT WINAPI GetDeviceID(LPCGUID pGuidSrc, LPGUID pGuidDest)
     }
 
     if ( IsEqualGUID( &DSDEVID_DefaultPlayback, pGuidSrc ) ||
-	 IsEqualGUID( &DSDEVID_DefaultVoicePlayback, pGuidSrc ) ) {
-	*pGuidDest = DSOUND_renderer_guids[ds_default_playback];
-        TRACE("returns %s\n", get_device_id(pGuidDest));
-	return DS_OK;
+         IsEqualGUID( &DSDEVID_DefaultVoicePlayback, pGuidSrc ) ) {
+        if (IsEqualGUID( &DSDEVID_DefaultVoicePlayback, pGuidSrc ))
+            role =  eCommunications;
+        flow = eRender;
     }
 
     if ( IsEqualGUID( &DSDEVID_DefaultCapture, pGuidSrc ) ||
-	 IsEqualGUID( &DSDEVID_DefaultVoiceCapture, pGuidSrc ) ) {
-	*pGuidDest = DSOUND_capture_guids[ds_default_capture];
-        TRACE("returns %s\n", get_device_id(pGuidDest));
-	return DS_OK;
+         IsEqualGUID( &DSDEVID_DefaultVoiceCapture, pGuidSrc ) ) {
+        if (IsEqualGUID( &DSDEVID_DefaultVoiceCapture, pGuidSrc ))
+            role =  eCommunications;
+        flow = eCapture;
     }
 
-    *pGuidDest = *pGuidSrc;
-    TRACE("returns %s\n", get_device_id(pGuidDest));
-
+    hr = DSOUND_obtain_immdevice(flow, pGuidSrc, role, &dev);
+    if (SUCCEEDED(hr))
+        hr = DSOUND_immdevice_getguid(dev, pGuidDest);
+    if (dev)
+        IMMDevice_Release(dev);
+    if (FAILED(hr))
+    {
+        WARN("Failed with %08x\n", hr);
+        return DSERR_INVALIDPARAM;
+    }
+    TRACE("returns %s\n", debugstr_guid(pGuidDest));
     return DS_OK;
 }
 
@@ -338,60 +622,54 @@ HRESULT WINAPI DirectSoundEnumerateW(
 	LPDSENUMCALLBACKW lpDSEnumCallback,
 	LPVOID lpContext )
 {
-    unsigned devs, wod;
-    DSDRIVERDESC desc;
-    GUID guid;
-    int err;
-    WCHAR wDesc[MAXPNAMELEN];
-    WCHAR wName[MAXPNAMELEN];
+    HRESULT hr;
+    UINT devices = 0, i = 0;
+
+    WCHAR wDesc[MAXPNAMELEN] = { 'P','r','i','m','a','r','y',' ',
+        'S','o','u','n','d',' ','D','r','i','v','e','r',0 };
+    static const WCHAR wCapDrvName[] = { 'w','i','n','e','m','m','.','d','r','v', 0 };
+    static const WCHAR wCapEmpty[] = { 0 };
+    IMMDevice *dev;
+    IPropertyStore *store;
+    IMMDeviceCollection *col;
+    PROPVARIANT pv = { VT_EMPTY };
 
-    TRACE("lpDSEnumCallback = %p, lpContext = %p\n",
-	lpDSEnumCallback, lpContext);
+    TRACE("(%p,%p)\n", lpDSEnumCallback, lpContext );
 
     if (lpDSEnumCallback == NULL) {
-	WARN("invalid parameter: lpDSEnumCallback == NULL\n");
-	return DSERR_INVALIDPARAM;
+        WARN("invalid parameter: lpDSEnumCallback == NULL\n");
+        return DSERR_INVALIDPARAM;
     }
 
-    setup_dsound_options();
-
-    devs = waveOutGetNumDevs();
-    if (devs > 0) {
-	if (GetDeviceID(&DSDEVID_DefaultPlayback, &guid) == DS_OK) {
-            static const WCHAR empty[] = { 0 };
-	    for (wod = 0; wod < devs; ++wod) {
-                if (IsEqualGUID( &guid, &DSOUND_renderer_guids[wod] ) ) {
-                    err = mmErr(waveOutMessage(UlongToHandle(wod),DRV_QUERYDSOUNDDESC,(DWORD_PTR)&desc,ds_hw_accel));
-                    if (err == DS_OK) {
-                        TRACE("calling lpDSEnumCallback(NULL,\"%s\",\"%s\",%p)\n",
-                              "Primary Sound Driver",desc.szDrvname,lpContext);
-                        MultiByteToWideChar( CP_ACP, 0, "Primary Sound Driver", -1,
-                                             wDesc, sizeof(wDesc)/sizeof(WCHAR) );
-                        if (lpDSEnumCallback(NULL, wDesc, empty, lpContext) == FALSE)
-                            return DS_OK;
-		    }
-		}
-	    }
-	}
-    }
+    hr = DSOUND_enumerate_immdevice(eRender, &col);
+    if (FAILED(hr))
+        return hr == DSERR_NODRIVER ? S_OK : hr;
+
+    if (FAILED(IMMDeviceCollection_GetCount(col, &devices)) || !devices)
+        goto done;
 
-    for (wod = 0; wod < devs; ++wod) {
-        err = mmErr(waveOutMessage(UlongToHandle(wod),DRV_QUERYDSOUNDDESC,(DWORD_PTR)&desc,ds_hw_accel));
-	if (err == DS_OK) {
-            TRACE("calling lpDSEnumCallback(%s,\"%s\",\"%s\",%p)\n",
-                  debugstr_guid(&DSOUND_renderer_guids[wod]),desc.szDesc,desc.szDrvname,lpContext);
-            MultiByteToWideChar( CP_ACP, 0, desc.szDesc, -1,
-                                 wDesc, sizeof(wDesc)/sizeof(WCHAR) );
-            wDesc[(sizeof(wDesc)/sizeof(WCHAR)) - 1] = '\0';
-
-            MultiByteToWideChar( CP_ACP, 0, desc.szDrvname, -1,
-                                 wName, sizeof(wName)/sizeof(WCHAR) );
-            wName[(sizeof(wName)/sizeof(WCHAR)) - 1] = '\0';
-
-            if (lpDSEnumCallback(&DSOUND_renderer_guids[wod], wDesc, wName, lpContext) == FALSE)
-                return DS_OK;
-	}
+    if (lpDSEnumCallback(NULL, wDesc, wCapEmpty, lpContext) == FALSE)
+        goto done;
+
+    for (i = 0; i < devices; ++i)
+    {
+        IMMDeviceCollection_Item(col, i, &dev);
+        IMMDevice_OpenPropertyStore(dev, STGM_READ, &store);
+        IPropertyStore_GetValue(store, &PKEY_AudioEndpoint_GUID, &pv);
+        CLSIDFromString(pv.u.pwszVal, &DSOUND_renderer_guids[i]);
+        PropVariantClear(&pv);
+        IPropertyStore_GetValue(store, (const PROPERTYKEY*) &DEVPKEY_Device_FriendlyName, &pv);
+        lstrcpynW(wDesc, pv.u.pwszVal, sizeof(wDesc)/sizeof(*wDesc));
+        PropVariantClear(&pv);
+        IPropertyStore_Release(store);
+        IMMDevice_Release(dev);
+
+        if (lpDSEnumCallback(&DSOUND_renderer_guids[i], wDesc, wCapDrvName, lpContext) == FALSE)
+            break;
     }
+
+done:
+    IMMDeviceCollection_Release(col);
     return DS_OK;
 }
 
@@ -443,63 +721,54 @@ DirectSoundCaptureEnumerateW(
     LPDSENUMCALLBACKW lpDSEnumCallback,
     LPVOID lpContext)
 {
-    unsigned devs, wid;
-    DSDRIVERDESC desc;
-    GUID guid;
-    int err;
-    WCHAR wDesc[MAXPNAMELEN];
-    WCHAR wName[MAXPNAMELEN];
+    HRESULT hr;
+    UINT devices = 0, i = 0;
+
+    WCHAR wDesc[MAXPNAMELEN] = { 'P','r','i','m','a','r','y',' ',
+        'S','o','u','n','d',' ','C','a','p','t','u','r','e',' ','D','r','i','v','e','r',0 };
+    static const WCHAR wCapDrvName[] = { 'w','i','n','e','m','m','.','d','r','v', 0 };
+    static const WCHAR wEmptyDrv[] = { 0 };
+    IMMDevice *dev;
+    IPropertyStore *store;
+    IMMDeviceCollection *col;
+    PROPVARIANT pv = { VT_EMPTY };
 
     TRACE("(%p,%p)\n", lpDSEnumCallback, lpContext );
 
     if (lpDSEnumCallback == NULL) {
-	WARN("invalid parameter: lpDSEnumCallback == NULL\n");
+        WARN("invalid parameter: lpDSEnumCallback == NULL\n");
         return DSERR_INVALIDPARAM;
     }
 
-    setup_dsound_options();
-
-    devs = waveInGetNumDevs();
-    if (devs > 0) {
-	if (GetDeviceID(&DSDEVID_DefaultCapture, &guid) == DS_OK) {
-	    for (wid = 0; wid < devs; ++wid) {
-                if (IsEqualGUID( &guid, &DSOUND_capture_guids[wid] ) ) {
-                    err = mmErr(waveInMessage(UlongToHandle(wid),DRV_QUERYDSOUNDDESC,(DWORD_PTR)&desc,ds_hw_accel));
-                    if (err == DS_OK) {
-                        TRACE("calling lpDSEnumCallback(NULL,\"%s\",\"%s\",%p)\n",
-                              "Primary Sound Capture Driver",desc.szDrvname,lpContext);
-                        MultiByteToWideChar( CP_ACP, 0, "Primary Sound Capture Driver", -1,
-                                             wDesc, sizeof(wDesc)/sizeof(WCHAR) );
-                        MultiByteToWideChar( CP_ACP, 0, desc.szDrvname, -1,
-                                             wName, sizeof(wName)/sizeof(WCHAR) );
-                        wName[(sizeof(wName)/sizeof(WCHAR)) - 1] = '\0';
-
-                        if (lpDSEnumCallback(NULL, wDesc, wName, lpContext) == FALSE)
-                            return DS_OK;
-                    }
-                }
-	    }
-	}
-    }
+    hr = DSOUND_enumerate_immdevice(eCapture, &col);
+    if (FAILED(hr))
+        return hr == DSERR_NODRIVER ? S_OK : hr;
+
+    if (FAILED(IMMDeviceCollection_GetCount(col, &devices)) || !devices)
+        goto done;
+
+    if (lpDSEnumCallback(NULL, wDesc, wEmptyDrv, lpContext) == FALSE)
+        goto done;
 
-    for (wid = 0; wid < devs; ++wid) {
-        err = mmErr(waveInMessage(UlongToHandle(wid),DRV_QUERYDSOUNDDESC,(DWORD_PTR)&desc,ds_hw_accel));
-	if (err == DS_OK) {
-            TRACE("calling lpDSEnumCallback(%s,\"%s\",\"%s\",%p)\n",
-                  debugstr_guid(&DSOUND_capture_guids[wid]),desc.szDesc,desc.szDrvname,lpContext);
-            MultiByteToWideChar( CP_ACP, 0, desc.szDesc, -1,
-                                 wDesc, sizeof(wDesc)/sizeof(WCHAR) );
-            wDesc[(sizeof(wDesc)/sizeof(WCHAR)) - 1] = '\0';
-
-            MultiByteToWideChar( CP_ACP, 0, desc.szDrvname, -1,
-                                 wName, sizeof(wName)/sizeof(WCHAR) );
-            wName[(sizeof(wName)/sizeof(WCHAR)) - 1] = '\0';
-
-            if (lpDSEnumCallback(&DSOUND_capture_guids[wid], wDesc, wName, lpContext) == FALSE)
-                return DS_OK;
-	}
+    for (i = 0; i < devices; ++i)
+    {
+        IMMDeviceCollection_Item(col, i, &dev);
+        IMMDevice_OpenPropertyStore(dev, STGM_READ, &store);
+        IPropertyStore_GetValue(store, &PKEY_AudioEndpoint_GUID, &pv);
+        CLSIDFromString(pv.u.pwszVal, &DSOUND_capture_guids[i]);
+        PropVariantClear(&pv);
+        IPropertyStore_GetValue(store, (const PROPERTYKEY*) &DEVPKEY_Device_FriendlyName, &pv);
+        lstrcpynW(wDesc, pv.u.pwszVal, sizeof(wDesc)/sizeof(*wDesc));
+        PropVariantClear(&pv);
+        IPropertyStore_Release(store);
+        IMMDevice_Release(dev);
+
+        if (lpDSEnumCallback(&DSOUND_capture_guids[i], wDesc, wCapDrvName, lpContext) == FALSE)
+            break;
     }
 
+done:
+    IMMDeviceCollection_Release(col);
     return DS_OK;
 }
 
@@ -668,18 +937,14 @@ HRESULT WINAPI DllCanUnloadNow(void)
  */
 BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD fdwReason, LPVOID lpvReserved)
 {
-    int i;
     TRACE("(%p %d %p)\n", hInstDLL, fdwReason, lpvReserved);
 
     switch (fdwReason) {
     case DLL_PROCESS_ATTACH:
         TRACE("DLL_PROCESS_ATTACH\n");
-        for (i = 0; i < MAXWAVEDRIVERS; i++) {
-            DSOUND_renderer[i] = NULL;
-            DSOUND_capture[i] = NULL;
-            INIT_GUID(DSOUND_renderer_guids[i], 0xbd6dd71a, 0x3deb, 0x11d1, 0xb1, 0x71, 0x00, 0xc0, 0x4f, 0xc2, 0x00, 0x00 + i);
-            INIT_GUID(DSOUND_capture_guids[i],  0xbd6dd71b, 0x3deb, 0x11d1, 0xb1, 0x71, 0x00, 0xc0, 0x4f, 0xc2, 0x00, 0x00 + i);
-        }
+#ifdef HAVE_OPENAL
+        load_libopenal();
+#endif /*HAVE_OPENAL*/
         instance = hInstDLL;
         DisableThreadLibraryCalls(hInstDLL);
         /* Increase refcount on dsound by 1 */
@@ -687,6 +952,17 @@ BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD fdwReason, LPVOID lpvReserved)
         break;
     case DLL_PROCESS_DETACH:
         TRACE("DLL_PROCESS_DETACH\n");
+        if (mme)
+        {
+            IMMDeviceEnumerator_Release(mme);
+            if (!lpvReserved)
+                TerminateThread(DSOUND_mmdevapi_thread_handle, 0);
+            CloseHandle(DSOUND_mmdevapi_thread_handle);
+        }
+#ifdef SONAME_LIBOPENAL
+        if (openal_handle)
+            wine_dlclose(openal_handle, NULL, 0);
+#endif /*SONAME_LIBOPENAL*/
         break;
     default:
         TRACE("UNKNOWN REASON\n");
diff --git a/dlls/dsound/dsound_private.h b/dlls/dsound/dsound_private.h
index 61c8b0d..b7d551f 100644
--- a/dlls/dsound/dsound_private.h
+++ b/dlls/dsound/dsound_private.h
@@ -22,361 +22,454 @@
 /* Linux does not support better timing than 10ms */
 #define DS_TIME_RES 2  /* Resolution of multimedia timer */
 #define DS_TIME_DEL 10  /* Delay of multimedia timer callback, and duration of HEL fragment */
+/* Default refresh count, can be overridden */
+#define FAKE_REFRESH_COUNT (1000/DS_TIME_DEL/2)
+
+#include "wingdi.h"
+#include "mmdeviceapi.h"
+#include "audioclient.h"
 
 #include "wine/list.h"
 
-/* direct sound hardware acceleration levels */
-#define DS_HW_ACCEL_FULL        0	/* default on Windows 98 */
-#define DS_HW_ACCEL_STANDARD    1	/* default on Windows 2000 */
-#define DS_HW_ACCEL_BASIC       2
-#define DS_HW_ACCEL_EMULATION   3
-
-extern int ds_emuldriver DECLSPEC_HIDDEN;
-extern int ds_hel_buflen DECLSPEC_HIDDEN;
-extern int ds_snd_queue_max DECLSPEC_HIDDEN;
-extern int ds_snd_queue_min DECLSPEC_HIDDEN;
-extern int ds_snd_shadow_maxsize DECLSPEC_HIDDEN;
-extern int ds_hw_accel DECLSPEC_HIDDEN;
-extern int ds_default_sample_rate DECLSPEC_HIDDEN;
-extern int ds_default_bits_per_sample DECLSPEC_HIDDEN;
-
-/*****************************************************************************
- * Predeclare the interface implementation structures
- */
-typedef struct IDirectSoundImpl              IDirectSoundImpl;
-typedef struct IDirectSound_IUnknown         IDirectSound_IUnknown;
-typedef struct IDirectSound_IDirectSound     IDirectSound_IDirectSound;
-typedef struct IDirectSound8_IUnknown        IDirectSound8_IUnknown;
-typedef struct IDirectSound8_IDirectSound    IDirectSound8_IDirectSound;
-typedef struct IDirectSound8_IDirectSound8   IDirectSound8_IDirectSound8;
-typedef struct IDirectSoundBufferImpl        IDirectSoundBufferImpl;
-typedef struct IDirectSoundCaptureImpl       IDirectSoundCaptureImpl;
-typedef struct IDirectSoundCaptureBufferImpl IDirectSoundCaptureBufferImpl;
-typedef struct IDirectSoundNotifyImpl        IDirectSoundNotifyImpl;
-typedef struct IDirectSoundCaptureNotifyImpl IDirectSoundCaptureNotifyImpl;
-typedef struct IDirectSound3DListenerImpl    IDirectSound3DListenerImpl;
-typedef struct IDirectSound3DBufferImpl      IDirectSound3DBufferImpl;
-typedef struct IKsBufferPropertySetImpl      IKsBufferPropertySetImpl;
-typedef struct DirectSoundDevice             DirectSoundDevice;
-typedef struct DirectSoundCaptureDevice      DirectSoundCaptureDevice;
-
-/* dsound_convert.h */
-typedef void (*bitsconvertfunc)(const void *, void *, UINT, UINT, INT, UINT, UINT);
-extern const bitsconvertfunc convertbpp[5][4] DECLSPEC_HIDDEN;
-typedef void (*mixfunc)(const void *, void *, unsigned);
-extern const mixfunc mixfunctions[4] DECLSPEC_HIDDEN;
-typedef void (*normfunc)(const void *, void *, unsigned);
-extern const normfunc normfunctions[4] DECLSPEC_HIDDEN;
-
-/*****************************************************************************
- * IDirectSoundDevice implementation structure
- */
-struct DirectSoundDevice
+#ifdef HAVE_OPENAL
+
+#ifdef HAVE_AL_AL_H
+#include <AL/al.h>
+#include <AL/alc.h>
+#elif defined(HAVE_OPENAL_AL_H)
+#include <OpenAL/al.h>
+#include <OpenAL/alc.h>
+#else
+#error No OpenAL headers found?
+#endif
+
+#include "alext.h"
+#include "eax.h"
+
+/* All openal functions */
+extern int openal_loaded;
+#ifdef SONAME_LIBOPENAL
+extern LPALCCREATECONTEXT palcCreateContext;
+extern LPALCMAKECONTEXTCURRENT palcMakeContextCurrent;
+extern LPALCPROCESSCONTEXT palcProcessContext;
+extern LPALCSUSPENDCONTEXT palcSuspendContext;
+extern LPALCDESTROYCONTEXT palcDestroyContext;
+extern LPALCGETCURRENTCONTEXT palcGetCurrentContext;
+extern LPALCGETCONTEXTSDEVICE palcGetContextsDevice;
+extern LPALCOPENDEVICE palcOpenDevice;
+extern LPALCCLOSEDEVICE palcCloseDevice;
+extern LPALCGETERROR palcGetError;
+extern LPALCISEXTENSIONPRESENT palcIsExtensionPresent;
+extern LPALCGETPROCADDRESS palcGetProcAddress;
+extern LPALCGETENUMVALUE palcGetEnumValue;
+extern LPALCGETSTRING palcGetString;
+extern LPALCGETINTEGERV palcGetIntegerv;
+extern LPALCCAPTUREOPENDEVICE palcCaptureOpenDevice;
+extern LPALCCAPTURECLOSEDEVICE palcCaptureCloseDevice;
+extern LPALCCAPTURESTART palcCaptureStart;
+extern LPALCCAPTURESTOP palcCaptureStop;
+extern LPALCCAPTURESAMPLES palcCaptureSamples;
+extern LPALENABLE palEnable;
+extern LPALDISABLE palDisable;
+extern LPALISENABLED palIsEnabled;
+extern LPALGETSTRING palGetString;
+extern LPALGETBOOLEANV palGetBooleanv;
+extern LPALGETINTEGERV palGetIntegerv;
+extern LPALGETFLOATV palGetFloatv;
+extern LPALGETDOUBLEV palGetDoublev;
+extern LPALGETBOOLEAN palGetBoolean;
+extern LPALGETINTEGER palGetInteger;
+extern LPALGETFLOAT palGetFloat;
+extern LPALGETDOUBLE palGetDouble;
+extern LPALGETERROR palGetError;
+extern LPALISEXTENSIONPRESENT palIsExtensionPresent;
+extern LPALGETPROCADDRESS palGetProcAddress;
+extern LPALGETENUMVALUE palGetEnumValue;
+extern LPALLISTENERF palListenerf;
+extern LPALLISTENER3F palListener3f;
+extern LPALLISTENERFV palListenerfv;
+extern LPALLISTENERI palListeneri;
+extern LPALLISTENER3I palListener3i;
+extern LPALLISTENERIV palListeneriv;
+extern LPALGETLISTENERF palGetListenerf;
+extern LPALGETLISTENER3F palGetListener3f;
+extern LPALGETLISTENERFV palGetListenerfv;
+extern LPALGETLISTENERI palGetListeneri;
+extern LPALGETLISTENER3I palGetListener3i;
+extern LPALGETLISTENERIV palGetListeneriv;
+extern LPALGENSOURCES palGenSources;
+extern LPALDELETESOURCES palDeleteSources;
+extern LPALISSOURCE palIsSource;
+extern LPALSOURCEF palSourcef;
+extern LPALSOURCE3F palSource3f;
+extern LPALSOURCEFV palSourcefv;
+extern LPALSOURCEI palSourcei;
+extern LPALSOURCE3I palSource3i;
+extern LPALSOURCEIV palSourceiv;
+extern LPALGETSOURCEF palGetSourcef;
+extern LPALGETSOURCE3F palGetSource3f;
+extern LPALGETSOURCEFV palGetSourcefv;
+extern LPALGETSOURCEI palGetSourcei;
+extern LPALGETSOURCE3I palGetSource3i;
+extern LPALGETSOURCEIV palGetSourceiv;
+extern LPALSOURCEPLAYV palSourcePlayv;
+extern LPALSOURCESTOPV palSourceStopv;
+extern LPALSOURCEREWINDV palSourceRewindv;
+extern LPALSOURCEPAUSEV palSourcePausev;
+extern LPALSOURCEPLAY palSourcePlay;
+extern LPALSOURCESTOP palSourceStop;
+extern LPALSOURCEREWIND palSourceRewind;
+extern LPALSOURCEPAUSE palSourcePause;
+extern LPALSOURCEQUEUEBUFFERS palSourceQueueBuffers;
+extern LPALSOURCEUNQUEUEBUFFERS palSourceUnqueueBuffers;
+extern LPALGENBUFFERS palGenBuffers;
+extern LPALDELETEBUFFERS palDeleteBuffers;
+extern LPALISBUFFER palIsBuffer;
+extern LPALBUFFERF palBufferf;
+extern LPALBUFFER3F palBuffer3f;
+extern LPALBUFFERFV palBufferfv;
+extern LPALBUFFERI palBufferi;
+extern LPALBUFFER3I palBuffer3i;
+extern LPALBUFFERIV palBufferiv;
+extern LPALGETBUFFERF palGetBufferf;
+extern LPALGETBUFFER3F palGetBuffer3f;
+extern LPALGETBUFFERFV palGetBufferfv;
+extern LPALGETBUFFERI palGetBufferi;
+extern LPALGETBUFFER3I palGetBuffer3i;
+extern LPALGETBUFFERIV palGetBufferiv;
+extern LPALBUFFERDATA palBufferData;
+extern LPALDOPPLERFACTOR palDopplerFactor;
+extern LPALDOPPLERVELOCITY palDopplerVelocity;
+extern LPALDISTANCEMODEL palDistanceModel;
+extern LPALSPEEDOFSOUND palSpeedOfSound;
+#else
+#define palcCreateContext alcCreateContext
+#define palcMakeContextCurrent alcMakeContextCurrent
+#define palcProcessContext alcProcessContext
+#define palcSuspendContext alcSuspendContext
+#define palcDestroyContext alcDestroyContext
+#define palcGetCurrentContext alcGetCurrentContext
+#define palcGetContextsDevice alcGetContextsDevice
+#define palcOpenDevice alcOpenDevice
+#define palcCloseDevice alcCloseDevice
+#define palcGetError alcGetError
+#define palcIsExtensionPresent alcIsExtensionPresent
+#define palcGetProcAddress alcGetProcAddress
+#define palcGetEnumValue alcGetEnumValue
+#define palcGetString alcGetString
+#define palcGetIntegerv alcGetIntegerv
+#define palcCaptureOpenDevice alcCaptureOpenDevice
+#define palcCaptureCloseDevice alcCaptureCloseDevice
+#define palcCaptureStart alcCaptureStart
+#define palcCaptureStop alcCaptureStop
+#define palcCaptureSamples alcCaptureSamples
+#define palEnable alEnable
+#define palDisable alDisable
+#define palIsEnabled alIsEnabled
+#define palGetString alGetString
+#define palGetBooleanv alGetBooleanv
+#define palGetIntegerv alGetIntegerv
+#define palGetFloatv alGetFloatv
+#define palGetDoublev alGetDoublev
+#define palGetBoolean alGetBoolean
+#define palGetInteger alGetInteger
+#define palGetFloat alGetFloat
+#define palGetDouble alGetDouble
+#define palGetError alGetError
+#define palIsExtensionPresent alIsExtensionPresent
+#define palGetProcAddress alGetProcAddress
+#define palGetEnumValue alGetEnumValue
+#define palListenerf alListenerf
+#define palListener3f alListener3f
+#define palListenerfv alListenerfv
+#define palListeneri alListeneri
+#define palListener3i alListener3i
+#define palListeneriv alListeneriv
+#define palGetListenerf alGetListenerf
+#define palGetListener3f alGetListener3f
+#define palGetListenerfv alGetListenerfv
+#define palGetListeneri alGetListeneri
+#define palGetListener3i alGetListener3i
+#define palGetListeneriv alGetListeneriv
+#define palGenSources alGenSources
+#define palDeleteSources alDeleteSources
+#define palIsSource alIsSource
+#define palSourcef alSourcef
+#define palSource3f alSource3f
+#define palSourcefv alSourcefv
+#define palSourcei alSourcei
+#define palSource3i alSource3i
+#define palSourceiv alSourceiv
+#define palGetSourcef alGetSourcef
+#define palGetSource3f alGetSource3f
+#define palGetSourcefv alGetSourcefv
+#define palGetSourcei alGetSourcei
+#define palGetSource3i alGetSource3i
+#define palGetSourceiv alGetSourceiv
+#define palSourcePlayv alSourcePlayv
+#define palSourceStopv alSourceStopv
+#define palSourceRewindv alSourceRewindv
+#define palSourcePausev alSourcePausev
+#define palSourcePlay alSourcePlay
+#define palSourceStop alSourceStop
+#define palSourceRewind alSourceRewind
+#define palSourcePause alSourcePause
+#define palSourceQueueBuffers alSourceQueueBuffers
+#define palSourceUnqueueBuffers alSourceUnqueueBuffers
+#define palGenBuffers alGenBuffers
+#define palDeleteBuffers alDeleteBuffers
+#define palIsBuffer alIsBuffer
+#define palBufferf alBufferf
+#define palBuffer3f alBuffer3f
+#define palBufferfv alBufferfv
+#define palBufferi alBufferi
+#define palBuffer3i alBuffer3i
+#define palBufferiv alBufferiv
+#define palGetBufferf alGetBufferf
+#define palGetBuffer3f alGetBuffer3f
+#define palGetBufferfv alGetBufferfv
+#define palGetBufferi alGetBufferi
+#define palGetBuffer3i alGetBuffer3i
+#define palGetBufferiv alGetBufferiv
+#define palBufferData alBufferData
+#define palDopplerFactor alDopplerFactor
+#define palDopplerVelocity alDopplerVelocity
+#define palDistanceModel alDistanceModel
+#define palSpeedOfSound alSpeedOfSound
+#endif
+
+/* Experimental extension to write openal data to a buffer */
+#ifndef ALC_SOFT_device_loopback
+#define ALC_SOFT_device_loopback 1
+#define ALC_FORMAT_CHANNELS                      0x1990
+#define ALC_FORMAT_TYPE                          0x1991
+typedef ALCdevice* (ALC_APIENTRY*LPALCLOOPBACKOPENDEVICESOFT)(void);
+typedef ALCboolean (ALC_APIENTRY*LPALCISRENDERFORMATSUPPORTEDSOFT)(ALCdevice *device, ALCsizei freq, ALenum channels, ALenum type);
+typedef void (ALC_APIENTRY*LPALCRENDERSAMPLESSOFT)(ALCdevice *device, ALCvoid *buffer, ALCsizei samples);
+
+ALC_API ALCdevice* ALC_APIENTRY alcLoopbackOpenDeviceSOFT(void);
+ALC_API ALCboolean ALC_APIENTRY alcIsRenderFormatSupportedSOFTSOFT(ALCdevice *device, ALCsizei freq, ALenum channels, ALenum type);
+ALC_API void ALC_APIENTRY alcRenderSamplesSOFT(ALCdevice *device, ALCvoid *buffer, ALCsizei samples);
+#endif
+
+#ifdef SONAME_LIBOPENAL
+extern LPALCLOOPBACKOPENDEVICESOFT palcLoopbackOpenDeviceSOFT;
+extern LPALCISRENDERFORMATSUPPORTEDSOFT palcIsRenderFormatSupportedSOFT;
+extern LPALCRENDERSAMPLESSOFT palcRenderSamplesSOFT;
+#else
+#define palcLoopbackOpenDeviceSOFT alcLoopbackOpenDeviceSOFT
+#define palcIsRenderFormatSupportedSOFT alcIsRenderFormatSupportedSOFT
+#define palcRenderSamplesSOFT alcRenderSamplesSOFT
+#endif
+
+#include <math.h>
+#include "wingdi.h"
+#include "mmreg.h"
+
+/* OpenAL only allows for 1 single access to the device at the same time */
+extern CRITICAL_SECTION openal_crst;
+
+
+extern LPALCMAKECONTEXTCURRENT set_context;
+extern LPALCGETCURRENTCONTEXT get_context;
+extern BOOL local_contexts;
+
+/* Device implementation */
+typedef struct DS8Primary DS8Primary;
+typedef struct DS8Buffer DS8Buffer;
+
+typedef struct DS8Impl
 {
-    LONG                        ref;
-
-    GUID                        guid;
-    PIDSDRIVER                  driver;
-    DSDRIVERDESC                drvdesc;
-    DSDRIVERCAPS                drvcaps;
-    DWORD                       priolevel;
-    PWAVEFORMATEX               pwfx;
-    HWAVEOUT                    hwo;
-    LPWAVEHDR                   pwave;
-    UINT                        timerID, pwplay, pwqueue, prebuf, helfrags;
-    DWORD                       fraglen;
-    PIDSDRIVERBUFFER            hwbuf;
-    LPBYTE                      buffer;
-    DWORD                       writelead, buflen, state, playpos, mixpos;
-    int                         nrofbuffers;
-    IDirectSoundBufferImpl**    buffers;
-    RTL_RWLOCK                  buffer_list_lock;
-    CRITICAL_SECTION            mixlock;
-    IDirectSoundBufferImpl     *primary;
-    DWORD                       speaker_config;
-    LPBYTE                      tmp_buffer, mix_buffer;
-    DWORD                       tmp_buffer_len, mix_buffer_len;
-
-    DSVOLUMEPAN                 volpan;
-
-    mixfunc mixfunction;
-    normfunc normfunction;
-
-    /* DirectSound3DListener fields */
-    IDirectSound3DListenerImpl*	listener;
-    DS3DLISTENER                ds3dl;
-    BOOL                        ds3dl_need_recalc;
-};
+    IDirectSound8 IDirectSound8_iface;
 
-/* reference counted buffer memory for duplicated buffer memory */
-typedef struct BufferMemory
-{
-    LONG                        ref;
-    LPBYTE                      memory;
-    struct list buffers;
-} BufferMemory;
-
-ULONG DirectSoundDevice_Release(DirectSoundDevice * device) DECLSPEC_HIDDEN;
-HRESULT DirectSoundDevice_Initialize(
-    DirectSoundDevice ** ppDevice,
-    LPCGUID lpcGUID) DECLSPEC_HIDDEN;
-HRESULT DirectSoundDevice_AddBuffer(
-    DirectSoundDevice * device,
-    IDirectSoundBufferImpl * pDSB) DECLSPEC_HIDDEN;
-HRESULT DirectSoundDevice_RemoveBuffer(
-    DirectSoundDevice * device,
-    IDirectSoundBufferImpl * pDSB) DECLSPEC_HIDDEN;
-HRESULT DirectSoundDevice_GetCaps(DirectSoundDevice * device, LPDSCAPS lpDSCaps) DECLSPEC_HIDDEN;
-HRESULT DirectSoundDevice_CreateSoundBuffer(
-    DirectSoundDevice * device,
-    LPCDSBUFFERDESC dsbd,
-    LPLPDIRECTSOUNDBUFFER ppdsb,
-    LPUNKNOWN lpunk,
-    BOOL from8) DECLSPEC_HIDDEN;
-HRESULT DirectSoundDevice_DuplicateSoundBuffer(
-    DirectSoundDevice * device,
-    LPDIRECTSOUNDBUFFER psb,
-    LPLPDIRECTSOUNDBUFFER ppdsb) DECLSPEC_HIDDEN;
-HRESULT DirectSoundDevice_SetCooperativeLevel(
-    DirectSoundDevice * devcie,
-    HWND hwnd,
-    DWORD level) DECLSPEC_HIDDEN;
-HRESULT DirectSoundDevice_Compact(DirectSoundDevice * device) DECLSPEC_HIDDEN;
-HRESULT DirectSoundDevice_GetSpeakerConfig(
-    DirectSoundDevice * device,
-    LPDWORD lpdwSpeakerConfig) DECLSPEC_HIDDEN;
-HRESULT DirectSoundDevice_SetSpeakerConfig(
-    DirectSoundDevice * device,
-    DWORD config) DECLSPEC_HIDDEN;
-HRESULT DirectSoundDevice_VerifyCertification(DirectSoundDevice * device,
-    LPDWORD pdwCertified) DECLSPEC_HIDDEN;
-
-/*****************************************************************************
- * IDirectSoundBuffer implementation structure
- */
-struct IDirectSoundBufferImpl
-{
-    IDirectSoundBuffer8         IDirectSoundBuffer8_iface;
-    LONG                        numIfaces; /* "in use interfaces" refcount */
-    LONG                        ref;
-    /* IDirectSoundBufferImpl fields */
-    DirectSoundDevice*          device;
-    RTL_RWLOCK                  lock;
-    PIDSDRIVERBUFFER            hwbuf;
-    PWAVEFORMATEX               pwfx;
-    BufferMemory*               buffer;
-    LPBYTE                      tmp_buffer;
-    DWORD                       playflags,state,leadin;
-    DWORD                       writelead,buflen;
-    DWORD                       nAvgBytesPerSec;
-    DWORD                       freq, tmp_buffer_len, max_buffer_len;
-    DSVOLUMEPAN                 volpan;
-    DSBUFFERDESC                dsbd;
-    /* used for frequency conversion (PerfectPitch) */
-    ULONG                       freqneeded, freqAdjust, freqAcc, freqAccNext, resampleinmixer;
-    /* used for mixing */
-    DWORD                       primary_mixpos, buf_mixpos, sec_mixpos;
-
-    /* IDirectSoundNotifyImpl fields */
-    IDirectSoundNotifyImpl*     notify;
-    LPDSBPOSITIONNOTIFY         notifies;
-    int                         nrofnotifies;
-    PIDSDRIVERNOTIFY            hwnotify;
-
-    /* DirectSound3DBuffer fields */
-    IDirectSound3DBufferImpl*   ds3db;
-    DS3DBUFFER                  ds3db_ds3db;
-    LONG                        ds3db_lVolume;
-    BOOL                        ds3db_need_recalc;
-
-    /* IKsPropertySet fields */
-    IKsBufferPropertySetImpl*   iks;
-    bitsconvertfunc convert;
-    struct list entry;
-};
+    LONG ref;
+    BOOL is_8;
 
-HRESULT IDirectSoundBufferImpl_Create(
-    DirectSoundDevice *device,
-    IDirectSoundBufferImpl **ppdsb,
-    LPCDSBUFFERDESC dsbd) DECLSPEC_HIDDEN;
-HRESULT IDirectSoundBufferImpl_Destroy(
-    IDirectSoundBufferImpl *pdsb) DECLSPEC_HIDDEN;
-HRESULT IDirectSoundBufferImpl_Duplicate(
-    DirectSoundDevice *device,
-    IDirectSoundBufferImpl **ppdsb,
-    IDirectSoundBufferImpl *pdsb) DECLSPEC_HIDDEN;
-void secondarybuffer_destroy(IDirectSoundBufferImpl *This) DECLSPEC_HIDDEN;
-
-/*****************************************************************************
- * DirectSoundCaptureDevice implementation structure
- */
-struct DirectSoundCaptureDevice
-{
-    /* IDirectSoundCaptureImpl fields */
-    GUID                               guid;
-    LONG                               ref;
-
-    /* DirectSound driver stuff */
-    PIDSCDRIVER                        driver;
-    DSDRIVERDESC                       drvdesc;
-    DSCDRIVERCAPS                      drvcaps;
-    PIDSCDRIVERBUFFER                  hwbuf;
-
-    /* wave driver info */
-    HWAVEIN                            hwi;
-
-    /* more stuff */
-    LPBYTE                             buffer;
-    DWORD                              buflen;
-
-    PWAVEFORMATEX                      pwfx;
-
-    IDirectSoundCaptureBufferImpl*     capture_buffer;
-    DWORD                              state;
-    LPWAVEHDR                          pwave;
-    int                                nrofpwaves;
-    int                                index;
-    CRITICAL_SECTION                   lock;
-};
+    LONG *deviceref;
+    ALCdevice *device;
+    DS8Primary *primary;
 
-/*****************************************************************************
- * IDirectSoundCaptureBuffer implementation structure
- */
-struct IDirectSoundCaptureBufferImpl
-{
-    /* IUnknown fields */
-    const IDirectSoundCaptureBuffer8Vtbl *lpVtbl;
-    LONG                                ref;
-
-    /* IDirectSoundCaptureBufferImpl fields */
-    DirectSoundCaptureDevice*           device;
-    /* FIXME: don't need this */
-    LPDSCBUFFERDESC                     pdscbd;
-    DWORD                               flags;
-
-    /* IDirectSoundCaptureNotifyImpl fields */
-    IDirectSoundCaptureNotifyImpl*      notify;
-    LPDSBPOSITIONNOTIFY                 notifies;
-    int                                 nrofnotifies;
-    PIDSDRIVERNOTIFY                    hwnotify;
-};
+    DWORD speaker_config;
+    DWORD prio_level;
+    GUID guid;
+} DS8Impl;
 
-/*****************************************************************************
- *  IDirectSound3DListener implementation structure
- */
-struct IDirectSound3DListenerImpl
+typedef struct ExtALFuncs
 {
-    /* IUnknown fields */
-    const IDirectSound3DListenerVtbl *lpVtbl;
-    LONG                        ref;
-    /* IDirectSound3DListenerImpl fields */
-    DirectSoundDevice*          device;
-};
+    PFNALBUFFERSUBDATASOFTPROC BufferSubData;
+    PFNALBUFFERDATASTATICPROC BufferDataStatic;
 
-HRESULT IDirectSound3DListenerImpl_Create(
-    DirectSoundDevice           *device,
-    IDirectSound3DListenerImpl **pdsl) DECLSPEC_HIDDEN;
+    LPALGENEFFECTS GenEffects;
+    LPALDELETEEFFECTS DeleteEffects;
+    LPALEFFECTI Effecti;
+    LPALEFFECTF Effectf;
 
-/*****************************************************************************
- *  IKsBufferPropertySet implementation structure
- */
-struct IKsBufferPropertySetImpl
+    LPALGENAUXILIARYEFFECTSLOTS GenAuxiliaryEffectSlots;
+    LPALDELETEAUXILIARYEFFECTSLOTS DeleteAuxiliaryEffectSlots;
+    LPALAUXILIARYEFFECTSLOTI AuxiliaryEffectSloti;
+
+} ExtALFuncs;
+
+struct DS8Primary
 {
-    /* IUnknown fields */
-    const IKsPropertySetVtbl   *lpVtbl;
-    LONG 			ref;
-    /* IKsPropertySetImpl fields */
-    IDirectSoundBufferImpl*	dsb;
+    IDirectSoundBuffer IDirectSoundBuffer_iface;
+    IDirectSound3DListener IDirectSound3DListener_iface;
+    IKsPropertySet IKsPropertySet_iface;
+
+    LONG ref, ds3d_ref, prop_ref;
+    IDirectSoundBuffer8 *write_emu;
+    DS8Impl *parent;
+
+    CRITICAL_SECTION crst;
+
+    DWORD buf_size;
+    BOOL stopped;
+    DWORD flags;
+    WAVEFORMATEX *format;
+    ALCcontext *ctx;
+    BOOL has_efx;
+
+    ALuint *sources;
+    DWORD nsources, sizesources;
+    DWORD max_sources;
+    DS8Buffer **buffers;
+    DWORD nbuffers, sizebuffers;
+    DS8Buffer **notifies;
+    DWORD nnotifies, sizenotifies;
+    UINT timer_id;
+    DWORD timer_res;
+
+    ALuint auxslot;
+    ALuint effect;
+    EAXLISTENERPROPERTIES eax_prop;
+
+    ExtALFuncs ExtAL;
+    union {
+        struct {
+            BOOL pos : 1;
+            BOOL vel : 1;
+            BOOL orientation : 1;
+            BOOL distancefactor : 1;
+            BOOL rollofffactor : 1;
+            BOOL dopplerfactor : 1;
+            BOOL effect : 1;
+        } bit;
+        int flags;
+    } dirty;
+    ALfloat rollofffactor;
+    DS3DLISTENER listen;
+
+    IAudioClient *dev;
+    IAudioRenderClient *render_dev;
 };
 
-HRESULT IKsBufferPropertySetImpl_Create(
-    IDirectSoundBufferImpl *dsb,
-    IKsBufferPropertySetImpl **piks) DECLSPEC_HIDDEN;
-HRESULT IKsBufferPropertySetImpl_Destroy(
-    IKsBufferPropertySetImpl *piks) DECLSPEC_HIDDEN;
+typedef struct DS8Data DS8Data;
 
-HRESULT IKsPrivatePropertySetImpl_Create(REFIID riid, IKsPropertySet **piks) DECLSPEC_HIDDEN;
-
-/*****************************************************************************
- * IDirectSound3DBuffer implementation structure
- */
-struct IDirectSound3DBufferImpl
+struct DS8Buffer
 {
-    /* IUnknown fields */
-    const IDirectSound3DBufferVtbl *lpVtbl;
-    LONG                        ref;
-    /* IDirectSound3DBufferImpl fields */
-    IDirectSoundBufferImpl*     dsb;
+    IDirectSoundBuffer8 IDirectSoundBuffer8_iface;
+    IDirectSound3DBuffer IDirectSound3DBuffer_iface;
+    IDirectSoundNotify IDirectSoundNotify_iface;
+    IKsPropertySet IKsPropertySet_iface;
+
+    LONG ref, ds3d_ref, not_ref, prop_ref;
+    LONG all_ref;
+
+    DWORD ds3dmode;
+    DS8Primary *primary;
+    DS8Data *buffer;
+    ALuint source;
+    ALuint curidx;
+    BOOL isplaying, islooping, bufferlost;
+    ALCcontext *ctx;
+    ExtALFuncs *ExtAL;
+    CRITICAL_SECTION *crst;
+
+    DS3DBUFFER ds3dbuffer;
+    union {
+        struct {
+            BOOL pos : 1;
+            BOOL vel : 1;
+            BOOL cone_angles : 1;
+            BOOL cone_orient : 1;
+            BOOL cone_outsidevolume : 1;
+            BOOL min_distance : 1;
+            BOOL max_distance : 1;
+            BOOL mode : 1;
+        } bit;
+        int flags;
+    } dirty;
+
+    DWORD nnotify, lastpos;
+    DSBPOSITIONNOTIFY *notify;
 };
 
-HRESULT IDirectSound3DBufferImpl_Create(
-    IDirectSoundBufferImpl *dsb,
-    IDirectSound3DBufferImpl **pds3db) DECLSPEC_HIDDEN;
-HRESULT IDirectSound3DBufferImpl_Destroy(
-    IDirectSound3DBufferImpl *pds3db) DECLSPEC_HIDDEN;
+extern HRESULT DS8Primary_Create(DS8Primary **prim, DS8Impl *parent);
+extern void DS8Primary_Destroy(DS8Primary *prim);
 
-/*******************************************************************************
- */
+extern HRESULT DS8Buffer_Create(DS8Buffer **ppv, DS8Primary *parent, DS8Buffer *orig);
+extern void DS8Buffer_Destroy(DS8Buffer *buf);
 
-/* dsound.c */
+static inline ALdouble gain_to_mB(ALdouble gain)
+{
+    return log10(gain) * 2000.0;
+}
+
+static inline ALdouble mB_to_gain(ALdouble millibels)
+{
+    return pow(10.0, millibels/2000.0);
+}
+
+#define getALError() \
+do { \
+    ALenum err = palGetError(); \
+    if(err != AL_NO_ERROR) \
+    { \
+        ERR(">>>>>>>>>>>> Received AL error %#x on context %p, %s:%u\n", err, get_context(), __FUNCTION__, __LINE__); \
+    } \
+} while (0)
+
+#define getALCError(dev) \
+do { \
+    ALenum err = palcGetError(dev); \
+    if(err != ALC_NO_ERROR) \
+    { \
+        ERR(">>>>>>>>>>>> Received ALC error %#x on device %p, %s:%u\n", err, dev, __FUNCTION__, __LINE__); \
+    } \
+} while(0)
+
+#define setALContext(actx) \
+    do { \
+        ALCcontext *__old_ctx, *cur_ctx = actx; \
+        if (!local_contexts) EnterCriticalSection(&openal_crst); \
+        __old_ctx = get_context(); \
+        if (__old_ctx != cur_ctx && set_context(cur_ctx) == ALC_FALSE) {\
+            ERR("Couldn't set current context!!\n"); \
+            getALCError(palcGetContextsDevice(cur_ctx)); \
+        }
+
+/* Only restore a NULL context if using global contexts, for TLS contexts always restore */
+#define popALContext() \
+        do { getALError(); getALCError(NULL); } while (0); \
+        if (__old_ctx != cur_ctx && \
+            (local_contexts || __old_ctx) && \
+            set_context(__old_ctx) == ALC_FALSE) { \
+            ERR("Couldn't restore old context!!\n"); \
+            getALCError(palcGetContextsDevice(__old_ctx)); \
+        } \
+        if (!local_contexts) LeaveCriticalSection(&openal_crst); \
+    } while (0)
+
+#endif
 
 HRESULT DSOUND_Create(REFIID riid, LPDIRECTSOUND *ppDS) DECLSPEC_HIDDEN;
 HRESULT DSOUND_Create8(REFIID riid, LPDIRECTSOUND8 *ppDS) DECLSPEC_HIDDEN;
-
-/* primary.c */
-
-DWORD DSOUND_fraglen(DWORD nSamplesPerSec, DWORD nBlockAlign) DECLSPEC_HIDDEN;
-HRESULT DSOUND_PrimaryCreate(DirectSoundDevice *device) DECLSPEC_HIDDEN;
-HRESULT DSOUND_PrimaryDestroy(DirectSoundDevice *device) DECLSPEC_HIDDEN;
-HRESULT DSOUND_PrimaryPlay(DirectSoundDevice *device) DECLSPEC_HIDDEN;
-HRESULT DSOUND_PrimaryStop(DirectSoundDevice *device) DECLSPEC_HIDDEN;
-HRESULT DSOUND_PrimaryGetPosition(DirectSoundDevice *device, LPDWORD playpos, LPDWORD writepos) DECLSPEC_HIDDEN;
-LPWAVEFORMATEX DSOUND_CopyFormat(LPCWAVEFORMATEX wfex) DECLSPEC_HIDDEN;
-HRESULT DSOUND_ReopenDevice(DirectSoundDevice *device, BOOL forcewave) DECLSPEC_HIDDEN;
-HRESULT primarybuffer_create(DirectSoundDevice *device, IDirectSoundBufferImpl **ppdsb,
-    const DSBUFFERDESC *dsbd) DECLSPEC_HIDDEN;
-void primarybuffer_destroy(IDirectSoundBufferImpl *This) DECLSPEC_HIDDEN;
-HRESULT primarybuffer_SetFormat(DirectSoundDevice *device, LPCWAVEFORMATEX wfex) DECLSPEC_HIDDEN;
-
-/* duplex.c */
- 
 HRESULT DSOUND_FullDuplexCreate(REFIID riid, LPDIRECTSOUNDFULLDUPLEX* ppDSFD) DECLSPEC_HIDDEN;
-
-/* mixer.c */
-DWORD DSOUND_bufpos_to_mixpos(const DirectSoundDevice* device, DWORD pos) DECLSPEC_HIDDEN;
-void DSOUND_CheckEvent(const IDirectSoundBufferImpl *dsb, DWORD playpos, int len) DECLSPEC_HIDDEN;
-void DSOUND_RecalcVolPan(PDSVOLUMEPAN volpan) DECLSPEC_HIDDEN;
-void DSOUND_AmpFactorToVolPan(PDSVOLUMEPAN volpan) DECLSPEC_HIDDEN;
-void DSOUND_RecalcFormat(IDirectSoundBufferImpl *dsb) DECLSPEC_HIDDEN;
-void DSOUND_MixToTemporary(const IDirectSoundBufferImpl *dsb, DWORD writepos, DWORD mixlen, BOOL inmixer) DECLSPEC_HIDDEN;
-DWORD DSOUND_secpos_to_bufpos(const IDirectSoundBufferImpl *dsb, DWORD secpos, DWORD secmixpos, DWORD* overshot) DECLSPEC_HIDDEN;
-
-void CALLBACK DSOUND_timer(UINT timerID, UINT msg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2) DECLSPEC_HIDDEN;
-void CALLBACK DSOUND_callback(HWAVEOUT hwo, UINT msg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2) DECLSPEC_HIDDEN;
-
-/* sound3d.c */
-
-void DSOUND_Calc3DBuffer(IDirectSoundBufferImpl *dsb) DECLSPEC_HIDDEN;
-
-/* capture.c */
- 
 HRESULT DSOUND_CaptureCreate(REFIID riid, LPDIRECTSOUNDCAPTURE *ppDSC) DECLSPEC_HIDDEN;
 HRESULT DSOUND_CaptureCreate8(REFIID riid, LPDIRECTSOUNDCAPTURE8 *ppDSC8) DECLSPEC_HIDDEN;
+HRESULT IKsPrivatePropertySetImpl_Create(REFIID riid, IKsPropertySet **piks) DECLSPEC_HIDDEN;
 
-#define STATE_STOPPED   0
-#define STATE_STARTING  1
-#define STATE_PLAYING   2
-#define STATE_CAPTURING 2
-#define STATE_STOPPING  3
-
-#define DSOUND_FREQSHIFT (20)
-
-extern DirectSoundDevice* DSOUND_renderer[MAXWAVEDRIVERS] DECLSPEC_HIDDEN;
-extern GUID DSOUND_renderer_guids[MAXWAVEDRIVERS] DECLSPEC_HIDDEN;
-
-extern DirectSoundCaptureDevice * DSOUND_capture[MAXWAVEDRIVERS] DECLSPEC_HIDDEN;
-extern GUID DSOUND_capture_guids[MAXWAVEDRIVERS] DECLSPEC_HIDDEN;
-
-HRESULT mmErr(UINT err) DECLSPEC_HIDDEN;
-void setup_dsound_options(void) DECLSPEC_HIDDEN;
-const char * dumpCooperativeLevel(DWORD level) DECLSPEC_HIDDEN;
+HRESULT DSOUND_obtain_immdevice(EDataFlow flow, const GUID *guid, ERole role, IMMDevice **dev) DECLSPEC_HIDDEN;
+HRESULT DSOUND_enumerate_immdevice(EDataFlow flow, IMMDeviceCollection **collection) DECLSPEC_HIDDEN;
+HRESULT DSOUND_immdevice_getguid(IMMDevice *dev, GUID *guid) DECLSPEC_HIDDEN;
+IMMDeviceEnumerator *DSOUND_obtain_mme(void) DECLSPEC_HIDDEN;
diff --git a/dlls/dsound/duplex.c b/dlls/dsound/duplex.c
index 4a1fbd2..fd6488e 100644
--- a/dlls/dsound/duplex.c
+++ b/dlls/dsound/duplex.c
@@ -222,7 +222,7 @@ static HRESULT WINAPI IDirectSoundFullDuplex_IDirectSound8_SetCooperativeLevel(
     DWORD level)
 {
     IDirectSoundFullDuplex_IDirectSound8 *This = (IDirectSoundFullDuplex_IDirectSound8 *)iface;
-    TRACE("(%p,%p,%s)\n",This,hwnd,dumpCooperativeLevel(level));
+    TRACE("(%p,%p,%x)\n",This,hwnd,level);
     return IDirectSound8_SetCooperativeLevel(This->pdsfd->renderer_device,hwnd,level);
 }
 
@@ -632,9 +632,6 @@ HRESULT DSOUND_FullDuplexCreate(
         return E_NOINTERFACE;
     }
 
-    /* Get dsound configuration */
-    setup_dsound_options();
-
     This = HeapAlloc(GetProcessHeap(),
         HEAP_ZERO_MEMORY, sizeof(IDirectSoundFullDuplexImpl));
 
diff --git a/dlls/dsound/eax.h b/dlls/dsound/eax.h
new file mode 100644
index 0000000..e41e83e
--- /dev/null
+++ b/dlls/dsound/eax.h
@@ -0,0 +1,167 @@
+/*  			DirectSound
+ *
+ * Copyright 2010 Chris Robinson
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef EAX_H
+#define EAX_H
+
+extern IID DSPROPSETID_EAX20_ListenerProperties;
+typedef enum {
+    DSPROPERTY_EAXLISTENER_NONE,
+    DSPROPERTY_EAXLISTENER_ALLPARAMETERS,
+    DSPROPERTY_EAXLISTENER_ROOM,
+    DSPROPERTY_EAXLISTENER_ROOMHF,
+    DSPROPERTY_EAXLISTENER_ROOMROLLOFFFACTOR,
+    DSPROPERTY_EAXLISTENER_DECAYTIME,
+    DSPROPERTY_EAXLISTENER_DECAYHFRATIO,
+    DSPROPERTY_EAXLISTENER_REFLECTIONS,
+    DSPROPERTY_EAXLISTENER_REFLECTIONSDELAY,
+    DSPROPERTY_EAXLISTENER_REVERB,
+    DSPROPERTY_EAXLISTENER_REVERBDELAY,
+    DSPROPERTY_EAXLISTENER_ENVIRONMENT,
+    DSPROPERTY_EAXLISTENER_ENVIRONMENTSIZE,
+    DSPROPERTY_EAXLISTENER_ENVIRONMENTDIFFUSION,
+    DSPROPERTY_EAXLISTENER_AIRABSORPTIONHF,
+    DSPROPERTY_EAXLISTENER_FLAGS
+} DSPROPERTY_EAX_LISTENERPROPERTY;
+
+/* Stores the value being set, but does not apply it */
+#define DSPROPERTY_EAXLISTENER_DEFERRED               0x80000000
+/* The lack of the deferred flag forces a call to CommitDeferredSettings(),
+ * applying *all* deferred settings, including the EAX property being set */
+#define DSPROPERTY_EAXLISTENER_IMMEDIATE              0x00000000
+/* Same as IMMEDIATE; causes a commit of deferred properties but implies no
+ * extra property being set */
+#define DSPROPERTY_EAXLISTENER_COMMITDEFERREDSETTINGS 0x00000000
+
+typedef struct _EAXLISTENERPROPERTIES {
+    LONG lRoom;
+    LONG lRoomHF;
+    FLOAT flRoomRolloffFactor;
+    FLOAT flDecayTime;
+    FLOAT flDecayHFRatio;
+    LONG lReflections;
+    FLOAT flReflectionsDelay;
+    LONG lReverb;
+    FLOAT flReverbDelay;
+    DWORD dwEnvironment;
+    FLOAT flEnvironmentSize;
+    FLOAT flEnvironmentDiffusion;
+    FLOAT flAirAbsorptionHF;
+    DWORD dwFlags;
+} EAXLISTENERPROPERTIES, *LPEAXLISTENERPROPERTIES;
+
+/* These flags determine what properties are modified when the environment size
+   is changed */
+#define EAXLISTENERFLAGS_DECAYTIMESCALE        0x00000001
+#define EAXLISTENERFLAGS_REFLECTIONSSCALE      0x00000002
+#define EAXLISTENERFLAGS_REFLECTIONSDELAYSCALE 0x00000004
+#define EAXLISTENERFLAGS_REVERBSCALE           0x00000008
+#define EAXLISTENERFLAGS_REVERBDELAYSCALE      0x00000010
+/* This flag limits the high frequency decay according to air absorption */
+#define EAXLISTENERFLAGS_DECAYHFLIMIT          0x00000020
+
+/* EAX environment presets */
+/*    Room   RoomHF   RRlOff  DecTm   DcHF   Refl    RefDel  Revb   RevDel  Env  Size   Diffuse  AirAbs  Flags */
+#define REVERB_PRESET_GENERIC \
+    { -1000, -100,    0.0f,   1.49f,  0.83f, -2602,  0.007f, 200,   0.011f, 0,   7.5f,  1.000f,  -5.0f,  0x3f }
+#define REVERB_PRESET_PADDEDCELL \
+    { -1000, -6000,   0.00f,  0.17f,  0.10f, -1204,  0.001f, 207,   0.002f, 1,   1.4f,  1.000f,  -5.0f,  0x3f }
+#define REVERB_PRESET_ROOM \
+    { -1000, -454,    0.00f,  0.40f,  0.83f, -1646,  0.002f, 53,    0.003f, 2,   1.9f,  1.000f,  -5.0f,  0x3f }
+#define REVERB_PRESET_BATHROOM \
+    { -1000, -1200,   0.00f,  1.49f,  0.54f, -370,   0.007f, 1030,  0.011f, 3,   1.4f,  1.000f,  -5.0f,  0x3f }
+#define REVERB_PRESET_LIVINGROOM \
+    { -1000, -6000,   0.00f,  0.50f,  0.10f, -1376,  0.003f, -1104, 0.004f, 4,   2.5f,  1.000f,  -5.0f,  0x3f }
+#define REVERB_PRESET_STONEROOM \
+    { -1000, -300,    0.00f,  2.31f,  0.64f, -711,   0.012f, 83,    0.017f, 5,   11.6f, 1.000f,  -5.0f,  0x3f }
+#define REVERB_PRESET_AUDITORIUM \
+    { -1000, -476,    0.00f,  4.32f,  0.59f, -789,   0.020f, -289,  0.030f, 6,   21.6f, 1.000f,  -5.0f,  0x3f }
+#define REVERB_PRESET_CONCERTHALL \
+    { -1000, -500,    0.00f,  3.92f,  0.70f, -1230,  0.020f, -2,    0.029f, 7,   19.6f, 1.000f,  -5.0f,  0x3f }
+#define REVERB_PRESET_CAVE \
+    { -1000, 0,       0.00f,  2.91f,  1.30f, -602,   0.015f, -302,  0.022f, 8,   14.6f, 1.000f,  -5.0f,  0x1f }
+#define REVERB_PRESET_ARENA \
+    { -1000, -698,    0.00f,  7.24f,  0.33f, -1166,  0.020f, 16,    0.030f, 9,   36.2f, 1.000f,  -5.0f,  0x3f }
+#define REVERB_PRESET_HANGAR \
+    { -1000, -1000,   0.00f,  10.05f, 0.23f, -602,   0.020f, 198,   0.030f, 10,  50.3f, 1.000f,  -5.0f,  0x3f }
+#define REVERB_PRESET_CARPETEDHALLWAY \
+    { -1000, -4000,   0.00f,  0.30f,  0.10f, -1831,  0.002f, -1630, 0.030f, 11,  1.9f,  1.000f,  -5.0f,  0x3f }
+#define REVERB_PRESET_HALLWAY \
+    { -1000, -300,    0.00f,  1.49f,  0.59f, -1219,  0.007f, 441,   0.011f, 12,  1.8f,  1.000f,  -5.0f,  0x3f }
+#define REVERB_PRESET_STONECORRIDOR \
+    { -1000, -237,    0.00f,  2.70f,  0.79f, -1214,  0.013f, 395,   0.020f, 13, 13.5f,  1.000f,  -5.0f,  0x3f }
+#define REVERB_PRESET_ALLEY \
+    { -1000, -270,    0.00f,  1.49f,  0.86f, -1204,  0.007f, -4,    0.011f, 14, 7.5f,   0.300f,  -5.0f,  0x3f }
+#define REVERB_PRESET_FOREST \
+    { -1000, -3300,   0.00f,  1.49f,  0.54f, -2560,  0.162f, -229,  0.088f, 15, 38.0f,  0.300f,  -5.0f,  0x3f }
+#define REVERB_PRESET_CITY \
+    { -1000, -800,    0.00f,  1.49f,  0.67f, -2273,  0.007f, -1691, 0.011f, 16, 7.5f,   0.500f,  -5.0f,  0x3f }
+#define REVERB_PRESET_MOUNTAINS \
+    { -1000, -2500,   0.00f,  1.49f,  0.21f, -2780,  0.300f, -1434, 0.100f, 17, 100.0f, 0.270f,  -5.0f,  0x1f }
+#define REVERB_PRESET_QUARRY \
+    { -1000, -1000,   0.00f,  1.49f,  0.83f, -10000, 0.061f, 500,   0.025f, 18, 17.5f,  1.000f,  -5.0f,  0x3f }
+#define REVERB_PRESET_PLAIN \
+    { -1000, -2000,  0.00f,   1.49f,  0.50f, -2466,  0.179f, -1926, 0.100f, 19, 42.5f,  0.210f,  -5.0f,  0x3f }
+#define REVERB_PRESET_PARKINGLOT \
+    { -1000, 0,       0.00f,  1.65f,  1.50f, -1363,  0.008f, -1153, 0.012f, 20, 8.3f,   1.000f,  -5.0f,  0x1f }
+#define REVERB_PRESET_SEWERPIPE \
+    { -1000, -1000,  0.00f,   2.81f,  0.14f, 429,    0.014f, 1023,  0.021f, 21, 1.7f,   0.800f,  -5.0f,  0x3f }
+#define REVERB_PRESET_UNDERWATER \
+    { -1000, -4000,   0.00f,  1.49f,  0.10f, -449,   0.007f, 1700,  0.011f, 22, 1.8f,   1.000f,  -5.0f,  0x3f }
+#define REVERB_PRESET_DRUGGED \
+    { -1000, 0,       0.00f,  8.39f,  1.39f, -115,   0.002f, 985,   0.030f, 23,  1.9f,  0.500f,  -5.0f,  0x1f }
+#define REVERB_PRESET_DIZZY \
+    { -1000, -400,    0.00f, 17.23f,  0.56f, -1713,  0.020f, -613,  0.030f, 24,  1.8f,  0.600f,  -5.0f,  0x1f }
+#define REVERB_PRESET_PSYCHOTIC \
+    { -1000, -151,    0.00f, 7.56f,   0.91f, -626,   0.020f, 774,   0.030f, 25,  1.0f,  0.500f,  -5.0f,  0x1f }
+
+enum {
+    EAX_ENVIRONMENT_GENERIC,
+    EAX_ENVIRONMENT_PADDEDCELL,
+    EAX_ENVIRONMENT_ROOM,
+    EAX_ENVIRONMENT_BATHROOM,
+    EAX_ENVIRONMENT_LIVINGROOM,
+    EAX_ENVIRONMENT_STONEROOM,
+    EAX_ENVIRONMENT_AUDITORIUM,
+    EAX_ENVIRONMENT_CONCERTHALL,
+    EAX_ENVIRONMENT_CAVE,
+    EAX_ENVIRONMENT_ARENA,
+    EAX_ENVIRONMENT_HANGAR,
+    EAX_ENVIRONMENT_CARPETEDHALLWAY,
+    EAX_ENVIRONMENT_HALLWAY,
+    EAX_ENVIRONMENT_STONECORRIDOR,
+    EAX_ENVIRONMENT_ALLEY,
+    EAX_ENVIRONMENT_FOREST,
+    EAX_ENVIRONMENT_CITY,
+    EAX_ENVIRONMENT_MOUNTAINS,
+    EAX_ENVIRONMENT_QUARRY,
+    EAX_ENVIRONMENT_PLAIN,
+    EAX_ENVIRONMENT_PARKINGLOT,
+    EAX_ENVIRONMENT_SEWERPIPE,
+    EAX_ENVIRONMENT_UNDERWATER,
+    EAX_ENVIRONMENT_DRUGGED,
+    EAX_ENVIRONMENT_DIZZY,
+    EAX_ENVIRONMENT_PSYCHOTIC,
+
+    EAX_ENVIRONMENT_COUNT
+};
+
+extern const EAXLISTENERPROPERTIES EnvironmentDefaults[EAX_ENVIRONMENT_COUNT];
+
+#endif
diff --git a/dlls/dsound/efx.h b/dlls/dsound/efx.h
new file mode 100644
index 0000000..0ccef95
--- /dev/null
+++ b/dlls/dsound/efx.h
@@ -0,0 +1,758 @@
+#ifndef AL_EFX_H
+#define AL_EFX_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ALC_EXT_EFX_NAME                         "ALC_EXT_EFX"
+
+#define ALC_EFX_MAJOR_VERSION                    0x20001
+#define ALC_EFX_MINOR_VERSION                    0x20002
+#define ALC_MAX_AUXILIARY_SENDS                  0x20003
+
+
+/* Listener properties. */
+#define AL_METERS_PER_UNIT                       0x20004
+
+/* Source properties. */
+#define AL_DIRECT_FILTER                         0x20005
+#define AL_AUXILIARY_SEND_FILTER                 0x20006
+#define AL_AIR_ABSORPTION_FACTOR                 0x20007
+#define AL_ROOM_ROLLOFF_FACTOR                   0x20008
+#define AL_CONE_OUTER_GAINHF                     0x20009
+#define AL_DIRECT_FILTER_GAINHF_AUTO             0x2000A
+#define AL_AUXILIARY_SEND_FILTER_GAIN_AUTO       0x2000B
+#define AL_AUXILIARY_SEND_FILTER_GAINHF_AUTO     0x2000C
+
+
+/* Effect properties. */
+
+/* Reverb effect parameters */
+#define AL_REVERB_DENSITY                        0x0001
+#define AL_REVERB_DIFFUSION                      0x0002
+#define AL_REVERB_GAIN                           0x0003
+#define AL_REVERB_GAINHF                         0x0004
+#define AL_REVERB_DECAY_TIME                     0x0005
+#define AL_REVERB_DECAY_HFRATIO                  0x0006
+#define AL_REVERB_REFLECTIONS_GAIN               0x0007
+#define AL_REVERB_REFLECTIONS_DELAY              0x0008
+#define AL_REVERB_LATE_REVERB_GAIN               0x0009
+#define AL_REVERB_LATE_REVERB_DELAY              0x000A
+#define AL_REVERB_AIR_ABSORPTION_GAINHF          0x000B
+#define AL_REVERB_ROOM_ROLLOFF_FACTOR            0x000C
+#define AL_REVERB_DECAY_HFLIMIT                  0x000D
+
+/* EAX Reverb effect parameters */
+#define AL_EAXREVERB_DENSITY                     0x0001
+#define AL_EAXREVERB_DIFFUSION                   0x0002
+#define AL_EAXREVERB_GAIN                        0x0003
+#define AL_EAXREVERB_GAINHF                      0x0004
+#define AL_EAXREVERB_GAINLF                      0x0005
+#define AL_EAXREVERB_DECAY_TIME                  0x0006
+#define AL_EAXREVERB_DECAY_HFRATIO               0x0007
+#define AL_EAXREVERB_DECAY_LFRATIO               0x0008
+#define AL_EAXREVERB_REFLECTIONS_GAIN            0x0009
+#define AL_EAXREVERB_REFLECTIONS_DELAY           0x000A
+#define AL_EAXREVERB_REFLECTIONS_PAN             0x000B
+#define AL_EAXREVERB_LATE_REVERB_GAIN            0x000C
+#define AL_EAXREVERB_LATE_REVERB_DELAY           0x000D
+#define AL_EAXREVERB_LATE_REVERB_PAN             0x000E
+#define AL_EAXREVERB_ECHO_TIME                   0x000F
+#define AL_EAXREVERB_ECHO_DEPTH                  0x0010
+#define AL_EAXREVERB_MODULATION_TIME             0x0011
+#define AL_EAXREVERB_MODULATION_DEPTH            0x0012
+#define AL_EAXREVERB_AIR_ABSORPTION_GAINHF       0x0013
+#define AL_EAXREVERB_HFREFERENCE                 0x0014
+#define AL_EAXREVERB_LFREFERENCE                 0x0015
+#define AL_EAXREVERB_ROOM_ROLLOFF_FACTOR         0x0016
+#define AL_EAXREVERB_DECAY_HFLIMIT               0x0017
+
+/* Chorus effect parameters */
+#define AL_CHORUS_WAVEFORM                       0x0001
+#define AL_CHORUS_PHASE                          0x0002
+#define AL_CHORUS_RATE                           0x0003
+#define AL_CHORUS_DEPTH                          0x0004
+#define AL_CHORUS_FEEDBACK                       0x0005
+#define AL_CHORUS_DELAY                          0x0006
+
+/* Distortion effect parameters */
+#define AL_DISTORTION_EDGE                       0x0001
+#define AL_DISTORTION_GAIN                       0x0002
+#define AL_DISTORTION_LOWPASS_CUTOFF             0x0003
+#define AL_DISTORTION_EQCENTER                   0x0004
+#define AL_DISTORTION_EQBANDWIDTH                0x0005
+
+/* Echo effect parameters */
+#define AL_ECHO_DELAY                            0x0001
+#define AL_ECHO_LRDELAY                          0x0002
+#define AL_ECHO_DAMPING                          0x0003
+#define AL_ECHO_FEEDBACK                         0x0004
+#define AL_ECHO_SPREAD                           0x0005
+
+/* Flanger effect parameters */
+#define AL_FLANGER_WAVEFORM                      0x0001
+#define AL_FLANGER_PHASE                         0x0002
+#define AL_FLANGER_RATE                          0x0003
+#define AL_FLANGER_DEPTH                         0x0004
+#define AL_FLANGER_FEEDBACK                      0x0005
+#define AL_FLANGER_DELAY                         0x0006
+
+/* Frequency shifter effect parameters */
+#define AL_FREQUENCY_SHIFTER_FREQUENCY           0x0001
+#define AL_FREQUENCY_SHIFTER_LEFT_DIRECTION      0x0002
+#define AL_FREQUENCY_SHIFTER_RIGHT_DIRECTION     0x0003
+
+/* Vocal morpher effect parameters */
+#define AL_VOCAL_MORPHER_PHONEMEA                0x0001
+#define AL_VOCAL_MORPHER_PHONEMEA_COARSE_TUNING  0x0002
+#define AL_VOCAL_MORPHER_PHONEMEB                0x0003
+#define AL_VOCAL_MORPHER_PHONEMEB_COARSE_TUNING  0x0004
+#define AL_VOCAL_MORPHER_WAVEFORM                0x0005
+#define AL_VOCAL_MORPHER_RATE                    0x0006
+
+/* Pitchshifter effect parameters */
+#define AL_PITCH_SHIFTER_COARSE_TUNE             0x0001
+#define AL_PITCH_SHIFTER_FINE_TUNE               0x0002
+
+/* Ringmodulator effect parameters */
+#define AL_RING_MODULATOR_FREQUENCY              0x0001
+#define AL_RING_MODULATOR_HIGHPASS_CUTOFF        0x0002
+#define AL_RING_MODULATOR_WAVEFORM               0x0003
+
+/* Autowah effect parameters */
+#define AL_AUTOWAH_ATTACK_TIME                   0x0001
+#define AL_AUTOWAH_RELEASE_TIME                  0x0002
+#define AL_AUTOWAH_RESONANCE                     0x0003
+#define AL_AUTOWAH_PEAK_GAIN                     0x0004
+
+/* Compressor effect parameters */
+#define AL_COMPRESSOR_ONOFF                      0x0001
+
+/* Equalizer effect parameters */
+#define AL_EQUALIZER_LOW_GAIN                    0x0001
+#define AL_EQUALIZER_LOW_CUTOFF                  0x0002
+#define AL_EQUALIZER_MID1_GAIN                   0x0003
+#define AL_EQUALIZER_MID1_CENTER                 0x0004
+#define AL_EQUALIZER_MID1_WIDTH                  0x0005
+#define AL_EQUALIZER_MID2_GAIN                   0x0006
+#define AL_EQUALIZER_MID2_CENTER                 0x0007
+#define AL_EQUALIZER_MID2_WIDTH                  0x0008
+#define AL_EQUALIZER_HIGH_GAIN                   0x0009
+#define AL_EQUALIZER_HIGH_CUTOFF                 0x000A
+
+/* Effect type */
+#define AL_EFFECT_FIRST_PARAMETER                0x0000
+#define AL_EFFECT_LAST_PARAMETER                 0x8000
+#define AL_EFFECT_TYPE                           0x8001
+
+/* Effect types, used with the AL_EFFECT_TYPE property */
+#define AL_EFFECT_NULL                           0x0000
+#define AL_EFFECT_REVERB                         0x0001
+#define AL_EFFECT_CHORUS                         0x0002
+#define AL_EFFECT_DISTORTION                     0x0003
+#define AL_EFFECT_ECHO                           0x0004
+#define AL_EFFECT_FLANGER                        0x0005
+#define AL_EFFECT_FREQUENCY_SHIFTER              0x0006
+#define AL_EFFECT_VOCAL_MORPHER                  0x0007
+#define AL_EFFECT_PITCH_SHIFTER                  0x0008
+#define AL_EFFECT_RING_MODULATOR                 0x0009
+#define AL_EFFECT_AUTOWAH                        0x000A
+#define AL_EFFECT_COMPRESSOR                     0x000B
+#define AL_EFFECT_EQUALIZER                      0x000C
+#define AL_EFFECT_EAXREVERB                      0x8000
+
+/* Auxiliary Effect Slot properties. */
+#define AL_EFFECTSLOT_EFFECT                     0x0001
+#define AL_EFFECTSLOT_GAIN                       0x0002
+#define AL_EFFECTSLOT_AUXILIARY_SEND_AUTO        0x0003
+
+/* NULL Auxiliary Slot ID to disable a source send. */
+#define AL_EFFECTSLOT_NULL                       0x0000
+
+
+/* Filter properties. */
+
+/* Lowpass filter parameters */
+#define AL_LOWPASS_GAIN                          0x0001
+#define AL_LOWPASS_GAINHF                        0x0002
+
+/* Highpass filter parameters */
+#define AL_HIGHPASS_GAIN                         0x0001
+#define AL_HIGHPASS_GAINLF                       0x0002
+
+/* Bandpass filter parameters */
+#define AL_BANDPASS_GAIN                         0x0001
+#define AL_BANDPASS_GAINLF                       0x0002
+#define AL_BANDPASS_GAINHF                       0x0003
+
+/* Filter type */
+#define AL_FILTER_FIRST_PARAMETER                0x0000
+#define AL_FILTER_LAST_PARAMETER                 0x8000
+#define AL_FILTER_TYPE                           0x8001
+
+/* Filter types, used with the AL_FILTER_TYPE property */
+#define AL_FILTER_NULL                           0x0000
+#define AL_FILTER_LOWPASS                        0x0001
+#define AL_FILTER_HIGHPASS                       0x0002
+#define AL_FILTER_BANDPASS                       0x0003
+
+
+/* Effect object function types. */
+typedef void (AL_APIENTRY *LPALGENEFFECTS)(ALsizei, ALuint*);
+typedef void (AL_APIENTRY *LPALDELETEEFFECTS)(ALsizei, ALuint*);
+typedef ALboolean (AL_APIENTRY *LPALISEFFECT)(ALuint);
+typedef void (AL_APIENTRY *LPALEFFECTI)(ALuint, ALenum, ALint);
+typedef void (AL_APIENTRY *LPALEFFECTIV)(ALuint, ALenum, ALint*);
+typedef void (AL_APIENTRY *LPALEFFECTF)(ALuint, ALenum, ALfloat);
+typedef void (AL_APIENTRY *LPALEFFECTFV)(ALuint, ALenum, ALfloat*);
+typedef void (AL_APIENTRY *LPALGETEFFECTI)(ALuint, ALenum, ALint*);
+typedef void (AL_APIENTRY *LPALGETEFFECTIV)(ALuint, ALenum, ALint*);
+typedef void (AL_APIENTRY *LPALGETEFFECTF)(ALuint, ALenum, ALfloat*);
+typedef void (AL_APIENTRY *LPALGETEFFECTFV)(ALuint, ALenum, ALfloat*);
+
+/* Filter object function types. */
+typedef void (AL_APIENTRY *LPALGENFILTERS)(ALsizei, ALuint*);
+typedef void (AL_APIENTRY *LPALDELETEFILTERS)(ALsizei, ALuint*);
+typedef ALboolean (AL_APIENTRY *LPALISFILTER)(ALuint);
+typedef void (AL_APIENTRY *LPALFILTERI)(ALuint, ALenum, ALint);
+typedef void (AL_APIENTRY *LPALFILTERIV)(ALuint, ALenum, ALint*);
+typedef void (AL_APIENTRY *LPALFILTERF)(ALuint, ALenum, ALfloat);
+typedef void (AL_APIENTRY *LPALFILTERFV)(ALuint, ALenum, ALfloat*);
+typedef void (AL_APIENTRY *LPALGETFILTERI)(ALuint, ALenum, ALint*);
+typedef void (AL_APIENTRY *LPALGETFILTERIV)(ALuint, ALenum, ALint*);
+typedef void (AL_APIENTRY *LPALGETFILTERF)(ALuint, ALenum, ALfloat*);
+typedef void (AL_APIENTRY *LPALGETFILTERFV)(ALuint, ALenum, ALfloat*);
+
+/* Auxiliary Effect Slot object function types. */
+typedef void (AL_APIENTRY *LPALGENAUXILIARYEFFECTSLOTS)(ALsizei, ALuint*);
+typedef void (AL_APIENTRY *LPALDELETEAUXILIARYEFFECTSLOTS)(ALsizei, ALuint*);
+typedef ALboolean (AL_APIENTRY *LPALISAUXILIARYEFFECTSLOT)(ALuint);
+typedef void (AL_APIENTRY *LPALAUXILIARYEFFECTSLOTI)(ALuint, ALenum, ALint);
+typedef void (AL_APIENTRY *LPALAUXILIARYEFFECTSLOTIV)(ALuint, ALenum, ALint*);
+typedef void (AL_APIENTRY *LPALAUXILIARYEFFECTSLOTF)(ALuint, ALenum, ALfloat);
+typedef void (AL_APIENTRY *LPALAUXILIARYEFFECTSLOTFV)(ALuint, ALenum, ALfloat*);
+typedef void (AL_APIENTRY *LPALGETAUXILIARYEFFECTSLOTI)(ALuint, ALenum, ALint*);
+typedef void (AL_APIENTRY *LPALGETAUXILIARYEFFECTSLOTIV)(ALuint, ALenum, ALint*);
+typedef void (AL_APIENTRY *LPALGETAUXILIARYEFFECTSLOTF)(ALuint, ALenum, ALfloat*);
+typedef void (AL_APIENTRY *LPALGETAUXILIARYEFFECTSLOTFV)(ALuint, ALenum, ALfloat*);
+
+#ifdef AL_ALEXT_PROTOTYPES
+AL_API ALvoid AL_APIENTRY alGenEffects(ALsizei n, ALuint *effects);
+AL_API ALvoid AL_APIENTRY alDeleteEffects(ALsizei n, ALuint *effects);
+AL_API ALboolean AL_APIENTRY alIsEffect(ALuint effect);
+AL_API ALvoid AL_APIENTRY alEffecti(ALuint effect, ALenum param, ALint iValue);
+AL_API ALvoid AL_APIENTRY alEffectiv(ALuint effect, ALenum param, ALint *piValues);
+AL_API ALvoid AL_APIENTRY alEffectf(ALuint effect, ALenum param, ALfloat flValue);
+AL_API ALvoid AL_APIENTRY alEffectfv(ALuint effect, ALenum param, ALfloat *pflValues);
+AL_API ALvoid AL_APIENTRY alGetEffecti(ALuint effect, ALenum param, ALint *piValue);
+AL_API ALvoid AL_APIENTRY alGetEffectiv(ALuint effect, ALenum param, ALint *piValues);
+AL_API ALvoid AL_APIENTRY alGetEffectf(ALuint effect, ALenum param, ALfloat *pflValue);
+AL_API ALvoid AL_APIENTRY alGetEffectfv(ALuint effect, ALenum param, ALfloat *pflValues);
+
+AL_API ALvoid AL_APIENTRY alGenFilters(ALsizei n, ALuint *filters);
+AL_API ALvoid AL_APIENTRY alDeleteFilters(ALsizei n, ALuint *filters);
+AL_API ALboolean AL_APIENTRY alIsFilter(ALuint filter);
+AL_API ALvoid AL_APIENTRY alFilteri(ALuint filter, ALenum param, ALint iValue);
+AL_API ALvoid AL_APIENTRY alFilteriv(ALuint filter, ALenum param, ALint *piValues);
+AL_API ALvoid AL_APIENTRY alFilterf(ALuint filter, ALenum param, ALfloat flValue);
+AL_API ALvoid AL_APIENTRY alFilterfv(ALuint filter, ALenum param, ALfloat *pflValues);
+AL_API ALvoid AL_APIENTRY alGetFilteri(ALuint filter, ALenum param, ALint *piValue);
+AL_API ALvoid AL_APIENTRY alGetFilteriv(ALuint filter, ALenum param, ALint *piValues);
+AL_API ALvoid AL_APIENTRY alGetFilterf(ALuint filter, ALenum param, ALfloat *pflValue);
+AL_API ALvoid AL_APIENTRY alGetFilterfv(ALuint filter, ALenum param, ALfloat *pflValues);
+
+AL_API ALvoid AL_APIENTRY alGenAuxiliaryEffectSlots(ALsizei n, ALuint *effectslots);
+AL_API ALvoid AL_APIENTRY alDeleteAuxiliaryEffectSlots(ALsizei n, ALuint *effectslots);
+AL_API ALboolean AL_APIENTRY alIsAuxiliaryEffectSlot(ALuint effectslot);
+AL_API ALvoid AL_APIENTRY alAuxiliaryEffectSloti(ALuint effectslot, ALenum param, ALint iValue);
+AL_API ALvoid AL_APIENTRY alAuxiliaryEffectSlotiv(ALuint effectslot, ALenum param, ALint *piValues);
+AL_API ALvoid AL_APIENTRY alAuxiliaryEffectSlotf(ALuint effectslot, ALenum param, ALfloat flValue);
+AL_API ALvoid AL_APIENTRY alAuxiliaryEffectSlotfv(ALuint effectslot, ALenum param, ALfloat *pflValues);
+AL_API ALvoid AL_APIENTRY alGetAuxiliaryEffectSloti(ALuint effectslot, ALenum param, ALint *piValue);
+AL_API ALvoid AL_APIENTRY alGetAuxiliaryEffectSlotiv(ALuint effectslot, ALenum param, ALint *piValues);
+AL_API ALvoid AL_APIENTRY alGetAuxiliaryEffectSlotf(ALuint effectslot, ALenum param, ALfloat *pflValue);
+AL_API ALvoid AL_APIENTRY alGetAuxiliaryEffectSlotfv(ALuint effectslot, ALenum param, ALfloat *pflValues);
+#endif
+
+/* Filter ranges and defaults. */
+
+/* Lowpass filter */
+#define LOWPASS_MIN_GAIN                         (0.0f)
+#define LOWPASS_MAX_GAIN                         (1.0f)
+#define LOWPASS_DEFAULT_GAIN                     (1.0f)
+
+#define LOWPASS_MIN_GAINHF                       (0.0f)
+#define LOWPASS_MAX_GAINHF                       (1.0f)
+#define LOWPASS_DEFAULT_GAINHF                   (1.0f)
+
+/* Highpass filter */
+#define HIGHPASS_MIN_GAIN                        (0.0f)
+#define HIGHPASS_MAX_GAIN                        (1.0f)
+#define HIGHPASS_DEFAULT_GAIN                    (1.0f)
+
+#define HIGHPASS_MIN_GAINLF                      (0.0f)
+#define HIGHPASS_MAX_GAINLF                      (1.0f)
+#define HIGHPASS_DEFAULT_GAINLF                  (1.0f)
+
+/* Bandpass filter */
+#define BANDPASS_MIN_GAIN                        (0.0f)
+#define BANDPASS_MAX_GAIN                        (1.0f)
+#define BANDPASS_DEFAULT_GAIN                    (1.0f)
+
+#define BANDPASS_MIN_GAINHF                      (0.0f)
+#define BANDPASS_MAX_GAINHF                      (1.0f)
+#define BANDPASS_DEFAULT_GAINHF                  (1.0f)
+
+#define BANDPASS_MIN_GAINLF                      (0.0f)
+#define BANDPASS_MAX_GAINLF                      (1.0f)
+#define BANDPASS_DEFAULT_GAINLF                  (1.0f)
+
+
+/* Effect parameter ranges and defaults. */
+
+/* Standard reverb effect */
+#define AL_REVERB_MIN_DENSITY                    (0.0f)
+#define AL_REVERB_MAX_DENSITY                    (1.0f)
+#define AL_REVERB_DEFAULT_DENSITY                (1.0f)
+
+#define AL_REVERB_MIN_DIFFUSION                  (0.0f)
+#define AL_REVERB_MAX_DIFFUSION                  (1.0f)
+#define AL_REVERB_DEFAULT_DIFFUSION              (1.0f)
+
+#define AL_REVERB_MIN_GAIN                       (0.0f)
+#define AL_REVERB_MAX_GAIN                       (1.0f)
+#define AL_REVERB_DEFAULT_GAIN                   (0.32f)
+
+#define AL_REVERB_MIN_GAINHF                     (0.0f)
+#define AL_REVERB_MAX_GAINHF                     (1.0f)
+#define AL_REVERB_DEFAULT_GAINHF                 (0.89f)
+
+#define AL_REVERB_MIN_DECAY_TIME                 (0.1f)
+#define AL_REVERB_MAX_DECAY_TIME                 (20.0f)
+#define AL_REVERB_DEFAULT_DECAY_TIME             (1.49f)
+
+#define AL_REVERB_MIN_DECAY_HFRATIO              (0.1f)
+#define AL_REVERB_MAX_DECAY_HFRATIO              (2.0f)
+#define AL_REVERB_DEFAULT_DECAY_HFRATIO          (0.83f)
+
+#define AL_REVERB_MIN_REFLECTIONS_GAIN           (0.0f)
+#define AL_REVERB_MAX_REFLECTIONS_GAIN           (3.16f)
+#define AL_REVERB_DEFAULT_REFLECTIONS_GAIN       (0.05f)
+
+#define AL_REVERB_MIN_REFLECTIONS_DELAY          (0.0f)
+#define AL_REVERB_MAX_REFLECTIONS_DELAY          (0.3f)
+#define AL_REVERB_DEFAULT_REFLECTIONS_DELAY      (0.007f)
+
+#define AL_REVERB_MIN_LATE_REVERB_GAIN           (0.0f)
+#define AL_REVERB_MAX_LATE_REVERB_GAIN           (10.0f)
+#define AL_REVERB_DEFAULT_LATE_REVERB_GAIN       (1.26f)
+
+#define AL_REVERB_MIN_LATE_REVERB_DELAY          (0.0f)
+#define AL_REVERB_MAX_LATE_REVERB_DELAY          (0.1f)
+#define AL_REVERB_DEFAULT_LATE_REVERB_DELAY      (0.011f)
+
+#define AL_REVERB_MIN_AIR_ABSORPTION_GAINHF      (0.892f)
+#define AL_REVERB_MAX_AIR_ABSORPTION_GAINHF      (1.0f)
+#define AL_REVERB_DEFAULT_AIR_ABSORPTION_GAINHF  (0.994f)
+
+#define AL_REVERB_MIN_ROOM_ROLLOFF_FACTOR        (0.0f)
+#define AL_REVERB_MAX_ROOM_ROLLOFF_FACTOR        (10.0f)
+#define AL_REVERB_DEFAULT_ROOM_ROLLOFF_FACTOR    (0.0f)
+
+#define AL_REVERB_MIN_DECAY_HFLIMIT              AL_FALSE
+#define AL_REVERB_MAX_DECAY_HFLIMIT              AL_TRUE
+#define AL_REVERB_DEFAULT_DECAY_HFLIMIT          AL_TRUE
+
+/* EAX reverb effect */
+#define AL_EAXREVERB_MIN_DENSITY                 (0.0f)
+#define AL_EAXREVERB_MAX_DENSITY                 (1.0f)
+#define AL_EAXREVERB_DEFAULT_DENSITY             (1.0f)
+
+#define AL_EAXREVERB_MIN_DIFFUSION               (0.0f)
+#define AL_EAXREVERB_MAX_DIFFUSION               (1.0f)
+#define AL_EAXREVERB_DEFAULT_DIFFUSION           (1.0f)
+
+#define AL_EAXREVERB_MIN_GAIN                    (0.0f)
+#define AL_EAXREVERB_MAX_GAIN                    (1.0f)
+#define AL_EAXREVERB_DEFAULT_GAIN                (0.32f)
+
+#define AL_EAXREVERB_MIN_GAINHF                  (0.0f)
+#define AL_EAXREVERB_MAX_GAINHF                  (1.0f)
+#define AL_EAXREVERB_DEFAULT_GAINHF              (0.89f)
+
+#define AL_EAXREVERB_MIN_GAINLF                  (0.0f)
+#define AL_EAXREVERB_MAX_GAINLF                  (1.0f)
+#define AL_EAXREVERB_DEFAULT_GAINLF              (1.0f)
+
+#define AL_EAXREVERB_MIN_DECAY_TIME              (0.1f)
+#define AL_EAXREVERB_MAX_DECAY_TIME              (20.0f)
+#define AL_EAXREVERB_DEFAULT_DECAY_TIME          (1.49f)
+
+#define AL_EAXREVERB_MIN_DECAY_HFRATIO           (0.1f)
+#define AL_EAXREVERB_MAX_DECAY_HFRATIO           (2.0f)
+#define AL_EAXREVERB_DEFAULT_DECAY_HFRATIO       (0.83f)
+
+#define AL_EAXREVERB_MIN_DECAY_LFRATIO           (0.1f)
+#define AL_EAXREVERB_MAX_DECAY_LFRATIO           (2.0f)
+#define AL_EAXREVERB_DEFAULT_DECAY_LFRATIO       (1.0f)
+
+#define AL_EAXREVERB_MIN_REFLECTIONS_GAIN        (0.0f)
+#define AL_EAXREVERB_MAX_REFLECTIONS_GAIN        (3.16f)
+#define AL_EAXREVERB_DEFAULT_REFLECTIONS_GAIN    (0.05f)
+
+#define AL_EAXREVERB_MIN_REFLECTIONS_DELAY       (0.0f)
+#define AL_EAXREVERB_MAX_REFLECTIONS_DELAY       (0.3f)
+#define AL_EAXREVERB_DEFAULT_REFLECTIONS_DELAY   (0.007f)
+
+#define AL_EAXREVERB_DEFAULT_REFLECTIONS_PAN_XYZ (0.0f)
+
+#define AL_EAXREVERB_MIN_LATE_REVERB_GAIN        (0.0f)
+#define AL_EAXREVERB_MAX_LATE_REVERB_GAIN        (10.0f)
+#define AL_EAXREVERB_DEFAULT_LATE_REVERB_GAIN    (1.26f)
+
+#define AL_EAXREVERB_MIN_LATE_REVERB_DELAY       (0.0f)
+#define AL_EAXREVERB_MAX_LATE_REVERB_DELAY       (0.1f)
+#define AL_EAXREVERB_DEFAULT_LATE_REVERB_DELAY   (0.011f)
+
+#define AL_EAXREVERB_DEFAULT_LATE_REVERB_PAN_XYZ (0.0f)
+
+#define AL_EAXREVERB_MIN_ECHO_TIME               (0.075f)
+#define AL_EAXREVERB_MAX_ECHO_TIME               (0.25f)
+#define AL_EAXREVERB_DEFAULT_ECHO_TIME           (0.25f)
+
+#define AL_EAXREVERB_MIN_ECHO_DEPTH              (0.0f)
+#define AL_EAXREVERB_MAX_ECHO_DEPTH              (1.0f)
+#define AL_EAXREVERB_DEFAULT_ECHO_DEPTH          (0.0f)
+
+#define AL_EAXREVERB_MIN_MODULATION_TIME         (0.04f)
+#define AL_EAXREVERB_MAX_MODULATION_TIME         (4.0f)
+#define AL_EAXREVERB_DEFAULT_MODULATION_TIME     (0.25f)
+
+#define AL_EAXREVERB_MIN_MODULATION_DEPTH        (0.0f)
+#define AL_EAXREVERB_MAX_MODULATION_DEPTH        (1.0f)
+#define AL_EAXREVERB_DEFAULT_MODULATION_DEPTH    (0.0f)
+
+#define AL_EAXREVERB_MIN_AIR_ABSORPTION_GAINHF   (0.892f)
+#define AL_EAXREVERB_MAX_AIR_ABSORPTION_GAINHF   (1.0f)
+#define AL_EAXREVERB_DEFAULT_AIR_ABSORPTION_GAINHF (0.994f)
+
+#define AL_EAXREVERB_MIN_HFREFERENCE             (1000.0f)
+#define AL_EAXREVERB_MAX_HFREFERENCE             (20000.0f)
+#define AL_EAXREVERB_DEFAULT_HFREFERENCE         (5000.0f)
+
+#define AL_EAXREVERB_MIN_LFREFERENCE             (20.0f)
+#define AL_EAXREVERB_MAX_LFREFERENCE             (1000.0f)
+#define AL_EAXREVERB_DEFAULT_LFREFERENCE         (250.0f)
+
+#define AL_EAXREVERB_MIN_ROOM_ROLLOFF_FACTOR     (0.0f)
+#define AL_EAXREVERB_MAX_ROOM_ROLLOFF_FACTOR     (10.0f)
+#define AL_EAXREVERB_DEFAULT_ROOM_ROLLOFF_FACTOR (0.0f)
+
+#define AL_EAXREVERB_MIN_DECAY_HFLIMIT           AL_FALSE
+#define AL_EAXREVERB_MAX_DECAY_HFLIMIT           AL_TRUE
+#define AL_EAXREVERB_DEFAULT_DECAY_HFLIMIT       AL_TRUE
+
+/* Chorus effect */
+#define AL_CHORUS_WAVEFORM_SINUSOID              (0)
+#define AL_CHORUS_WAVEFORM_TRIANGLE              (1)
+
+#define AL_CHORUS_MIN_WAVEFORM                   (0)
+#define AL_CHORUS_MAX_WAVEFORM                   (1)
+#define AL_CHORUS_DEFAULT_WAVEFORM               (1)
+
+#define AL_CHORUS_MIN_PHASE                      (-180)
+#define AL_CHORUS_MAX_PHASE                      (180)
+#define AL_CHORUS_DEFAULT_PHASE                  (90)
+
+#define AL_CHORUS_MIN_RATE                       (0.0f)
+#define AL_CHORUS_MAX_RATE                       (10.0f)
+#define AL_CHORUS_DEFAULT_RATE                   (1.1f)
+
+#define AL_CHORUS_MIN_DEPTH                      (0.0f)
+#define AL_CHORUS_MAX_DEPTH                      (1.0f)
+#define AL_CHORUS_DEFAULT_DEPTH                  (0.1f)
+
+#define AL_CHORUS_MIN_FEEDBACK                   (-1.0f)
+#define AL_CHORUS_MAX_FEEDBACK                   (1.0f)
+#define AL_CHORUS_DEFAULT_FEEDBACK               (0.25f)
+
+#define AL_CHORUS_MIN_DELAY                      (0.0f)
+#define AL_CHORUS_MAX_DELAY                      (0.016f)
+#define AL_CHORUS_DEFAULT_DELAY                  (0.016f)
+
+/* Distortion effect */
+#define AL_DISTORTION_MIN_EDGE                   (0.0f)
+#define AL_DISTORTION_MAX_EDGE                   (1.0f)
+#define AL_DISTORTION_DEFAULT_EDGE               (0.2f)
+
+#define AL_DISTORTION_MIN_GAIN                   (0.01f)
+#define AL_DISTORTION_MAX_GAIN                   (1.0f)
+#define AL_DISTORTION_DEFAULT_GAIN               (0.05f)
+
+#define AL_DISTORTION_MIN_LOWPASS_CUTOFF         (80.0f)
+#define AL_DISTORTION_MAX_LOWPASS_CUTOFF         (24000.0f)
+#define AL_DISTORTION_DEFAULT_LOWPASS_CUTOFF     (8000.0f)
+
+#define AL_DISTORTION_MIN_EQCENTER               (80.0f)
+#define AL_DISTORTION_MAX_EQCENTER               (24000.0f)
+#define AL_DISTORTION_DEFAULT_EQCENTER           (3600.0f)
+
+#define AL_DISTORTION_MIN_EQBANDWIDTH            (80.0f)
+#define AL_DISTORTION_MAX_EQBANDWIDTH            (24000.0f)
+#define AL_DISTORTION_DEFAULT_EQBANDWIDTH        (3600.0f)
+
+/* Echo effect */
+#define AL_ECHO_MIN_DELAY                        (0.0f)
+#define AL_ECHO_MAX_DELAY                        (0.207f)
+#define AL_ECHO_DEFAULT_DELAY                    (0.1f)
+
+#define AL_ECHO_MIN_LRDELAY                      (0.0f)
+#define AL_ECHO_MAX_LRDELAY                      (0.404f)
+#define AL_ECHO_DEFAULT_LRDELAY                  (0.1f)
+
+#define AL_ECHO_MIN_DAMPING                      (0.0f)
+#define AL_ECHO_MAX_DAMPING                      (0.99f)
+#define AL_ECHO_DEFAULT_DAMPING                  (0.5f)
+
+#define AL_ECHO_MIN_FEEDBACK                     (0.0f)
+#define AL_ECHO_MAX_FEEDBACK                     (1.0f)
+#define AL_ECHO_DEFAULT_FEEDBACK                 (0.5f)
+
+#define AL_ECHO_MIN_SPREAD                       (-1.0f)
+#define AL_ECHO_MAX_SPREAD                       (1.0f)
+#define AL_ECHO_DEFAULT_SPREAD                   (-1.0f)
+
+/* Flanger effect */
+#define AL_FLANGER_WAVEFORM_SINUSOID             (0)
+#define AL_FLANGER_WAVEFORM_TRIANGLE             (1)
+
+#define AL_FLANGER_MIN_WAVEFORM                  (0)
+#define AL_FLANGER_MAX_WAVEFORM                  (1)
+#define AL_FLANGER_DEFAULT_WAVEFORM              (1)
+
+#define AL_FLANGER_MIN_PHASE                     (-180)
+#define AL_FLANGER_MAX_PHASE                     (180)
+#define AL_FLANGER_DEFAULT_PHASE                 (0)
+
+#define AL_FLANGER_MIN_RATE                      (0.0f)
+#define AL_FLANGER_MAX_RATE                      (10.0f)
+#define AL_FLANGER_DEFAULT_RATE                  (0.27f)
+
+#define AL_FLANGER_MIN_DEPTH                     (0.0f)
+#define AL_FLANGER_MAX_DEPTH                     (1.0f)
+#define AL_FLANGER_DEFAULT_DEPTH                 (1.0f)
+
+#define AL_FLANGER_MIN_FEEDBACK                  (-1.0f)
+#define AL_FLANGER_MAX_FEEDBACK                  (1.0f)
+#define AL_FLANGER_DEFAULT_FEEDBACK              (-0.5f)
+
+#define AL_FLANGER_MIN_DELAY                     (0.0f)
+#define AL_FLANGER_MAX_DELAY                     (0.004f)
+#define AL_FLANGER_DEFAULT_DELAY                 (0.002f)
+
+/* Frequency shifter effect */
+#define AL_FREQUENCY_SHIFTER_MIN_FREQUENCY       (0.0f)
+#define AL_FREQUENCY_SHIFTER_MAX_FREQUENCY       (24000.0f)
+#define AL_FREQUENCY_SHIFTER_DEFAULT_FREQUENCY   (0.0f)
+
+#define AL_FREQUENCY_SHIFTER_MIN_LEFT_DIRECTION  (0)
+#define AL_FREQUENCY_SHIFTER_MAX_LEFT_DIRECTION  (2)
+#define AL_FREQUENCY_SHIFTER_DEFAULT_LEFT_DIRECTION (0)
+
+#define AL_FREQUENCY_SHIFTER_DIRECTION_DOWN      (0)
+#define AL_FREQUENCY_SHIFTER_DIRECTION_UP        (1)
+#define AL_FREQUENCY_SHIFTER_DIRECTION_OFF       (2)
+
+#define AL_FREQUENCY_SHIFTER_MIN_RIGHT_DIRECTION (0)
+#define AL_FREQUENCY_SHIFTER_MAX_RIGHT_DIRECTION (2)
+#define AL_FREQUENCY_SHIFTER_DEFAULT_RIGHT_DIRECTION (0)
+
+/* Vocal morpher effect */
+#define AL_VOCAL_MORPHER_MIN_PHONEMEA            (0)
+#define AL_VOCAL_MORPHER_MAX_PHONEMEA            (29)
+#define AL_VOCAL_MORPHER_DEFAULT_PHONEMEA        (0)
+
+#define AL_VOCAL_MORPHER_MIN_PHONEMEA_COARSE_TUNING (-24)
+#define AL_VOCAL_MORPHER_MAX_PHONEMEA_COARSE_TUNING (24)
+#define AL_VOCAL_MORPHER_DEFAULT_PHONEMEA_COARSE_TUNING (0)
+
+#define AL_VOCAL_MORPHER_MIN_PHONEMEB            (0)
+#define AL_VOCAL_MORPHER_MAX_PHONEMEB            (29)
+#define AL_VOCAL_MORPHER_DEFAULT_PHONEMEB        (10)
+
+#define AL_VOCAL_MORPHER_MIN_PHONEMEB_COARSE_TUNING (-24)
+#define AL_VOCAL_MORPHER_MAX_PHONEMEB_COARSE_TUNING (24)
+#define AL_VOCAL_MORPHER_DEFAULT_PHONEMEB_COARSE_TUNING (0)
+
+#define AL_VOCAL_MORPHER_PHONEME_A               (0)
+#define AL_VOCAL_MORPHER_PHONEME_E               (1)
+#define AL_VOCAL_MORPHER_PHONEME_I               (2)
+#define AL_VOCAL_MORPHER_PHONEME_O               (3)
+#define AL_VOCAL_MORPHER_PHONEME_U               (4)
+#define AL_VOCAL_MORPHER_PHONEME_AA              (5)
+#define AL_VOCAL_MORPHER_PHONEME_AE              (6)
+#define AL_VOCAL_MORPHER_PHONEME_AH              (7)
+#define AL_VOCAL_MORPHER_PHONEME_AO              (8)
+#define AL_VOCAL_MORPHER_PHONEME_EH              (9)
+#define AL_VOCAL_MORPHER_PHONEME_ER              (10)
+#define AL_VOCAL_MORPHER_PHONEME_IH              (11)
+#define AL_VOCAL_MORPHER_PHONEME_IY              (12)
+#define AL_VOCAL_MORPHER_PHONEME_UH              (13)
+#define AL_VOCAL_MORPHER_PHONEME_UW              (14)
+#define AL_VOCAL_MORPHER_PHONEME_B               (15)
+#define AL_VOCAL_MORPHER_PHONEME_D               (16)
+#define AL_VOCAL_MORPHER_PHONEME_F               (17)
+#define AL_VOCAL_MORPHER_PHONEME_G               (18)
+#define AL_VOCAL_MORPHER_PHONEME_J               (19)
+#define AL_VOCAL_MORPHER_PHONEME_K               (20)
+#define AL_VOCAL_MORPHER_PHONEME_L               (21)
+#define AL_VOCAL_MORPHER_PHONEME_M               (22)
+#define AL_VOCAL_MORPHER_PHONEME_N               (23)
+#define AL_VOCAL_MORPHER_PHONEME_P               (24)
+#define AL_VOCAL_MORPHER_PHONEME_R               (25)
+#define AL_VOCAL_MORPHER_PHONEME_S               (26)
+#define AL_VOCAL_MORPHER_PHONEME_T               (27)
+#define AL_VOCAL_MORPHER_PHONEME_V               (28)
+#define AL_VOCAL_MORPHER_PHONEME_Z               (29)
+
+#define AL_VOCAL_MORPHER_WAVEFORM_SINUSOID       (0)
+#define AL_VOCAL_MORPHER_WAVEFORM_TRIANGLE       (1)
+#define AL_VOCAL_MORPHER_WAVEFORM_SAWTOOTH       (2)
+
+#define AL_VOCAL_MORPHER_MIN_WAVEFORM            (0)
+#define AL_VOCAL_MORPHER_MAX_WAVEFORM            (2)
+#define AL_VOCAL_MORPHER_DEFAULT_WAVEFORM        (0)
+
+#define AL_VOCAL_MORPHER_MIN_RATE                (0.0f)
+#define AL_VOCAL_MORPHER_MAX_RATE                (10.0f)
+#define AL_VOCAL_MORPHER_DEFAULT_RATE            (1.41f)
+
+/* Pitch shifter effect */
+#define AL_PITCH_SHIFTER_MIN_COARSE_TUNE         (-12)
+#define AL_PITCH_SHIFTER_MAX_COARSE_TUNE         (12)
+#define AL_PITCH_SHIFTER_DEFAULT_COARSE_TUNE     (12)
+
+#define AL_PITCH_SHIFTER_MIN_FINE_TUNE           (-50)
+#define AL_PITCH_SHIFTER_MAX_FINE_TUNE           (50)
+#define AL_PITCH_SHIFTER_DEFAULT_FINE_TUNE       (0)
+
+/* Ring modulator effect */
+#define AL_RING_MODULATOR_MIN_FREQUENCY          (0.0f)
+#define AL_RING_MODULATOR_MAX_FREQUENCY          (8000.0f)
+#define AL_RING_MODULATOR_DEFAULT_FREQUENCY      (440.0f)
+
+#define AL_RING_MODULATOR_MIN_HIGHPASS_CUTOFF    (0.0f)
+#define AL_RING_MODULATOR_MAX_HIGHPASS_CUTOFF    (24000.0f)
+#define AL_RING_MODULATOR_DEFAULT_HIGHPASS_CUTOFF (800.0f)
+
+#define AL_RING_MODULATOR_SINUSOID               (0)
+#define AL_RING_MODULATOR_SAWTOOTH               (1)
+#define AL_RING_MODULATOR_SQUARE                 (2)
+
+#define AL_RING_MODULATOR_MIN_WAVEFORM           (0)
+#define AL_RING_MODULATOR_MAX_WAVEFORM           (2)
+#define AL_RING_MODULATOR_DEFAULT_WAVEFORM       (0)
+
+/* Autowah effect */
+#define AL_AUTOWAH_MIN_ATTACK_TIME               (0.0001f)
+#define AL_AUTOWAH_MAX_ATTACK_TIME               (1.0f)
+#define AL_AUTOWAH_DEFAULT_ATTACK_TIME           (0.06f)
+
+#define AL_AUTOWAH_MIN_RELEASE_TIME              (0.0001f)
+#define AL_AUTOWAH_MAX_RELEASE_TIME              (1.0f)
+#define AL_AUTOWAH_DEFAULT_RELEASE_TIME          (0.06f)
+
+#define AL_AUTOWAH_MIN_RESONANCE                 (2.0f)
+#define AL_AUTOWAH_MAX_RESONANCE                 (1000.0f)
+#define AL_AUTOWAH_DEFAULT_RESONANCE             (1000.0f)
+
+#define AL_AUTOWAH_MIN_PEAK_GAIN                 (0.00003f)
+#define AL_AUTOWAH_MAX_PEAK_GAIN                 (31621.0f)
+#define AL_AUTOWAH_DEFAULT_PEAK_GAIN             (11.22f)
+
+/* Compressor effect */
+#define AL_COMPRESSOR_MIN_ONOFF                  (0)
+#define AL_COMPRESSOR_MAX_ONOFF                  (1)
+#define AL_COMPRESSOR_DEFAULT_ONOFF              (1)
+
+/* Equalizer effect */
+#define AL_EQUALIZER_MIN_LOW_GAIN                (0.126f)
+#define AL_EQUALIZER_MAX_LOW_GAIN                (7.943f)
+#define AL_EQUALIZER_DEFAULT_LOW_GAIN            (1.0f)
+
+#define AL_EQUALIZER_MIN_LOW_CUTOFF              (50.0f)
+#define AL_EQUALIZER_MAX_LOW_CUTOFF              (800.0f)
+#define AL_EQUALIZER_DEFAULT_LOW_CUTOFF          (200.0f)
+
+#define AL_EQUALIZER_MIN_MID1_GAIN               (0.126f)
+#define AL_EQUALIZER_MAX_MID1_GAIN               (7.943f)
+#define AL_EQUALIZER_DEFAULT_MID1_GAIN           (1.0f)
+
+#define AL_EQUALIZER_MIN_MID1_CENTER             (200.0f)
+#define AL_EQUALIZER_MAX_MID1_CENTER             (3000.0f)
+#define AL_EQUALIZER_DEFAULT_MID1_CENTER         (500.0f)
+
+#define AL_EQUALIZER_MIN_MID1_WIDTH              (0.01f)
+#define AL_EQUALIZER_MAX_MID1_WIDTH              (1.0f)
+#define AL_EQUALIZER_DEFAULT_MID1_WIDTH          (1.0f)
+
+#define AL_EQUALIZER_MIN_MID2_GAIN               (0.126f)
+#define AL_EQUALIZER_MAX_MID2_GAIN               (7.943f)
+#define AL_EQUALIZER_DEFAULT_MID2_GAIN           (1.0f)
+
+#define AL_EQUALIZER_MIN_MID2_CENTER             (1000.0f)
+#define AL_EQUALIZER_MAX_MID2_CENTER             (8000.0f)
+#define AL_EQUALIZER_DEFAULT_MID2_CENTER         (3000.0f)
+
+#define AL_EQUALIZER_MIN_MID2_WIDTH              (0.01f)
+#define AL_EQUALIZER_MAX_MID2_WIDTH              (1.0f)
+#define AL_EQUALIZER_DEFAULT_MID2_WIDTH          (1.0f)
+
+#define AL_EQUALIZER_MIN_HIGH_GAIN               (0.126f)
+#define AL_EQUALIZER_MAX_HIGH_GAIN               (7.943f)
+#define AL_EQUALIZER_DEFAULT_HIGH_GAIN           (1.0f)
+
+#define AL_EQUALIZER_MIN_HIGH_CUTOFF             (4000.0f)
+#define AL_EQUALIZER_MAX_HIGH_CUTOFF             (16000.0f)
+#define AL_EQUALIZER_DEFAULT_HIGH_CUTOFF         (6000.0f)
+
+
+/* Source parameter value ranges and defaults. */
+#define AL_MIN_AIR_ABSORPTION_FACTOR             (0.0f)
+#define AL_MAX_AIR_ABSORPTION_FACTOR             (10.0f)
+#define AL_DEFAULT_AIR_ABSORPTION_FACTOR         (0.0f)
+
+#define AL_MIN_ROOM_ROLLOFF_FACTOR               (0.0f)
+#define AL_MAX_ROOM_ROLLOFF_FACTOR               (10.0f)
+#define AL_DEFAULT_ROOM_ROLLOFF_FACTOR           (0.0f)
+
+#define AL_MIN_CONE_OUTER_GAINHF                 (0.0f)
+#define AL_MAX_CONE_OUTER_GAINHF                 (1.0f)
+#define AL_DEFAULT_CONE_OUTER_GAINHF             (1.0f)
+
+#define AL_MIN_DIRECT_FILTER_GAINHF_AUTO         AL_FALSE
+#define AL_MAX_DIRECT_FILTER_GAINHF_AUTO         AL_TRUE
+#define AL_DEFAULT_DIRECT_FILTER_GAINHF_AUTO     AL_TRUE
+
+#define AL_MIN_AUXILIARY_SEND_FILTER_GAIN_AUTO   AL_FALSE
+#define AL_MAX_AUXILIARY_SEND_FILTER_GAIN_AUTO   AL_TRUE
+#define AL_DEFAULT_AUXILIARY_SEND_FILTER_GAIN_AUTO AL_TRUE
+
+#define AL_MIN_AUXILIARY_SEND_FILTER_GAINHF_AUTO AL_FALSE
+#define AL_MAX_AUXILIARY_SEND_FILTER_GAINHF_AUTO AL_TRUE
+#define AL_DEFAULT_AUXILIARY_SEND_FILTER_GAINHF_AUTO AL_TRUE
+
+
+/* Listener parameter value ranges and defaults. */
+#define AL_MIN_METERS_PER_UNIT                   FLT_MIN
+#define AL_MAX_METERS_PER_UNIT                   FLT_MAX
+#define AL_DEFAULT_METERS_PER_UNIT               (1.0f)
+
+
+#ifdef __cplusplus
+}  /* extern "C" */
+#endif
+
+#endif /* AL_EFX_H */
diff --git a/dlls/dsound/mixer.c b/dlls/dsound/mixer.c
deleted file mode 100644
index 5ed8d90..0000000
--- a/dlls/dsound/mixer.c
+++ /dev/null
@@ -1,1062 +0,0 @@
-/*  			DirectSound
- *
- * Copyright 1998 Marcus Meissner
- * Copyright 1998 Rob Riggs
- * Copyright 2000-2002 TransGaming Technologies, Inc.
- * Copyright 2007 Peter Dons Tychsen
- * Copyright 2007 Maarten Lankhorst
- * Copyright 2011 Owen Rudge for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#include <assert.h>
-#include <stdarg.h>
-#include <math.h>	/* Insomnia - pow() function */
-
-#define NONAMELESSSTRUCT
-#define NONAMELESSUNION
-#include "windef.h"
-#include "winbase.h"
-#include "mmsystem.h"
-#include "wingdi.h"
-#include "mmreg.h"
-#include "winternl.h"
-#include "wine/debug.h"
-#include "dsound.h"
-#include "ks.h"
-#include "ksmedia.h"
-#include "dsdriver.h"
-#include "dsound_private.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(dsound);
-
-void DSOUND_RecalcVolPan(PDSVOLUMEPAN volpan)
-{
-	double temp;
-	TRACE("(%p)\n",volpan);
-
-	TRACE("Vol=%d Pan=%d\n", volpan->lVolume, volpan->lPan);
-	/* the AmpFactors are expressed in 16.16 fixed point */
-	volpan->dwVolAmpFactor = (ULONG) (pow(2.0, volpan->lVolume / 600.0) * 0xffff);
-	/* FIXME: dwPan{Left|Right}AmpFactor */
-
-	/* FIXME: use calculated vol and pan ampfactors */
-	temp = (double) (volpan->lVolume - (volpan->lPan > 0 ? volpan->lPan : 0));
-	volpan->dwTotalLeftAmpFactor = (ULONG) (pow(2.0, temp / 600.0) * 0xffff);
-	temp = (double) (volpan->lVolume + (volpan->lPan < 0 ? volpan->lPan : 0));
-	volpan->dwTotalRightAmpFactor = (ULONG) (pow(2.0, temp / 600.0) * 0xffff);
-
-	TRACE("left = %x, right = %x\n", volpan->dwTotalLeftAmpFactor, volpan->dwTotalRightAmpFactor);
-}
-
-void DSOUND_AmpFactorToVolPan(PDSVOLUMEPAN volpan)
-{
-    double left,right;
-    TRACE("(%p)\n",volpan);
-
-    TRACE("left=%x, right=%x\n",volpan->dwTotalLeftAmpFactor,volpan->dwTotalRightAmpFactor);
-    if (volpan->dwTotalLeftAmpFactor==0)
-        left=-10000;
-    else
-        left=600 * log(((double)volpan->dwTotalLeftAmpFactor) / 0xffff) / log(2);
-    if (volpan->dwTotalRightAmpFactor==0)
-        right=-10000;
-    else
-        right=600 * log(((double)volpan->dwTotalRightAmpFactor) / 0xffff) / log(2);
-    if (left<right)
-    {
-        volpan->lVolume=right;
-        volpan->dwVolAmpFactor=volpan->dwTotalRightAmpFactor;
-    }
-    else
-    {
-        volpan->lVolume=left;
-        volpan->dwVolAmpFactor=volpan->dwTotalLeftAmpFactor;
-    }
-    if (volpan->lVolume < -10000)
-        volpan->lVolume=-10000;
-    volpan->lPan=right-left;
-    if (volpan->lPan < -10000)
-        volpan->lPan=-10000;
-
-    TRACE("Vol=%d Pan=%d\n", volpan->lVolume, volpan->lPan);
-}
-
-/** Convert a primary buffer position to a pointer position for device->mix_buffer
- * device: DirectSoundDevice for which to calculate
- * pos: Primary buffer position to converts
- * Returns: Offset for mix_buffer
- */
-DWORD DSOUND_bufpos_to_mixpos(const DirectSoundDevice* device, DWORD pos)
-{
-    DWORD ret = pos * 32 / device->pwfx->wBitsPerSample;
-    if (device->pwfx->wBitsPerSample == 32)
-        ret *= 2;
-    return ret;
-}
-
-/* NOTE: Not all secpos have to always be mapped to a bufpos, other way around is always the case
- * DWORD64 is used here because a single DWORD wouldn't be big enough to fit the freqAcc for big buffers
- */
-/** This function converts a 'native' sample pointer to a resampled pointer that fits for primary
- * secmixpos is used to decide which freqAcc is needed
- * overshot tells what the 'actual' secpos is now (optional)
- */
-DWORD DSOUND_secpos_to_bufpos(const IDirectSoundBufferImpl *dsb, DWORD secpos, DWORD secmixpos, DWORD* overshot)
-{
-	DWORD64 framelen = secpos / dsb->pwfx->nBlockAlign;
-	DWORD64 freqAdjust = dsb->freqAdjust;
-	DWORD64 acc, freqAcc;
-
-	if (secpos < secmixpos)
-		freqAcc = dsb->freqAccNext;
-	else freqAcc = dsb->freqAcc;
-	acc = (framelen << DSOUND_FREQSHIFT) + (freqAdjust - 1 - freqAcc);
-	acc /= freqAdjust;
-	if (overshot)
-	{
-		DWORD64 oshot = acc * freqAdjust + freqAcc;
-		assert(oshot >= framelen << DSOUND_FREQSHIFT);
-		oshot -= framelen << DSOUND_FREQSHIFT;
-		*overshot = (DWORD)oshot;
-		assert(*overshot < dsb->freqAdjust);
-	}
-	return (DWORD)acc * dsb->device->pwfx->nBlockAlign;
-}
-
-/** Convert a resampled pointer that fits for primary to a 'native' sample pointer
- * freqAccNext is used here rather than freqAcc: In case the app wants to fill up to
- * the play position it won't overwrite it
- */
-static DWORD DSOUND_bufpos_to_secpos(const IDirectSoundBufferImpl *dsb, DWORD bufpos)
-{
-	DWORD oAdv = dsb->device->pwfx->nBlockAlign, iAdv = dsb->pwfx->nBlockAlign, pos;
-	DWORD64 framelen;
-	DWORD64 acc;
-
-	framelen = bufpos/oAdv;
-	acc = framelen * (DWORD64)dsb->freqAdjust + (DWORD64)dsb->freqAccNext;
-	acc = acc >> DSOUND_FREQSHIFT;
-	pos = (DWORD)acc * iAdv;
-	if (pos >= dsb->buflen)
-		/* Because of differences between freqAcc and freqAccNext, this might happen */
-		pos = dsb->buflen - iAdv;
-	TRACE("Converted %d/%d to %d/%d\n", bufpos, dsb->tmp_buffer_len, pos, dsb->buflen);
-	return pos;
-}
-
-/**
- * Move freqAccNext to freqAcc, and find new values for buffer length and freqAccNext
- */
-static void DSOUND_RecalcFreqAcc(IDirectSoundBufferImpl *dsb)
-{
-	if (!dsb->freqneeded) return;
-	dsb->freqAcc = dsb->freqAccNext;
-	dsb->tmp_buffer_len = DSOUND_secpos_to_bufpos(dsb, dsb->buflen, 0, &dsb->freqAccNext);
-	TRACE("New freqadjust: %04x, new buflen: %d\n", dsb->freqAccNext, dsb->tmp_buffer_len);
-}
-
-/**
- * Recalculate the size for temporary buffer, and new writelead
- * Should be called when one of the following things occur:
- * - Primary buffer format is changed
- * - This buffer format (frequency) is changed
- *
- * After this, DSOUND_MixToTemporary(dsb, 0, dsb->buflen) should
- * be called to refill the temporary buffer with data.
- */
-void DSOUND_RecalcFormat(IDirectSoundBufferImpl *dsb)
-{
-	BOOL needremix = TRUE, needresample = (dsb->freq != dsb->device->pwfx->nSamplesPerSec);
-	DWORD bAlign = dsb->pwfx->nBlockAlign, pAlign = dsb->device->pwfx->nBlockAlign;
-	WAVEFORMATEXTENSIBLE *pwfxe;
-	BOOL ieee = FALSE;
-
-	TRACE("(%p)\n",dsb);
-
-	pwfxe = (WAVEFORMATEXTENSIBLE *) dsb->pwfx;
-
-	if ((pwfxe->Format.wFormatTag == WAVE_FORMAT_IEEE_FLOAT) || ((pwfxe->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE)
-	    && (IsEqualGUID(&pwfxe->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))))
-		ieee = TRUE;
-
-	/* calculate the 10ms write lead */
-	dsb->writelead = (dsb->freq / 100) * dsb->pwfx->nBlockAlign;
-
-	if ((dsb->pwfx->wBitsPerSample == dsb->device->pwfx->wBitsPerSample) &&
-	    (dsb->pwfx->nChannels == dsb->device->pwfx->nChannels) && !needresample && !ieee)
-		needremix = FALSE;
-	HeapFree(GetProcessHeap(), 0, dsb->tmp_buffer);
-	dsb->tmp_buffer = NULL;
-	dsb->max_buffer_len = dsb->freqAcc = dsb->freqAccNext = 0;
-	dsb->freqneeded = needresample;
-
-	if (ieee)
-		dsb->convert = convertbpp[4][dsb->device->pwfx->wBitsPerSample/8 - 1];
-	else
-		dsb->convert = convertbpp[dsb->pwfx->wBitsPerSample/8 - 1][dsb->device->pwfx->wBitsPerSample/8 - 1];
-
-	dsb->resampleinmixer = FALSE;
-
-	if (needremix)
-	{
-		if (needresample)
-			DSOUND_RecalcFreqAcc(dsb);
-		else
-			dsb->tmp_buffer_len = dsb->buflen / bAlign * pAlign;
-		dsb->max_buffer_len = dsb->tmp_buffer_len;
-		if ((dsb->max_buffer_len <= dsb->device->buflen || dsb->max_buffer_len < ds_snd_shadow_maxsize * 1024 * 1024) && ds_snd_shadow_maxsize >= 0)
-			dsb->tmp_buffer = HeapAlloc(GetProcessHeap(), 0, dsb->max_buffer_len);
-		if (dsb->tmp_buffer)
-			FillMemory(dsb->tmp_buffer, dsb->tmp_buffer_len, dsb->device->pwfx->wBitsPerSample == 8 ? 128 : 0);
-		else
-			dsb->resampleinmixer = TRUE;
-	}
-	else dsb->max_buffer_len = dsb->tmp_buffer_len = dsb->buflen;
-	dsb->buf_mixpos = DSOUND_secpos_to_bufpos(dsb, dsb->sec_mixpos, 0, NULL);
-}
-
-/**
- * Check for application callback requests for when the play position
- * reaches certain points.
- *
- * The offsets that will be triggered will be those between the recorded
- * "last played" position for the buffer (i.e. dsb->playpos) and "len" bytes
- * beyond that position.
- */
-void DSOUND_CheckEvent(const IDirectSoundBufferImpl *dsb, DWORD playpos, int len)
-{
-	int			i;
-	DWORD			offset;
-	LPDSBPOSITIONNOTIFY	event;
-	TRACE("(%p,%d)\n",dsb,len);
-
-	if (dsb->nrofnotifies == 0)
-		return;
-
-	TRACE("(%p) buflen = %d, playpos = %d, len = %d\n",
-		dsb, dsb->buflen, playpos, len);
-	for (i = 0; i < dsb->nrofnotifies ; i++) {
-		event = dsb->notifies + i;
-		offset = event->dwOffset;
-		TRACE("checking %d, position %d, event = %p\n",
-			i, offset, event->hEventNotify);
-		/* DSBPN_OFFSETSTOP has to be the last element. So this is */
-		/* OK. [Inside DirectX, p274] */
-		/* Windows does not seem to enforce this, and some apps rely */
-		/* on that, so we can't stop there. */
-		/*  */
-		/* This also means we can't sort the entries by offset, */
-		/* because DSBPN_OFFSETSTOP == -1 */
-		if (offset == DSBPN_OFFSETSTOP) {
-			if (dsb->state == STATE_STOPPED) {
-				SetEvent(event->hEventNotify);
-				TRACE("signalled event %p (%d)\n", event->hEventNotify, i);
-			}
-                        continue;
-		}
-		if ((playpos + len) >= dsb->buflen) {
-			if ((offset < ((playpos + len) % dsb->buflen)) ||
-			    (offset >= playpos)) {
-				TRACE("signalled event %p (%d)\n", event->hEventNotify, i);
-				SetEvent(event->hEventNotify);
-			}
-		} else {
-			if ((offset >= playpos) && (offset < (playpos + len))) {
-				TRACE("signalled event %p (%d)\n", event->hEventNotify, i);
-				SetEvent(event->hEventNotify);
-			}
-		}
-	}
-}
-
-/**
- * Copy a single frame from the given input buffer to the given output buffer.
- * Translate 8 <-> 16 bits and mono <-> stereo
- */
-static inline void cp_fields(const IDirectSoundBufferImpl *dsb, const BYTE *ibuf, BYTE *obuf,
-        UINT istride, UINT ostride, UINT count, UINT freqAcc, UINT adj)
-{
-    DirectSoundDevice *device = dsb->device;
-    INT istep = dsb->pwfx->wBitsPerSample / 8, ostep = device->pwfx->wBitsPerSample / 8;
-
-    if (device->pwfx->nChannels == dsb->pwfx->nChannels ||
-        (device->pwfx->nChannels == 2 && dsb->pwfx->nChannels == 6) ||
-        (device->pwfx->nChannels == 8 && dsb->pwfx->nChannels == 2) ||
-        (device->pwfx->nChannels == 6 && dsb->pwfx->nChannels == 2)) {
-        dsb->convert(ibuf, obuf, istride, ostride, count, freqAcc, adj);
-        if (device->pwfx->nChannels == 2 || dsb->pwfx->nChannels == 2)
-            dsb->convert(ibuf + istep, obuf + ostep, istride, ostride, count, freqAcc, adj);
-        return;
-    }
-
-    if (device->pwfx->nChannels == 1 && dsb->pwfx->nChannels == 2)
-    {
-        dsb->convert(ibuf, obuf, istride, ostride, count, freqAcc, adj);
-        return;
-    }
-
-    if (device->pwfx->nChannels == 2 && dsb->pwfx->nChannels == 1)
-    {
-        dsb->convert(ibuf, obuf, istride, ostride, count, freqAcc, adj);
-        dsb->convert(ibuf, obuf + ostep, istride, ostride, count, freqAcc, adj);
-        return;
-    }
-
-    WARN("Unable to remap channels: device=%u, buffer=%u\n", device->pwfx->nChannels,
-            dsb->pwfx->nChannels);
-}
-
-/**
- * Calculate the distance between two buffer offsets, taking wraparound
- * into account.
- */
-static inline DWORD DSOUND_BufPtrDiff(DWORD buflen, DWORD ptr1, DWORD ptr2)
-{
-/* If these asserts fail, the problem is not here, but in the underlying code */
-	assert(ptr1 < buflen);
-	assert(ptr2 < buflen);
-	if (ptr1 >= ptr2) {
-		return ptr1 - ptr2;
-	} else {
-		return buflen + ptr1 - ptr2;
-	}
-}
-/**
- * Mix at most the given amount of data into the allocated temporary buffer
- * of the given secondary buffer, starting from the dsb's first currently
- * unsampled frame (writepos), translating frequency (pitch), stereo/mono
- * and bits-per-sample so that it is ideal for the primary buffer.
- * Doesn't perform any mixing - this is a straight copy/convert operation.
- *
- * dsb = the secondary buffer
- * writepos = Starting position of changed buffer
- * len = number of bytes to resample from writepos
- *
- * NOTE: writepos + len <= buflen. When called by mixer, MixOne makes sure of this.
- */
-void DSOUND_MixToTemporary(const IDirectSoundBufferImpl *dsb, DWORD writepos, DWORD len, BOOL inmixer)
-{
-	INT	size;
-	BYTE	*ibp, *obp, *obp_begin;
-	INT	iAdvance = dsb->pwfx->nBlockAlign;
-	INT	oAdvance = dsb->device->pwfx->nBlockAlign;
-	DWORD freqAcc, target_writepos = 0, overshot, maxlen;
-
-	/* We resample only when needed */
-	if ((dsb->tmp_buffer && inmixer) || (!dsb->tmp_buffer && !inmixer) || dsb->resampleinmixer != inmixer)
-		return;
-
-	assert(writepos + len <= dsb->buflen);
-	if (inmixer && writepos + len < dsb->buflen)
-		len += dsb->pwfx->nBlockAlign;
-
-	maxlen = DSOUND_secpos_to_bufpos(dsb, len, 0, NULL);
-
-	ibp = dsb->buffer->memory + writepos;
-	if (!inmixer)
-		obp_begin = dsb->tmp_buffer;
-	else if (dsb->device->tmp_buffer_len < maxlen || !dsb->device->tmp_buffer)
-	{
-		dsb->device->tmp_buffer_len = maxlen;
-		if (dsb->device->tmp_buffer)
-			dsb->device->tmp_buffer = HeapReAlloc(GetProcessHeap(), 0, dsb->device->tmp_buffer, maxlen);
-		else
-			dsb->device->tmp_buffer = HeapAlloc(GetProcessHeap(), 0, maxlen);
-		obp_begin = dsb->device->tmp_buffer;
-	}
-	else
-		obp_begin = dsb->device->tmp_buffer;
-
-	TRACE("(%p, %p)\n", dsb, ibp);
-	size = len / iAdvance;
-
-	/* Check for same sample rate */
-	if (dsb->freq == dsb->device->pwfx->nSamplesPerSec) {
-		TRACE("(%p) Same sample rate %d = primary %d\n", dsb,
-			dsb->freq, dsb->device->pwfx->nSamplesPerSec);
-		obp = obp_begin;
-		if (!inmixer)
-			 obp += writepos/iAdvance*oAdvance;
-
-		cp_fields(dsb, ibp, obp, iAdvance, oAdvance, size, 0, 1 << DSOUND_FREQSHIFT);
-		return;
-	}
-
-	/* Mix in different sample rates */
-	TRACE("(%p) Adjusting frequency: %d -> %d\n", dsb, dsb->freq, dsb->device->pwfx->nSamplesPerSec);
-
-	target_writepos = DSOUND_secpos_to_bufpos(dsb, writepos, dsb->sec_mixpos, &freqAcc);
-	overshot = freqAcc >> DSOUND_FREQSHIFT;
-	if (overshot)
-	{
-		if (overshot >= size)
-			return;
-		size -= overshot;
-		writepos += overshot * iAdvance;
-		if (writepos >= dsb->buflen)
-			return;
-		ibp = dsb->buffer->memory + writepos;
-		freqAcc &= (1 << DSOUND_FREQSHIFT) - 1;
-		TRACE("Overshot: %d, freqAcc: %04x\n", overshot, freqAcc);
-	}
-
-	if (!inmixer)
-		obp = obp_begin + target_writepos;
-	else obp = obp_begin;
-
-	/* FIXME: Small problem here when we're overwriting buf_mixpos, it then STILL uses old freqAcc, not sure if it matters or not */
-	cp_fields(dsb, ibp, obp, iAdvance, oAdvance, size, freqAcc, dsb->freqAdjust);
-}
-
-/** Apply volume to the given soundbuffer from (primary) position writepos and length len
- * Returns: NULL if no volume needs to be applied
- * or else a memory handle that holds 'len' volume adjusted buffer */
-static LPBYTE DSOUND_MixerVol(const IDirectSoundBufferImpl *dsb, INT len)
-{
-	INT	i;
-	BYTE	*bpc;
-	INT16	*bps, *mems;
-	DWORD vLeft, vRight;
-	INT nChannels = dsb->device->pwfx->nChannels;
-	LPBYTE mem = (dsb->tmp_buffer ? dsb->tmp_buffer : dsb->buffer->memory) + dsb->buf_mixpos;
-
-	if (dsb->resampleinmixer)
-		mem = dsb->device->tmp_buffer;
-
-	TRACE("(%p,%d)\n",dsb,len);
-	TRACE("left = %x, right = %x\n", dsb->volpan.dwTotalLeftAmpFactor,
-		dsb->volpan.dwTotalRightAmpFactor);
-
-	if ((!(dsb->dsbd.dwFlags & DSBCAPS_CTRLPAN) || (dsb->volpan.lPan == 0)) &&
-	    (!(dsb->dsbd.dwFlags & DSBCAPS_CTRLVOLUME) || (dsb->volpan.lVolume == 0)) &&
-	     !(dsb->dsbd.dwFlags & DSBCAPS_CTRL3D))
-		return NULL; /* Nothing to do */
-
-	if (nChannels != 1 && nChannels != 2)
-	{
-		FIXME("There is no support for %d channels\n", nChannels);
-		return NULL;
-	}
-
-	if (dsb->device->pwfx->wBitsPerSample != 8 && dsb->device->pwfx->wBitsPerSample != 16)
-	{
-		FIXME("There is no support for %d bpp\n", dsb->device->pwfx->wBitsPerSample);
-		return NULL;
-	}
-
-	if (dsb->device->tmp_buffer_len < len || !dsb->device->tmp_buffer)
-	{
-		/* If we just resampled in DSOUND_MixToTemporary, we shouldn't need to resize here */
-		assert(!dsb->resampleinmixer);
-		dsb->device->tmp_buffer_len = len;
-		if (dsb->device->tmp_buffer)
-			dsb->device->tmp_buffer = HeapReAlloc(GetProcessHeap(), 0, dsb->device->tmp_buffer, len);
-		else
-			dsb->device->tmp_buffer = HeapAlloc(GetProcessHeap(), 0, len);
-	}
-
-	bpc = dsb->device->tmp_buffer;
-	bps = (INT16 *)bpc;
-	mems = (INT16 *)mem;
-	vLeft = dsb->volpan.dwTotalLeftAmpFactor;
-	if (nChannels > 1)
-		vRight = dsb->volpan.dwTotalRightAmpFactor;
-	else
-		vRight = vLeft;
-
-	switch (dsb->device->pwfx->wBitsPerSample) {
-	case 8:
-		/* 8-bit WAV is unsigned, but we need to operate */
-		/* on signed data for this to work properly */
-		for (i = 0; i < len-1; i+=2) {
-			*(bpc++) = (((*(mem++) - 128) * vLeft) >> 16) + 128;
-			*(bpc++) = (((*(mem++) - 128) * vRight) >> 16) + 128;
-		}
-		if (len % 2 == 1 && nChannels == 1)
-			*(bpc++) = (((*(mem++) - 128) * vLeft) >> 16) + 128;
-		break;
-	case 16:
-		/* 16-bit WAV is signed -- much better */
-		for (i = 0; i < len-3; i += 4) {
-			*(bps++) = (*(mems++) * vLeft) >> 16;
-			*(bps++) = (*(mems++) * vRight) >> 16;
-		}
-		if (len % 4 == 2 && nChannels == 1)
-			*(bps++) = ((INT)*(mems++) * vLeft) >> 16;
-		break;
-	}
-	return dsb->device->tmp_buffer;
-}
-
-/**
- * Mix (at most) the given number of bytes into the given position of the
- * device buffer, from the secondary buffer "dsb" (starting at the current
- * mix position for that buffer).
- *
- * Returns the number of bytes actually mixed into the device buffer. This
- * will match fraglen unless the end of the secondary buffer is reached
- * (and it is not looping).
- *
- * dsb  = the secondary buffer to mix from
- * writepos = position (offset) in device buffer to write at
- * fraglen = number of bytes to mix
- */
-static DWORD DSOUND_MixInBuffer(IDirectSoundBufferImpl *dsb, DWORD writepos, DWORD fraglen)
-{
-	INT len = fraglen, ilen;
-	BYTE *ibuf = (dsb->tmp_buffer ? dsb->tmp_buffer : dsb->buffer->memory) + dsb->buf_mixpos, *volbuf;
-	DWORD oldpos, mixbufpos;
-
-	TRACE("buf_mixpos=%d/%d sec_mixpos=%d/%d\n", dsb->buf_mixpos, dsb->tmp_buffer_len, dsb->sec_mixpos, dsb->buflen);
-	TRACE("(%p,%d,%d)\n",dsb,writepos,fraglen);
-
-	assert(dsb->buf_mixpos + len <= dsb->tmp_buffer_len);
-
-	if (len % dsb->device->pwfx->nBlockAlign) {
-		INT nBlockAlign = dsb->device->pwfx->nBlockAlign;
-		ERR("length not a multiple of block size, len = %d, block size = %d\n", len, nBlockAlign);
-		len -= len % nBlockAlign; /* data alignment */
-	}
-
-	/* Resample buffer to temporary buffer specifically allocated for this purpose, if needed */
-	DSOUND_MixToTemporary(dsb, dsb->sec_mixpos, DSOUND_bufpos_to_secpos(dsb, dsb->buf_mixpos+len) - dsb->sec_mixpos, TRUE);
-	if (dsb->resampleinmixer)
-		ibuf = dsb->device->tmp_buffer;
-
-	/* Apply volume if needed */
-	volbuf = DSOUND_MixerVol(dsb, len);
-	if (volbuf)
-		ibuf = volbuf;
-
-	mixbufpos = DSOUND_bufpos_to_mixpos(dsb->device, writepos);
-	/* Now mix the temporary buffer into the devices main buffer */
-	if ((writepos + len) <= dsb->device->buflen)
-		dsb->device->mixfunction(ibuf, dsb->device->mix_buffer + mixbufpos, len);
-	else
-	{
-		DWORD todo = dsb->device->buflen - writepos;
-		dsb->device->mixfunction(ibuf, dsb->device->mix_buffer + mixbufpos, todo);
-		dsb->device->mixfunction(ibuf + todo, dsb->device->mix_buffer, len - todo);
-	}
-
-	oldpos = dsb->sec_mixpos;
-	dsb->buf_mixpos += len;
-
-	if (dsb->buf_mixpos >= dsb->tmp_buffer_len) {
-		if (dsb->buf_mixpos > dsb->tmp_buffer_len)
-			ERR("Mixpos (%u) past buflen (%u), capping...\n", dsb->buf_mixpos, dsb->tmp_buffer_len);
-		if (dsb->playflags & DSBPLAY_LOOPING) {
-			dsb->buf_mixpos -= dsb->tmp_buffer_len;
-		} else if (dsb->buf_mixpos >= dsb->tmp_buffer_len) {
-			dsb->buf_mixpos = dsb->sec_mixpos = 0;
-			dsb->state = STATE_STOPPED;
-		}
-		DSOUND_RecalcFreqAcc(dsb);
-	}
-
-	dsb->sec_mixpos = DSOUND_bufpos_to_secpos(dsb, dsb->buf_mixpos);
-	ilen = DSOUND_BufPtrDiff(dsb->buflen, dsb->sec_mixpos, oldpos);
-	/* check for notification positions */
-	if (dsb->dsbd.dwFlags & DSBCAPS_CTRLPOSITIONNOTIFY &&
-	    dsb->state != STATE_STARTING) {
-		DSOUND_CheckEvent(dsb, oldpos, ilen);
-	}
-
-	/* increase mix position */
-	dsb->primary_mixpos += len;
-	if (dsb->primary_mixpos >= dsb->device->buflen)
-		dsb->primary_mixpos -= dsb->device->buflen;
-	return len;
-}
-
-/**
- * Mix some frames from the given secondary buffer "dsb" into the device
- * primary buffer.
- *
- * dsb = the secondary buffer
- * playpos = the current play position in the device buffer (primary buffer)
- * writepos = the current safe-to-write position in the device buffer
- * mixlen = the maximum number of bytes in the primary buffer to mix, from the
- *          current writepos.
- *
- * Returns: the number of bytes beyond the writepos that were mixed.
- */
-static DWORD DSOUND_MixOne(IDirectSoundBufferImpl *dsb, DWORD writepos, DWORD mixlen)
-{
-	/* The buffer's primary_mixpos may be before or after the device
-	 * buffer's mixpos, but both must be ahead of writepos. */
-	DWORD primary_done;
-
-	TRACE("(%p,%d,%d)\n",dsb,writepos,mixlen);
-	TRACE("writepos=%d, buf_mixpos=%d, primary_mixpos=%d, mixlen=%d\n", writepos, dsb->buf_mixpos, dsb->primary_mixpos, mixlen);
-	TRACE("looping=%d, leadin=%d, buflen=%d\n", dsb->playflags, dsb->leadin, dsb->tmp_buffer_len);
-
-	/* If leading in, only mix about 20 ms, and 'skip' mixing the rest, for more fluid pointer advancement */
-	if (dsb->leadin && dsb->state == STATE_STARTING)
-	{
-		if (mixlen > 2 * dsb->device->fraglen)
-		{
-			dsb->primary_mixpos += mixlen - 2 * dsb->device->fraglen;
-			dsb->primary_mixpos %= dsb->device->buflen;
-		}
-	}
-	dsb->leadin = FALSE;
-
-	/* calculate how much pre-buffering has already been done for this buffer */
-	primary_done = DSOUND_BufPtrDiff(dsb->device->buflen, dsb->primary_mixpos, writepos);
-
-	/* sanity */
-	if(mixlen < primary_done)
-	{
-		/* Should *NEVER* happen */
-		ERR("Fatal error. Under/Overflow? primary_done=%d, mixpos=%d/%d (%d/%d), primary_mixpos=%d, writepos=%d, mixlen=%d\n", primary_done,dsb->buf_mixpos,dsb->tmp_buffer_len,dsb->sec_mixpos, dsb->buflen, dsb->primary_mixpos, writepos, mixlen);
-		dsb->primary_mixpos = writepos + mixlen;
-		dsb->primary_mixpos %= dsb->device->buflen;
-		return mixlen;
-	}
-
-	/* take into account already mixed data */
-	mixlen -= primary_done;
-
-	TRACE("primary_done=%d, mixlen (primary) = %i\n", primary_done, mixlen);
-
-	if (!mixlen)
-		return primary_done;
-
-	/* First try to mix to the end of the buffer if possible
-	 * Theoretically it would allow for better optimization
-	*/
-	if (mixlen + dsb->buf_mixpos >= dsb->tmp_buffer_len)
-	{
-		DWORD newmixed, mixfirst = dsb->tmp_buffer_len - dsb->buf_mixpos;
-		newmixed = DSOUND_MixInBuffer(dsb, dsb->primary_mixpos, mixfirst);
-		mixlen -= newmixed;
-
-		if (dsb->playflags & DSBPLAY_LOOPING)
-			while (newmixed && mixlen)
-			{
-				mixfirst = (dsb->tmp_buffer_len < mixlen ? dsb->tmp_buffer_len : mixlen);
-				newmixed = DSOUND_MixInBuffer(dsb, dsb->primary_mixpos, mixfirst);
-				mixlen -= newmixed;
-			}
-	}
-	else DSOUND_MixInBuffer(dsb, dsb->primary_mixpos, mixlen);
-
-	/* re-calculate the primary done */
-	primary_done = DSOUND_BufPtrDiff(dsb->device->buflen, dsb->primary_mixpos, writepos);
-
-	TRACE("new primary_mixpos=%d, total mixed data=%d\n", dsb->primary_mixpos, primary_done);
-
-	/* Report back the total prebuffered amount for this buffer */
-	return primary_done;
-}
-
-/**
- * For a DirectSoundDevice, go through all the currently playing buffers and
- * mix them in to the device buffer.
- *
- * writepos = the current safe-to-write position in the primary buffer
- * mixlen = the maximum amount to mix into the primary buffer
- *          (beyond the current writepos)
- * recover = true if the sound device may have been reset and the write
- *           position in the device buffer changed
- * all_stopped = reports back if all buffers have stopped
- *
- * Returns:  the length beyond the writepos that was mixed to.
- */
-
-static DWORD DSOUND_MixToPrimary(const DirectSoundDevice *device, DWORD writepos, DWORD mixlen, BOOL recover, BOOL *all_stopped)
-{
-	INT i, len;
-	DWORD minlen = 0;
-	IDirectSoundBufferImpl	*dsb;
-
-	/* unless we find a running buffer, all have stopped */
-	*all_stopped = TRUE;
-
-	TRACE("(%d,%d,%d)\n", writepos, mixlen, recover);
-	for (i = 0; i < device->nrofbuffers; i++) {
-		dsb = device->buffers[i];
-
-		TRACE("MixToPrimary for %p, state=%d\n", dsb, dsb->state);
-
-		if (dsb->buflen && dsb->state && !dsb->hwbuf) {
-			TRACE("Checking %p, mixlen=%d\n", dsb, mixlen);
-			RtlAcquireResourceShared(&dsb->lock, TRUE);
-			/* if buffer is stopping it is stopped now */
-			if (dsb->state == STATE_STOPPING) {
-				dsb->state = STATE_STOPPED;
-				DSOUND_CheckEvent(dsb, 0, 0);
-			} else if (dsb->state != STATE_STOPPED) {
-
-				/* if recovering, reset the mix position */
-				if ((dsb->state == STATE_STARTING) || recover) {
-					dsb->primary_mixpos = writepos;
-				}
-
-				/* if the buffer was starting, it must be playing now */
-				if (dsb->state == STATE_STARTING)
-					dsb->state = STATE_PLAYING;
-
-				/* mix next buffer into the main buffer */
-				len = DSOUND_MixOne(dsb, writepos, mixlen);
-
-				if (!minlen) minlen = len;
-
-				/* record the minimum length mixed from all buffers */
-				/* we only want to return the length which *all* buffers have mixed */
-				else if (len) minlen = (len < minlen) ? len : minlen;
-
-				*all_stopped = FALSE;
-			}
-			RtlReleaseResource(&dsb->lock);
-		}
-	}
-
-	TRACE("Mixed at least %d from all buffers\n", minlen);
-	return minlen;
-}
-
-/**
- * Add buffers to the emulated wave device system.
- *
- * device = The current dsound playback device
- * force = If TRUE, the function will buffer up as many frags as possible,
- *         even though and will ignore the actual state of the primary buffer.
- *
- * Returns:  None
- */
-
-static void DSOUND_WaveQueue(DirectSoundDevice *device, BOOL force)
-{
-	DWORD prebuf_frags, wave_writepos, wave_fragpos, i;
-	TRACE("(%p)\n", device);
-
-	/* calculate the current wave frag position */
-	wave_fragpos = (device->pwplay + device->pwqueue) % device->helfrags;
-
-	/* calculate the current wave write position */
-	wave_writepos = wave_fragpos * device->fraglen;
-
-	TRACE("wave_fragpos = %i, wave_writepos = %i, pwqueue = %i, prebuf = %i\n",
-		wave_fragpos, wave_writepos, device->pwqueue, device->prebuf);
-
-	if (!force)
-	{
-		/* check remaining prebuffered frags */
-		prebuf_frags = device->mixpos / device->fraglen;
-		if (prebuf_frags == device->helfrags)
-			--prebuf_frags;
-		TRACE("wave_fragpos = %d, mixpos_frags = %d\n", wave_fragpos, prebuf_frags);
-		if (prebuf_frags < wave_fragpos)
-			prebuf_frags += device->helfrags;
-		prebuf_frags -= wave_fragpos;
-		TRACE("wanted prebuf_frags = %d\n", prebuf_frags);
-	}
-	else
-		/* buffer the maximum amount of frags */
-		prebuf_frags = device->prebuf;
-
-	/* limit to the queue we have left */
-	if ((prebuf_frags + device->pwqueue) > device->prebuf)
-		prebuf_frags = device->prebuf - device->pwqueue;
-
-	TRACE("prebuf_frags = %i\n", prebuf_frags);
-
-	/* adjust queue */
-	device->pwqueue += prebuf_frags;
-
-	/* get out of CS when calling the wave system */
-	LeaveCriticalSection(&(device->mixlock));
-	/* **** */
-
-	/* queue up the new buffers */
-	for(i=0; i<prebuf_frags; i++){
-		TRACE("queueing wave buffer %i\n", wave_fragpos);
-		waveOutWrite(device->hwo, &device->pwave[wave_fragpos], sizeof(WAVEHDR));
-		wave_fragpos++;
-		wave_fragpos %= device->helfrags;
-	}
-
-	/* **** */
-	EnterCriticalSection(&(device->mixlock));
-
-	TRACE("queue now = %i\n", device->pwqueue);
-}
-
-/**
- * Perform mixing for a Direct Sound device. That is, go through all the
- * secondary buffers (the sound bites currently playing) and mix them in
- * to the primary buffer (the device buffer).
- */
-static void DSOUND_PerformMix(DirectSoundDevice *device)
-{
-	TRACE("(%p)\n", device);
-
-	/* **** */
-	EnterCriticalSection(&(device->mixlock));
-
-	if (device->priolevel != DSSCL_WRITEPRIMARY) {
-		BOOL recover = FALSE, all_stopped = FALSE;
-		DWORD playpos, writepos, writelead, maxq, frag, prebuff_max, prebuff_left, size1, size2, mixplaypos, mixplaypos2;
-		LPVOID buf1, buf2;
-		BOOL lock = (device->hwbuf && !(device->drvdesc.dwFlags & DSDDESC_DONTNEEDPRIMARYLOCK));
-		int nfiller;
-
-		/* the sound of silence */
-		nfiller = device->pwfx->wBitsPerSample == 8 ? 128 : 0;
-
-		/* get the position in the primary buffer */
-		if (DSOUND_PrimaryGetPosition(device, &playpos, &writepos) != 0){
-			LeaveCriticalSection(&(device->mixlock));
-			return;
-		}
-
-		TRACE("primary playpos=%d, writepos=%d, clrpos=%d, mixpos=%d, buflen=%d\n",
-		      playpos,writepos,device->playpos,device->mixpos,device->buflen);
-		assert(device->playpos < device->buflen);
-
-		mixplaypos = DSOUND_bufpos_to_mixpos(device, device->playpos);
-		mixplaypos2 = DSOUND_bufpos_to_mixpos(device, playpos);
-
-		/* calc maximum prebuff */
-		prebuff_max = (device->prebuf * device->fraglen);
-		if (!device->hwbuf && playpos + prebuff_max >= device->helfrags * device->fraglen)
-			prebuff_max += device->buflen - device->helfrags * device->fraglen;
-
-		/* check how close we are to an underrun. It occurs when the writepos overtakes the mixpos */
-		prebuff_left = DSOUND_BufPtrDiff(device->buflen, device->mixpos, playpos);
-		writelead = DSOUND_BufPtrDiff(device->buflen, writepos, playpos);
-
-		/* check for underrun. underrun occurs when the write position passes the mix position
-		 * also wipe out just-played sound data */
-		if((prebuff_left > prebuff_max) || (device->state == STATE_STOPPED) || (device->state == STATE_STARTING)){
-			if (device->state == STATE_STOPPING || device->state == STATE_PLAYING)
-				WARN("Probable buffer underrun\n");
-			else TRACE("Buffer starting or buffer underrun\n");
-
-			/* recover mixing for all buffers */
-			recover = TRUE;
-
-			/* reset mix position to write position */
-			device->mixpos = writepos;
-
-			ZeroMemory(device->mix_buffer, device->mix_buffer_len);
-			ZeroMemory(device->buffer, device->buflen);
-		} else if (playpos < device->playpos) {
-			buf1 = device->buffer + device->playpos;
-			buf2 = device->buffer;
-			size1 = device->buflen - device->playpos;
-			size2 = playpos;
-			FillMemory(device->mix_buffer + mixplaypos, device->mix_buffer_len - mixplaypos, 0);
-			FillMemory(device->mix_buffer, mixplaypos2, 0);
-			if (lock)
-				IDsDriverBuffer_Lock(device->hwbuf, &buf1, &size1, &buf2, &size2, device->playpos, size1+size2, 0);
-			FillMemory(buf1, size1, nfiller);
-			if (playpos && (!buf2 || !size2))
-				FIXME("%d: (%d, %d)=>(%d, %d) There should be an additional buffer here!!\n", __LINE__, device->playpos, device->mixpos, playpos, writepos);
-			FillMemory(buf2, size2, nfiller);
-			if (lock)
-				IDsDriverBuffer_Unlock(device->hwbuf, buf1, size1, buf2, size2);
-		} else {
-			buf1 = device->buffer + device->playpos;
-			buf2 = NULL;
-			size1 = playpos - device->playpos;
-			size2 = 0;
-			FillMemory(device->mix_buffer + mixplaypos, mixplaypos2 - mixplaypos, 0);
-			if (lock)
-				IDsDriverBuffer_Lock(device->hwbuf, &buf1, &size1, &buf2, &size2, device->playpos, size1+size2, 0);
-			FillMemory(buf1, size1, nfiller);
-			if (buf2 && size2)
-			{
-				FIXME("%d: There should be no additional buffer here!!\n", __LINE__);
-				FillMemory(buf2, size2, nfiller);
-			}
-			if (lock)
-				IDsDriverBuffer_Unlock(device->hwbuf, buf1, size1, buf2, size2);
-		}
-		device->playpos = playpos;
-
-		/* find the maximum we can prebuffer from current write position */
-		maxq = (writelead < prebuff_max) ? (prebuff_max - writelead) : 0;
-
-		TRACE("prebuff_left = %d, prebuff_max = %dx%d=%d, writelead=%d\n",
-			prebuff_left, device->prebuf, device->fraglen, prebuff_max, writelead);
-
-		if (lock)
-			IDsDriverBuffer_Lock(device->hwbuf, &buf1, &size1, &buf2, &size2, writepos, maxq, 0);
-
-		/* do the mixing */
-		frag = DSOUND_MixToPrimary(device, writepos, maxq, recover, &all_stopped);
-
-		if (frag + writepos > device->buflen)
-		{
-			DWORD todo = device->buflen - writepos;
-			device->normfunction(device->mix_buffer + DSOUND_bufpos_to_mixpos(device, writepos), device->buffer + writepos, todo);
-			device->normfunction(device->mix_buffer, device->buffer, frag - todo);
-		}
-		else
-			device->normfunction(device->mix_buffer + DSOUND_bufpos_to_mixpos(device, writepos), device->buffer + writepos, frag);
-
-		/* update the mix position, taking wrap-around into account */
-		device->mixpos = writepos + frag;
-		device->mixpos %= device->buflen;
-
-		if (lock)
-		{
-			DWORD frag2 = (frag > size1 ? frag - size1 : 0);
-			frag -= frag2;
-			if (frag2 > size2)
-			{
-				FIXME("Buffering too much! (%d, %d, %d, %d)\n", maxq, frag, size2, frag2 - size2);
-				frag2 = size2;
-			}
-			IDsDriverBuffer_Unlock(device->hwbuf, buf1, frag, buf2, frag2);
-		}
-
-		/* update prebuff left */
-		prebuff_left = DSOUND_BufPtrDiff(device->buflen, device->mixpos, playpos);
-
-		/* check if have a whole fragment */
-		if (prebuff_left >= device->fraglen){
-
-			/* update the wave queue if using wave system */
-			if (!device->hwbuf)
-				DSOUND_WaveQueue(device, FALSE);
-
-			/* buffers are full. start playing if applicable */
-			if(device->state == STATE_STARTING){
-				TRACE("started primary buffer\n");
-				if(DSOUND_PrimaryPlay(device) != DS_OK){
-					WARN("DSOUND_PrimaryPlay failed\n");
-				}
-				else{
-					/* we are playing now */
-					device->state = STATE_PLAYING;
-				}
-			}
-
-			/* buffers are full. start stopping if applicable */
-			if(device->state == STATE_STOPPED){
-				TRACE("restarting primary buffer\n");
-				if(DSOUND_PrimaryPlay(device) != DS_OK){
-					WARN("DSOUND_PrimaryPlay failed\n");
-				}
-				else{
-					/* start stopping again. as soon as there is no more data, it will stop */
-					device->state = STATE_STOPPING;
-				}
-			}
-		}
-
-		/* if device was stopping, its for sure stopped when all buffers have stopped */
-		else if((all_stopped == TRUE) && (device->state == STATE_STOPPING)){
-			TRACE("All buffers have stopped. Stopping primary buffer\n");
-			device->state = STATE_STOPPED;
-
-			/* stop the primary buffer now */
-			DSOUND_PrimaryStop(device);
-		}
-
-	} else {
-
-		/* update the wave queue if using wave system */
-		if (!device->hwbuf)
-			DSOUND_WaveQueue(device, TRUE);
-		else
-			/* Keep alsa happy, which needs GetPosition called once every 10 ms */
-			IDsDriverBuffer_GetPosition(device->hwbuf, NULL, NULL);
-
-		/* in the DSSCL_WRITEPRIMARY mode, the app is totally in charge... */
-		if (device->state == STATE_STARTING) {
-			if (DSOUND_PrimaryPlay(device) != DS_OK)
-				WARN("DSOUND_PrimaryPlay failed\n");
-			else
-				device->state = STATE_PLAYING;
-		}
-		else if (device->state == STATE_STOPPING) {
-			if (DSOUND_PrimaryStop(device) != DS_OK)
-				WARN("DSOUND_PrimaryStop failed\n");
-			else
-				device->state = STATE_STOPPED;
-		}
-	}
-
-	LeaveCriticalSection(&(device->mixlock));
-	/* **** */
-}
-
-void CALLBACK DSOUND_timer(UINT timerID, UINT msg, DWORD_PTR dwUser,
-                           DWORD_PTR dw1, DWORD_PTR dw2)
-{
-	DirectSoundDevice * device = (DirectSoundDevice*)dwUser;
-	DWORD start_time =  GetTickCount();
-	DWORD end_time;
-	TRACE("(%d,%d,0x%lx,0x%lx,0x%lx)\n",timerID,msg,dwUser,dw1,dw2);
-	TRACE("entering at %d\n", start_time);
-
-	if (DSOUND_renderer[device->drvdesc.dnDevNode] != device) {
-		ERR("dsound died without killing us?\n");
-		timeKillEvent(timerID);
-		timeEndPeriod(DS_TIME_RES);
-		return;
-	}
-
-	RtlAcquireResourceShared(&(device->buffer_list_lock), TRUE);
-
-	if (device->ref)
-		DSOUND_PerformMix(device);
-
-	RtlReleaseResource(&(device->buffer_list_lock));
-
-	end_time = GetTickCount();
-	TRACE("completed processing at %d, duration = %d\n", end_time, end_time - start_time);
-}
-
-void CALLBACK DSOUND_callback(HWAVEOUT hwo, UINT msg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2)
-{
-	DirectSoundDevice * device = (DirectSoundDevice*)dwUser;
-	TRACE("(%p,%x,%lx,%lx,%lx)\n",hwo,msg,dwUser,dw1,dw2);
-	TRACE("entering at %d, msg=%08x(%s)\n", GetTickCount(), msg,
-		msg==MM_WOM_DONE ? "MM_WOM_DONE" : msg==MM_WOM_CLOSE ? "MM_WOM_CLOSE" : 
-		msg==MM_WOM_OPEN ? "MM_WOM_OPEN" : "UNKNOWN");
-
-	/* check if packet completed from wave driver */
-	if (msg == MM_WOM_DONE) {
-
-		/* **** */
-		EnterCriticalSection(&(device->mixlock));
-
-		TRACE("done playing primary pos=%d\n", device->pwplay * device->fraglen);
-
-		/* update playpos */
-		device->pwplay++;
-		device->pwplay %= device->helfrags;
-
-		/* sanity */
-		if(device->pwqueue == 0){
-			ERR("Wave queue corrupted!\n");
-		}
-
-		/* update queue */
-		device->pwqueue--;
-
-		LeaveCriticalSection(&(device->mixlock));
-		/* **** */
-	}
-	TRACE("completed\n");
-}
diff --git a/dlls/dsound/primary.c b/dlls/dsound/primary.c
index c726edf..a7b7ca5 100644
--- a/dlls/dsound/primary.c
+++ b/dlls/dsound/primary.c
@@ -1,8 +1,9 @@
-/*  			DirectSound
+/* DirectSound COM interface
  *
- * Copyright 1998 Marcus Meissner
- * Copyright 1998 Rob Riggs
- * Copyright 2000-2002 TransGaming Technologies, Inc.
+ * Copyright 2009 Maarten Lankhorst
+ *
+ * Some code taken from the original dsound-openal implementation
+ *    Copyright 2007-2009 Chris Robinson
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -17,1258 +18,1842 @@
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- *
- * TODO:
- *      When PrimarySetFormat (via ReopenDevice or PrimaryOpen) fails,
- *       it leaves dsound in unusable (not really open) state.
  */
-
+#include "config.h"
+#ifdef HAVE_OPENAL
 #include <stdarg.h>
 
+#define COBJMACROS
 #define NONAMELESSSTRUCT
 #define NONAMELESSUNION
 #include "windef.h"
 #include "winbase.h"
 #include "winuser.h"
+#include "winnls.h"
+#include "winreg.h"
+#include "vfwmsgs.h"
 #include "mmsystem.h"
 #include "winternl.h"
 #include "mmddk.h"
 #include "wine/debug.h"
 #include "dsound.h"
-#include "dsdriver.h"
 #include "dsound_private.h"
+#include "mmreg.h"
+#include "ks.h"
+#include "ksmedia.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(dsound);
 
-/** Calculate how long a fragment length of about 10 ms should be in frames
- *
- * nSamplesPerSec: Frequency rate in samples per second
- * nBlockAlign: Size of a single blockalign
- *
- * Returns:
- * Size in bytes of a single fragment
- */
-DWORD DSOUND_fraglen(DWORD nSamplesPerSec, DWORD nBlockAlign)
+static const IDirectSoundBufferVtbl DS8Primary_Vtbl;
+static const IDirectSound3DListenerVtbl DS8Primary3D_Vtbl;
+static const IKsPropertySetVtbl DS8PrimaryProp_Vtbl;
+
+/* Sample types */
+#define AL_BYTE                                  0x1400
+#define AL_UNSIGNED_BYTE                         0x1401
+#define AL_SHORT                                 0x1402
+#define AL_UNSIGNED_SHORT                        0x1403
+#define AL_INT                                   0x1404
+#define AL_UNSIGNED_INT                          0x1405
+#define AL_FLOAT                                 0x1406
+#define AL_DOUBLE                                0x1407
+#define AL_MULAW                                 0x1408
+#define AL_IMA4                                  0x1409
+
+/* Channel configurations */
+#define AL_MONO                                  0x1500
+#define AL_STEREO                                0x1501
+#define AL_REAR                                  0x1502
+#define AL_QUAD                                  0x1503
+#define AL_5POINT1                               0x1504 /* (WFX order) */
+#define AL_6POINT1                               0x1505 /* (WFX order) */
+#define AL_7POINT1                               0x1506 /* (WFX order) */
+
+static HRESULT openal_type(const WAVEFORMATEX *wfx, int *channelmask, int *fmt)
+{
+    switch (wfx->wBitsPerSample)
+    {
+        case 8: *fmt = AL_UNSIGNED_BYTE; break;
+        case 16: *fmt = AL_SHORT; break;
+        case 32:
+            if (IsEqualGUID(&((WAVEFORMATEXTENSIBLE*)wfx)->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM))
+                *fmt = AL_INT; break;
+            if (IsEqualGUID(&((WAVEFORMATEXTENSIBLE*)wfx)->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))
+                *fmt = AL_FLOAT; break;
+        default:
+            return DSERR_INVALIDCALL;
+    }
+    switch (wfx->nChannels)
+    {
+        case 1: *channelmask = AL_MONO; break;
+        case 2: *channelmask = AL_STEREO; break;
+        case 4: *channelmask = AL_QUAD; break;
+        case 6: *channelmask = AL_5POINT1; break;
+        case 7: *channelmask = AL_6POINT1; break;
+        case 8: *channelmask = AL_7POINT1; break;
+        default:
+            ERR("Unhandled channels %i\n", wfx->nChannels);
+            return DSERR_INVALIDPARAM;
+    }
+    return S_OK;
+}
+
+static HRESULT WINAPI create_mmdevapi(DS8Primary *This, WAVEFORMATEX **format)
 {
-    /* Given a timer delay of 10ms, the fragment size is approximately:
-     *     fraglen = (nSamplesPerSec * 10 / 1000) * nBlockAlign
-     * ==> fraglen = (nSamplesPerSec / 100) * nBlockSize
-     *
-     * ALSA uses buffers that are powers of 2. Because of this, fraglen
-     * is rounded up to the nearest power of 2:
+    HRESULT hr;
+    IMMDevice *dev = NULL;
+
+    hr = DSOUND_obtain_immdevice(eRender, &This->parent->guid, eMultimedia, &dev);
+    if (SUCCEEDED(hr))
+        hr = IMMDevice_Activate(dev, &IID_IAudioClient, CLSCTX_ALL, NULL, (void**)&This->dev);
+    if (SUCCEEDED(hr))
+        hr = IAudioClient_GetMixFormat(This->dev, format);
+    if (SUCCEEDED(hr))
+        hr = IAudioClient_Initialize(This->dev, AUDCLNT_SHAREMODE_SHARED, 0, 5000000, 0, *format, NULL);
+    if (SUCCEEDED(hr))
+        hr = IAudioClient_GetService(This->dev, &IID_IAudioRenderClient, (void**)&This->render_dev);
+    if (FAILED(hr))
+    {
+        if (This->dev)
+            IUnknown_Release(This->dev);
+        This->dev = NULL;
+        if (dev)
+            IUnknown_Release(dev);
+        if (hr == AUDCLNT_E_UNSUPPORTED_FORMAT)
+        {
+            FIXME("Couldn't open device: bad format\n");
+            return DSERR_BADFORMAT;
+        }
+        ERR("couldn't open device %s %i: %08x\n", debugstr_guid(&This->parent->guid), (*format)->nSamplesPerSec, hr);
+        return DSERR_NODRIVER;
+    }
+    return S_OK;
+}
+
+HRESULT DS8Primary_Create(DS8Primary **ppv, DS8Impl *parent)
+{
+    HRESULT hr = DSERR_OUTOFMEMORY;
+    DS8Primary *This = NULL;
+    DS3DLISTENER *listener;
+    WAVEFORMATEX *wfx, *realwfx;
+    ALuint srcs[256];
+    ALCint attrs[] = {
+        ALC_FORMAT_CHANNELS, AL_STEREO,
+        ALC_FORMAT_TYPE, AL_FLOAT,
+        ALC_FREQUENCY, 48000,
+        0
+    };
+    DWORD nsources;
+
+    *ppv = NULL;
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*This));
+    if(!This) return hr;
+
+    InitializeCriticalSection(&This->crst);
+    This->crst.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": DS8Primary.crst");
+
+    /* Allocate enough for a WAVEFORMATEXTENSIBLE */
+    This->format = wfx = HeapAlloc(GetProcessHeap(), 0, sizeof(WAVEFORMATEXTENSIBLE));
+    if(!wfx) goto fail;
+    This->parent = parent;
+
+    hr = create_mmdevapi(This, &realwfx);
+    if (SUCCEEDED(hr))
+        hr = openal_type(realwfx, &attrs[1], &attrs[3]);
+    else
+        goto fail;
+    attrs[5] = realwfx->nSamplesPerSec;
+    CoTaskMemFree(realwfx);
+
+    hr = DSERR_NODRIVER;
+    This->ctx = palcCreateContext(parent->device, attrs);
+    if(!This->ctx)
+    {
+        ALCenum err = palcGetError(parent->device);
+        ERR("Could not create context (%#x)!\n", err);
+        goto fail;
+    }
+
+    setALContext(This->ctx);
+    if(palIsExtensionPresent("AL_EXT_STATIC_BUFFER"))
+    {
+        TRACE("Found AL_EXT_STATIC_BUFFER\n");
+        This->ExtAL.BufferDataStatic = (PFNALBUFFERDATASTATICPROC)palGetProcAddress("alBufferDataStatic");
+        if(!This->ExtAL.BufferDataStatic)
+            ERR("Missing alBufferDataStatic!\n");
+    }
+    if(!This->ExtAL.BufferDataStatic && palIsExtensionPresent("AL_SOFT_buffer_sub_data"))
+    {
+        TRACE("Found AL_SOFT_buffer_sub_data\n");
+        This->ExtAL.BufferSubData = (PFNALBUFFERSUBDATASOFTPROC)palGetProcAddress("alBufferSubDataSOFT");
+        if(!This->ExtAL.BufferSubData)
+            ERR("Missing alBufferSubDataSOFT!\n");
+    }
+
+    if(palcIsExtensionPresent(parent->device, "ALC_EXT_EFX"))
+    {
+        This->has_efx = TRUE;
+
+#define LOAD_FUNC(x) (This->ExtAL.x = palGetProcAddress("al" #x))
+        LOAD_FUNC(GenEffects);
+        LOAD_FUNC(DeleteEffects);
+        LOAD_FUNC(Effecti);
+        LOAD_FUNC(Effectf);
+
+        LOAD_FUNC(GenAuxiliaryEffectSlots);
+        LOAD_FUNC(DeleteAuxiliaryEffectSlots);
+        LOAD_FUNC(AuxiliaryEffectSloti);
+#undef LOAD_FUNC
+
+        This->ExtAL.GenEffects(1, &This->effect);
+        This->ExtAL.Effecti(This->effect, AL_EFFECT_TYPE, AL_EFFECT_REVERB);
+
+        This->ExtAL.GenAuxiliaryEffectSlots(1, &This->auxslot);
+    }
+    This->eax_prop = EnvironmentDefaults[EAX_ENVIRONMENT_GENERIC];
+
+    wfx->wFormatTag = WAVE_FORMAT_PCM;
+    wfx->nChannels = 2;
+    wfx->wBitsPerSample = 8;
+    wfx->nSamplesPerSec = 22050;
+    wfx->nBlockAlign = wfx->wBitsPerSample * wfx->nChannels / 8;
+    wfx->nAvgBytesPerSec = wfx->nSamplesPerSec * wfx->nBlockAlign;
+    wfx->cbSize = 0;
+
+    This->IDirectSoundBuffer_iface.lpVtbl = &DS8Primary_Vtbl;
+    This->IDirectSound3DListener_iface.lpVtbl = &DS8Primary3D_Vtbl;
+    This->IKsPropertySet_iface.lpVtbl = &DS8PrimaryProp_Vtbl;
+    This->stopped = TRUE;
+    /* Apparently primary buffer size is always 32k,
+     * tested on windows with 192k 24 bits sound @ 6 channels
+     * where it will run out in 60 ms and it isn't pointer aligned
      */
+    This->buf_size = 32768;
+
+    if(!This->ExtAL.BufferSubData && !This->ExtAL.BufferDataStatic)
+    {
+        ERR("Missing alBufferSubDataEXT and alBufferDataStatic on device '%s', sound playback quality may be degraded\n",
+             palcGetString(parent->device, ALC_DEVICE_SPECIFIER));
+        ERR("Please consider using OpenAL-Soft\n");
+    }
+
+    /* Make sure DS3DListener defaults are applied to OpenAL */
+    listener = &This->listen;
+    listener->dwSize = sizeof(*listener);
+    listener->vPosition.x = 0.0;
+    listener->vPosition.y = 0.0;
+    listener->vPosition.z = 0.0;
+    listener->vVelocity.x = 0.0;
+    listener->vVelocity.y = 0.0;
+    listener->vVelocity.z = 0.0;
+    listener->vOrientFront.x = 0.0;
+    listener->vOrientFront.y = 0.0;
+    listener->vOrientFront.z = 1.0;
+    listener->vOrientTop.x = 0.0;
+    listener->vOrientTop.y = 1.0;
+    listener->vOrientTop.z = 0.0;
+    listener->flDistanceFactor = DS3D_DEFAULTDISTANCEFACTOR;
+    listener->flRolloffFactor = DS3D_DEFAULTROLLOFFFACTOR;
+    listener->flDopplerFactor = DS3D_DEFAULTDOPPLERFACTOR;
+    hr = IDirectSound3DListener_SetAllParameters(&This->IDirectSound3DListener_iface, listener, DS3D_IMMEDIATE);
+    if(FAILED(hr))
+        ERR("Could not set 3d parameters: %08x\n", hr);
+
+    for(nsources = 0;nsources < sizeof(srcs)/sizeof(*srcs);nsources++)
+    {
+        palGenSources(1, &srcs[nsources]);
+        if(palGetError() != AL_NO_ERROR)
+            break;
+    }
+    palDeleteSources(nsources, srcs);
+    getALError();
+
+    This->max_sources = nsources;
+    This->sizenotifies = This->sizebuffers = This->sizesources = nsources+1;
+    This->sources = HeapAlloc(GetProcessHeap(), 0, nsources*sizeof(*This->sources));
+    This->buffers = HeapAlloc(GetProcessHeap(), 0, nsources*sizeof(*This->buffers));
+    This->notifies = HeapAlloc(GetProcessHeap(), 0, nsources*sizeof(*This->notifies));
+
+    popALContext();
+    if(!This->sources || !This->buffers || !This->notifies)
+        goto fail;
+
+    *ppv = This;
+    return S_OK;
+
+fail:
+    DS8Primary_Destroy(This);
+    return hr;
+}
+
+void DS8Primary_Destroy(DS8Primary *This)
+{
+    TRACE("Destroying primary %p\n", This);
+
+    if(This->timer_id)
+    {
+        timeKillEvent(This->timer_id);
+        timeEndPeriod(This->timer_res);
+        TRACE("Killed timer\n");
+    }
+
+    if(This->ctx)
+    {
+        /* Calling setALContext is not appropriate here,
+         * since we *have* to unset the context before destroying it
+         */
+        ALCcontext *old_ctx;
+
+        EnterCriticalSection(&openal_crst);
+        if (This->dev)
+        {
+            IAudioClient_Stop(This->dev);
+            IUnknown_Release(This->render_dev);
+            IUnknown_Release(This->dev);
+        }
+        old_ctx = get_context();
+        if(old_ctx != This->ctx)
+            set_context(This->ctx);
+        else
+            old_ctx = NULL;
+
+        while(This->nbuffers--)
+            DS8Buffer_Destroy(This->buffers[This->nbuffers]);
+
+        if(This->nsources)
+            palDeleteSources(This->nsources, This->sources);
+
+        if(This->effect)
+            This->ExtAL.DeleteEffects(1, &This->effect);
+        if(This->auxslot)
+            This->ExtAL.DeleteAuxiliaryEffectSlots(1, &This->auxslot);
+
+        HeapFree(GetProcessHeap(), 0, This->sources);
+        HeapFree(GetProcessHeap(), 0, This->notifies);
+        HeapFree(GetProcessHeap(), 0, This->buffers);
+
+        set_context(old_ctx);
+        palcDestroyContext(This->ctx);
+        LeaveCriticalSection(&openal_crst);
+    }
+
+    This->crst.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection(&This->crst);
+
+    HeapFree(GetProcessHeap(), 0, This->format);
+    HeapFree(GetProcessHeap(), 0, This);
+}
+
+static inline DS8Primary *impl_from_IDirectSoundBuffer(IDirectSoundBuffer *iface)
+{
+    return CONTAINING_RECORD(iface, DS8Primary, IDirectSoundBuffer_iface);
+}
+
+static HRESULT WINAPI DS8Primary_QueryInterface(IDirectSoundBuffer *iface, REFIID riid, LPVOID *ppv)
+{
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    *ppv = NULL;
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+       IsEqualIID(riid, &IID_IDirectSoundBuffer))
+        *ppv = &This->IDirectSoundBuffer_iface;
+    else if(IsEqualIID(riid, &IID_IDirectSound3DListener))
+    {
+        if((This->flags&DSBCAPS_CTRL3D))
+            *ppv = &This->IDirectSound3DListener_iface;
+    }
+    else
+        FIXME("Unhandled GUID: %s\n", debugstr_guid(riid));
+
+    if(*ppv)
+    {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
 
-    if (nSamplesPerSec <= 12800)
-        return 128 * nBlockAlign;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI DS8Primary_AddRef(IDirectSoundBuffer *iface)
+{
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+    LONG ret;
+
+    ret = InterlockedIncrement(&This->ref);
+    if(This->ref == 1)
+        This->flags = 0;
 
-    if (nSamplesPerSec <= 25600)
-        return 256 * nBlockAlign;
+    return ret;
+}
+
+static ULONG WINAPI DS8Primary_Release(IDirectSoundBuffer *iface)
+{
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+    LONG ret;
 
-    if (nSamplesPerSec <= 51200)
-        return 512 * nBlockAlign;
+    ret = InterlockedDecrement(&This->ref);
 
-    return 1024 * nBlockAlign;
+    return ret;
 }
 
-static void DSOUND_RecalcPrimary(DirectSoundDevice *device)
+static HRESULT WINAPI DS8Primary_GetCaps(IDirectSoundBuffer *iface, DSBCAPS *caps)
 {
-    TRACE("(%p)\n", device);
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
 
-    device->fraglen = DSOUND_fraglen(device->pwfx->nSamplesPerSec, device->pwfx->nBlockAlign);
-    device->helfrags = device->buflen / device->fraglen;
-    TRACE("fraglen=%d helfrags=%d\n", device->fraglen, device->helfrags);
+    TRACE("(%p)->(%p)\n", iface, caps);
 
-    if (device->hwbuf && device->drvdesc.dwFlags & DSDDESC_DONTNEEDWRITELEAD)
-        device->writelead = 0;
+    if(!caps || caps->dwSize < sizeof(*caps))
+    {
+        WARN("Invalid DSBCAPS (%p, %u)\n", caps, caps ? caps->dwSize : 0);
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(&This->crst);
+    caps->dwFlags = This->flags;
+    caps->dwBufferBytes = This->buf_size;
+    caps->dwUnlockTransferRate = 0;
+    caps->dwPlayCpuOverhead = 0;
+    LeaveCriticalSection(&This->crst);
+
+    return DS_OK;
+}
+
+static HRESULT WINAPI DS8Primary_GetCurrentPosition(IDirectSoundBuffer *iface, DWORD *playpos, DWORD *curpos)
+{
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+    HRESULT hr = DSERR_PRIOLEVELNEEDED;
+
+    EnterCriticalSection(&This->crst);
+    if(This->write_emu)
+        hr = IDirectSoundBuffer8_GetCurrentPosition(This->write_emu, playpos, curpos);
+    LeaveCriticalSection(&This->crst);
+
+    return hr;
+}
+
+static HRESULT WINAPI DS8Primary_GetFormat(IDirectSoundBuffer *iface, WAVEFORMATEX *wfx, DWORD allocated, DWORD *written)
+{
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+    HRESULT hr = S_OK;
+    UINT size;
+
+    if(!wfx && !written)
+    {
+        WARN("Cannot report format or format size\n");
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(&This->crst);
+    size = sizeof(*This->format) + This->format->cbSize;
+    if(written)
+        *written = size;
+    if(wfx)
+    {
+        if(allocated < size)
+            hr = DSERR_INVALIDPARAM;
+        else
+            memcpy(wfx, This->format, size);
+    }
+    LeaveCriticalSection(&This->crst);
+
+    return hr;
+}
+
+static HRESULT WINAPI DS8Primary_GetVolume(IDirectSoundBuffer *iface, LONG *volume)
+{
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+    HRESULT hr = S_OK;
+    LONG vol;
+
+    TRACE("(%p)->(%p)\n", iface, volume);
+
+    if(!volume)
+        return DSERR_INVALIDPARAM;
+
+    EnterCriticalSection(&This->crst);
+    if(!(This->flags & DSBCAPS_CTRLVOLUME))
+        hr = DSERR_CONTROLUNAVAIL;
+    else
+    {
+        ALfloat gain;
+
+        setALContext(This->ctx);
+        palGetListenerf(AL_GAIN, &gain);
+        getALError();
+        popALContext();
+
+        vol = gain_to_mB(gain);
+        vol = max(vol, DSBVOLUME_MIN);
+        *volume = min(vol, DSBVOLUME_MAX);
+    }
+    LeaveCriticalSection(&This->crst);
+
+    return hr;
+}
+
+static HRESULT WINAPI DS8Primary_GetPan(IDirectSoundBuffer *iface, LONG *pan)
+{
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+    HRESULT hr = S_OK;
+
+    WARN("(%p)->(%p): semi-stub\n", iface, pan);
+
+    if(!pan)
+        return DSERR_INVALIDPARAM;
+
+    EnterCriticalSection(&This->crst);
+    if(This->write_emu)
+        hr = IDirectSoundBuffer8_GetPan(This->write_emu, pan);
+    else if(!(This->flags & DSBCAPS_CTRLPAN))
+        hr = DSERR_CONTROLUNAVAIL;
     else
-        /* calculate the 10ms write lead */
-        device->writelead = (device->pwfx->nSamplesPerSec / 100) * device->pwfx->nBlockAlign;
+        *pan = 0;
+    LeaveCriticalSection(&This->crst);
+
+    return hr;
 }
 
-HRESULT DSOUND_ReopenDevice(DirectSoundDevice *device, BOOL forcewave)
+static HRESULT WINAPI DS8Primary_GetFrequency(IDirectSoundBuffer *iface, DWORD *freq)
 {
-	HRESULT hres = DS_OK;
-	TRACE("(%p, %d)\n", device, forcewave);
-
-	if (device->driver)
-	{
-		IDsDriver_Close(device->driver);
-		if (device->drvdesc.dwFlags & DSDDESC_DOMMSYSTEMOPEN)
-			waveOutClose(device->hwo);
-		IDsDriver_Release(device->driver);
-		device->driver = NULL;
-		device->buffer = NULL;
-		device->hwo = 0;
-	}
-	else if (device->drvdesc.dwFlags & DSDDESC_DOMMSYSTEMOPEN)
-		waveOutClose(device->hwo);
-
-	/* DRV_QUERYDSOUNDIFACE is a "Wine extension" to get the DSound interface */
-	if (ds_hw_accel != DS_HW_ACCEL_EMULATION && !forcewave)
-		waveOutMessage((HWAVEOUT)device->drvdesc.dnDevNode, DRV_QUERYDSOUNDIFACE, (DWORD_PTR)&device->driver, 0);
-
-	/* Get driver description */
-	if (device->driver) {
-		DWORD wod = device->drvdesc.dnDevNode;
-		hres = IDsDriver_GetDriverDesc(device->driver,&(device->drvdesc));
-		device->drvdesc.dnDevNode = wod;
-		if (FAILED(hres)) {
-			WARN("IDsDriver_GetDriverDesc failed: %08x\n", hres);
-			IDsDriver_Release(device->driver);
-			device->driver = NULL;
-		}
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+    HRESULT hr = S_OK;
+
+    WARN("(%p)->(%p): semi-stub\n", iface, freq);
+
+    if(!freq)
+        return DSERR_INVALIDPARAM;
+
+    EnterCriticalSection(&This->crst);
+    if(!(This->flags & DSBCAPS_CTRLFREQUENCY))
+        hr = DSERR_CONTROLUNAVAIL;
+    else
+        *freq = This->format->nSamplesPerSec;
+    LeaveCriticalSection(&This->crst);
+
+    return hr;
+}
+
+static HRESULT WINAPI DS8Primary_GetStatus(IDirectSoundBuffer *iface, DWORD *status)
+{
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+
+    TRACE("(%p)->(%p)\n", iface, status);
+
+    if(!status)
+        return DSERR_INVALIDPARAM;
+
+    EnterCriticalSection(&This->crst);
+
+    *status = DSBSTATUS_PLAYING|DSBSTATUS_LOOPING;
+    if((This->flags&DSBCAPS_LOCDEFER))
+        *status |= DSBSTATUS_LOCHARDWARE;
+
+    if(This->stopped)
+    {
+        DWORD i, state;
+        HRESULT hr;
+
+        for(i = 0;i < This->nbuffers;++i)
+        {
+            hr = IDirectSoundBuffer_GetStatus((IDirectSoundBuffer*)This->buffers[i], &state);
+            if(SUCCEEDED(hr) && (state&DSBSTATUS_PLAYING))
+                break;
         }
+        if(i == This->nbuffers)
+        {
+            /* Primary stopped and no buffers playing.. */
+            *status = 0;
+        }
+    }
+
+    LeaveCriticalSection(&This->crst);
 
-        /* if no DirectSound interface available, use WINMM API instead */
-	if (!device->driver)
-		device->drvdesc.dwFlags = DSDDESC_DOMMSYSTEMOPEN | DSDDESC_DOMMSYSTEMSETFORMAT;
-
-	if (device->drvdesc.dwFlags & DSDDESC_DOMMSYSTEMOPEN)
-	{
-		DWORD flags = CALLBACK_FUNCTION | WAVE_MAPPED;
-
-		if (device->driver)
-			flags |= WAVE_DIRECTSOUND;
-
-		hres = mmErr(waveOutOpen(&(device->hwo), device->drvdesc.dnDevNode, device->pwfx, (DWORD_PTR)DSOUND_callback, (DWORD_PTR)device, flags));
-		if (FAILED(hres)) {
-			WARN("waveOutOpen failed\n");
-			if (device->driver)
-			{
-				IDsDriver_Release(device->driver);
-				device->driver = NULL;
-			}
-			return hres;
-		}
-	}
-
-	if (device->driver)
-		hres = IDsDriver_Open(device->driver);
-
-	return hres;
+    return S_OK;
 }
 
-static HRESULT DSOUND_PrimaryOpen(DirectSoundDevice *device)
+static HRESULT WINAPI DS8Primary_Initialize(IDirectSoundBuffer *iface, IDirectSound *ds, const DSBUFFERDESC *desc)
 {
-	DWORD buflen;
-	HRESULT err = DS_OK;
-	TRACE("(%p)\n", device);
-
-	/* on original windows, the buffer it set to a fixed size, no matter what the settings are.
-	   on windows this size is always fixed (tested on win-xp) */
-	if (!device->buflen)
-		device->buflen = ds_hel_buflen;
-	buflen = device->buflen;
-	buflen -= buflen % device->pwfx->nBlockAlign;
-	device->buflen = buflen;
-
-	if (device->driver)
-	{
-		err = IDsDriver_CreateSoundBuffer(device->driver,device->pwfx,
-						  DSBCAPS_PRIMARYBUFFER,0,
-						  &(device->buflen),&(device->buffer),
-						  (LPVOID*)&(device->hwbuf));
-
-		if (err != DS_OK) {
-			WARN("IDsDriver_CreateSoundBuffer failed (%08x), falling back to waveout\n", err);
-			err = DSOUND_ReopenDevice(device, TRUE);
-			if (FAILED(err))
-			{
-				WARN("Falling back to waveout failed too! Giving up\n");
-				return err;
-			}
-		}
-                if (device->hwbuf)
-                    IDsDriverBuffer_SetVolumePan(device->hwbuf, &device->volpan);
-
-                DSOUND_RecalcPrimary(device);
-		device->prebuf = ds_snd_queue_max;
-		if (device->helfrags < ds_snd_queue_min)
-		{
-			WARN("Too little sound buffer to be effective (%d/%d) falling back to waveout\n", device->buflen, ds_snd_queue_min * device->fraglen);
-			device->buflen = buflen;
-			IDsDriverBuffer_Release(device->hwbuf);
-			device->hwbuf = NULL;
-			err = DSOUND_ReopenDevice(device, TRUE);
-			if (FAILED(err))
-			{
-				WARN("Falling back to waveout failed too! Giving up\n");
-				return err;
-			}
-		}
-		else if (device->helfrags < ds_snd_queue_max)
-			device->prebuf = device->helfrags;
-	}
-
-	device->mix_buffer_len = DSOUND_bufpos_to_mixpos(device, device->buflen);
-	device->mix_buffer = HeapAlloc(GetProcessHeap(), 0, device->mix_buffer_len);
-	if (!device->mix_buffer)
-	{
-		if (device->hwbuf)
-			IDsDriverBuffer_Release(device->hwbuf);
-		device->hwbuf = NULL;
-		return DSERR_OUTOFMEMORY;
-	}
-
-	if (device->state == STATE_PLAYING) device->state = STATE_STARTING;
-	else if (device->state == STATE_STOPPING) device->state = STATE_STOPPED;
-
-	/* are we using waveOut stuff? */
-	if (!device->driver) {
-		LPBYTE newbuf;
-		LPWAVEHDR headers = NULL;
-		DWORD overshot;
-		unsigned int c;
-
-		/* Start in pause mode, to allow buffers to get filled */
-		waveOutPause(device->hwo);
-
-		TRACE("desired buflen=%d, old buffer=%p\n", buflen, device->buffer);
-
-		/* reallocate emulated primary buffer */
-		if (device->buffer)
-			newbuf = HeapReAlloc(GetProcessHeap(),0,device->buffer, buflen);
-		else
-			newbuf = HeapAlloc(GetProcessHeap(),0, buflen);
-
-		if (!newbuf) {
-			ERR("failed to allocate primary buffer\n");
-			return DSERR_OUTOFMEMORY;
-			/* but the old buffer might still exist and must be re-prepared */
-		}
-
-		DSOUND_RecalcPrimary(device);
-		if (device->pwave)
-			headers = HeapReAlloc(GetProcessHeap(),0,device->pwave, device->helfrags * sizeof(WAVEHDR));
-		else
-			headers = HeapAlloc(GetProcessHeap(),0,device->helfrags * sizeof(WAVEHDR));
-
-		if (!headers) {
-			ERR("failed to allocate wave headers\n");
-			HeapFree(GetProcessHeap(), 0, newbuf);
-			DSOUND_RecalcPrimary(device);
-			return DSERR_OUTOFMEMORY;
-		}
-
-		device->buffer = newbuf;
-		device->pwave = headers;
-
-		/* prepare fragment headers */
-		for (c=0; c<device->helfrags; c++) {
-			device->pwave[c].lpData = (char*)device->buffer + c*device->fraglen;
-			device->pwave[c].dwBufferLength = device->fraglen;
-			device->pwave[c].dwUser = (DWORD_PTR)device;
-			device->pwave[c].dwFlags = 0;
-			device->pwave[c].dwLoops = 0;
-			err = mmErr(waveOutPrepareHeader(device->hwo,&device->pwave[c],sizeof(WAVEHDR)));
-			if (err != DS_OK) {
-				while (c--)
-					waveOutUnprepareHeader(device->hwo,&device->pwave[c],sizeof(WAVEHDR));
-				break;
-			}
-		}
-
-		overshot = device->buflen % device->fraglen;
-		/* sanity */
-		if(overshot)
-		{
-			overshot -= overshot % device->pwfx->nBlockAlign;
-			device->pwave[device->helfrags - 1].dwBufferLength += overshot;
-		}
-
-		TRACE("fraglen=%d, overshot=%d\n", device->fraglen, overshot);
-	}
-	device->mixfunction = mixfunctions[device->pwfx->wBitsPerSample/8 - 1];
-	device->normfunction = normfunctions[device->pwfx->wBitsPerSample/8 - 1];
-	FillMemory(device->buffer, device->buflen, (device->pwfx->wBitsPerSample == 8) ? 128 : 0);
-	FillMemory(device->mix_buffer, device->mix_buffer_len, 0);
-	device->pwplay = device->pwqueue = device->playpos = device->mixpos = 0;
-	return err;
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("(%p)->(%p, %p)\n", iface, ds, desc);
+
+    if(!desc || desc->lpwfxFormat || desc->dwBufferBytes)
+    {
+        WARN("Bad DSBDESC for primary buffer\n");
+        return DSERR_INVALIDPARAM;
+    }
+    if((desc->dwFlags&DSBCAPS_CTRLFX) ||
+       (desc->dwFlags&DSBCAPS_CTRLPOSITIONNOTIFY) ||
+       (desc->dwFlags&DSBCAPS_LOCSOFTWARE))
+    {
+        WARN("Bad dwFlags %08x\n", desc->dwFlags);
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(&This->crst);
+    /* Should be 0 if not initialized */
+    if(This->flags)
+    {
+        hr = DSERR_ALREADYINITIALIZED;
+        goto out;
+    }
+
+    if(This->parent->prio_level == DSSCL_WRITEPRIMARY)
+    {
+        DSBUFFERDESC emudesc;
+        DS8Buffer *emu;
+
+        if(This->write_emu)
+        {
+            ERR("There shouldn't be a write_emu!\n");
+            IDirectSoundBuffer8_Release(This->write_emu);
+            This->write_emu = NULL;
+        }
+
+        memset(&emudesc, 0, sizeof(emudesc));
+        emudesc.dwSize = sizeof(emudesc);
+        emudesc.dwFlags = DSBCAPS_LOCHARDWARE | (desc->dwFlags&DSBCAPS_CTRLPAN);
+        /* Dont play last incomplete sample */
+        emudesc.dwBufferBytes = This->buf_size - (This->buf_size % This->format->nBlockAlign);
+        emudesc.lpwfxFormat = This->format;
+
+        hr = DS8Buffer_Create(&emu, This, NULL);
+        if(SUCCEEDED(hr))
+        {
+            This->write_emu = &emu->IDirectSoundBuffer8_iface;
+            hr = IDirectSoundBuffer8_Initialize(This->write_emu, ds, &emudesc);
+            if(FAILED(hr))
+            {
+                IDirectSoundBuffer8_Release(This->write_emu);
+                This->write_emu = NULL;
+            }
+        }
+    }
+
+    if(SUCCEEDED(hr))
+        This->flags = desc->dwFlags | DSBCAPS_LOCHARDWARE;
+out:
+    LeaveCriticalSection(&This->crst);
+    return hr;
 }
 
+static HRESULT WINAPI DS8Primary_Lock(IDirectSoundBuffer *iface, DWORD ofs, DWORD bytes, void **ptr1, DWORD *len1, void **ptr2, DWORD *len2, DWORD flags)
+{
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+    HRESULT hr = DSERR_PRIOLEVELNEEDED;
+
+    TRACE("(%p)->(%u, %u, %p, %p, %p, %p, %u)\n", iface, ofs, bytes, ptr1, len1, ptr2, len2, flags);
+
+    EnterCriticalSection(&This->crst);
+    if(This->write_emu)
+        hr = IDirectSoundBuffer8_Lock(This->write_emu, ofs, bytes, ptr1, len1, ptr2, len2, flags);
+    LeaveCriticalSection(&This->crst);
 
-static void DSOUND_PrimaryClose(DirectSoundDevice *device)
+    return hr;
+}
+
+static HRESULT WINAPI DS8Primary_Play(IDirectSoundBuffer *iface, DWORD res1, DWORD res2, DWORD flags)
 {
-	TRACE("(%p)\n", device);
-
-	/* are we using waveOut stuff? */
-	if (!device->hwbuf) {
-		unsigned c;
-
-		/* get out of CS when calling the wave system */
-		LeaveCriticalSection(&(device->mixlock));
-		/* **** */
-		device->pwqueue = (DWORD)-1; /* resetting queues */
-		waveOutReset(device->hwo);
-		for (c=0; c<device->helfrags; c++)
-			waveOutUnprepareHeader(device->hwo, &device->pwave[c], sizeof(WAVEHDR));
-		/* **** */
-		EnterCriticalSection(&(device->mixlock));
-
-		/* clear the queue */
-		device->pwqueue = 0;
-	} else {
-		ULONG ref = IDsDriverBuffer_Release(device->hwbuf);
-		if (!ref)
-			device->hwbuf = 0;
-		else
-			ERR("Still %d references on primary buffer, refcount leak?\n", ref);
-	}
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%u, %u, %u)\n", iface, res1, res2, flags);
+
+    if(!(flags & DSBPLAY_LOOPING))
+    {
+        WARN("Flags (%08x) not set to DSBPLAY_LOOPING\n", flags);
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(&This->crst);
+    hr = S_OK;
+    if(This->write_emu)
+        hr = IDirectSoundBuffer8_Play(This->write_emu, res1, res2, flags);
+    if(SUCCEEDED(hr))
+        This->stopped = FALSE;
+    LeaveCriticalSection(&This->crst);
+
+    return hr;
 }
 
-HRESULT DSOUND_PrimaryCreate(DirectSoundDevice *device)
+static HRESULT WINAPI DS8Primary_SetCurrentPosition(IDirectSoundBuffer *iface, DWORD pos)
 {
-	HRESULT err = DS_OK;
-	TRACE("(%p)\n", device);
+    WARN("(%p)->(%u)\n", iface, pos);
+    return DSERR_INVALIDCALL;
+}
 
-	device->buflen = ds_hel_buflen;
-	err = DSOUND_PrimaryOpen(device);
+/* Just assume the format is crap, and clean up the damage */
+static void copy_waveformat(WAVEFORMATEX *wfx, const WAVEFORMATEX *from)
+{
+    if(from->wFormatTag == WAVE_FORMAT_PCM || from->wFormatTag == WAVE_FORMAT_IEEE_FLOAT)
+    {
+        wfx->cbSize = 0;
+        if(from->wBitsPerSample == 8 ||
+           from->wBitsPerSample == 16 ||
+           from->wBitsPerSample == 24 ||
+           from->wBitsPerSample == 32)
+            wfx->wBitsPerSample = from->wBitsPerSample;
+    }
+    else if(from->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
+    {
+        WAVEFORMATEXTENSIBLE *wfe = (WAVEFORMATEXTENSIBLE*)wfx;
+        const WAVEFORMATEXTENSIBLE *fromx = (const WAVEFORMATEXTENSIBLE*)from;
+        DWORD size = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
+
+        /* Fail silently.. */
+        if(from->cbSize < size)
+            return;
+        if(!fromx->Samples.wValidBitsPerSample &&
+           !fromx->Format.wBitsPerSample)
+            return;
+
+        if(!IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM) &&
+           !IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))
+        {
+            ERR("Unhandled extensible format: %s\n", debugstr_guid(&wfe->SubFormat));
+            return;
+        }
 
-	if (err != DS_OK) {
-		WARN("DSOUND_PrimaryOpen failed\n");
-		return err;
-	}
+        wfe->Format.wBitsPerSample = from->wBitsPerSample;
+        wfe->Samples.wValidBitsPerSample = fromx->Samples.wValidBitsPerSample;
+        if(!wfe->Samples.wValidBitsPerSample)
+            wfe->Samples.wValidBitsPerSample = wfe->Format.wBitsPerSample;
+        wfe->Format.cbSize = size;
+        wfe->dwChannelMask = fromx->dwChannelMask;
+        wfe->SubFormat = fromx->SubFormat;
+    }
+    else
+    {
+        ERR("Unhandled format tag %04x\n", from->wFormatTag);
+        return;
+    }
 
-	device->state = STATE_STOPPED;
-	return DS_OK;
+    if(from->nChannels)
+        wfx->nChannels = from->nChannels;
+    wfx->wFormatTag = from->wFormatTag;
+    if(from->nSamplesPerSec >= DSBFREQUENCY_MIN &&
+       from->nSamplesPerSec <= DSBFREQUENCY_MAX)
+        wfx->nSamplesPerSec = from->nSamplesPerSec;
+    wfx->nBlockAlign = wfx->wBitsPerSample * wfx->nChannels / 8;
+    wfx->nAvgBytesPerSec = wfx->nSamplesPerSec * wfx->nBlockAlign;
 }
 
-HRESULT DSOUND_PrimaryDestroy(DirectSoundDevice *device)
+static HRESULT WINAPI DS8Primary_SetFormat(IDirectSoundBuffer *iface, const WAVEFORMATEX *wfx)
 {
-	TRACE("(%p)\n", device);
-
-	/* **** */
-	EnterCriticalSection(&(device->mixlock));
-
-	DSOUND_PrimaryClose(device);
-	if (device->driver) {
-		if (device->hwbuf) {
-			if (IDsDriverBuffer_Release(device->hwbuf) == 0)
-				device->hwbuf = 0;
-		}
-	} else
-                HeapFree(GetProcessHeap(),0,device->pwave);
-        HeapFree(GetProcessHeap(),0,device->pwfx);
-        device->pwfx=NULL;
-
-	LeaveCriticalSection(&(device->mixlock));
-	/* **** */
-
-	return DS_OK;
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("(%p)->(%p)\n", iface, wfx);
+
+    if(!wfx)
+    {
+        WARN("Missing format\n");
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(&This->crst);
+
+    if(This->parent->prio_level < DSSCL_PRIORITY)
+    {
+        hr = DSERR_PRIOLEVELNEEDED;
+        goto out;
+    }
+
+    TRACE("Requested primary format:\n"
+          "    FormatTag      = %04x\n"
+          "    Channels       = %u\n"
+          "    SamplesPerSec  = %u\n"
+          "    AvgBytesPerSec = %u\n"
+          "    BlockAlign     = %u\n"
+          "    BitsPerSample  = %u\n",
+          wfx->wFormatTag, wfx->nChannels,
+          wfx->nSamplesPerSec, wfx->nAvgBytesPerSec,
+          wfx->nBlockAlign, wfx->wBitsPerSample);
+
+    if(This->write_emu)
+    {
+        DS8Buffer *buf;
+        DSBUFFERDESC desc;
+
+        memset(&desc, 0, sizeof(desc));
+        desc.dwSize = sizeof(desc);
+        desc.dwFlags = DSBCAPS_LOCHARDWARE|DSBCAPS_CTRLPAN;
+        desc.dwBufferBytes = This->buf_size - (This->buf_size % This->format->nBlockAlign);
+        /* Shouldn't be changed */
+        desc.lpwfxFormat = (WAVEFORMATEX*)wfx;
+
+        hr = DS8Buffer_Create(&buf, This, NULL);
+        if(FAILED(hr))
+            goto out;
+
+        hr = IDirectSoundBuffer8_Initialize(&buf->IDirectSoundBuffer8_iface, (IDirectSound*)&This->parent->IDirectSound8_iface, &desc);
+        if(FAILED(hr))
+            DS8Buffer_Destroy(buf);
+        else
+        {
+            IDirectSoundBuffer8_Release(This->write_emu);
+            This->write_emu = &buf->IDirectSoundBuffer8_iface;
+            IDirectSoundBuffer8_GetFormat(This->write_emu, This->format, sizeof(WAVEFORMATEXTENSIBLE), NULL);
+        }
+    }
+    else
+    {
+        copy_waveformat(This->format, wfx);
+        WARN("Potentially re-create the device because frequency has changed?\n");
+        hr = S_OK;
+    }
+out:
+    LeaveCriticalSection(&This->crst);
+    return hr;
+}
+
+static HRESULT WINAPI DS8Primary_SetVolume(IDirectSoundBuffer *iface, LONG vol)
+{
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("(%p)->(%d)\n", iface, vol);
+
+    if(vol > DSBVOLUME_MAX || vol < DSBVOLUME_MIN)
+    {
+        WARN("Invalid volume (%d)\n", vol);
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(&This->crst);
+    if(!(This->flags & DSBCAPS_CTRLVOLUME))
+        hr = DSERR_CONTROLUNAVAIL;
+    if(SUCCEEDED(hr))
+    {
+        ALfloat fvol = mB_to_gain(vol);
+
+        setALContext(This->ctx);
+        palListenerf(AL_GAIN, fvol);
+        popALContext();
+    }
+    LeaveCriticalSection(&This->crst);
+
+    return hr;
+}
+
+static HRESULT WINAPI DS8Primary_SetPan(IDirectSoundBuffer *iface, LONG pan)
+{
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%d)\n", iface, pan);
+
+    if(pan > DSBPAN_RIGHT || pan < DSBPAN_LEFT)
+    {
+        WARN("invalid parameter: pan = %d\n", pan);
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(&This->crst);
+    if(!(This->flags & DSBCAPS_CTRLPAN))
+    {
+        WARN("control unavailable\n");
+        hr = DSERR_CONTROLUNAVAIL;
+    }
+    else if(This->write_emu)
+        hr = IDirectSoundBuffer8_SetPan(This->write_emu, pan);
+    else
+    {
+        FIXME("Not supported\n");
+        hr = E_NOTIMPL;
+    }
+    LeaveCriticalSection(&This->crst);
+
+    return hr;
 }
 
-HRESULT DSOUND_PrimaryPlay(DirectSoundDevice *device)
+static HRESULT WINAPI DS8Primary_SetFrequency(IDirectSoundBuffer *iface, DWORD freq)
 {
-	HRESULT err = DS_OK;
-	TRACE("(%p)\n", device);
-
-	if (device->hwbuf) {
-		err = IDsDriverBuffer_Play(device->hwbuf, 0, 0, DSBPLAY_LOOPING);
-		if (err != DS_OK)
-			WARN("IDsDriverBuffer_Play failed\n");
-	} else {
-		err = mmErr(waveOutRestart(device->hwo));
-		if (err != DS_OK)
-			WARN("waveOutRestart failed\n");
-	}
-
-	return err;
+    WARN("(%p)->(%u)\n", iface, freq);
+    return DSERR_CONTROLUNAVAIL;
 }
 
-HRESULT DSOUND_PrimaryStop(DirectSoundDevice *device)
+static HRESULT WINAPI DS8Primary_Stop(IDirectSoundBuffer *iface)
 {
-	HRESULT err = DS_OK;
-	TRACE("(%p)\n", device);
-
-	if (device->hwbuf) {
-		err = IDsDriverBuffer_Stop(device->hwbuf);
-		if (err == DSERR_BUFFERLOST) {
-			DSOUND_PrimaryClose(device);
-			err = DSOUND_ReopenDevice(device, FALSE);
-			if (FAILED(err))
-				ERR("DSOUND_ReopenDevice failed\n");
-			else
-			{
-				err = DSOUND_PrimaryOpen(device);
-				if (FAILED(err))
-					WARN("DSOUND_PrimaryOpen failed\n");
-			}
-		} else if (err != DS_OK) {
-			WARN("IDsDriverBuffer_Stop failed\n");
-		}
-	} else {
-
-		/* don't call the wave system with the lock set */
-		LeaveCriticalSection(&(device->mixlock));
-		/* **** */
-
-		err = mmErr(waveOutPause(device->hwo));
-
-		/* **** */
-		EnterCriticalSection(&(device->mixlock));
-
-		if (err != DS_OK)
-			WARN("waveOutPause failed\n");
-	}
-
-	return err;
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("(%p)->()\n", iface);
+
+    EnterCriticalSection(&This->crst);
+    if(This->write_emu)
+        hr = IDirectSoundBuffer8_Stop(This->write_emu);
+    if(SUCCEEDED(hr))
+        This->stopped = TRUE;
+    LeaveCriticalSection(&This->crst);
+
+    return hr;
 }
 
-HRESULT DSOUND_PrimaryGetPosition(DirectSoundDevice *device, LPDWORD playpos, LPDWORD writepos)
+static HRESULT WINAPI DS8Primary_Unlock(IDirectSoundBuffer *iface, void *ptr1, DWORD len1, void *ptr2, DWORD len2)
 {
-	TRACE("(%p,%p,%p)\n", device, playpos, writepos);
-
-	if (device->hwbuf) {
-		HRESULT err=IDsDriverBuffer_GetPosition(device->hwbuf,playpos,writepos);
-		if (err != S_OK) {
-			WARN("IDsDriverBuffer_GetPosition failed\n");
-			return err;
-		}
-	} else {
-		TRACE("pwplay=%i, pwqueue=%i\n", device->pwplay, device->pwqueue);
-
-		/* check if playpos was requested */
-		if (playpos)
-			/* use the cached play position */
-			*playpos = device->pwplay * device->fraglen;
-
-		/* check if writepos was requested */
-		if (writepos)
-			/* the writepos is the first non-queued position */
-			*writepos = ((device->pwplay + device->pwqueue) % device->helfrags) * device->fraglen;
-	}
-	TRACE("playpos = %d, writepos = %d (%p, time=%d)\n", playpos?*playpos:-1, writepos?*writepos:-1, device, GetTickCount());
-	return DS_OK;
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+    HRESULT hr = DSERR_INVALIDCALL;
+
+    TRACE("(%p)->(%p, %u, %p, %u)\n", iface, ptr1, len1, ptr2, len2);
+
+    EnterCriticalSection(&This->crst);
+    if(This->write_emu)
+        hr = IDirectSoundBuffer8_Unlock(This->write_emu, ptr1, len1, ptr2, len2);
+    LeaveCriticalSection(&This->crst);
+
+    return hr;
+}
+
+static HRESULT WINAPI DS8Primary_Restore(IDirectSoundBuffer *iface)
+{
+    DS8Primary *This = impl_from_IDirectSoundBuffer(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("(%p)->()\n", iface);
+
+    EnterCriticalSection(&This->crst);
+    if(This->write_emu)
+        hr = IDirectSoundBuffer8_Restore(This->write_emu);
+    LeaveCriticalSection(&This->crst);
+
+    return hr;
 }
 
-static DWORD DSOUND_GetFormatSize(LPCWAVEFORMATEX wfex)
+static const IDirectSoundBufferVtbl DS8Primary_Vtbl =
 {
-	if (wfex->wFormatTag == WAVE_FORMAT_PCM)
-		return sizeof(WAVEFORMATEX);
-	else
-		return sizeof(WAVEFORMATEX) + wfex->cbSize;
+    DS8Primary_QueryInterface,
+    DS8Primary_AddRef,
+    DS8Primary_Release,
+    DS8Primary_GetCaps,
+    DS8Primary_GetCurrentPosition,
+    DS8Primary_GetFormat,
+    DS8Primary_GetVolume,
+    DS8Primary_GetPan,
+    DS8Primary_GetFrequency,
+    DS8Primary_GetStatus,
+    DS8Primary_Initialize,
+    DS8Primary_Lock,
+    DS8Primary_Play,
+    DS8Primary_SetCurrentPosition,
+    DS8Primary_SetFormat,
+    DS8Primary_SetVolume,
+    DS8Primary_SetPan,
+    DS8Primary_SetFrequency,
+    DS8Primary_Stop,
+    DS8Primary_Unlock,
+    DS8Primary_Restore
+};
+
+static inline DS8Primary *impl_from_IDirectSound3DListener(IDirectSound3DListener *iface)
+{
+    return CONTAINING_RECORD(iface, DS8Primary, IDirectSound3DListener_iface);
 }
 
-LPWAVEFORMATEX DSOUND_CopyFormat(LPCWAVEFORMATEX wfex)
+static HRESULT WINAPI DS8Primary3D_QueryInterface(IDirectSound3DListener *iface, REFIID riid, void **ppv)
 {
-	DWORD size = DSOUND_GetFormatSize(wfex);
-	LPWAVEFORMATEX pwfx = HeapAlloc(GetProcessHeap(),0,size);
-	if (pwfx == NULL) {
-		WARN("out of memory\n");
-	} else if (wfex->wFormatTag != WAVE_FORMAT_PCM) {
-		CopyMemory(pwfx, wfex, size);
-	} else {
-		CopyMemory(pwfx, wfex, sizeof(PCMWAVEFORMAT));
-		pwfx->cbSize=0;
-		if (pwfx->nBlockAlign != pwfx->nChannels * pwfx->wBitsPerSample/8) {
-			WARN("Fixing bad nBlockAlign (%u)\n", pwfx->nBlockAlign);
-			pwfx->nBlockAlign  = pwfx->nChannels * pwfx->wBitsPerSample/8;
-		}
-		if (pwfx->nAvgBytesPerSec != pwfx->nSamplesPerSec * pwfx->nBlockAlign) {
-			WARN("Fixing bad nAvgBytesPerSec (%u)\n", pwfx->nAvgBytesPerSec);
-			pwfx->nAvgBytesPerSec  = pwfx->nSamplesPerSec * pwfx->nBlockAlign;
-		}
-	}
-	return pwfx;
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+    return IDirectSoundBuffer_QueryInterface((IDirectSoundBuffer*)This, riid, ppv);
 }
 
-HRESULT primarybuffer_SetFormat(DirectSoundDevice *device, LPCWAVEFORMATEX wfex)
+static ULONG WINAPI DS8Primary3D_AddRef(IDirectSound3DListener *iface)
 {
-	HRESULT err = DSERR_BUFFERLOST;
-	int i;
-	DWORD nSamplesPerSec, bpp, chans;
-	LPWAVEFORMATEX oldpwfx;
-        BOOL forced = device->priolevel == DSSCL_WRITEPRIMARY;
-
-	TRACE("(%p,%p)\n", device, wfex);
-
-	if (device->priolevel == DSSCL_NORMAL) {
-		WARN("failed priority check!\n");
-		return DSERR_PRIOLEVELNEEDED;
-	}
-
-	/* Let's be pedantic! */
-	if (wfex == NULL) {
-		WARN("invalid parameter: wfex==NULL!\n");
-		return DSERR_INVALIDPARAM;
-	}
-	TRACE("(formattag=0x%04x,chans=%d,samplerate=%d,"
-              "bytespersec=%d,blockalign=%d,bitspersamp=%d,cbSize=%d)\n",
-	      wfex->wFormatTag, wfex->nChannels, wfex->nSamplesPerSec,
-	      wfex->nAvgBytesPerSec, wfex->nBlockAlign,
-	      wfex->wBitsPerSample, wfex->cbSize);
-
-	/* **** */
-	RtlAcquireResourceExclusive(&(device->buffer_list_lock), TRUE);
-	EnterCriticalSection(&(device->mixlock));
-
-	nSamplesPerSec = device->pwfx->nSamplesPerSec;
-	bpp = device->pwfx->wBitsPerSample;
-	chans = device->pwfx->nChannels;
-
-	oldpwfx = device->pwfx;
-	device->pwfx = DSOUND_CopyFormat(wfex);
-	if (device->pwfx == NULL) {
-		device->pwfx = oldpwfx;
-		oldpwfx = NULL;
-		err = DSERR_OUTOFMEMORY;
-		goto done;
-	}
-
-	if (!(device->drvdesc.dwFlags & DSDDESC_DOMMSYSTEMSETFORMAT) && device->hwbuf) {
-		err = IDsDriverBuffer_SetFormat(device->hwbuf, device->pwfx);
-
-		/* On bad format, try to re-create, big chance it will work then, only do this if we <HAVE> to */
-		if (forced && (device->pwfx->nSamplesPerSec/100 != wfex->nSamplesPerSec/100 || err == DSERR_BADFORMAT))
-		{
-			DWORD cp_size = wfex->wFormatTag == WAVE_FORMAT_PCM ?
-				sizeof(PCMWAVEFORMAT) : sizeof(WAVEFORMATEX) + wfex->cbSize;
-			err = DSERR_BUFFERLOST;
-			CopyMemory(device->pwfx, wfex, cp_size);
-		}
-
-		if (err != DSERR_BUFFERLOST && FAILED(err)) {
-			DWORD size = DSOUND_GetFormatSize(oldpwfx);
-			WARN("IDsDriverBuffer_SetFormat failed\n");
-			if (!forced) {
-				CopyMemory(device->pwfx, oldpwfx, size);
-				err = DS_OK;
-			}
-			goto done;
-		}
-
-		if (err == S_FALSE)
-		{
-			/* ALSA specific: S_FALSE tells that recreation was successful,
-			 * but size and location may be changed, and buffer has to be restarted
-			 * I put it here, so if frequency doesn't match the error will be changed to DSERR_BUFFERLOST
-			 * and the entire re-initialization will occur anyway
-			 */
-			IDsDriverBuffer_Lock(device->hwbuf, (LPVOID *)&device->buffer, &device->buflen, NULL, NULL, 0, 0, DSBLOCK_ENTIREBUFFER);
-			IDsDriverBuffer_Unlock(device->hwbuf, device->buffer, 0, NULL, 0);
-
-			if (device->state == STATE_PLAYING) device->state = STATE_STARTING;
-			else if (device->state == STATE_STOPPING) device->state = STATE_STOPPED;
-			device->pwplay = device->pwqueue = device->playpos = device->mixpos = 0;
-			err = DS_OK;
-		}
-		DSOUND_RecalcPrimary(device);
-	}
-
-	if (err == DSERR_BUFFERLOST)
-	{
-		DSOUND_PrimaryClose(device);
-
-		err = DSOUND_ReopenDevice(device, FALSE);
-		if (FAILED(err))
-		{
-			WARN("DSOUND_ReopenDevice failed: %08x\n", err);
-			goto done;
-		}
-		err = DSOUND_PrimaryOpen(device);
-		if (err != DS_OK) {
-			WARN("DSOUND_PrimaryOpen failed\n");
-			goto done;
-		}
-
-		if (wfex->nSamplesPerSec/100 != device->pwfx->nSamplesPerSec/100 && forced && device->buffer)
-		{
-			DSOUND_PrimaryClose(device);
-			device->pwfx->nSamplesPerSec = wfex->nSamplesPerSec;
-			err = DSOUND_ReopenDevice(device, TRUE);
-			if (FAILED(err))
-				WARN("DSOUND_ReopenDevice(2) failed: %08x\n", err);
-			else if (FAILED((err = DSOUND_PrimaryOpen(device))))
-				WARN("DSOUND_PrimaryOpen(2) failed: %08x\n", err);
-		}
-	}
-
-	device->mix_buffer_len = DSOUND_bufpos_to_mixpos(device, device->buflen);
-	device->mix_buffer = HeapReAlloc(GetProcessHeap(), 0, device->mix_buffer, device->mix_buffer_len);
-	FillMemory(device->mix_buffer, device->mix_buffer_len, 0);
-	device->mixfunction = mixfunctions[device->pwfx->wBitsPerSample/8 - 1];
-	device->normfunction = normfunctions[device->pwfx->wBitsPerSample/8 - 1];
-
-	if (nSamplesPerSec != device->pwfx->nSamplesPerSec || bpp != device->pwfx->wBitsPerSample || chans != device->pwfx->nChannels) {
-		IDirectSoundBufferImpl** dsb = device->buffers;
-		for (i = 0; i < device->nrofbuffers; i++, dsb++) {
-			/* **** */
-			RtlAcquireResourceExclusive(&(*dsb)->lock, TRUE);
-
-			(*dsb)->freqAdjust = ((DWORD64)(*dsb)->freq << DSOUND_FREQSHIFT) / device->pwfx->nSamplesPerSec;
-			DSOUND_RecalcFormat((*dsb));
-			DSOUND_MixToTemporary((*dsb), 0, (*dsb)->buflen, FALSE);
-			(*dsb)->primary_mixpos = 0;
-
-			RtlReleaseResource(&(*dsb)->lock);
-			/* **** */
-		}
-	}
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+    LONG ret;
 
-done:
-	LeaveCriticalSection(&(device->mixlock));
-	RtlReleaseResource(&(device->buffer_list_lock));
-	/* **** */
+    ret = InterlockedIncrement(&This->ds3d_ref);
+    TRACE("new refcount %d\n", ret);
 
-	HeapFree(GetProcessHeap(), 0, oldpwfx);
-	return err;
+    return ret;
 }
 
-/*******************************************************************************
- *		PrimaryBuffer
+
+/* Considering the primary buffer doesn't get destroyed
+ * it doesn't make sense to destroy ds3d here
  */
-static inline IDirectSoundBufferImpl *impl_from_IDirectSoundBuffer(IDirectSoundBuffer *iface)
+static ULONG WINAPI DS8Primary3D_Release(IDirectSound3DListener *iface)
 {
-    /* IDirectSoundBuffer and IDirectSoundBuffer8 use the same iface. */
-    return CONTAINING_RECORD(iface, IDirectSoundBufferImpl, IDirectSoundBuffer8_iface);
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+    LONG ret;
+
+    ret = InterlockedDecrement(&This->ds3d_ref);
+    TRACE("new refcount %d\n", ret);
+
+    return ret;
 }
 
-/* This sets this format for the <em>Primary Buffer Only</em> */
-/* See file:///cdrom/sdk52/docs/worddoc/dsound.doc page 120 */
-static HRESULT WINAPI PrimaryBufferImpl_SetFormat(
-    LPDIRECTSOUNDBUFFER iface,
-    LPCWAVEFORMATEX wfex)
+
+static HRESULT WINAPI DS8Primary3D_GetAllParameters(IDirectSound3DListener *iface, DS3DLISTENER *listener)
 {
-    IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-    TRACE("(%p,%p)\n", iface, wfex);
-    return primarybuffer_SetFormat(This->device, wfex);
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+    HRESULT hr;
+    DS3DLISTENER listen;
+
+    TRACE("(%p)->(%p)\n", iface, listener);
+
+    if(!listener || listener->dwSize < sizeof(*listener))
+    {
+        WARN("Invalid DS3DLISTENER %p %u\n", listener, listener ? listener->dwSize : 0);
+        return DSERR_INVALIDPARAM;
+    }
+    listen.dwSize = listener->dwSize;
+
+    EnterCriticalSection(&This->crst);
+    setALContext(This->ctx);
+    hr = IDirectSound3DListener_GetPosition(iface, &listen.vPosition);
+    if(SUCCEEDED(hr))
+        hr = IDirectSound3DListener_GetVelocity(iface, &listen.vVelocity);
+    if(SUCCEEDED(hr))
+        hr = IDirectSound3DListener_GetOrientation(iface, &listen.vOrientFront, &listen.vOrientTop);
+    if(SUCCEEDED(hr))
+        hr = IDirectSound3DListener_GetDistanceFactor(iface, &listen.flDistanceFactor);
+    if(SUCCEEDED(hr))
+        hr = IDirectSound3DListener_GetRolloffFactor(iface, &listen.flRolloffFactor);
+    if(SUCCEEDED(hr))
+        hr = IDirectSound3DListener_GetRolloffFactor(iface, &listen.flDopplerFactor);
+    if(SUCCEEDED(hr))
+        memcpy(listener, &listen, sizeof(listen));
+    popALContext();
+    LeaveCriticalSection(&This->crst);
+
+    return hr;
 }
 
-static HRESULT WINAPI PrimaryBufferImpl_SetVolume(
-	LPDIRECTSOUNDBUFFER iface,LONG vol
-) {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-        DirectSoundDevice *device = This->device;
-	DWORD ampfactors;
-        HRESULT hres = DS_OK;
-	TRACE("(%p,%d)\n", iface, vol);
-
-	if (!(This->dsbd.dwFlags & DSBCAPS_CTRLVOLUME)) {
-		WARN("control unavailable\n");
-		return DSERR_CONTROLUNAVAIL;
-	}
-
-	if ((vol > DSBVOLUME_MAX) || (vol < DSBVOLUME_MIN)) {
-		WARN("invalid parameter: vol = %d\n", vol);
-		return DSERR_INVALIDPARAM;
-	}
-
-	/* **** */
-	EnterCriticalSection(&(device->mixlock));
-
-        waveOutGetVolume(device->hwo, &ampfactors);
-        device->volpan.dwTotalLeftAmpFactor=ampfactors & 0xffff;
-        device->volpan.dwTotalRightAmpFactor=ampfactors >> 16;
-        DSOUND_AmpFactorToVolPan(&device->volpan);
-        if (vol != device->volpan.lVolume) {
-            device->volpan.lVolume=vol;
-            DSOUND_RecalcVolPan(&device->volpan);
-            if (device->hwbuf) {
-                hres = IDsDriverBuffer_SetVolumePan(device->hwbuf, &device->volpan);
-                if (hres != DS_OK)
-                    WARN("IDsDriverBuffer_SetVolumePan failed\n");
-            } else {
-                ampfactors = (device->volpan.dwTotalLeftAmpFactor & 0xffff) | (device->volpan.dwTotalRightAmpFactor << 16);
-                waveOutSetVolume(device->hwo, ampfactors);
-            }
-        }
+static HRESULT WINAPI DS8Primary3D_GetDistanceFactor(IDirectSound3DListener *iface, D3DVALUE *distancefactor)
+{
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+
+    TRACE("(%p)->(%p)\n", iface, distancefactor);
+
+    if(!distancefactor)
+    {
+        WARN("Invalid parameter %p\n", distancefactor);
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(&This->crst);
+    setALContext(This->ctx);
 
-	LeaveCriticalSection(&(device->mixlock));
-	/* **** */
+    *distancefactor = 343.3f/palGetFloat(AL_SPEED_OF_SOUND);
+    getALError();
 
-	return hres;
+    popALContext();
+    LeaveCriticalSection(&This->crst);
+
+    return S_OK;
 }
 
-static HRESULT WINAPI PrimaryBufferImpl_GetVolume(
-	LPDIRECTSOUNDBUFFER iface,LPLONG vol
-) {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-        DirectSoundDevice *device = This->device;
-	DWORD ampfactors;
-	TRACE("(%p,%p)\n", iface, vol);
-
-	if (!(This->dsbd.dwFlags & DSBCAPS_CTRLVOLUME)) {
-		WARN("control unavailable\n");
-		return DSERR_CONTROLUNAVAIL;
-	}
-
-	if (vol == NULL) {
-		WARN("invalid parameter: vol = NULL\n");
-		return DSERR_INVALIDPARAM;
-	}
-
-        if (!device->hwbuf)
-        {
-	    waveOutGetVolume(device->hwo, &ampfactors);
-	    device->volpan.dwTotalLeftAmpFactor=ampfactors & 0xffff;
-	    device->volpan.dwTotalRightAmpFactor=ampfactors >> 16;
-	    DSOUND_AmpFactorToVolPan(&device->volpan);
-        }
-        *vol = device->volpan.lVolume;
-	return DS_OK;
+static HRESULT WINAPI DS8Primary3D_GetDopplerFactor(IDirectSound3DListener *iface, D3DVALUE *dopplerfactor)
+{
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+
+    TRACE("(%p)->(%p)\n", iface, dopplerfactor);
+
+    if(!dopplerfactor)
+    {
+        WARN("Invalid parameter %p\n", dopplerfactor);
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(&This->crst);
+    setALContext(This->ctx);
+
+    *dopplerfactor = palGetFloat(AL_DOPPLER_FACTOR);
+    getALError();
+
+    popALContext();
+    LeaveCriticalSection(&This->crst);
+
+    return S_OK;
 }
 
-static HRESULT WINAPI PrimaryBufferImpl_SetFrequency(
-	LPDIRECTSOUNDBUFFER iface,DWORD freq
-) {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-	TRACE("(%p,%d)\n",This,freq);
+static HRESULT WINAPI DS8Primary3D_GetOrientation(IDirectSound3DListener *iface, D3DVECTOR *front, D3DVECTOR *top)
+{
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+    ALfloat orient[6];
+
+    TRACE("(%p)->(%p, %p)\n", iface, front, top);
 
-	/* You cannot set the frequency of the primary buffer */
-	WARN("control unavailable\n");
-	return DSERR_CONTROLUNAVAIL;
+    if(!front || !top)
+    {
+        WARN("Invalid parameter %p %p\n", front, top);
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(&This->crst);
+    setALContext(This->ctx);
+
+    palGetListenerfv(AL_ORIENTATION, orient);
+    getALError();
+
+    front->x =  orient[0];
+    front->y =  orient[1];
+    front->z = -orient[2];
+    top->x =  orient[3];
+    top->y =  orient[4];
+    top->z = -orient[5];
+
+    popALContext();
+    LeaveCriticalSection(&This->crst);
+
+    return S_OK;
 }
 
-static HRESULT WINAPI PrimaryBufferImpl_Play(
-	LPDIRECTSOUNDBUFFER iface,DWORD reserved1,DWORD reserved2,DWORD flags
-) {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-        DirectSoundDevice *device = This->device;
-	TRACE("(%p,%08x,%08x,%08x)\n", iface, reserved1, reserved2, flags);
+static HRESULT WINAPI DS8Primary3D_GetPosition(IDirectSound3DListener *iface, D3DVECTOR *pos)
+{
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+    ALfloat alpos[3];
 
-	if (!(flags & DSBPLAY_LOOPING)) {
-		WARN("invalid parameter: flags = %08x\n", flags);
-		return DSERR_INVALIDPARAM;
-	}
+    TRACE("(%p)->(%p)\n", iface, pos);
 
-	/* **** */
-	EnterCriticalSection(&(device->mixlock));
+    if(!pos)
+    {
+        WARN("Invalid parameter %p\n", pos);
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(&This->crst);
+    setALContext(This->ctx);
 
-	if (device->state == STATE_STOPPED)
-		device->state = STATE_STARTING;
-	else if (device->state == STATE_STOPPING)
-		device->state = STATE_PLAYING;
+    palGetListenerfv(AL_POSITION, alpos);
+    getALError();
 
-	LeaveCriticalSection(&(device->mixlock));
-	/* **** */
+    pos->x =  alpos[0];
+    pos->y =  alpos[1];
+    pos->z = -alpos[2];
 
-	return DS_OK;
+    popALContext();
+    LeaveCriticalSection(&This->crst);
+
+    return S_OK;
 }
 
-static HRESULT WINAPI PrimaryBufferImpl_Stop(LPDIRECTSOUNDBUFFER iface)
+static HRESULT WINAPI DS8Primary3D_GetRolloffFactor(IDirectSound3DListener *iface, D3DVALUE *rollofffactor)
 {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-        DirectSoundDevice *device = This->device;
-	TRACE("(%p)\n", iface);
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
 
-	/* **** */
-	EnterCriticalSection(&(device->mixlock));
+    TRACE("(%p)->(%p)\n", iface, rollofffactor);
 
-	if (device->state == STATE_PLAYING)
-		device->state = STATE_STOPPING;
-	else if (device->state == STATE_STARTING)
-		device->state = STATE_STOPPED;
+    if(!rollofffactor)
+    {
+        WARN("Invalid parameter %p\n", rollofffactor);
+        return DSERR_INVALIDPARAM;
+    }
 
-	LeaveCriticalSection(&(device->mixlock));
-	/* **** */
+    EnterCriticalSection(&This->crst);
+    *rollofffactor = This->rollofffactor;
+    LeaveCriticalSection(&This->crst);
 
-	return DS_OK;
+    return S_OK;
 }
 
-static ULONG WINAPI PrimaryBufferImpl_AddRef(LPDIRECTSOUNDBUFFER iface)
+static HRESULT WINAPI DS8Primary3D_GetVelocity(IDirectSound3DListener *iface, D3DVECTOR *velocity)
 {
-    IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-    ULONG ref = InterlockedIncrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref - 1);
-    if(ref == 1)
-        InterlockedIncrement(&This->numIfaces);
-    return ref;
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+    ALfloat vel[3];
+
+    TRACE("(%p)->(%p)\n", iface, velocity);
+
+    if(!velocity)
+    {
+        WARN("Invalid parameter %p\n", velocity);
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(&This->crst);
+    setALContext(This->ctx);
+
+    palGetListenerfv(AL_VELOCITY, vel);
+    getALError();
+
+    velocity->x =  vel[0];
+    velocity->y =  vel[1];
+    velocity->z = -vel[2];
+
+    popALContext();
+    LeaveCriticalSection(&This->crst);
+
+    return S_OK;
 }
 
-void primarybuffer_destroy(IDirectSoundBufferImpl *This)
+static HRESULT WINAPI DS8Primary3D_SetAllParameters(IDirectSound3DListener *iface, const DS3DLISTENER *listen, DWORD apply)
 {
-    This->device->primary = NULL;
-    HeapFree(GetProcessHeap(), 0, This);
-    TRACE("(%p) released\n", This);
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+
+    TRACE("(%p)->(%p, %u)\n", iface, listen, apply);
+
+    if(!listen || listen->dwSize < sizeof(*listen))
+    {
+        WARN("Invalid parameter %p %u\n", listen, listen ? listen->dwSize : 0);
+        return DSERR_INVALIDPARAM;
+    }
+
+    if(listen->flDistanceFactor > DS3D_MAXDISTANCEFACTOR ||
+       listen->flDistanceFactor < DS3D_MINDISTANCEFACTOR)
+    {
+        WARN("Invalid distance factor (%f)\n", listen->flDistanceFactor);
+        return DSERR_INVALIDPARAM;
+    }
+
+    if(listen->flDopplerFactor > DS3D_MAXDOPPLERFACTOR ||
+       listen->flDopplerFactor < DS3D_MINDOPPLERFACTOR)
+    {
+        WARN("Invalid doppler factor (%f)\n", listen->flDopplerFactor);
+        return DSERR_INVALIDPARAM;
+    }
+
+    if(listen->flRolloffFactor < DS3D_MINROLLOFFFACTOR ||
+       listen->flRolloffFactor > DS3D_MAXROLLOFFFACTOR)
+    {
+        WARN("Invalid rolloff factor (%f)\n", listen->flRolloffFactor);
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(&This->crst);
+    setALContext(This->ctx);
+    IDirectSound3DListener_SetPosition(iface, listen->vPosition.x, listen->vPosition.y, listen->vPosition.z, apply);
+    IDirectSound3DListener_SetVelocity(iface, listen->vVelocity.x, listen->vVelocity.y, listen->vVelocity.z, apply);
+    IDirectSound3DListener_SetOrientation(iface, listen->vOrientFront.x, listen->vOrientFront.y, listen->vOrientFront.z,
+                                          listen->vOrientTop.x, listen->vOrientTop.y, listen->vOrientTop.z, apply);
+    IDirectSound3DListener_SetDistanceFactor(iface, listen->flDistanceFactor, apply);
+    IDirectSound3DListener_SetRolloffFactor(iface, listen->flRolloffFactor, apply);
+    IDirectSound3DListener_SetDopplerFactor(iface, listen->flDopplerFactor, apply);
+    popALContext();
+    LeaveCriticalSection(&This->crst);
+
+    return S_OK;
 }
 
-static ULONG WINAPI PrimaryBufferImpl_Release(LPDIRECTSOUNDBUFFER iface)
+static HRESULT WINAPI DS8Primary3D_SetDistanceFactor(IDirectSound3DListener *iface, D3DVALUE factor, DWORD apply)
 {
-    IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-    DWORD ref = InterlockedDecrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref + 1);
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+
+    TRACE("(%p)->(%f, %u)\n", iface, factor, apply);
+
+    if(factor < DS3D_MINDISTANCEFACTOR ||
+       factor > DS3D_MAXDISTANCEFACTOR)
+    {
+        WARN("Invalid parameter %f\n", factor);
+        return DSERR_INVALIDPARAM;
+    }
 
-    if (!ref && !InterlockedDecrement(&This->numIfaces))
-        primarybuffer_destroy(This);
-    return ref;
+    EnterCriticalSection(&This->crst);
+    if(apply == DS3D_DEFERRED)
+    {
+        This->listen.flDistanceFactor = factor;
+        This->dirty.bit.distancefactor = 1;
+    }
+    else
+    {
+        setALContext(This->ctx);
+        palSpeedOfSound(343.3f/factor);
+        if(This->has_efx)
+            palListenerf(AL_METERS_PER_UNIT, factor);
+        getALError();
+        popALContext();
+    }
+    LeaveCriticalSection(&This->crst);
+
+    return S_OK;
 }
 
-static HRESULT WINAPI PrimaryBufferImpl_GetCurrentPosition(
-	LPDIRECTSOUNDBUFFER iface,LPDWORD playpos,LPDWORD writepos
-) {
-	HRESULT	hres;
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-        DirectSoundDevice *device = This->device;
-	TRACE("(%p,%p,%p)\n", iface, playpos, writepos);
-
-	/* **** */
-	EnterCriticalSection(&(device->mixlock));
-
-	hres = DSOUND_PrimaryGetPosition(device, playpos, writepos);
-	if (hres != DS_OK) {
-		WARN("DSOUND_PrimaryGetPosition failed\n");
-		LeaveCriticalSection(&(device->mixlock));
-		return hres;
-	}
-	if (writepos) {
-		if (device->state != STATE_STOPPED)
-			/* apply the documented 10ms lead to writepos */
-			*writepos += device->writelead;
-		while (*writepos >= device->buflen) *writepos -= device->buflen;
-	}
-
-	LeaveCriticalSection(&(device->mixlock));
-	/* **** */
-
-	TRACE("playpos = %d, writepos = %d (%p, time=%d)\n", playpos?*playpos:0, writepos?*writepos:0, device, GetTickCount());
-	return DS_OK;
+static HRESULT WINAPI DS8Primary3D_SetDopplerFactor(IDirectSound3DListener *iface, D3DVALUE factor, DWORD apply)
+{
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+
+    TRACE("(%p)->(%f, %u)\n", iface, factor, apply);
+
+    if(factor < DS3D_MINDOPPLERFACTOR ||
+       factor > DS3D_MAXDOPPLERFACTOR)
+    {
+        WARN("Invalid parameter %f\n", factor);
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(&This->crst);
+    if(apply == DS3D_DEFERRED)
+    {
+        This->listen.flDopplerFactor = factor;
+        This->dirty.bit.dopplerfactor = 1;
+    }
+    else
+    {
+        setALContext(This->ctx);
+        palDopplerFactor(factor);
+        getALError();
+        popALContext();
+    }
+    LeaveCriticalSection(&This->crst);
+
+    return S_OK;
 }
 
-static HRESULT WINAPI PrimaryBufferImpl_GetStatus(
-	LPDIRECTSOUNDBUFFER iface,LPDWORD status
-) {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-        DirectSoundDevice *device = This->device;
-	TRACE("(%p,%p)\n", iface, status);
-
-	if (status == NULL) {
-		WARN("invalid parameter: status == NULL\n");
-		return DSERR_INVALIDPARAM;
-	}
-
-	*status = 0;
-	if ((device->state == STATE_STARTING) ||
-	    (device->state == STATE_PLAYING))
-		*status |= DSBSTATUS_PLAYING | DSBSTATUS_LOOPING;
-
-	TRACE("status=%x\n", *status);
-	return DS_OK;
+static HRESULT WINAPI DS8Primary3D_SetOrientation(IDirectSound3DListener *iface, D3DVALUE xFront, D3DVALUE yFront, D3DVALUE zFront, D3DVALUE xTop, D3DVALUE yTop, D3DVALUE zTop, DWORD apply)
+{
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+
+    TRACE("(%p)->(%f, %f, %f, %f, %f, %f, %u)\n", iface, xFront, yFront, zFront, xTop, yTop, zTop, apply);
+
+    EnterCriticalSection(&This->crst);
+    if(apply == DS3D_DEFERRED)
+    {
+        This->listen.vOrientFront.x = xFront;
+        This->listen.vOrientFront.y = yFront;
+        This->listen.vOrientFront.z = zFront;
+        This->listen.vOrientTop.x = xTop;
+        This->listen.vOrientTop.y = yTop;
+        This->listen.vOrientTop.z = zTop;
+        This->dirty.bit.orientation = 1;
+    }
+    else
+    {
+        ALfloat orient[6] = {
+            xFront, yFront, -zFront,
+            xTop, yTop, -zTop
+        };
+        setALContext(This->ctx);
+        palListenerfv(AL_ORIENTATION, orient);
+        getALError();
+        popALContext();
+    }
+    LeaveCriticalSection(&This->crst);
+
+    return S_OK;
 }
 
+static HRESULT WINAPI DS8Primary3D_SetPosition(IDirectSound3DListener *iface, D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD apply)
+{
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+
+    TRACE("(%p)->(%f, %f, %f, %u)\n", iface, x, y, z, apply);
+
+    EnterCriticalSection(&This->crst);
+    if(apply == DS3D_DEFERRED)
+    {
+        This->listen.vPosition.x = x;
+        This->listen.vPosition.y = y;
+        This->listen.vPosition.z = z;
+        This->dirty.bit.pos = 1;
+    }
+    else
+    {
+        setALContext(This->ctx);
+        palListener3f(AL_POSITION, x, y, -z);
+        getALError();
+        popALContext();
+    }
+    LeaveCriticalSection(&This->crst);
+
+    return S_OK;
+}
 
-static HRESULT WINAPI PrimaryBufferImpl_GetFormat(
-    LPDIRECTSOUNDBUFFER iface,
-    LPWAVEFORMATEX lpwf,
-    DWORD wfsize,
-    LPDWORD wfwritten)
+static HRESULT WINAPI DS8Primary3D_SetRolloffFactor(IDirectSound3DListener *iface, D3DVALUE factor, DWORD apply)
 {
-    DWORD size;
-    IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-    DirectSoundDevice *device = This->device;
-    TRACE("(%p,%p,%d,%p)\n", iface, lpwf, wfsize, wfwritten);
-
-    size = sizeof(WAVEFORMATEX) + device->pwfx->cbSize;
-
-    if (lpwf) {	/* NULL is valid */
-        if (wfsize >= size) {
-            CopyMemory(lpwf,device->pwfx,size);
-            if (wfwritten)
-                *wfwritten = size;
-        } else {
-            WARN("invalid parameter: wfsize too small\n");
-            if (wfwritten)
-                *wfwritten = 0;
-            return DSERR_INVALIDPARAM;
-        }
-    } else {
-        if (wfwritten)
-            *wfwritten = sizeof(WAVEFORMATEX) + device->pwfx->cbSize;
-        else {
-            WARN("invalid parameter: wfwritten == NULL\n");
-            return DSERR_INVALIDPARAM;
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+
+    TRACE("(%p)->(%f, %u)\n", iface, factor, apply);
+
+    if(factor < DS3D_MINROLLOFFFACTOR ||
+       factor > DS3D_MAXROLLOFFFACTOR)
+    {
+        WARN("Invalid parameter %f\n", factor);
+        return DSERR_INVALIDPARAM;
+    }
+
+    EnterCriticalSection(&This->crst);
+    if(apply == DS3D_DEFERRED)
+    {
+        This->listen.flRolloffFactor = factor;
+        This->dirty.bit.rollofffactor = 1;
+    }
+    else
+    {
+        DWORD i;
+
+        setALContext(This->ctx);
+        for(i = 0;i < This->nbuffers;++i)
+        {
+            if(This->buffers[i]->ds3dmode != DS3DMODE_DISABLE)
+                palSourcef(This->buffers[i]->source, AL_ROLLOFF_FACTOR, factor);
         }
+        getALError();
+        popALContext();
+
+        This->rollofffactor = factor;
     }
+    LeaveCriticalSection(&This->crst);
 
-    return DS_OK;
+    return S_OK;
 }
 
-static HRESULT WINAPI PrimaryBufferImpl_Lock(
-	LPDIRECTSOUNDBUFFER iface,DWORD writecursor,DWORD writebytes,LPVOID *lplpaudioptr1,LPDWORD audiobytes1,LPVOID *lplpaudioptr2,LPDWORD audiobytes2,DWORD flags
-) {
-	HRESULT hres;
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-        DirectSoundDevice *device = This->device;
-	TRACE("(%p,%d,%d,%p,%p,%p,%p,0x%08x) at %d\n",
-		iface,
-		writecursor,
-		writebytes,
-		lplpaudioptr1,
-		audiobytes1,
-		lplpaudioptr2,
-		audiobytes2,
-		flags,
-		GetTickCount()
-	);
-
-        if (!audiobytes1)
-            return DSERR_INVALIDPARAM;
+static HRESULT WINAPI DS8Primary3D_SetVelocity(IDirectSound3DListener *iface, D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD apply)
+{
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+
+    TRACE("(%p)->(%f, %f, %f, %u)\n", iface, x, y, z, apply);
+
+    EnterCriticalSection(&This->crst);
+    if(apply == DS3D_DEFERRED)
+    {
+        This->listen.vVelocity.x = x;
+        This->listen.vVelocity.y = y;
+        This->listen.vVelocity.z = z;
+        This->dirty.bit.vel = 1;
+    }
+    else
+    {
+        setALContext(This->ctx);
+        palListener3f(AL_VELOCITY, x, y, -z);
+        getALError();
+        popALContext();
+    }
+    LeaveCriticalSection(&This->crst);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI DS8Primary3D_CommitDeferredSettings(IDirectSound3DListener *iface)
+{
+    DS8Primary *This = impl_from_IDirectSound3DListener(iface);
+    const DS3DLISTENER *listen = &This->listen;
+    DWORD i;
+
+    EnterCriticalSection(&This->crst);
+    setALContext(This->ctx);
+    palcSuspendContext(This->ctx);
+
+    if(This->dirty.bit.pos)
+        palListener3f(AL_POSITION, listen->vPosition.x, listen->vPosition.y, -listen->vPosition.z);
+    if(This->dirty.bit.vel)
+        palListener3f(AL_VELOCITY, listen->vVelocity.x, listen->vVelocity.y, -listen->vVelocity.z);
+    if(This->dirty.bit.orientation)
+    {
+        ALfloat orient[6] = {
+            listen->vOrientFront.x, listen->vOrientFront.y, -listen->vOrientFront.z,
+            listen->vOrientTop.x, listen->vOrientTop.y, -listen->vOrientTop.z
+        };
+        palListenerfv(AL_ORIENTATION, orient);
+    }
+    if(This->dirty.bit.distancefactor)
+    {
+        palSpeedOfSound(343.3f/listen->flDistanceFactor);
+        if(This->has_efx)
+            palListenerf(AL_METERS_PER_UNIT, listen->flDistanceFactor);
+    }
 
-	if (device->priolevel != DSSCL_WRITEPRIMARY) {
-		WARN("failed priority check!\n");
-		return DSERR_PRIOLEVELNEEDED;
-	}
-
-        /* when this flag is set, writecursor is meaningless and must be calculated */
-	if (flags & DSBLOCK_FROMWRITECURSOR) {
-		/* GetCurrentPosition does too much magic to duplicate here */
-		hres = IDirectSoundBuffer_GetCurrentPosition(iface, NULL, &writecursor);
-		if (hres != DS_OK) {
-			WARN("IDirectSoundBuffer_GetCurrentPosition failed\n");
-			return hres;
-		}
-	}
-
-        /* when this flag is set, writebytes is meaningless and must be set */
-	if (flags & DSBLOCK_ENTIREBUFFER)
-		writebytes = device->buflen;
-
-        if (writecursor >= device->buflen) {
-                WARN("Invalid parameter, writecursor: %u >= buflen: %u\n",
-		     writecursor, device->buflen);
-                return DSERR_INVALIDPARAM;
+    if(This->dirty.bit.rollofffactor)
+    {
+        for(i = 0;i < This->nbuffers;++i)
+        {
+            if(This->buffers[i]->ds3dmode != DS3DMODE_DISABLE)
+                palSourcef(This->buffers[i]->source, AL_ROLLOFF_FACTOR, This->rollofffactor);
         }
+    }
+
+    if(This->dirty.bit.dopplerfactor)
+        palDopplerFactor(listen->flDopplerFactor);
+
+    if(This->dirty.bit.effect)
+        This->ExtAL.AuxiliaryEffectSloti(This->auxslot, AL_EFFECTSLOT_EFFECT, This->effect);
+
+    /* getALError is here for debugging */
+    getALError();
+
+    TRACE("Dirty flags was: 0x%02x\n", This->dirty.flags);
+    This->dirty.flags = 0;
+
+    for(i = 0;i < This->nbuffers;++i)
+    {
+        DS8Buffer *buf = This->buffers[i];
 
-        if (writebytes > device->buflen) {
-                WARN("Invalid parameter, writebytes: %u > buflen: %u\n",
-		     writebytes, device->buflen);
-                return DSERR_INVALIDPARAM;
+        if(!buf->dirty.flags)
+            continue;
+
+        if(buf->dirty.bit.pos)
+            palSource3f(buf->source, AL_POSITION,
+                        buf->ds3dbuffer.vPosition.x,
+                        buf->ds3dbuffer.vPosition.y,
+                       -buf->ds3dbuffer.vPosition.z);
+        if(buf->dirty.bit.vel)
+            palSource3f(buf->source, AL_VELOCITY,
+                        buf->ds3dbuffer.vVelocity.x,
+                        buf->ds3dbuffer.vVelocity.y,
+                       -buf->ds3dbuffer.vVelocity.z);
+        if(buf->dirty.bit.cone_angles)
+        {
+            palSourcei(buf->source, AL_CONE_INNER_ANGLE,
+                       buf->ds3dbuffer.dwInsideConeAngle);
+            palSourcei(buf->source, AL_CONE_OUTER_ANGLE,
+                       buf->ds3dbuffer.dwOutsideConeAngle);
+        }
+        if(buf->dirty.bit.cone_orient)
+            palSource3f(buf->source, AL_DIRECTION,
+                        buf->ds3dbuffer.vConeOrientation.x,
+                        buf->ds3dbuffer.vConeOrientation.y,
+                       -buf->ds3dbuffer.vConeOrientation.z);
+        if(buf->dirty.bit.cone_outsidevolume)
+            palSourcef(buf->source, AL_CONE_OUTER_GAIN,
+                       mB_to_gain(buf->ds3dbuffer.lConeOutsideVolume));
+        if(buf->dirty.bit.min_distance)
+            palSourcef(buf->source, AL_REFERENCE_DISTANCE, buf->ds3dbuffer.flMinDistance);
+        if(buf->dirty.bit.max_distance)
+            palSourcef(buf->source, AL_MAX_DISTANCE, buf->ds3dbuffer.flMaxDistance);
+        if(buf->dirty.bit.mode)
+        {
+            buf->ds3dmode = buf->ds3dbuffer.dwMode;
+            palSourcei(buf->source, AL_SOURCE_RELATIVE,
+                       (buf->ds3dmode!=DS3DMODE_NORMAL) ? AL_TRUE : AL_FALSE);
+            palSourcef(buf->source, AL_ROLLOFF_FACTOR,
+                       (buf->ds3dmode==DS3DMODE_DISABLE) ? 0.0f : This->rollofffactor);
         }
+        buf->dirty.flags = 0;
+    }
+
+    palcProcessContext(This->ctx);
+    popALContext();
+    LeaveCriticalSection(&This->crst);
 
-	if (!(device->drvdesc.dwFlags & DSDDESC_DONTNEEDPRIMARYLOCK) && device->hwbuf) {
-		hres = IDsDriverBuffer_Lock(device->hwbuf,
-					    lplpaudioptr1, audiobytes1,
-					    lplpaudioptr2, audiobytes2,
-					    writecursor, writebytes,
-					    0);
-		if (hres != DS_OK) {
-			WARN("IDsDriverBuffer_Lock failed\n");
-			return hres;
-		}
-	} else {
-		if (writecursor+writebytes <= device->buflen) {
-			*(LPBYTE*)lplpaudioptr1 = device->buffer+writecursor;
-			*audiobytes1 = writebytes;
-			if (lplpaudioptr2)
-				*(LPBYTE*)lplpaudioptr2 = NULL;
-			if (audiobytes2)
-				*audiobytes2 = 0;
-			TRACE("->%d.0\n",writebytes);
-		} else {
-			*(LPBYTE*)lplpaudioptr1 = device->buffer+writecursor;
-			*audiobytes1 = device->buflen-writecursor;
-			if (lplpaudioptr2)
-				*(LPBYTE*)lplpaudioptr2 = device->buffer;
-			if (audiobytes2)
-				*audiobytes2 = writebytes-(device->buflen-writecursor);
-			TRACE("->%d.%d\n",*audiobytes1,audiobytes2?*audiobytes2:0);
-		}
-	}
-	return DS_OK;
+    return S_OK;
 }
 
-static HRESULT WINAPI PrimaryBufferImpl_SetCurrentPosition(
-	LPDIRECTSOUNDBUFFER iface,DWORD newpos
-) {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-	TRACE("(%p,%d)\n",This,newpos);
+static const IDirectSound3DListenerVtbl DS8Primary3D_Vtbl =
+{
+    DS8Primary3D_QueryInterface,
+    DS8Primary3D_AddRef,
+    DS8Primary3D_Release,
+    DS8Primary3D_GetAllParameters,
+    DS8Primary3D_GetDistanceFactor,
+    DS8Primary3D_GetDopplerFactor,
+    DS8Primary3D_GetOrientation,
+    DS8Primary3D_GetPosition,
+    DS8Primary3D_GetRolloffFactor,
+    DS8Primary3D_GetVelocity,
+    DS8Primary3D_SetAllParameters,
+    DS8Primary3D_SetDistanceFactor,
+    DS8Primary3D_SetDopplerFactor,
+    DS8Primary3D_SetOrientation,
+    DS8Primary3D_SetPosition,
+    DS8Primary3D_SetRolloffFactor,
+    DS8Primary3D_SetVelocity,
+    DS8Primary3D_CommitDeferredSettings
+};
 
-	/* You cannot set the position of the primary buffer */
-	WARN("invalid call\n");
-	return DSERR_INVALIDCALL;
+/* NOTE: Although the app handles listener properties through secondary buffers,
+ * we pass the requests to the primary buffer though a propertyset interface.
+ * These methods are not exposed to the app. */
+static inline DS8Primary *impl_from_IKsPropertySet(IKsPropertySet *iface)
+{
+    return CONTAINING_RECORD(iface, DS8Primary, IKsPropertySet_iface);
 }
 
-static HRESULT WINAPI PrimaryBufferImpl_SetPan(
-	LPDIRECTSOUNDBUFFER iface,LONG pan
-) {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-        DirectSoundDevice *device = This->device;
-	DWORD ampfactors;
-        HRESULT hres = DS_OK;
-	TRACE("(%p,%d)\n", iface, pan);
-
-	if (!(This->dsbd.dwFlags & DSBCAPS_CTRLPAN)) {
-		WARN("control unavailable\n");
-		return DSERR_CONTROLUNAVAIL;
-	}
-
-	if ((pan > DSBPAN_RIGHT) || (pan < DSBPAN_LEFT)) {
-		WARN("invalid parameter: pan = %d\n", pan);
-		return DSERR_INVALIDPARAM;
-	}
-
-	/* **** */
-	EnterCriticalSection(&(device->mixlock));
-
-        if (!device->hwbuf)
+static HRESULT WINAPI DS8PrimaryProp_QueryInterface(IKsPropertySet *iface, REFIID riid, void **ppv)
+{
+    DS8Primary *This = impl_from_IKsPropertySet(iface);
+    return IDirectSoundBuffer_QueryInterface((IDirectSoundBuffer*)This, riid, ppv);
+}
+
+static ULONG WINAPI DS8PrimaryProp_AddRef(IKsPropertySet *iface)
+{
+    DS8Primary *This = impl_from_IKsPropertySet(iface);
+    LONG ret;
+
+    ret = InterlockedIncrement(&This->prop_ref);
+    TRACE("new refcount %d\n", ret);
+
+    return ret;
+}
+
+static ULONG WINAPI DS8PrimaryProp_Release(IKsPropertySet *iface)
+{
+    DS8Primary *This = impl_from_IKsPropertySet(iface);
+    LONG ret;
+
+    ret = InterlockedDecrement(&This->prop_ref);
+    TRACE("new refcount %d\n", ret);
+
+    return ret;
+}
+
+static HRESULT WINAPI DS8PrimaryProp_Get(IKsPropertySet *iface, REFGUID guidPropSet,
+    ULONG dwPropID,
+    LPVOID pInstanceData,
+    ULONG cbInstanceData,
+    LPVOID pPropData,
+    ULONG cbPropData,
+    PULONG pcbReturned)
+{
+    DS8Primary *This = impl_from_IKsPropertySet(iface);
+    HRESULT res = E_PROP_ID_UNSUPPORTED;
+
+    TRACE("(%p)->(%s, %u, %p, %u, %p, %u, %p)\n", iface, debugstr_guid(guidPropSet),
+          dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData, pcbReturned);
+
+    EnterCriticalSection(&This->crst);
+
+    if(IsEqualIID(guidPropSet, &DSPROPSETID_EAX20_ListenerProperties))
+    {
+        if(dwPropID == DSPROPERTY_EAXLISTENER_ALLPARAMETERS)
         {
-            waveOutGetVolume(device->hwo, &ampfactors);
-            device->volpan.dwTotalLeftAmpFactor=ampfactors & 0xffff;
-            device->volpan.dwTotalRightAmpFactor=ampfactors >> 16;
-            DSOUND_AmpFactorToVolPan(&device->volpan);
+            EAXLISTENERPROPERTIES *props;
+
+            if(This->effect == 0)
+                goto done;
+
+            if(cbPropData < sizeof(EAXLISTENERPROPERTIES))
+            {
+                res = DSERR_INVALIDPARAM;
+                goto done;
+            }
+
+            props = (EAXLISTENERPROPERTIES*)pPropData;
+            *props = This->eax_prop;
+
+            res = DS_OK;
         }
-        if (pan != device->volpan.lPan) {
-            device->volpan.lPan=pan;
-            DSOUND_RecalcVolPan(&device->volpan);
-            if (device->hwbuf) {
-                hres = IDsDriverBuffer_SetVolumePan(device->hwbuf, &device->volpan);
-                if (hres != DS_OK)
-                    WARN("IDsDriverBuffer_SetVolumePan failed\n");
-            } else {
-                ampfactors = (device->volpan.dwTotalLeftAmpFactor & 0xffff) | (device->volpan.dwTotalRightAmpFactor << 16);
-                waveOutSetVolume(device->hwo, ampfactors);
+        else if(dwPropID == DSPROPERTY_EAXLISTENER_ROOM)
+        {
+            if(This->effect == 0)
+                goto done;
+
+            if(cbPropData < sizeof(LONG))
+            {
+                res = DSERR_INVALIDPARAM;
+                goto done;
             }
+
+            *(LONG*)pPropData = This->eax_prop.lRoom;
+
+            res = DS_OK;
         }
+        else if(dwPropID == DSPROPERTY_EAXLISTENER_ENVIRONMENT)
+        {
+            if(This->effect == 0)
+                goto done;
 
-	LeaveCriticalSection(&(device->mixlock));
-	/* **** */
+            if(cbPropData < sizeof(DWORD))
+            {
+                res = DSERR_INVALIDPARAM;
+                goto done;
+            }
 
-	return hres;
-}
+            *(DWORD*)pPropData = This->eax_prop.dwEnvironment;
 
-static HRESULT WINAPI PrimaryBufferImpl_GetPan(
-	LPDIRECTSOUNDBUFFER iface,LPLONG pan
-) {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-        DirectSoundDevice *device = This->device;
-	DWORD ampfactors;
-	TRACE("(%p,%p)\n", iface, pan);
-
-	if (!(This->dsbd.dwFlags & DSBCAPS_CTRLPAN)) {
-		WARN("control unavailable\n");
-		return DSERR_CONTROLUNAVAIL;
-	}
-
-	if (pan == NULL) {
-		WARN("invalid parameter: pan == NULL\n");
-		return DSERR_INVALIDPARAM;
-	}
-
-        if (!device->hwbuf)
+            res = DS_OK;
+        }
+        else if(dwPropID == DSPROPERTY_EAXLISTENER_FLAGS)
         {
-	    waveOutGetVolume(device->hwo, &ampfactors);
-	    device->volpan.dwTotalLeftAmpFactor=ampfactors & 0xffff;
-	    device->volpan.dwTotalRightAmpFactor=ampfactors >> 16;
-	    DSOUND_AmpFactorToVolPan(&device->volpan);
+            if(This->effect == 0)
+                goto done;
+
+            if(cbPropData < sizeof(DWORD))
+            {
+                res = DSERR_INVALIDPARAM;
+                goto done;
+            }
+
+            *(DWORD*)pPropData = This->eax_prop.dwFlags;
+
+            res = DS_OK;
         }
-	*pan = device->volpan.lPan;
-	return DS_OK;
-}
+        else
+            FIXME("Unhandled propid: 0x%08x\n", dwPropID);
+    }
+    else
+        FIXME("Unhandled propset: %s\n", debugstr_guid(guidPropSet));
 
-static HRESULT WINAPI PrimaryBufferImpl_Unlock(
-	LPDIRECTSOUNDBUFFER iface,LPVOID p1,DWORD x1,LPVOID p2,DWORD x2
-) {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-        DirectSoundDevice *device = This->device;
-	TRACE("(%p,%p,%d,%p,%d)\n", iface, p1, x1, p2, x2);
-
-	if (device->priolevel != DSSCL_WRITEPRIMARY) {
-		WARN("failed priority check!\n");
-		return DSERR_PRIOLEVELNEEDED;
-	}
-
-	if (!(device->drvdesc.dwFlags & DSDDESC_DONTNEEDPRIMARYLOCK) && device->hwbuf) {
-		HRESULT	hres;
-
-		if ((char *)p1 - (char *)device->buffer + x1 > device->buflen)
-		    hres = DSERR_INVALIDPARAM;
-		else
-		    hres = IDsDriverBuffer_Unlock(device->hwbuf, p1, x1, p2, x2);
-
-		if (hres != DS_OK) {
-			WARN("IDsDriverBuffer_Unlock failed\n");
-			return hres;
-		}
-	}
-
-	return DS_OK;
-}
+done:
+    LeaveCriticalSection(&This->crst);
 
-static HRESULT WINAPI PrimaryBufferImpl_Restore(
-	LPDIRECTSOUNDBUFFER iface
-) {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-	FIXME("(%p):stub\n",This);
-	return DS_OK;
+    return res;
 }
 
-static HRESULT WINAPI PrimaryBufferImpl_GetFrequency(
-	LPDIRECTSOUNDBUFFER iface,LPDWORD freq
-) {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-        DirectSoundDevice *device = This->device;
-	TRACE("(%p,%p)\n", iface, freq);
+static HRESULT WINAPI DS8PrimaryProp_Set(IKsPropertySet *iface, REFGUID guidPropSet,
+    ULONG dwPropID,
+    LPVOID pInstanceData,
+    ULONG cbInstanceData,
+    LPVOID pPropData,
+    ULONG cbPropData)
+{
+    DS8Primary *This = impl_from_IKsPropertySet(iface);
+    HRESULT res = E_PROP_ID_UNSUPPORTED;
 
-	if (freq == NULL) {
-		WARN("invalid parameter: freq == NULL\n");
-		return DSERR_INVALIDPARAM;
-	}
+    TRACE("(%p)->(%s, %u, %p, %u, %p, %u)\n", iface, debugstr_guid(guidPropSet),
+          dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData);
 
-	if (!(This->dsbd.dwFlags & DSBCAPS_CTRLFREQUENCY)) {
-		WARN("control unavailable\n");
-		return DSERR_CONTROLUNAVAIL;
-	}
+    EnterCriticalSection(&This->crst);
+    setALContext(This->ctx);
 
-	*freq = device->pwfx->nSamplesPerSec;
-	TRACE("-> %d\n", *freq);
+    if(IsEqualIID(guidPropSet, &DSPROPSETID_EAX20_ListenerProperties))
+    {
+        ULONG propid = dwPropID & ~DSPROPERTY_EAXLISTENER_DEFERRED;
+        BOOL immediate = !(dwPropID&DSPROPERTY_EAXLISTENER_DEFERRED);
 
-	return DS_OK;
-}
+        if(propid == DSPROPERTY_EAXLISTENER_ENVIRONMENT)
+        {
+            DWORD idx;
 
-static HRESULT WINAPI PrimaryBufferImpl_Initialize(
-	LPDIRECTSOUNDBUFFER iface,LPDIRECTSOUND dsound,LPCDSBUFFERDESC dbsd
-) {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-	WARN("(%p) already initialized\n", This);
-	return DSERR_ALREADYINITIALIZED;
-}
+            if(cbPropData < sizeof(DWORD))
+            {
+                res = DSERR_INVALIDPARAM;
+                goto done;
+            }
+
+            idx = *(const DWORD*)pPropData;
+            if(idx >= EAX_ENVIRONMENT_COUNT)
+            {
+                res = DSERR_INVALIDPARAM;
+                goto done;
+            }
+
+            /* Get the environment index's default and pass it down to ALLPARAMETERS */
+            propid = DSPROPERTY_EAXLISTENER_ALLPARAMETERS;
+            pPropData = (void*)&EnvironmentDefaults[idx];
+            cbPropData = sizeof(EnvironmentDefaults[idx]);
+        }
+        /* FIXME: Need to validate property values... */
+        if(propid == DSPROPERTY_EAXLISTENER_ALLPARAMETERS)
+        {
+            const EAXLISTENERPROPERTIES *props;
+
+            if(This->effect == 0)
+                goto done;
+
+            if(cbPropData < sizeof(EAXLISTENERPROPERTIES))
+            {
+                res = DSERR_INVALIDPARAM;
+                goto done;
+            }
+
+            props = (const EAXLISTENERPROPERTIES*)pPropData;
+
+            This->eax_prop = *props;
+            This->ExtAL.Effectf(This->effect, AL_REVERB_GAIN, mB_to_gain(props->lRoom));
+            This->ExtAL.Effectf(This->effect, AL_REVERB_GAINHF, mB_to_gain(props->lRoomHF));
+
+            This->ExtAL.Effectf(This->effect, AL_REVERB_ROOM_ROLLOFF_FACTOR, props->flRoomRolloffFactor);
+
+            This->ExtAL.Effectf(This->effect, AL_REVERB_DECAY_TIME, props->flDecayTime);
+            This->ExtAL.Effectf(This->effect, AL_REVERB_DECAY_HFRATIO, props->flDecayHFRatio);
+
+            This->ExtAL.Effectf(This->effect, AL_REVERB_REFLECTIONS_GAIN, mB_to_gain(props->lReflections));
+            This->ExtAL.Effectf(This->effect, AL_REVERB_REFLECTIONS_DELAY, props->flReflectionsDelay);
+
+            This->ExtAL.Effectf(This->effect, AL_REVERB_LATE_REVERB_GAIN, mB_to_gain(props->lReverb));
+            This->ExtAL.Effectf(This->effect, AL_REVERB_LATE_REVERB_DELAY, props->flReverbDelay);
+
+            This->ExtAL.Effectf(This->effect, AL_REVERB_AIR_ABSORPTION_GAINHF,
+                                mB_to_gain(props->flAirAbsorptionHF));
+            This->ExtAL.Effecti(This->effect, AL_REVERB_DECAY_HFLIMIT,
+                                (props->dwFlags&EAXLISTENERFLAGS_DECAYHFLIMIT)?AL_TRUE:AL_FALSE);
+
+            getALError();
+
+            This->dirty.bit.effect = 1;
+
+            res = DS_OK;
+        }
+        else if(propid == DSPROPERTY_EAXLISTENER_ROOM)
+        {
+            if(This->effect == 0)
+                goto done;
+
+            if(cbPropData < sizeof(LONG))
+            {
+                res = DSERR_INVALIDPARAM;
+                goto done;
+            }
 
-static HRESULT WINAPI PrimaryBufferImpl_GetCaps(
-	LPDIRECTSOUNDBUFFER iface,LPDSBCAPS caps
-) {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-        DirectSoundDevice *device = This->device;
-  	TRACE("(%p,%p)\n", iface, caps);
+            This->eax_prop.lRoom = *(const LONG*)pPropData;
+            This->ExtAL.Effectf(This->effect, AL_REVERB_GAIN, mB_to_gain(This->eax_prop.lRoom));
+            getALError();
 
-	if (caps == NULL) {
-		WARN("invalid parameter: caps == NULL\n");
-		return DSERR_INVALIDPARAM;
-	}
+            This->dirty.bit.effect = 1;
 
-	if (caps->dwSize < sizeof(*caps)) {
-		WARN("invalid parameter: caps->dwSize = %d\n", caps->dwSize);
-		return DSERR_INVALIDPARAM;
-	}
+            res = DS_OK;
+        }
+        else if(propid == DSPROPERTY_EAXLISTENER_FLAGS)
+        {
+            if(This->effect == 0)
+                goto done;
+
+            if(cbPropData < sizeof(DWORD))
+            {
+                res = DSERR_INVALIDPARAM;
+                goto done;
+            }
 
-	caps->dwFlags = This->dsbd.dwFlags;
-	caps->dwBufferBytes = device->buflen;
+            This->eax_prop.dwFlags = *(const DWORD*)pPropData;
+            This->ExtAL.Effecti(This->effect, AL_REVERB_DECAY_HFLIMIT,
+                                (This->eax_prop.dwFlags&EAXLISTENERFLAGS_DECAYHFLIMIT) ?
+                                AL_TRUE : AL_FALSE);
+            getALError();
+
+            This->dirty.bit.effect = 1;
+
+            res = DS_OK;
+        }
+        else if(propid != 0)
+            FIXME("Unhandled propid: 0x%08x\n", propid);
+
+        if(res == DS_OK && immediate)
+            IDirectSound3DListener_CommitDeferredSettings(&This->IDirectSound3DListener_iface);
+    }
+    else
+        FIXME("Unhandled propset: %s\n", debugstr_guid(guidPropSet));
 
-	/* Windows reports these as zero */
-	caps->dwUnlockTransferRate = 0;
-	caps->dwPlayCpuOverhead = 0;
+done:
+    popALContext();
+    LeaveCriticalSection(&This->crst);
 
-	return DS_OK;
+    return res;
 }
 
-static HRESULT WINAPI PrimaryBufferImpl_QueryInterface(
-	LPDIRECTSOUNDBUFFER iface,REFIID riid,LPVOID *ppobj
-) {
-        IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
-        DirectSoundDevice *device = This->device;
-	TRACE("(%p,%s,%p)\n", iface, debugstr_guid(riid), ppobj);
-
-	if (ppobj == NULL) {
-		WARN("invalid parameter\n");
-		return E_INVALIDARG;
-	}
-
-	*ppobj = NULL;	/* assume failure */
-
-	if ( IsEqualGUID(riid, &IID_IUnknown) ||
-	     IsEqualGUID(riid, &IID_IDirectSoundBuffer) ) {
-		IDirectSoundBuffer_AddRef((LPDIRECTSOUNDBUFFER)This);
-		*ppobj = This;
-		return S_OK;
-	}
-
-	/* DirectSoundBuffer and DirectSoundBuffer8 are different and */
-	/* a primary buffer can't have a DirectSoundBuffer8 interface */
-	if ( IsEqualGUID( &IID_IDirectSoundBuffer8, riid ) ) {
-		WARN("app requested DirectSoundBuffer8 on primary buffer\n");
-		return E_NOINTERFACE;
-	}
-
-	if ( IsEqualGUID( &IID_IDirectSoundNotify, riid ) ) {
-		ERR("app requested IDirectSoundNotify on primary buffer\n");
-		/* FIXME: should we support this? */
-		return E_NOINTERFACE;
-	}
-
-	if ( IsEqualGUID( &IID_IDirectSound3DBuffer, riid ) ) {
-		ERR("app requested IDirectSound3DBuffer on primary buffer\n");
-		return E_NOINTERFACE;
-	}
-
-        if ( IsEqualGUID( &IID_IDirectSound3DListener, riid ) ) {
-		if (!device->listener)
-			IDirectSound3DListenerImpl_Create(device, &device->listener);
-		if (device->listener) {
-			*ppobj = device->listener;
-			IDirectSound3DListener_AddRef((LPDIRECTSOUND3DLISTENER)*ppobj);
-			return S_OK;
-		}
-
-		WARN("IID_IDirectSound3DListener failed\n");
-		return E_NOINTERFACE;
-	}
-
-	if ( IsEqualGUID( &IID_IKsPropertySet, riid ) ) {
-		FIXME("app requested IKsPropertySet on primary buffer\n");
-		return E_NOINTERFACE;
-	}
-
-	FIXME( "Unknown IID %s\n", debugstr_guid( riid ) );
-	return E_NOINTERFACE;
+static HRESULT WINAPI DS8PrimaryProp_QuerySupport(IKsPropertySet *iface, REFGUID guidPropSet,
+    ULONG dwPropID,
+    PULONG pTypeSupport)
+{
+    DS8Primary *This = impl_from_IKsPropertySet(iface);
+    HRESULT res = E_PROP_ID_UNSUPPORTED;
+
+    TRACE("(%p)->(%s, %u, %p)\n", iface, debugstr_guid(guidPropSet), dwPropID, pTypeSupport);
+
+    if(!pTypeSupport)
+        return E_POINTER;
+    *pTypeSupport = 0;
+
+    if(IsEqualIID(guidPropSet, &DSPROPSETID_EAX20_ListenerProperties))
+    {
+        if(dwPropID == DSPROPERTY_EAXLISTENER_ALLPARAMETERS ||
+           dwPropID == DSPROPERTY_EAXLISTENER_ROOM ||
+           dwPropID == DSPROPERTY_EAXLISTENER_ENVIRONMENT ||
+           dwPropID == DSPROPERTY_EAXLISTENER_FLAGS)
+        {
+            if(This->effect != 0)
+            {
+                *pTypeSupport = KSPROPERTY_SUPPORT_GET|KSPROPERTY_SUPPORT_SET;
+                res = DS_OK;
+            }
+        }
+        else
+            FIXME("Unhandled propid: 0x%08x\n", dwPropID);
+    }
+    else
+        FIXME("Unhandled propset: %s\n", debugstr_guid(guidPropSet));
+
+    return res;
 }
 
-static const IDirectSoundBufferVtbl dspbvt =
+static const IKsPropertySetVtbl DS8PrimaryProp_Vtbl =
 {
-	PrimaryBufferImpl_QueryInterface,
-	PrimaryBufferImpl_AddRef,
-	PrimaryBufferImpl_Release,
-	PrimaryBufferImpl_GetCaps,
-	PrimaryBufferImpl_GetCurrentPosition,
-	PrimaryBufferImpl_GetFormat,
-	PrimaryBufferImpl_GetVolume,
-	PrimaryBufferImpl_GetPan,
-        PrimaryBufferImpl_GetFrequency,
-	PrimaryBufferImpl_GetStatus,
-	PrimaryBufferImpl_Initialize,
-	PrimaryBufferImpl_Lock,
-	PrimaryBufferImpl_Play,
-	PrimaryBufferImpl_SetCurrentPosition,
-	PrimaryBufferImpl_SetFormat,
-	PrimaryBufferImpl_SetVolume,
-	PrimaryBufferImpl_SetPan,
-	PrimaryBufferImpl_SetFrequency,
-	PrimaryBufferImpl_Stop,
-	PrimaryBufferImpl_Unlock,
-	PrimaryBufferImpl_Restore
+    DS8PrimaryProp_QueryInterface,
+    DS8PrimaryProp_AddRef,
+    DS8PrimaryProp_Release,
+    DS8PrimaryProp_Get,
+    DS8PrimaryProp_Set,
+    DS8PrimaryProp_QuerySupport
 };
 
-HRESULT primarybuffer_create(DirectSoundDevice *device, IDirectSoundBufferImpl **ppdsb,
-	const DSBUFFERDESC *dsbd)
-{
-	IDirectSoundBufferImpl *dsb;
-	TRACE("%p,%p,%p)\n",device,ppdsb,dsbd);
-
-	if (dsbd->lpwfxFormat) {
-		WARN("invalid parameter: dsbd->lpwfxFormat != NULL\n");
-		*ppdsb = NULL;
-		return DSERR_INVALIDPARAM;
-	}
-
-	dsb = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(*dsb));
-
-	if (dsb == NULL) {
-		WARN("out of memory\n");
-		*ppdsb = NULL;
-		return DSERR_OUTOFMEMORY;
-	}
-
-        dsb->ref = 1;
-        dsb->numIfaces = 1;
-	dsb->device = device;
-	dsb->IDirectSoundBuffer8_iface.lpVtbl = (IDirectSoundBuffer8Vtbl *)&dspbvt;
-	dsb->dsbd = *dsbd;
-
-	TRACE("Created primary buffer at %p\n", dsb);
-	TRACE("(formattag=0x%04x,chans=%d,samplerate=%d,"
-		"bytespersec=%d,blockalign=%d,bitspersamp=%d,cbSize=%d)\n",
-		device->pwfx->wFormatTag, device->pwfx->nChannels,
-                device->pwfx->nSamplesPerSec, device->pwfx->nAvgBytesPerSec,
-                device->pwfx->nBlockAlign, device->pwfx->wBitsPerSample,
-                device->pwfx->cbSize);
-
-	*ppdsb = dsb;
-	return S_OK;
-}
+#endif /*HAVE_OPENAL*/
diff --git a/dlls/dsound/propset.c b/dlls/dsound/propset.c
index e2d0e20..f7d04bb 100644
--- a/dlls/dsound/propset.c
+++ b/dlls/dsound/propset.c
@@ -117,17 +117,19 @@ static HRESULT DSPROPERTY_WaveDeviceMappingW(
     }
 
     if (ppd->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_RENDER) {
-        ULONG wod;
-        unsigned int wodn;
-        TRACE("DataFlow=DIRECTSOUNDDEVICE_DATAFLOW_RENDER\n");
+        DWORD_PTR len;
+        WCHAR *data;
+        MMRESULT res;
+        ULONG wod, wodn;
+        IMMDevice *dev = NULL;
+        TRACE("DataFlow=DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE\n");
+
         wodn = waveOutGetNumDevs();
         for (wod = 0; wod < wodn; wod++) {
             WAVEOUTCAPSW capsW;
-            MMRESULT res;
             res = waveOutGetDevCapsW(wod, &capsW, sizeof(capsW));
             if (res == MMSYSERR_NOERROR) {
                 if (lstrcmpW(capsW.szPname, ppd->DeviceName) == 0) {
-                    ppd->DeviceId = DSOUND_renderer_guids[wod];
                     hr = DS_OK;
                     TRACE("found %s for %s\n", debugstr_guid(&ppd->DeviceId),
                           debugstr_w(ppd->DeviceName));
@@ -135,18 +137,37 @@ static HRESULT DSPROPERTY_WaveDeviceMappingW(
                 }
             }
         }
+        res = waveOutMessage(UlongToHandle(wod),DRV_QUERYFUNCTIONINSTANCEIDSIZE,(DWORD_PTR)&len,0);
+        if (res == MMSYSERR_NOTSUPPORTED)
+        {
+            FIXME("No matching winmm device found, assuming winmm doesn't support mmdevapi and falling back to first device\n");
+            ppd->DeviceId = DSDEVID_DefaultPlayback;
+            goto out;
+        }
+        data = HeapAlloc(GetProcessHeap(), 0, len);
+        if (!data)
+            hr = E_OUTOFMEMORY;
+        else
+            waveOutMessage(UlongToHandle(wod),DRV_QUERYFUNCTIONINSTANCEID,(DWORD_PTR)data, len);
+        if (SUCCEEDED(hr))
+            hr = IMMDeviceEnumerator_GetDevice(DSOUND_obtain_mme(), data, &dev);
+        if (SUCCEEDED(hr))
+            hr = DSOUND_immdevice_getguid(dev, &ppd->DeviceId);
+        HeapFree(GetProcessHeap(), 0, data);
     } else if (ppd->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE) {
-        ULONG wid;
-        unsigned int widn;
+        DWORD_PTR len;
+        WCHAR *data;
+        MMRESULT res;
+        ULONG wid, widn;
+        IMMDevice *dev = NULL;
         TRACE("DataFlow=DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE\n");
+
         widn = waveInGetNumDevs();
         for (wid = 0; wid < widn; wid++) {
             WAVEINCAPSW capsW;
-            MMRESULT res;
             res = waveInGetDevCapsW(wid, &capsW, sizeof(capsW));
             if (res == MMSYSERR_NOERROR) {
                 if (lstrcmpW(capsW.szPname, ppd->DeviceName) == 0) {
-                    ppd->DeviceId = DSOUND_capture_guids[wid];
                     hr = DS_OK;
                     TRACE("found %s for %s\n", debugstr_guid(&ppd->DeviceId),
                           debugstr_w(ppd->DeviceName));
@@ -154,8 +175,26 @@ static HRESULT DSPROPERTY_WaveDeviceMappingW(
                 }
             }
         }
+        res = waveInMessage(UlongToHandle(wid),DRV_QUERYFUNCTIONINSTANCEIDSIZE,(DWORD_PTR)&len,0);
+        if (res == MMSYSERR_NOTSUPPORTED)
+        {
+            FIXME("No matching winmm device found, assuming winmm doesn't support mmdevapi and falling back to first device\n");
+            ppd->DeviceId = DSDEVID_DefaultCapture;
+            goto out;
+        }
+        data = HeapAlloc(GetProcessHeap(), 0, len);
+        if (!data)
+            hr = E_OUTOFMEMORY;
+        else
+            waveInMessage(UlongToHandle(wid),DRV_QUERYFUNCTIONINSTANCEID,(DWORD_PTR)data, len);
+        if (SUCCEEDED(hr))
+            hr = IMMDeviceEnumerator_GetDevice(DSOUND_obtain_mme(), data, &dev);
+        if (SUCCEEDED(hr))
+            hr = DSOUND_immdevice_getguid(dev, &ppd->DeviceId);
+        HeapFree(GetProcessHeap(), 0, data);
     }
 
+out:
     if (pcbReturned)
         *pcbReturned = cbPropData;
 
@@ -205,8 +244,9 @@ static HRESULT DSPROPERTY_DescriptionW(
     PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA ppd = pPropData;
     HRESULT err;
     GUID dev_guid;
-    ULONG wod, wid, wodn, widn;
+    ULONG wodn, widn;
     DSDRIVERDESC desc;
+    HRESULT hr;
 
     TRACE("pPropData=%p,cbPropData=%d,pcbReturned=%p)\n",
           pPropData,cbPropData,pcbReturned);
@@ -226,35 +266,92 @@ static HRESULT DSPROPERTY_DescriptionW(
         }
     }
 
-    setup_dsound_options();
-
     GetDeviceID(&ppd->DeviceId, &dev_guid);
 
     wodn = waveOutGetNumDevs();
     widn = waveInGetNumDevs();
-    wid = wod = dev_guid.Data4[7];
-    if (!memcmp(&dev_guid, &DSOUND_renderer_guids[0], sizeof(GUID)-1)
-        && wod < wodn)
     {
-        ppd->DataFlow = DIRECTSOUNDDEVICE_DATAFLOW_RENDER;
-        ppd->WaveDeviceId = wod;
-    }
-    else if (!memcmp(&dev_guid, &DSOUND_capture_guids[0], sizeof(GUID)-1)
-             && wid < widn)
-    {
-        ppd->DataFlow = DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE;
-        ppd->WaveDeviceId = wid;
-    }
-    else
-    {
-        WARN("Device not found\n");
-        return E_PROP_ID_UNSUPPORTED;
+        IMMDeviceCollection *col = NULL;
+        IMMDevice *dev;
+        IMMEndpoint *endpoint = 0;
+        MMRESULT res;
+        EDataFlow flow;
+        WCHAR *str, *str2;
+        DWORD len = 0, len2;
+        GUID guid;
+        int i = 0;
+        static int once;
+
+        hr = DSOUND_enumerate_immdevice(eAll, &col);
+        if (FAILED(hr))
+            return hr;
+        while (IMMDeviceCollection_Item(col, i++, &dev) == S_OK)
+        {
+            DSOUND_immdevice_getguid(dev, &guid);
+            if (IsEqualGUID(&guid, &dev_guid))
+                break;
+            IMMDevice_Release(dev);
+            dev = NULL;
+        }
+        IMMDeviceCollection_Release(col);
+        if (!dev)
+            return E_PROP_ID_UNSUPPORTED;
+        IUnknown_QueryInterface(dev, &IID_IMMEndpoint, (void**)&endpoint);
+        IMMEndpoint_GetDataFlow(endpoint, &flow);
+        IUnknown_Release(endpoint);
+        ppd->DataFlow = flow == eCapture ? DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE : DIRECTSOUNDDEVICE_DATAFLOW_RENDER;
+        IMMDevice_GetId(dev, &str);
+        IMMDevice_Release(dev);
+        len = (lstrlenW(str) + 1)*sizeof(WCHAR);
+        str2 = HeapAlloc(GetProcessHeap(), 0, len);
+
+        if (flow == eCapture)
+        {
+            for (i = 0; i < widn; ++i)
+            {
+                res = waveInMessage(UlongToHandle(i),DRV_QUERYFUNCTIONINSTANCEIDSIZE,(DWORD_PTR)&len2,0);
+                if (res != MMSYSERR_NOERROR || len2 != len)
+                    continue;
+                waveInMessage(UlongToHandle(i),DRV_QUERYFUNCTIONINSTANCEID,(DWORD_PTR)str2, len2);
+                if (!lstrcmpW(str2, str))
+                    break;
+            }
+            if (i == widn)
+            {
+                if (!once++)
+                    FIXME("No matching winmm device found, assuming winmm doesn't support mmdevapi and falling back to first device\n");
+                else
+                    TRACE("No matching winmm device found, assuming winmm doesn't support mmdevapi and falling back to first device\n");
+                i = 0;
+            }
+        } else {
+            for (i = 0; i < wodn; ++i)
+            {
+                res = waveOutMessage(UlongToHandle(i),DRV_QUERYFUNCTIONINSTANCEIDSIZE,(DWORD_PTR)&len2,0);
+                if (res != MMSYSERR_NOERROR || len2 != len)
+                    continue;
+                waveOutMessage(UlongToHandle(i),DRV_QUERYFUNCTIONINSTANCEID,(DWORD_PTR)str2, len2);
+                if (!lstrcmpW(str2, str))
+                    break;
+            }
+            if (i == wodn)
+            {
+                if (!once++)
+                    FIXME("No matching winmm device found, assuming winmm doesn't support mmdevapi and falling back to first device\n");
+                else
+                    TRACE("No matching winmm device found, assuming winmm doesn't support mmdevapi and falling back to first device\n");
+                i = 0;
+            }
+        }
+        ppd->WaveDeviceId = i;
+        HeapFree(GetProcessHeap(), 0, str);
+        CoTaskMemFree(str2);
     }
 
     if (ppd->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_RENDER)
-        err = waveOutMessage(UlongToHandle(wod),DRV_QUERYDSOUNDDESC,(DWORD_PTR)&desc,ds_hw_accel);
+        err = waveOutMessage(UlongToHandle(ppd->WaveDeviceId),DRV_QUERYDSOUNDDESC,(DWORD_PTR)&desc,0);
     else
-        err = waveInMessage(UlongToHandle(wod),DRV_QUERYDSOUNDDESC,(DWORD_PTR)&desc,ds_hw_accel);
+        err = waveInMessage(UlongToHandle(ppd->WaveDeviceId),DRV_QUERYDSOUNDDESC,(DWORD_PTR)&desc,0);
 
     if (err != MMSYSERR_NOERROR)
     {
@@ -295,15 +392,32 @@ static HRESULT DSPROPERTY_DescriptionW(
     return S_OK;
 }
 
+struct extended_enumerate_data {
+    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA *ppd;
+    BOOL cont;
+};
+
+static BOOL CALLBACK enumerate_callback(GUID *guid, const WCHAR *desc, const WCHAR *module, void *ctx)
+{
+    struct extended_enumerate_data *enumdata = ctx;
+    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA data;
+
+    if (!guid)
+        return 1;
+
+    data.DeviceId = *guid;
+    DSPROPERTY_DescriptionW(&data, sizeof(data), NULL);
+    enumdata->cont = enumdata->ppd->Callback(&data, enumdata->ppd->Context);
+    return enumdata->cont;
+}
+
 static HRESULT DSPROPERTY_EnumerateW(
     LPVOID pPropData,
     ULONG cbPropData,
     PULONG pcbReturned )
 {
+    struct extended_enumerate_data data;
     PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA ppd = pPropData;
-    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA data;
-    BOOL ret;
-    int widn, wodn, i;
     TRACE("(pPropData=%p,cbPropData=%d,pcbReturned=%p)\n",
           pPropData,cbPropData,pcbReturned);
 
@@ -316,44 +430,11 @@ static HRESULT DSPROPERTY_EnumerateW(
         return E_PROP_ID_UNSUPPORTED;
     }
 
-    wodn = waveOutGetNumDevs();
-    widn = waveInGetNumDevs();
-
-    data.DeviceId = DSOUND_renderer_guids[0];
-    for (i = 0; i < wodn; ++i)
-    {
-        HRESULT hr;
-        data.DeviceId.Data4[7] = i;
-        hr = DSPROPERTY_DescriptionW(&data, sizeof(data), NULL);
-        if (FAILED(hr))
-        {
-            ERR("DescriptionW failed!\n");
-            return S_OK;
-        }
-        ret = ppd->Callback(&data, ppd->Context);
-        HeapFree(GetProcessHeap(), 0, data.Module);
-        HeapFree(GetProcessHeap(), 0, data.Description);
-        if (!ret)
-            return S_OK;
-    }
-
-    data.DeviceId = DSOUND_capture_guids[0];
-    for (i = 0; i < widn; ++i)
-    {
-        HRESULT hr;
-        data.DeviceId.Data4[7] = i;
-        hr = DSPROPERTY_DescriptionW(&data, sizeof(data), NULL);
-        if (FAILED(hr))
-        {
-            ERR("DescriptionW failed!\n");
-            return S_OK;
-        }
-        ret = ppd->Callback(&data, ppd->Context);
-        HeapFree(GetProcessHeap(), 0, data.Module);
-        HeapFree(GetProcessHeap(), 0, data.Description);
-        if (!ret)
-            return S_OK;
-    }
+    data.ppd = ppd;
+    data.cont = TRUE;
+    DirectSoundEnumerateW(enumerate_callback, &data);
+    if (data.cont)
+        DirectSoundCaptureEnumerateW(enumerate_callback, &data);
     return S_OK;
 }
 
diff --git a/dlls/dsound/sound3d.c b/dlls/dsound/sound3d.c
deleted file mode 100644
index e64cd43..0000000
--- a/dlls/dsound/sound3d.c
+++ /dev/null
@@ -1,1089 +0,0 @@
-/*  			DirectSound
- *
- * Copyright 1998 Marcus Meissner
- * Copyright 1998 Rob Riggs
- * Copyright 2000-2001 TransGaming Technologies, Inc.
- * Copyright 2002-2003 Rok Mandeljc <rok.mandeljc@gimb.org>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-/*
- * Most thread locking is complete. There may be a few race
- * conditions still lurking.
- *
- * Tested with a Soundblaster clone, a Gravis UltraSound Classic,
- * and a Turtle Beach Tropez+.
- *
- * TODO:
- *	Implement SetCooperativeLevel properly (need to address focus issues)
- *	Implement DirectSound3DBuffers (stubs in place)
- *	Use hardware 3D support if available
- *      Add critical section locking inside Release and AddRef methods
- *      Handle static buffers - put those in hardware, non-static not in hardware
- *      Hardware DuplicateSoundBuffer
- *      Proper volume calculation, and setting volume in HEL primary buffer
- *      Optimize WINMM and negotiate fragment size, decrease DS_HEL_MARGIN
- */
-
-#include <stdarg.h>
-#include <math.h>	/* Insomnia - pow() function */
-
-#define NONAMELESSUNION
-#define NONAMELESSSTRUCT
-#include "windef.h"
-#include "winbase.h"
-#include "winuser.h"
-#include "mmsystem.h"
-#include "winternl.h"
-#include "mmddk.h"
-#include "wine/debug.h"
-#include "dsound.h"
-#include "dsdriver.h"
-#include "dsound_private.h"
-
-/* default velocity of sound in the air */
-#define DEFAULT_VELOCITY 340
-
-WINE_DEFAULT_DEBUG_CHANNEL(dsound3d);
-
-/*******************************************************************************
- *              Auxiliary functions
- */
-
-/* scalar product (I believe it's called dot product in English) */
-static inline D3DVALUE ScalarProduct (const D3DVECTOR *a, const D3DVECTOR *b)
-{
-	D3DVALUE c;
-	c = (a->x*b->x) + (a->y*b->y) + (a->z*b->z);
-	TRACE("(%f,%f,%f) * (%f,%f,%f) = %f)\n", a->x, a->y, a->z, b->x, b->y,
-	      b->z, c);
-	return c;
-}
-
-/* vector product (I believe it's called cross product in English */
-static inline D3DVECTOR VectorProduct (const D3DVECTOR *a, const D3DVECTOR *b)
-{
-	D3DVECTOR c;
-	c.x = (a->y*b->z) - (a->z*b->y);
-	c.y = (a->z*b->x) - (a->x*b->z);
-	c.z = (a->x*b->y) - (a->y*b->x);
-	TRACE("(%f,%f,%f) x (%f,%f,%f) = (%f,%f,%f)\n", a->x, a->y, a->z, b->x, b->y,
-	      b->z, c.x, c.y, c.z);
-	return c;
-}
-
-/* magnitude (length) of vector */
-static inline D3DVALUE VectorMagnitude (const D3DVECTOR *a)
-{
-	D3DVALUE l;
-	l = sqrt (ScalarProduct (a, a));
-	TRACE("|(%f,%f,%f)| = %f\n", a->x, a->y, a->z, l);
-	return l;
-}
-
-/* conversion between radians and degrees */
-static inline D3DVALUE RadToDeg (D3DVALUE angle)
-{
-	D3DVALUE newangle;
-	newangle = angle * (360/(2*M_PI));
-	TRACE("%f rad = %f deg\n", angle, newangle);
-	return newangle;
-}
-
-/* angle between vectors - rad version */
-static inline D3DVALUE AngleBetweenVectorsRad (const D3DVECTOR *a, const D3DVECTOR *b)
-{
-	D3DVALUE la, lb, product, angle, cos;
-	/* definition of scalar product: a*b = |a|*|b|*cos... therefore: */
-	product = ScalarProduct (a,b);
-	la = VectorMagnitude (a);
-	lb = VectorMagnitude (b);
-	if (!la || !lb)
-		return 0;
-
-	cos = product/(la*lb);
-	angle = acos(cos);
-	TRACE("angle between (%f,%f,%f) and (%f,%f,%f) = %f radians (%f degrees)\n",  a->x, a->y, a->z, b->x,
-	      b->y, b->z, angle, RadToDeg(angle));
-	return angle;	
-}
-
-static inline D3DVALUE AngleBetweenVectorsDeg (const D3DVECTOR *a, const D3DVECTOR *b)
-{
-	return RadToDeg(AngleBetweenVectorsRad(a, b));
-}
-
-/* calculates vector between two points */
-static inline D3DVECTOR VectorBetweenTwoPoints (const D3DVECTOR *a, const D3DVECTOR *b)
-{
-	D3DVECTOR c;
-	c.x = b->x - a->x;
-	c.y = b->y - a->y;
-	c.z = b->z - a->z;
-	TRACE("A (%f,%f,%f), B (%f,%f,%f), AB = (%f,%f,%f)\n", a->x, a->y, a->z, b->x, b->y,
-	      b->z, c.x, c.y, c.z);
-	return c;
-}
-
-/* calculates the length of vector's projection on another vector */
-static inline D3DVALUE ProjectVector (const D3DVECTOR *a, const D3DVECTOR *p)
-{
-	D3DVALUE prod, result;
-	prod = ScalarProduct(a, p);
-	result = prod/VectorMagnitude(p);
-	TRACE("length projection of (%f,%f,%f) on (%f,%f,%f) = %f\n", a->x, a->y, a->z, p->x,
-              p->y, p->z, result);
-	return result;
-}
-
-/*******************************************************************************
- *              3D Buffer and Listener mixing
- */
-
-void DSOUND_Calc3DBuffer(IDirectSoundBufferImpl *dsb)
-{
-	/* volume, at which the sound will be played after all calcs. */
-	D3DVALUE lVolume = 0;
-	/* stuff for distance related stuff calc. */
-	D3DVECTOR vDistance;
-	D3DVALUE flDistance = 0;
-	/* panning related stuff */
-	D3DVALUE flAngle;
-	D3DVECTOR vLeft;
-	/* doppler shift related stuff */
-#if 0
-	D3DVALUE flFreq, flBufferVel, flListenerVel;
-#endif
-
-	TRACE("(%p)\n",dsb);
-
-	/* initial buffer volume */
-	lVolume = dsb->ds3db_lVolume;
-	
-	switch (dsb->ds3db_ds3db.dwMode)
-	{
-		case DS3DMODE_DISABLE:
-			TRACE("3D processing disabled\n");
-			/* this one is here only to eliminate annoying warning message */
-			DSOUND_RecalcVolPan (&dsb->volpan);
-			break;
-		case DS3DMODE_NORMAL:
-			TRACE("Normal 3D processing mode\n");
-			/* we need to calculate distance between buffer and listener*/
-			vDistance = VectorBetweenTwoPoints(&dsb->ds3db_ds3db.vPosition, &dsb->device->ds3dl.vPosition);
-			flDistance = VectorMagnitude (&vDistance);
-			break;
-		case DS3DMODE_HEADRELATIVE:
-			TRACE("Head-relative 3D processing mode\n");
-			/* distance between buffer and listener is same as buffer's position */
-			flDistance = VectorMagnitude (&dsb->ds3db_ds3db.vPosition);
-			break;
-	}
-	
-	if (flDistance > dsb->ds3db_ds3db.flMaxDistance)
-	{
-		/* some apps don't want you to hear too distant sounds... */
-		if (dsb->dsbd.dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE)
-		{
-			dsb->volpan.lVolume = DSBVOLUME_MIN;
-			DSOUND_RecalcVolPan (&dsb->volpan);		
-			/* i guess mixing here would be a waste of power */
-			return;
-		}
-		else
-			flDistance = dsb->ds3db_ds3db.flMaxDistance;
-	}		
-
-	if (flDistance < dsb->ds3db_ds3db.flMinDistance)
-		flDistance = dsb->ds3db_ds3db.flMinDistance;
-	
-	/* attenuation proportional to the distance squared, converted to millibels as in lVolume*/
-	lVolume -= log10(flDistance/dsb->ds3db_ds3db.flMinDistance * flDistance/dsb->ds3db_ds3db.flMinDistance)*1000;
-	TRACE("dist. att: Distance = %f, MinDistance = %f => adjusting volume %d to %f\n", flDistance, dsb->ds3db_ds3db.flMinDistance, dsb->ds3db_lVolume, lVolume);
-
-	/* conning */
-	/* sometimes it happens that vConeOrientation vector = (0,0,0); in this case angle is "nan" and it's useless*/
-	if (dsb->ds3db_ds3db.vConeOrientation.x == 0 && dsb->ds3db_ds3db.vConeOrientation.y == 0 && dsb->ds3db_ds3db.vConeOrientation.z == 0)
-	{
-		TRACE("conning: cones not set\n");
-	}
-	else
-	{
-		/* calculate angle */
-		flAngle = AngleBetweenVectorsDeg(&dsb->ds3db_ds3db.vConeOrientation, &vDistance);
-		/* if by any chance it happens that OutsideConeAngle = InsideConeAngle (that means that conning has no effect) */
-		if (dsb->ds3db_ds3db.dwInsideConeAngle != dsb->ds3db_ds3db.dwOutsideConeAngle)
-		{
-			/* my test show that for my way of calc., we need only half of angles */
-			DWORD dwInsideConeAngle = dsb->ds3db_ds3db.dwInsideConeAngle/2;
-			DWORD dwOutsideConeAngle = dsb->ds3db_ds3db.dwOutsideConeAngle/2;
-			if (dwOutsideConeAngle == dwInsideConeAngle)
-				++dwOutsideConeAngle;
-
-			/* full volume */
-			if (flAngle < dwInsideConeAngle)
-				flAngle = dwInsideConeAngle;
-			/* min (app defined) volume */
-			if (flAngle > dwOutsideConeAngle)
-				flAngle = dwOutsideConeAngle;
-			/* this probably isn't the right thing, but it's ok for the time being */
-			lVolume += ((dsb->ds3db_ds3db.lConeOutsideVolume)/((dwOutsideConeAngle) - (dwInsideConeAngle))) * flAngle;
-		}
-		TRACE("conning: Angle = %f deg; InsideConeAngle(/2) = %d deg; OutsideConeAngle(/2) = %d deg; ConeOutsideVolume = %d => adjusting volume to %f\n",
-		       flAngle, dsb->ds3db_ds3db.dwInsideConeAngle/2, dsb->ds3db_ds3db.dwOutsideConeAngle/2, dsb->ds3db_ds3db.lConeOutsideVolume, lVolume);
-	}
-	dsb->volpan.lVolume = lVolume;
-	
-	/* panning */
-	if (dsb->device->ds3dl.vPosition.x == dsb->ds3db_ds3db.vPosition.x &&
-	    dsb->device->ds3dl.vPosition.y == dsb->ds3db_ds3db.vPosition.y &&
-	    dsb->device->ds3dl.vPosition.z == dsb->ds3db_ds3db.vPosition.z) {
-		dsb->volpan.lPan = 0;
-		flAngle = 0.0;
-	}
-	else
-	{
-		vDistance = VectorBetweenTwoPoints(&dsb->device->ds3dl.vPosition, &dsb->ds3db_ds3db.vPosition);
-		vLeft = VectorProduct(&dsb->device->ds3dl.vOrientFront, &dsb->device->ds3dl.vOrientTop);
-		flAngle = AngleBetweenVectorsRad(&vLeft, &vDistance);
-		/* for now, we'll use "linear formula" (which is probably incorrect); if someone has it in book, correct it */
-		dsb->volpan.lPan = 10000*2*flAngle/M_PI - 10000;
-	}
-	TRACE("panning: Angle = %f rad, lPan = %d\n", flAngle, dsb->volpan.lPan);
-
-	/* FIXME: Doppler Effect disabled since i have no idea which frequency to change and how to do it */
-#if 0	
-	/* doppler shift*/
-	if ((VectorMagnitude(&ds3db_ds3db.vVelocity) == 0) && (VectorMagnitude(&dsb->device->ds3dl.vVelocity) == 0))
-	{
-		TRACE("doppler: Buffer and Listener don't have velocities\n");
-	}
-	else if (ds3db_ds3db.vVelocity != dsb->device->ds3dl.vVelocity)
-	{
-		/* calculate length of ds3db_ds3db.vVelocity component which causes Doppler Effect
-		   NOTE: if buffer moves TOWARDS the listener, it's velocity component is NEGATIVE
-		         if buffer moves AWAY from listener, it's velocity component is POSITIVE */
-		flBufferVel = ProjectVector(&dsb->ds3db_ds3db.vVelocity, &vDistance);
-		/* calculate length of ds3dl.vVelocity component which causes Doppler Effect
-		   NOTE: if listener moves TOWARDS the buffer, it's velocity component is POSITIVE
-		         if listener moves AWAY from buffer, it's velocity component is NEGATIVE */
-		flListenerVel = ProjectVector(&dsb->device->ds3dl.vVelocity, &vDistance);
-		/* formula taken from Gianicoli D.: Physics, 4th edition: */
-		/* FIXME: replace dsb->freq with appropriate frequency ! */
-		flFreq = dsb->freq * ((DEFAULT_VELOCITY + flListenerVel)/(DEFAULT_VELOCITY + flBufferVel));
-		TRACE("doppler: Buffer velocity (component) = %lf, Listener velocity (component) = %lf => Doppler shift: %ld Hz -> %lf Hz\n", flBufferVel, flListenerVel,
-		      dsb->freq, flFreq);
-		/* FIXME: replace following line with correct frequency setting ! */
-		dsb->freq = flFreq;
-		DSOUND_RecalcFormat(dsb);
-		DSOUND_MixToTemporary(dsb, 0, dsb->buflen);
-	}
-#endif	
-	
-	/* time for remix */
-	DSOUND_RecalcVolPan(&dsb->volpan);
-}
-
-static void DSOUND_Mix3DBuffer(IDirectSoundBufferImpl *dsb)
-{
-	TRACE("(%p)\n",dsb);
-
-	DSOUND_Calc3DBuffer(dsb);
-}
-
-static void DSOUND_ChangeListener(IDirectSound3DListenerImpl *ds3dl)
-{
-	int i;
-	TRACE("(%p)\n",ds3dl);
-	for (i = 0; i < ds3dl->device->nrofbuffers; i++)
-	{
-		/* check if this buffer is waiting for recalculation */
-		if (ds3dl->device->buffers[i]->ds3db_need_recalc)
-		{
-			DSOUND_Mix3DBuffer(ds3dl->device->buffers[i]);
-		}
-	}
-}
-
-/*******************************************************************************
- *              IDirectSound3DBuffer
- */
-
-/* IUnknown methods */
-static HRESULT WINAPI IDirectSound3DBufferImpl_QueryInterface(
-	LPDIRECTSOUND3DBUFFER iface, REFIID riid, LPVOID *ppobj)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-
-	TRACE("(%p,%s,%p)\n",This,debugstr_guid(riid),ppobj);
-	return IDirectSoundBuffer_QueryInterface((LPDIRECTSOUNDBUFFER8)This->dsb, riid, ppobj);
-}
-
-static ULONG WINAPI IDirectSound3DBufferImpl_AddRef(LPDIRECTSOUND3DBUFFER iface)
-{
-    IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-    ULONG ref = InterlockedIncrement(&(This->ref));
-
-    TRACE("(%p) ref was %d\n", This, ref - 1);
-
-    if(ref == 1)
-        InterlockedIncrement(&This->dsb->numIfaces);
-
-    return ref;
-}
-
-static ULONG WINAPI IDirectSound3DBufferImpl_Release(LPDIRECTSOUND3DBUFFER iface)
-{
-    IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-    ULONG ref = InterlockedDecrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref + 1);
-
-    if (!ref) {
-        This->dsb->ds3db = NULL;
-        if (!InterlockedDecrement(&This->dsb->numIfaces))
-            secondarybuffer_destroy(This->dsb);
-        HeapFree(GetProcessHeap(), 0, This);
-        TRACE("(%p) released\n", This);
-    }
-    return ref;
-}
-
-/* IDirectSound3DBuffer methods */
-static HRESULT WINAPI IDirectSound3DBufferImpl_GetAllParameters(
-	LPDIRECTSOUND3DBUFFER iface,
-	LPDS3DBUFFER lpDs3dBuffer)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("(%p,%p)\n",This,lpDs3dBuffer);
-
-	if (lpDs3dBuffer == NULL) {
-		WARN("invalid parameter: lpDs3dBuffer == NULL\n");
-		return DSERR_INVALIDPARAM;
-	}
-
-	if (lpDs3dBuffer->dwSize < sizeof(*lpDs3dBuffer)) {
-		WARN("invalid parameter: lpDs3dBuffer->dwSize = %d\n",lpDs3dBuffer->dwSize);
-		return DSERR_INVALIDPARAM;
-	}
-	
-	TRACE("returning: all parameters\n");
-	*lpDs3dBuffer = This->dsb->ds3db_ds3db;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_GetConeAngles(
-	LPDIRECTSOUND3DBUFFER iface,
-	LPDWORD lpdwInsideConeAngle,
-	LPDWORD lpdwOutsideConeAngle)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("returning: Inside Cone Angle = %d degrees; Outside Cone Angle = %d degrees\n",
-		This->dsb->ds3db_ds3db.dwInsideConeAngle, This->dsb->ds3db_ds3db.dwOutsideConeAngle);
-	*lpdwInsideConeAngle = This->dsb->ds3db_ds3db.dwInsideConeAngle;
-	*lpdwOutsideConeAngle = This->dsb->ds3db_ds3db.dwOutsideConeAngle;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_GetConeOrientation(
-	LPDIRECTSOUND3DBUFFER iface,
-	LPD3DVECTOR lpvConeOrientation)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("returning: Cone Orientation vector = (%f,%f,%f)\n",
-		This->dsb->ds3db_ds3db.vConeOrientation.x,
-		This->dsb->ds3db_ds3db.vConeOrientation.y,
-		This->dsb->ds3db_ds3db.vConeOrientation.z);
-	*lpvConeOrientation = This->dsb->ds3db_ds3db.vConeOrientation;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_GetConeOutsideVolume(
-	LPDIRECTSOUND3DBUFFER iface,
-	LPLONG lplConeOutsideVolume)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("returning: Cone Outside Volume = %d\n", This->dsb->ds3db_ds3db.lConeOutsideVolume);
-	*lplConeOutsideVolume = This->dsb->ds3db_ds3db.lConeOutsideVolume;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_GetMaxDistance(
-	LPDIRECTSOUND3DBUFFER iface,
-	LPD3DVALUE lpfMaxDistance)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("returning: Max Distance = %f\n", This->dsb->ds3db_ds3db.flMaxDistance);
-	*lpfMaxDistance = This->dsb->ds3db_ds3db.flMaxDistance;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_GetMinDistance(
-	LPDIRECTSOUND3DBUFFER iface,
-	LPD3DVALUE lpfMinDistance)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("returning: Min Distance = %f\n", This->dsb->ds3db_ds3db.flMinDistance);
-	*lpfMinDistance = This->dsb->ds3db_ds3db.flMinDistance;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_GetMode(
-	LPDIRECTSOUND3DBUFFER iface,
-	LPDWORD lpdwMode)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("returning: Mode = %d\n", This->dsb->ds3db_ds3db.dwMode);
-	*lpdwMode = This->dsb->ds3db_ds3db.dwMode;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_GetPosition(
-	LPDIRECTSOUND3DBUFFER iface,
-	LPD3DVECTOR lpvPosition)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("returning: Position vector = (%f,%f,%f)\n",
-		This->dsb->ds3db_ds3db.vPosition.x,
-		This->dsb->ds3db_ds3db.vPosition.y,
-		This->dsb->ds3db_ds3db.vPosition.z);
-	*lpvPosition = This->dsb->ds3db_ds3db.vPosition;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_GetVelocity(
-	LPDIRECTSOUND3DBUFFER iface,
-	LPD3DVECTOR lpvVelocity)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("returning: Velocity vector = (%f,%f,%f)\n",
-		This->dsb->ds3db_ds3db.vVelocity.x,
-		This->dsb->ds3db_ds3db.vVelocity.y,
-		This->dsb->ds3db_ds3db.vVelocity.z);
-	*lpvVelocity = This->dsb->ds3db_ds3db.vVelocity;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_SetAllParameters(
-	LPDIRECTSOUND3DBUFFER iface,
-	LPCDS3DBUFFER lpcDs3dBuffer,
-	DWORD dwApply)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	DWORD status = DSERR_INVALIDPARAM;
-	TRACE("(%p,%p,%x)\n",iface,lpcDs3dBuffer,dwApply);
-
-	if (lpcDs3dBuffer == NULL) {
-		WARN("invalid parameter: lpcDs3dBuffer == NULL\n");
-		return status;
-	}
-
-	if (lpcDs3dBuffer->dwSize != sizeof(DS3DBUFFER)) {
-		WARN("invalid parameter: lpcDs3dBuffer->dwSize = %d\n", lpcDs3dBuffer->dwSize);
-		return status;
-	}
-
-	TRACE("setting: all parameters; dwApply = %d\n", dwApply);
-	This->dsb->ds3db_ds3db = *lpcDs3dBuffer;
-
-	if (dwApply == DS3D_IMMEDIATE)
-	{
-		DSOUND_Mix3DBuffer(This->dsb);
-	}
-	This->dsb->ds3db_need_recalc = TRUE;
-	status = DS_OK;
-
-	return status;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_SetConeAngles(
-	LPDIRECTSOUND3DBUFFER iface,
-	DWORD dwInsideConeAngle,
-	DWORD dwOutsideConeAngle,
-	DWORD dwApply)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("setting: Inside Cone Angle = %d; Outside Cone Angle = %d; dwApply = %d\n",
-		dwInsideConeAngle, dwOutsideConeAngle, dwApply);
-	This->dsb->ds3db_ds3db.dwInsideConeAngle = dwInsideConeAngle;
-	This->dsb->ds3db_ds3db.dwOutsideConeAngle = dwOutsideConeAngle;
-	if (dwApply == DS3D_IMMEDIATE)
-	{
-		DSOUND_Mix3DBuffer(This->dsb);
-	}
-	This->dsb->ds3db_need_recalc = TRUE;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_SetConeOrientation(
-	LPDIRECTSOUND3DBUFFER iface,
-	D3DVALUE x, D3DVALUE y, D3DVALUE z,
-	DWORD dwApply)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("setting: Cone Orientation vector = (%f,%f,%f); dwApply = %d\n", x, y, z, dwApply);
-	This->dsb->ds3db_ds3db.vConeOrientation.x = x;
-	This->dsb->ds3db_ds3db.vConeOrientation.y = y;
-	This->dsb->ds3db_ds3db.vConeOrientation.z = z;
-	if (dwApply == DS3D_IMMEDIATE)
-	{
-		This->dsb->ds3db_need_recalc = FALSE;
-		DSOUND_Mix3DBuffer(This->dsb);
-	}
-	This->dsb->ds3db_need_recalc = TRUE;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_SetConeOutsideVolume(
-	LPDIRECTSOUND3DBUFFER iface,
-	LONG lConeOutsideVolume,
-	DWORD dwApply)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("setting: ConeOutsideVolume = %d; dwApply = %d\n", lConeOutsideVolume, dwApply);
-	This->dsb->ds3db_ds3db.lConeOutsideVolume = lConeOutsideVolume;
-	if (dwApply == DS3D_IMMEDIATE)
-	{
-		This->dsb->ds3db_need_recalc = FALSE;
-		DSOUND_Mix3DBuffer(This->dsb);
-	}
-	This->dsb->ds3db_need_recalc = TRUE;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_SetMaxDistance(
-	LPDIRECTSOUND3DBUFFER iface,
-	D3DVALUE fMaxDistance,
-	DWORD dwApply)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("setting: MaxDistance = %f; dwApply = %d\n", fMaxDistance, dwApply);
-	This->dsb->ds3db_ds3db.flMaxDistance = fMaxDistance;
-	if (dwApply == DS3D_IMMEDIATE)
-	{
-		This->dsb->ds3db_need_recalc = FALSE;
-		DSOUND_Mix3DBuffer(This->dsb);
-	}
-	This->dsb->ds3db_need_recalc = TRUE;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_SetMinDistance(
-	LPDIRECTSOUND3DBUFFER iface,
-	D3DVALUE fMinDistance,
-	DWORD dwApply)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("setting: MinDistance = %f; dwApply = %d\n", fMinDistance, dwApply);
-	This->dsb->ds3db_ds3db.flMinDistance = fMinDistance;
-	if (dwApply == DS3D_IMMEDIATE)
-	{
-		This->dsb->ds3db_need_recalc = FALSE;
-		DSOUND_Mix3DBuffer(This->dsb);
-	}
-	This->dsb->ds3db_need_recalc = TRUE;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_SetMode(
-	LPDIRECTSOUND3DBUFFER iface,
-	DWORD dwMode,
-	DWORD dwApply)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("setting: Mode = %d; dwApply = %d\n", dwMode, dwApply);
-	This->dsb->ds3db_ds3db.dwMode = dwMode;
-	if (dwApply == DS3D_IMMEDIATE)
-	{
-		This->dsb->ds3db_need_recalc = FALSE;
-		DSOUND_Mix3DBuffer(This->dsb);
-	}
-	This->dsb->ds3db_need_recalc = TRUE;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_SetPosition(
-	LPDIRECTSOUND3DBUFFER iface,
-	D3DVALUE x, D3DVALUE y, D3DVALUE z,
-	DWORD dwApply)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("setting: Position vector = (%f,%f,%f); dwApply = %d\n", x, y, z, dwApply);
-	This->dsb->ds3db_ds3db.vPosition.x = x;
-	This->dsb->ds3db_ds3db.vPosition.y = y;
-	This->dsb->ds3db_ds3db.vPosition.z = z;
-	if (dwApply == DS3D_IMMEDIATE)
-	{
-		This->dsb->ds3db_need_recalc = FALSE;
-		DSOUND_Mix3DBuffer(This->dsb);
-	}
-	This->dsb->ds3db_need_recalc = TRUE;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DBufferImpl_SetVelocity(
-	LPDIRECTSOUND3DBUFFER iface,
-	D3DVALUE x, D3DVALUE y, D3DVALUE z,
-	DWORD dwApply)
-{
-	IDirectSound3DBufferImpl *This = (IDirectSound3DBufferImpl *)iface;
-	TRACE("setting: Velocity vector = (%f,%f,%f); dwApply = %d\n", x, y, z, dwApply);
-	This->dsb->ds3db_ds3db.vVelocity.x = x;
-	This->dsb->ds3db_ds3db.vVelocity.y = y;
-	This->dsb->ds3db_ds3db.vVelocity.z = z;
-	if (dwApply == DS3D_IMMEDIATE)
-	{
-		This->dsb->ds3db_need_recalc = FALSE;
-		DSOUND_Mix3DBuffer(This->dsb);
-	}
-	This->dsb->ds3db_need_recalc = TRUE;
-	return DS_OK;
-}
-
-static const IDirectSound3DBufferVtbl ds3dbvt =
-{
-	/* IUnknown methods */
-	IDirectSound3DBufferImpl_QueryInterface,
-	IDirectSound3DBufferImpl_AddRef,
-	IDirectSound3DBufferImpl_Release,
-	/* IDirectSound3DBuffer methods */
-	IDirectSound3DBufferImpl_GetAllParameters,
-	IDirectSound3DBufferImpl_GetConeAngles,
-	IDirectSound3DBufferImpl_GetConeOrientation,
-	IDirectSound3DBufferImpl_GetConeOutsideVolume,
-	IDirectSound3DBufferImpl_GetMaxDistance,
-	IDirectSound3DBufferImpl_GetMinDistance,
-	IDirectSound3DBufferImpl_GetMode,
-	IDirectSound3DBufferImpl_GetPosition,
-	IDirectSound3DBufferImpl_GetVelocity,
-	IDirectSound3DBufferImpl_SetAllParameters,
-	IDirectSound3DBufferImpl_SetConeAngles,
-	IDirectSound3DBufferImpl_SetConeOrientation,
-	IDirectSound3DBufferImpl_SetConeOutsideVolume,
-	IDirectSound3DBufferImpl_SetMaxDistance,
-	IDirectSound3DBufferImpl_SetMinDistance,
-	IDirectSound3DBufferImpl_SetMode,
-	IDirectSound3DBufferImpl_SetPosition,
-	IDirectSound3DBufferImpl_SetVelocity,
-};
-
-HRESULT IDirectSound3DBufferImpl_Create(
-	IDirectSoundBufferImpl *dsb,
-	IDirectSound3DBufferImpl **pds3db)
-{
-	IDirectSound3DBufferImpl *ds3db;
-	TRACE("(%p,%p)\n",dsb,pds3db);
-
-	ds3db = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(*ds3db));
-
-	if (ds3db == NULL) {
-		WARN("out of memory\n");
-		*pds3db = 0;
-		return DSERR_OUTOFMEMORY;
-	}
-
-	ds3db->ref = 0;
-	ds3db->dsb = dsb;
-	ds3db->lpVtbl = &ds3dbvt;
-
-	ds3db->dsb->ds3db_ds3db.dwSize = sizeof(DS3DBUFFER);
-	ds3db->dsb->ds3db_ds3db.vPosition.x = 0.0;
-	ds3db->dsb->ds3db_ds3db.vPosition.y = 0.0;
-	ds3db->dsb->ds3db_ds3db.vPosition.z = 0.0;
-	ds3db->dsb->ds3db_ds3db.vVelocity.x = 0.0;
-	ds3db->dsb->ds3db_ds3db.vVelocity.y = 0.0;
-	ds3db->dsb->ds3db_ds3db.vVelocity.z = 0.0;
-	ds3db->dsb->ds3db_ds3db.dwInsideConeAngle = DS3D_DEFAULTCONEANGLE;
-	ds3db->dsb->ds3db_ds3db.dwOutsideConeAngle = DS3D_DEFAULTCONEANGLE;
-	ds3db->dsb->ds3db_ds3db.vConeOrientation.x = 0.0;
-	ds3db->dsb->ds3db_ds3db.vConeOrientation.y = 0.0;
-	ds3db->dsb->ds3db_ds3db.vConeOrientation.z = 0.0;
-	ds3db->dsb->ds3db_ds3db.lConeOutsideVolume = DS3D_DEFAULTCONEOUTSIDEVOLUME;
-	ds3db->dsb->ds3db_ds3db.flMinDistance = DS3D_DEFAULTMINDISTANCE;
-	ds3db->dsb->ds3db_ds3db.flMaxDistance = DS3D_DEFAULTMAXDISTANCE;
-	ds3db->dsb->ds3db_ds3db.dwMode = DS3DMODE_NORMAL;
-
-	ds3db->dsb->ds3db_need_recalc = TRUE;
-
-	*pds3db = ds3db;
-	return S_OK;
-}
-
-HRESULT IDirectSound3DBufferImpl_Destroy(
-    IDirectSound3DBufferImpl *pds3db)
-{
-    TRACE("(%p)\n",pds3db);
-
-    while (IDirectSound3DBufferImpl_Release((LPDIRECTSOUND3DBUFFER)pds3db) > 0);
-
-    return S_OK;
-}
-
-/*******************************************************************************
- *	      IDirectSound3DListener
- */
-
-/* IUnknown methods */
-static HRESULT WINAPI IDirectSound3DListenerImpl_QueryInterface(
-	LPDIRECTSOUND3DLISTENER iface, REFIID riid, LPVOID *ppobj)
-{
-	IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-
-	TRACE("(%p,%s,%p)\n",This,debugstr_guid(riid),ppobj);
-
-	if (ppobj == NULL) {
-		WARN("invalid parameter\n");
-		return E_INVALIDARG;
-	}
-
-	*ppobj = NULL;  /* assume failure */
-
-	if ( IsEqualGUID(riid, &IID_IUnknown) ||
-	     IsEqualGUID(riid, &IID_IDirectSound3DListener ) ) {
-                IDirectSound3DListener_AddRef((LPDIRECTSOUND3DLISTENER)This);
-		*ppobj = This;
-		return S_OK;
-	}
-
-	if ( IsEqualGUID(riid, &IID_IDirectSoundBuffer) ) {
-                *ppobj = &This->device->primary->IDirectSoundBuffer8_iface;
-                IDirectSoundBuffer8_AddRef(&This->device->primary->IDirectSoundBuffer8_iface);
-                return S_OK;
-	}
-
-        FIXME( "Unknown IID %s\n", debugstr_guid( riid ) );
-	return E_NOINTERFACE;
-}
-
-static ULONG WINAPI IDirectSound3DListenerImpl_AddRef(LPDIRECTSOUND3DLISTENER iface)
-{
-    IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-    ULONG ref = InterlockedIncrement(&(This->ref));
-
-    TRACE("(%p) ref was %d\n", This, ref - 1);
-
-    if(ref == 1)
-        InterlockedIncrement(&This->device->primary->numIfaces);
-
-    return ref;
-}
-
-static ULONG WINAPI IDirectSound3DListenerImpl_Release(LPDIRECTSOUND3DLISTENER iface)
-{
-    IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-    ULONG ref = InterlockedDecrement(&(This->ref));
-    TRACE("(%p) ref was %d\n", This, ref + 1);
-
-    if (!ref) {
-        This->device->listener = 0;
-        if (!InterlockedDecrement(&This->device->primary->numIfaces))
-            primarybuffer_destroy(This->device->primary);
-        HeapFree(GetProcessHeap(), 0, This);
-        TRACE("(%p) released\n", This);
-    }
-    return ref;
-}
-
-/* IDirectSound3DListener methods */
-static HRESULT WINAPI IDirectSound3DListenerImpl_GetAllParameter(
-	LPDIRECTSOUND3DLISTENER iface,
-	LPDS3DLISTENER lpDS3DL)
-{
-	IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-	TRACE("(%p,%p)\n",This,lpDS3DL);
-
-	if (lpDS3DL == NULL) {
-		WARN("invalid parameter: lpDS3DL == NULL\n");
-		return DSERR_INVALIDPARAM;
-	}
-
-	if (lpDS3DL->dwSize < sizeof(*lpDS3DL)) {
-		WARN("invalid parameter: lpDS3DL->dwSize = %d\n",lpDS3DL->dwSize);
-		return DSERR_INVALIDPARAM;
-	}
-	
-	TRACE("returning: all parameters\n");
-	*lpDS3DL = This->device->ds3dl;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DListenerImpl_GetDistanceFactor(
-	LPDIRECTSOUND3DLISTENER iface,
-	LPD3DVALUE lpfDistanceFactor)
-{
-	IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-	TRACE("returning: Distance Factor = %f\n", This->device->ds3dl.flDistanceFactor);
-	*lpfDistanceFactor = This->device->ds3dl.flDistanceFactor;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DListenerImpl_GetDopplerFactor(
-	LPDIRECTSOUND3DLISTENER iface,
-	LPD3DVALUE lpfDopplerFactor)
-{
-	IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-	TRACE("returning: Doppler Factor = %f\n", This->device->ds3dl.flDopplerFactor);
-	*lpfDopplerFactor = This->device->ds3dl.flDopplerFactor;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DListenerImpl_GetOrientation(
-	LPDIRECTSOUND3DLISTENER iface,
-	LPD3DVECTOR lpvOrientFront,
-	LPD3DVECTOR lpvOrientTop)
-{
-	IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-	TRACE("returning: OrientFront vector = (%f,%f,%f); OrientTop vector = (%f,%f,%f)\n", This->device->ds3dl.vOrientFront.x,
-	This->device->ds3dl.vOrientFront.y, This->device->ds3dl.vOrientFront.z, This->device->ds3dl.vOrientTop.x, This->device->ds3dl.vOrientTop.y,
-	This->device->ds3dl.vOrientTop.z);
-	*lpvOrientFront = This->device->ds3dl.vOrientFront;
-	*lpvOrientTop = This->device->ds3dl.vOrientTop;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DListenerImpl_GetPosition(
-	LPDIRECTSOUND3DLISTENER iface,
-	LPD3DVECTOR lpvPosition)
-{
-	IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-	TRACE("returning: Position vector = (%f,%f,%f)\n", This->device->ds3dl.vPosition.x, This->device->ds3dl.vPosition.y, This->device->ds3dl.vPosition.z);
-	*lpvPosition = This->device->ds3dl.vPosition;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DListenerImpl_GetRolloffFactor(
-	LPDIRECTSOUND3DLISTENER iface,
-	LPD3DVALUE lpfRolloffFactor)
-{
-	IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-	TRACE("returning: RolloffFactor = %f\n", This->device->ds3dl.flRolloffFactor);
-	*lpfRolloffFactor = This->device->ds3dl.flRolloffFactor;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DListenerImpl_GetVelocity(
-	LPDIRECTSOUND3DLISTENER iface,
-	LPD3DVECTOR lpvVelocity)
-{
-	IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-	TRACE("returning: Velocity vector = (%f,%f,%f)\n", This->device->ds3dl.vVelocity.x, This->device->ds3dl.vVelocity.y, This->device->ds3dl.vVelocity.z);
-	*lpvVelocity = This->device->ds3dl.vVelocity;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DListenerImpl_SetAllParameters(
-	LPDIRECTSOUND3DLISTENER iface,
-	LPCDS3DLISTENER lpcDS3DL,
-	DWORD dwApply)
-{
-	IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-	TRACE("setting: all parameters; dwApply = %d\n", dwApply);
-	This->device->ds3dl = *lpcDS3DL;
-	if (dwApply == DS3D_IMMEDIATE)
-	{
-		This->device->ds3dl_need_recalc = FALSE;
-		DSOUND_ChangeListener(This);
-	}
-	This->device->ds3dl_need_recalc = TRUE;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DListenerImpl_SetDistanceFactor(
-	LPDIRECTSOUND3DLISTENER iface,
-	D3DVALUE fDistanceFactor,
-	DWORD dwApply)
-{
-	IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-	TRACE("setting: Distance Factor = %f; dwApply = %d\n", fDistanceFactor, dwApply);
-	This->device->ds3dl.flDistanceFactor = fDistanceFactor;
-	if (dwApply == DS3D_IMMEDIATE)
-	{
-		This->device->ds3dl_need_recalc = FALSE;
-		DSOUND_ChangeListener(This);
-	}
-	This->device->ds3dl_need_recalc = TRUE;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DListenerImpl_SetDopplerFactor(
-	LPDIRECTSOUND3DLISTENER iface,
-	D3DVALUE fDopplerFactor,
-	DWORD dwApply)
-{
-	IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-	TRACE("setting: Doppler Factor = %f; dwApply = %d\n", fDopplerFactor, dwApply);
-	This->device->ds3dl.flDopplerFactor = fDopplerFactor;
-	if (dwApply == DS3D_IMMEDIATE)
-	{
-		This->device->ds3dl_need_recalc = FALSE;
-		DSOUND_ChangeListener(This);
-	}
-	This->device->ds3dl_need_recalc = TRUE;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DListenerImpl_SetOrientation(
-	LPDIRECTSOUND3DLISTENER iface,
-	D3DVALUE xFront, D3DVALUE yFront, D3DVALUE zFront,
-	D3DVALUE xTop, D3DVALUE yTop, D3DVALUE zTop,
-	DWORD dwApply)
-{
-	IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-	TRACE("setting: Front vector = (%f,%f,%f); Top vector = (%f,%f,%f); dwApply = %d\n",
-	xFront, yFront, zFront, xTop, yTop, zTop, dwApply);
-	This->device->ds3dl.vOrientFront.x = xFront;
-	This->device->ds3dl.vOrientFront.y = yFront;
-	This->device->ds3dl.vOrientFront.z = zFront;
-	This->device->ds3dl.vOrientTop.x = xTop;
-	This->device->ds3dl.vOrientTop.y = yTop;
-	This->device->ds3dl.vOrientTop.z = zTop;
-	if (dwApply == DS3D_IMMEDIATE)
-	{
-		This->device->ds3dl_need_recalc = FALSE;
-		DSOUND_ChangeListener(This);
-	}
-	This->device->ds3dl_need_recalc = TRUE;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DListenerImpl_SetPosition(
-	LPDIRECTSOUND3DLISTENER iface,
-	D3DVALUE x, D3DVALUE y, D3DVALUE z,
-	DWORD dwApply)
-{
-	IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-	TRACE("setting: Position vector = (%f,%f,%f); dwApply = %d\n", x, y, z, dwApply);
-	This->device->ds3dl.vPosition.x = x;
-	This->device->ds3dl.vPosition.y = y;
-	This->device->ds3dl.vPosition.z = z;
-	if (dwApply == DS3D_IMMEDIATE)
-	{
-		This->device->ds3dl_need_recalc = FALSE;
-		DSOUND_ChangeListener(This);
-	}
-	This->device->ds3dl_need_recalc = TRUE;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DListenerImpl_SetRolloffFactor(
-	LPDIRECTSOUND3DLISTENER iface,
-	D3DVALUE fRolloffFactor,
-	DWORD dwApply)
-{
-	IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-	TRACE("setting: Rolloff Factor = %f; dwApply = %d\n", fRolloffFactor, dwApply);
-	This->device->ds3dl.flRolloffFactor = fRolloffFactor;
-	if (dwApply == DS3D_IMMEDIATE)
-	{
-		This->device->ds3dl_need_recalc = FALSE;
-		DSOUND_ChangeListener(This);
-	}
-	This->device->ds3dl_need_recalc = TRUE;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DListenerImpl_SetVelocity(
-	LPDIRECTSOUND3DLISTENER iface,
-	D3DVALUE x, D3DVALUE y, D3DVALUE z,
-	DWORD dwApply)
-{
-	IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-	TRACE("setting: Velocity vector = (%f,%f,%f); dwApply = %d\n", x, y, z, dwApply);
-	This->device->ds3dl.vVelocity.x = x;
-	This->device->ds3dl.vVelocity.y = y;
-	This->device->ds3dl.vVelocity.z = z;
-	if (dwApply == DS3D_IMMEDIATE)
-	{
-		This->device->ds3dl_need_recalc = FALSE;
-		DSOUND_ChangeListener(This);
-	}
-	This->device->ds3dl_need_recalc = TRUE;
-	return DS_OK;
-}
-
-static HRESULT WINAPI IDirectSound3DListenerImpl_CommitDeferredSettings(
-	LPDIRECTSOUND3DLISTENER iface)
-{
-	IDirectSound3DListenerImpl *This = (IDirectSound3DListenerImpl *)iface;
-	TRACE("\n");
-	DSOUND_ChangeListener(This);
-	return DS_OK;
-}
-
-static const IDirectSound3DListenerVtbl ds3dlvt =
-{
-	/* IUnknown methods */
-	IDirectSound3DListenerImpl_QueryInterface,
-	IDirectSound3DListenerImpl_AddRef,
-	IDirectSound3DListenerImpl_Release,
-	/* IDirectSound3DListener methods */
-	IDirectSound3DListenerImpl_GetAllParameter,
-	IDirectSound3DListenerImpl_GetDistanceFactor,
-	IDirectSound3DListenerImpl_GetDopplerFactor,
-	IDirectSound3DListenerImpl_GetOrientation,
-	IDirectSound3DListenerImpl_GetPosition,
-	IDirectSound3DListenerImpl_GetRolloffFactor,
-	IDirectSound3DListenerImpl_GetVelocity,
-	IDirectSound3DListenerImpl_SetAllParameters,
-	IDirectSound3DListenerImpl_SetDistanceFactor,
-	IDirectSound3DListenerImpl_SetDopplerFactor,
-	IDirectSound3DListenerImpl_SetOrientation,
-	IDirectSound3DListenerImpl_SetPosition,
-	IDirectSound3DListenerImpl_SetRolloffFactor,
-	IDirectSound3DListenerImpl_SetVelocity,
-	IDirectSound3DListenerImpl_CommitDeferredSettings,
-};
-
-HRESULT IDirectSound3DListenerImpl_Create(
-	DirectSoundDevice * device,
-	IDirectSound3DListenerImpl ** ppdsl)
-{
-	IDirectSound3DListenerImpl *pdsl;
-	TRACE("(%p,%p)\n",device,ppdsl);
-
-	pdsl = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(*pdsl));
-
-	if (pdsl == NULL) {
-		WARN("out of memory\n");
-		*ppdsl = 0;
-		return DSERR_OUTOFMEMORY;
-	}
-
-	pdsl->ref = 0;
-	pdsl->lpVtbl = &ds3dlvt;
-
-	pdsl->device = device;
-
-	pdsl->device->ds3dl.dwSize = sizeof(DS3DLISTENER);
-	pdsl->device->ds3dl.vPosition.x = 0.0;
-	pdsl->device->ds3dl.vPosition.y = 0.0;
-	pdsl->device->ds3dl.vPosition.z = 0.0;
-	pdsl->device->ds3dl.vVelocity.x = 0.0;
-	pdsl->device->ds3dl.vVelocity.y = 0.0;
-	pdsl->device->ds3dl.vVelocity.z = 0.0;
-	pdsl->device->ds3dl.vOrientFront.x = 0.0;
-	pdsl->device->ds3dl.vOrientFront.y = 0.0;
-	pdsl->device->ds3dl.vOrientFront.z = 1.0;
-	pdsl->device->ds3dl.vOrientTop.x = 0.0;
-	pdsl->device->ds3dl.vOrientTop.y = 1.0;
-	pdsl->device->ds3dl.vOrientTop.z = 0.0;
-	pdsl->device->ds3dl.flDistanceFactor = DS3D_DEFAULTDISTANCEFACTOR;
-	pdsl->device->ds3dl.flRolloffFactor = DS3D_DEFAULTROLLOFFFACTOR;
-	pdsl->device->ds3dl.flDopplerFactor = DS3D_DEFAULTDOPPLERFACTOR;
-
-	pdsl->device->ds3dl_need_recalc = TRUE;
-
-	*ppdsl = pdsl;
-	return S_OK;
-}
diff --git a/dlls/mciqtz32/mciqtz.c b/dlls/mciqtz32/mciqtz.c
index 03f6f9d..863783c 100644
--- a/dlls/mciqtz32/mciqtz.c
+++ b/dlls/mciqtz32/mciqtz.c
@@ -220,7 +220,6 @@ static DWORD MCIQTZ_mciOpen(UINT wDevID, DWORD dwFlags,
         IVideoWindow_put_WindowStyle(wma->vidwin, style|WS_CHILD);
         IVideoWindow_put_Owner(wma->vidwin, (OAHWND)lpOpenParms->hWndParent);
         GetClientRect(lpOpenParms->hWndParent, &rc);
-        IVideoWindow_SetWindowPosition(wma->vidwin, rc.left, rc.top, rc.right - rc.top, rc.bottom - rc.top);
         wma->parent = (HWND)lpOpenParms->hWndParent;
     }
     else if (style)
@@ -293,9 +292,10 @@ static DWORD MCIQTZ_mciPlay(UINT wDevID, DWORD dwFlags, LPMCI_PLAY_PARMS lpParms
 {
     WINE_MCIQTZ* wma;
     HRESULT hr;
-    REFERENCE_TIME time1 = 0, time2 = 0;
+    REFERENCE_TIME time1 = 0, time2 = 0, cmptime = 0;
     GUID format;
-    DWORD pos1;
+    DWORD pos1, pos2;
+    RECT rc;
 
     TRACE("(%04x, %08X, %p)\n", wDevID, dwFlags, lpParms);
 
@@ -312,7 +312,11 @@ static DWORD MCIQTZ_mciPlay(UINT wDevID, DWORD dwFlags, LPMCI_PLAY_PARMS lpParms
             time1 = lpParms->dwFrom * 10000;
         else
             time1 = lpParms->dwFrom;
-        pos1 = AM_SEEKING_AbsolutePositioning;
+        IMediaSeeking_GetCurrentPosition(wma->seek, &cmptime);
+        if (cmptime != time1)
+            pos1 = AM_SEEKING_AbsolutePositioning;
+        else
+            pos1 = AM_SEEKING_NoPositioning;
     } else
         pos1 = AM_SEEKING_NoPositioning;
     if (dwFlags & MCI_TO) {
@@ -320,10 +324,21 @@ static DWORD MCIQTZ_mciPlay(UINT wDevID, DWORD dwFlags, LPMCI_PLAY_PARMS lpParms
             time2 = lpParms->dwTo * 10000;
         else
             time2 = lpParms->dwTo;
+        IMediaSeeking_GetStopPosition(wma->seek, &cmptime);
+        if (cmptime != time2)
+            pos2 = AM_SEEKING_AbsolutePositioning;
+        else
+            pos2 = AM_SEEKING_NoPositioning;
     } else
-        IMediaSeeking_GetDuration(wma->seek, &time2);
-    IMediaSeeking_SetPositions(wma->seek, &time1, pos1, &time2, AM_SEEKING_AbsolutePositioning);
+        pos2 = AM_SEEKING_NoPositioning;
+
+    if (wma->parent) {
+        GetClientRect(wma->parent, &rc);
+        IVideoWindow_SetWindowPosition(wma->vidwin, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top);
+    }
 
+    if (pos1 != AM_SEEKING_NoPositioning || pos2 != AM_SEEKING_NoPositioning)
+        IMediaSeeking_SetPositions(wma->seek, &time1, pos1, &time2, pos2);
     hr = IMediaControl_Run(wma->pmctrl);
     if (FAILED(hr)) {
         TRACE("Cannot run filtergraph (hr = %x)\n", hr);
@@ -363,8 +378,10 @@ static DWORD MCIQTZ_mciSeek(UINT wDevID, DWORD dwFlags, LPMCI_SEEK_PARMS lpParms
         FIXME("MCI_SEEK_TO_END not implemented yet\n");
         return MCIERR_INTERNAL;
     } else if (dwFlags & MCI_TO) {
-        FIXME("MCI_TO not implemented yet\n");
-        return MCIERR_INTERNAL;
+        if (wma->time_format == MCI_FORMAT_MILLISECONDS)
+            newpos = lpParms->dwTo;
+        else
+            newpos = lpParms->dwTo / 10000;
     } else {
         WARN("dwFlag doesn't tell where to seek to...\n");
         return MCIERR_MISSING_PARAMETER;
@@ -405,8 +422,7 @@ static DWORD MCIQTZ_mciStop(UINT wDevID, DWORD dwFlags, LPMCI_GENERIC_PARMS lpPa
         return MCIERR_INTERNAL;
     }
 
-    if (!wma->parent)
-        IVideoWindow_put_Visible(wma->vidwin, OAFALSE);
+    IVideoWindow_put_Visible(wma->vidwin, OAFALSE);
 
     return 0;
 }
@@ -425,6 +441,8 @@ static DWORD MCIQTZ_mciPause(UINT wDevID, DWORD dwFlags, LPMCI_GENERIC_PARMS lpP
     if (!wma)
         return MCIERR_INVALID_DEVICE_ID;
 
+    IVideoWindow_put_Visible(wma->vidwin, OATRUE);
+
     hr = IMediaControl_Pause(wma->pmctrl);
     if (FAILED(hr)) {
         TRACE("Cannot pause filtergraph (hr = %x)\n", hr);
@@ -553,10 +571,14 @@ static DWORD MCIQTZ_mciSet(UINT wDevID, DWORD dwFlags, LPMCI_DGV_SET_PARMS lpPar
         switch (lpParms->dwTimeFormat) {
             case MCI_FORMAT_MILLISECONDS:
                 TRACE("MCI_SET_TIME_FORMAT = MCI_FORMAT_MILLISECONDS\n");
+                if (IMediaSeeking_SetTimeFormat(wma->seek, &TIME_FORMAT_MEDIA_TIME) != S_OK)
+                    return MCIERR_BAD_TIME_FORMAT;
                 wma->time_format = MCI_FORMAT_MILLISECONDS;
                 break;
             case MCI_FORMAT_FRAMES:
                 TRACE("MCI_SET_TIME_FORMAT = MCI_FORMAT_FRAMES\n");
+                if (IMediaSeeking_SetTimeFormat(wma->seek, &TIME_FORMAT_FRAME) != S_OK)
+                    return MCIERR_BAD_TIME_FORMAT;
                 wma->time_format = MCI_FORMAT_FRAMES;
                 break;
             default:
@@ -613,37 +635,36 @@ static DWORD MCIQTZ_mciStatus(UINT wDevID, DWORD dwFlags, LPMCI_DGV_STATUS_PARMS
     switch (lpParms->dwItem) {
         case MCI_STATUS_LENGTH: {
             LONGLONG duration = -1;
-            GUID format;
-            switch (wma->time_format) {
-                case MCI_FORMAT_MILLISECONDS: format = TIME_FORMAT_MEDIA_TIME; break;
-                case MCI_FORMAT_FRAMES: format = TIME_FORMAT_FRAME; break;
-                default: ERR("Unhandled format %x\n", wma->time_format); break;
-            }
-            hr = IMediaSeeking_SetTimeFormat(wma->seek, &format);
-            if (FAILED(hr)) {
-                FIXME("Cannot set time format (hr = %x)\n", hr);
-                lpParms->dwReturn = 0;
-                break;
-            }
             hr = IMediaSeeking_GetDuration(wma->seek, &duration);
             if (FAILED(hr) || duration < 0) {
                 FIXME("Cannot read duration (hr = %x)\n", hr);
                 lpParms->dwReturn = 0;
-            } else if (wma->time_format != MCI_FORMAT_MILLISECONDS)
-                lpParms->dwReturn = duration;
-            else
+            } else if (wma->time_format == MCI_FORMAT_MILLISECONDS)
                 lpParms->dwReturn = duration / 10000;
+            else
+                lpParms->dwReturn = duration;
+            TRACE("MCI_STATUS_LENGTH = %lu\n", lpParms->dwReturn);
             break;
         }
         case MCI_STATUS_POSITION: {
             REFERENCE_TIME curpos;
 
+            if (dwFlags & MCI_STATUS_START) {
+                lpParms->dwReturn = 0;
+                TRACE("MCI_STATUS_POSITION with MCI_STATUS_START = %lu\n", lpParms->dwReturn);
+                break;
+            }
+
             hr = IMediaSeeking_GetCurrentPosition(wma->seek, &curpos);
             if (FAILED(hr)) {
                 FIXME("Cannot get position (hr = %x)\n", hr);
                 return MCIERR_INTERNAL;
             }
-            lpParms->dwReturn = curpos / 10000;
+            if (wma->time_format != MCI_FORMAT_MILLISECONDS)
+                lpParms->dwReturn = curpos;
+            else
+                lpParms->dwReturn = curpos / 10000;
+            TRACE("MCI_STATUS_POSITION current = %lu\n", lpParms->dwReturn);
             break;
         }
         case MCI_STATUS_NUMBER_OF_TRACKS:
@@ -802,7 +823,6 @@ static DWORD MCIQTZ_mciWindow(UINT wDevID, DWORD dwFlags, LPMCI_DGV_WINDOW_PARMS
 static DWORD MCIQTZ_mciUpdate(UINT wDevID, DWORD dwFlags, LPMCI_DGV_UPDATE_PARMS lpParms)
 {
     WINE_MCIQTZ *wma;
-    DWORD res = 0;
 
     TRACE("%04x, %08x, %p\n", wDevID, dwFlags, lpParms);
 
@@ -813,30 +833,22 @@ static DWORD MCIQTZ_mciUpdate(UINT wDevID, DWORD dwFlags, LPMCI_DGV_UPDATE_PARMS
     if (!wma)
         return MCIERR_INVALID_DEVICE_ID;
 
-    if (dwFlags & MCI_DGV_UPDATE_HDC) {
-        LONG state, size;
+    if (dwFlags & MCI_DGV_UPDATE_HDC && !(dwFlags & MCI_DGV_UPDATE_PAINT)) {
+        LONG state, newstate, size;
         BYTE *data;
         BITMAPINFO *info;
         HRESULT hr;
         RECT src, dest;
-        LONG visible = OATRUE;
 
-        res = MCIERR_INTERNAL;
-        IMediaControl_GetState(wma->pmctrl, -1, &state);
-        if (state == State_Running)
-            return MCIERR_UNSUPPORTED_FUNCTION;
-        /* If in stopped state, nothing has been drawn to screen
-         * moving to pause, which is needed for the old dib renderer, will result
-         * in a single frame drawn, so hide the window here */
-        IVideoWindow_get_Visible(wma->vidwin, &visible);
-        if (wma->parent)
-            IVideoWindow_put_Visible(wma->vidwin, OAFALSE);
-        /* FIXME: Should we check the original state and restore it? */
-        IMediaControl_Pause(wma->pmctrl);
         IMediaControl_GetState(wma->pmctrl, -1, &state);
+        if (state == State_Stopped)
+            IMediaControl_Pause(wma->pmctrl);
+        IMediaControl_GetState(wma->pmctrl, -1, &newstate);
         if (FAILED(hr = IBasicVideo_GetCurrentImage(wma->vidbasic, &size, NULL))) {
             WARN("Could not get image size (hr = %x)\n", hr);
-            goto out;
+            if (state == State_Stopped)
+                IMediaControl_Stop(wma->pmctrl);
+            return MCIERR_INTERNAL;
         }
         data = HeapAlloc(GetProcessHeap(), 0, size);
         info = (BITMAPINFO*)data;
@@ -850,14 +862,12 @@ static DWORD MCIQTZ_mciUpdate(UINT wDevID, DWORD dwFlags, LPMCI_DGV_UPDATE_PARMS
               src.left, src.top, src.right + src.left, src.bottom + src.top,
               data, info, DIB_RGB_COLORS, SRCCOPY);
         HeapFree(GetProcessHeap(), 0, data);
-        res = 0;
-out:
-        if (wma->parent)
-            IVideoWindow_put_Visible(wma->vidwin, visible);
+        if (state == State_Stopped)
+            IMediaControl_Stop(wma->pmctrl);
+        return 0;
     }
-    else if (dwFlags)
-        FIXME("Unhandled flags %x\n", dwFlags);
-    return res;
+    FIXME("Unhandled flags %x\n", dwFlags);
+    return MCIERR_INTERNAL;
 }
 
 /***************************************************************************
diff --git a/dlls/ntdll/directory.c b/dlls/ntdll/directory.c
index 5d6d2cc..4169897 100644
--- a/dlls/ntdll/directory.c
+++ b/dlls/ntdll/directory.c
@@ -2048,6 +2048,8 @@ NTSTATUS WINAPI NtQueryDirectoryFile( HANDLE handle, HANDLE event,
         fstat( fd, &st );
         curdir.dev = st.st_dev;
         curdir.ino = st.st_ino;
+        if (lseek( fd, 0, SEEK_CUR ) == 0)
+            restart_scan = TRUE;
 #ifdef VFAT_IOCTL_READDIR_BOTH
         if ((read_directory_vfat( fd, io, buffer, length, single_entry,
                                   mask, restart_scan, info_class )) != -1) goto done;
diff --git a/dlls/ntdll/heap.c b/dlls/ntdll/heap.c
index 2e945e9..9c2a1c8 100644
--- a/dlls/ntdll/heap.c
+++ b/dlls/ntdll/heap.c
@@ -747,7 +747,7 @@ static void *realloc_large_block( HEAP *heap, DWORD flags, void *ptr, SIZE_T siz
     ARENA_LARGE *arena = (ARENA_LARGE *)ptr - 1;
     void *new_ptr;
 
-    if (arena->block_size - sizeof(*arena) >= size)
+    if (arena->block_size - sizeof(*arena) >= size && !RUNNING_ON_VALGRIND)
     {
         SIZE_T unused = arena->block_size - sizeof(*arena) - size;
 
@@ -1821,7 +1821,7 @@ PVOID WINAPI RtlReAllocateHeap( HANDLE heap, ULONG flags, PVOID ptr, SIZE_T size
 
     oldBlockSize = (pArena->size & ARENA_SIZE_MASK);
     oldActualSize = (pArena->size & ARENA_SIZE_MASK) - pArena->unused_bytes;
-    if (rounded_size > oldBlockSize)
+    if (rounded_size > oldBlockSize || RUNNING_ON_VALGRIND)
     {
         char *pNext = (char *)(pArena + 1) + oldBlockSize;
 
@@ -1836,7 +1836,8 @@ PVOID WINAPI RtlReAllocateHeap( HANDLE heap, ULONG flags, PVOID ptr, SIZE_T size
         }
         if ((pNext < (char *)subheap->base + subheap->size) &&
             (*(DWORD *)pNext & ARENA_FLAG_FREE) &&
-            (oldBlockSize + (*(DWORD *)pNext & ARENA_SIZE_MASK) + sizeof(ARENA_FREE) >= rounded_size))
+            (oldBlockSize + (*(DWORD *)pNext & ARENA_SIZE_MASK) + sizeof(ARENA_FREE) >= rounded_size) &&
+            !RUNNING_ON_VALGRIND)
         {
             /* The next block is free and large enough */
             ARENA_FREE *pFree = (ARENA_FREE *)pNext;
diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
index 4956537..60caa2e 100644
--- a/dlls/ntdll/ntdll_misc.h
+++ b/dlls/ntdll/ntdll_misc.h
@@ -71,6 +71,7 @@ extern HANDLE thread_init(void) DECLSPEC_HIDDEN;
 extern void actctx_init(void) DECLSPEC_HIDDEN;
 extern void virtual_init(void) DECLSPEC_HIDDEN;
 extern void virtual_init_threading(void) DECLSPEC_HIDDEN;
+extern void virtual_init_mmap(void) DECLSPEC_HIDDEN;
 extern void fill_cpu_info(void) DECLSPEC_HIDDEN;
 extern void heap_set_debug_flags( HANDLE handle ) DECLSPEC_HIDDEN;
 
@@ -87,8 +88,6 @@ extern void DECLSPEC_NORETURN abort_thread( int status ) DECLSPEC_HIDDEN;
 extern void DECLSPEC_NORETURN terminate_thread( int status ) DECLSPEC_HIDDEN;
 extern void DECLSPEC_NORETURN exit_thread( int status ) DECLSPEC_HIDDEN;
 extern sigset_t server_block_set DECLSPEC_HIDDEN;
-extern void server_enter_uninterrupted_section( RTL_CRITICAL_SECTION *cs, sigset_t *sigset ) DECLSPEC_HIDDEN;
-extern void server_leave_uninterrupted_section( RTL_CRITICAL_SECTION *cs, sigset_t *sigset ) DECLSPEC_HIDDEN;
 extern int server_remove_fd_from_cache( HANDLE handle ) DECLSPEC_HIDDEN;
 extern int server_get_unix_fd( HANDLE handle, unsigned int access, int *unix_fd,
                                int *needs_close, enum server_fd_type *type, unsigned int *options ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/server.c b/dlls/ntdll/server.c
index 3243f9f..fd04a80 100644
--- a/dlls/ntdll/server.c
+++ b/dlls/ntdll/server.c
@@ -292,20 +292,14 @@ unsigned int wine_server_call( void *req_ptr )
 }
 
 
-/***********************************************************************
- *           server_enter_uninterrupted_section
- */
-void server_enter_uninterrupted_section( RTL_CRITICAL_SECTION *cs, sigset_t *sigset )
+static void server_enter_uninterrupted_section( RTL_CRITICAL_SECTION *cs, sigset_t *sigset )
 {
     pthread_sigmask( SIG_BLOCK, &server_block_set, sigset );
     RtlEnterCriticalSection( cs );
 }
 
 
-/***********************************************************************
- *           server_leave_uninterrupted_section
- */
-void server_leave_uninterrupted_section( RTL_CRITICAL_SECTION *cs, sigset_t *sigset )
+static void server_leave_uninterrupted_section( RTL_CRITICAL_SECTION *cs, sigset_t *sigset )
 {
     RtlLeaveCriticalSection( cs );
     pthread_sigmask( SIG_SETMASK, sigset, NULL );
diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
index e328c5f..884e986 100644
--- a/dlls/ntdll/thread.c
+++ b/dlls/ntdll/thread.c
@@ -298,6 +298,7 @@ HANDLE thread_init(void)
 
     fill_cpu_info();
 
+    virtual_init_mmap();
     return exe_file;
 }
 
diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
index 10fba17..d804011 100644
--- a/dlls/ntdll/virtual.c
+++ b/dlls/ntdll/virtual.c
@@ -104,14 +104,7 @@ static const BYTE VIRTUAL_Win32Flags[16] =
 
 static struct list views_list = LIST_INIT(views_list);
 
-static RTL_CRITICAL_SECTION csVirtual;
-static RTL_CRITICAL_SECTION_DEBUG critsect_debug =
-{
-    0, 0, &csVirtual,
-    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
-      0, 0, { (DWORD_PTR)(__FILE__ ": csVirtual") }
-};
-static RTL_CRITICAL_SECTION csVirtual = { &critsect_debug, -1, 0, 0, 0, 0 };
+static pthread_mutex_t csVirtual = PTHREAD_MUTEX_INITIALIZER;
 
 #ifdef __i386__
 /* These are always the same on an i386, and it will be faster this way */
@@ -156,9 +149,25 @@ static const int is_win64 = (sizeof(void *) > sizeof(int));
 static HANDLE virtual_heap;
 static void *preload_reserve_start;
 static void *preload_reserve_end;
-static int use_locks;
 static int force_exec_prot;  /* whether to force PROT_EXEC on all PROT_READ mmaps */
 
+static void *virtual_mmap_wrapper( void *addr, size_t size, int prot, int flags, int fd, LONGLONG offset );
+static int virtual_munmap_wrapper( void *addr, size_t size );
+static void *virtual_mremap_wrapper( void *addr, size_t old_len, size_t new_len, int flags, ... );
+
+static void server_enter_uninterrupted_section( pthread_mutex_t *cs, sigset_t *sigset )
+{
+    pthread_sigmask( SIG_BLOCK, &server_block_set, sigset );
+    pthread_mutex_lock( cs );
+}
+
+
+static void server_leave_uninterrupted_section( pthread_mutex_t *cs, sigset_t *sigset )
+{
+    pthread_mutex_unlock( cs );
+    pthread_sigmask( SIG_SETMASK, sigset, NULL );
+}
+
 
 /***********************************************************************
  *           VIRTUAL_GetProtStr
@@ -370,7 +379,7 @@ static void add_reserved_area( void *addr, size_t size )
     {
         /* unmap the part of the area that is below the limit */
         assert( (char *)addr + size > (char *)user_space_limit );
-        munmap( addr, (char *)user_space_limit - (char *)addr );
+        wine_munmap( addr, (char *)user_space_limit - (char *)addr );
         size -= (char *)user_space_limit - (char *)addr;
         addr = user_space_limit;
     }
@@ -398,11 +407,11 @@ static void remove_reserved_area( void *addr, size_t size )
     {
         if ((char *)view->base >= (char *)addr + size)
         {
-            munmap( addr, size );
+            wine_munmap( addr, size );
             break;
         }
         if ((char *)view->base + view->size <= (char *)addr) continue;
-        if (view->base > addr) munmap( addr, (char *)view->base - (char *)addr );
+        if (view->base > addr) wine_munmap( addr, (char *)view->base - (char *)addr );
         if ((char *)view->base + view->size > (char *)addr + size) break;
         size = (char *)addr + size - ((char *)view->base + view->size);
         addr = (char *)view->base + view->size;
@@ -427,14 +436,18 @@ static inline int is_beyond_limit( const void *addr, size_t size, const void *li
  * Unmap an area, or simply replace it by an empty mapping if it is
  * in a reserved area. The csVirtual section must be held by caller.
  */
-static inline void unmap_area( void *addr, size_t size )
+static inline int unmap_area( void *addr, size_t size )
 {
+    int ret = 0;
+
     if (wine_mmap_is_in_reserved_area( addr, size ))
         wine_anon_mmap( addr, size, PROT_NONE, MAP_NORESERVE | MAP_FIXED );
     else if (is_beyond_limit( addr, size, user_space_limit ))
         add_reserved_area( addr, size );
     else
-        munmap( addr, size );
+        ret = wine_munmap( addr, size );
+
+    return ret;
 }
 
 
@@ -704,12 +717,12 @@ static inline void *unmap_extra_space( void *ptr, size_t total_size, size_t want
     if ((ULONG_PTR)ptr & mask)
     {
         size_t extra = mask + 1 - ((ULONG_PTR)ptr & mask);
-        munmap( ptr, extra );
+        wine_munmap( ptr, extra );
         ptr = (char *)ptr + extra;
         total_size -= extra;
     }
     if (total_size > wanted_size)
-        munmap( (char *)ptr + wanted_size, total_size - wanted_size );
+        wine_munmap( (char *)ptr + wanted_size, total_size - wanted_size );
     return ptr;
 }
 
@@ -795,7 +808,7 @@ static NTSTATUS map_view( struct file_view **view_ret, void *base, size_t size,
             {
                 /* We couldn't get the address we wanted */
                 if (is_beyond_limit( ptr, size, user_space_limit )) add_reserved_area( ptr, size );
-                else munmap( ptr, size );
+                else wine_munmap( ptr, size );
                 return STATUS_CONFLICTING_ADDRESSES;
             }
             break;
@@ -850,6 +863,281 @@ done:
 
 
 /***********************************************************************
+ *           virtual_mmap_wrapper
+ */
+static void *virtual_mmap_wrapper( void *addr, size_t size, int prot, int flags, int fd, LONGLONG offset )
+{
+    void *ptr = (void *)-1;
+    struct alloc_area alloc;
+    sigset_t sigset;
+
+    TRACE("%p, %lu, 0x%x, 0x%x, %d, %lld\n", addr, (ULONG_PTR)size, prot, flags, fd, offset);
+
+    if (!virtual_heap || (flags & MAP_FIXED))
+        return wine_mmap( addr, size, prot, flags, fd, offset );
+
+    size = ROUND_SIZE( addr, size );
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    /* Try address first, if requested */
+    if (addr != NULL)
+    {
+        addr = ROUND_ADDR( addr, page_mask );
+        switch (wine_mmap_is_in_reserved_area( addr, size ))
+        {
+        case -1: /* partially in a reserved area */
+            break;
+        case 0:  /* not in a reserved area, do a normal allocation */
+            ptr = wine_mmap( addr, size, prot, flags, fd, offset );
+            if (ptr == (void *)-1 && errno == ENOMEM) break;
+            goto done;
+        default:
+        case 1:  /* in a reserved area, make sure the address is available */
+            if (!find_view_range( addr, size ))
+            {
+                /* replace the reserved area by our mapping */
+                ptr = wine_mmap( addr, size, prot, flags | MAP_FIXED, fd, offset );
+                goto done;
+            }
+            break;
+        }
+    }
+
+    alloc.size = size;
+    alloc.mask = page_mask;
+    alloc.top_down = 1;
+    alloc.limit = address_space_limit;
+    if (wine_mmap_enum_reserved_areas( alloc_reserved_area_callback, &alloc, 1 ))
+        ptr = wine_mmap( alloc.result, size, prot, flags | MAP_FIXED, fd, offset );
+    else
+        ptr = wine_mmap( NULL, size, prot, flags, fd, offset );
+
+done:
+    if (ptr != (void *)-1)
+    {
+        struct file_view *view;
+        WORD vprot = VPROT_COMMITTED | VPROT_SYSTEM | VPROT_NOEXEC;
+
+        if (prot != PROT_NONE)
+        {
+            if (prot & PROT_READ) vprot |= VPROT_READ;
+            if (prot & PROT_WRITE) vprot |= VPROT_WRITE;
+            if (prot & PROT_EXEC) vprot |= VPROT_EXEC;
+        }
+        if (!create_view( &view, ptr, size, vprot ))
+            TRACE( "returning %p-%p\n", ptr, (char *)ptr + size );
+        else
+        {
+            unmap_area( ptr, size );
+            WARN( "Failed to create view for %p, %lu, 0x%04x\n",
+                  ptr, (ULONG_PTR)size, vprot );
+            ptr = (void *)-1;
+            errno = ENOMEM;
+        }
+    }
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return ptr;
+}
+
+
+/***********************************************************************
+ *           virtual_munmap_wrapper
+ */
+static int virtual_munmap_wrapper( void *addr, size_t size )
+{
+    struct file_view *view, *next, *new_view;
+    sigset_t sigset;
+    size_t new_size;
+    char *end;
+    int ret;
+
+    size = ROUND_SIZE( addr, size );
+    addr = ROUND_ADDR( addr, page_mask );
+    end = (char *)addr + size;
+
+    TRACE( "%p-%p (%lu)\n", addr, end, (ULONG_PTR)size );
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    ret = unmap_area( addr, size );
+    if (ret != 0)
+        goto done;
+
+    LIST_FOR_EACH_ENTRY_SAFE( view, next, &views_list, struct file_view, entry )
+    {
+        if ((char *)view->base >= end) break;
+        if ((char *)view->base + view->size <= (char *)addr) continue;
+
+        if (!(view->protect & VPROT_SYSTEM))
+            FIXME( "unmapping range %p-%p but view %p-%p is not system\n",
+                  addr, (char *)addr + size, view->base, (char *)view->base + size );
+
+        if ((char *)view->base >= (char *)addr)
+        {
+            if ((char *)view->base + view->size <= end)
+            {
+                /* view is entirely within the unmapped space, remove it */
+                TRACE( "deleting view %p-%p\n",
+                       view->base, (char *)view->base + view->size );
+                delete_view( view );
+                continue;
+            }
+            /* move the base to contain the remaining part of the view */
+            TRACE( "rebasing view %p-%p to %p\n",
+                   view->base, (char *)view->base + view->size, end );
+            view->size -= (char *)end - (char *)view->base;
+            memmove( &view->prot[0],
+                     &view->prot[((char *)end - (char *)view->base) >> page_shift],
+                     view->size >> page_shift );
+            view->base = end;
+            break;
+        }
+        if ((char *)view->base + view->size <= end)
+        {
+            /* truncate the view */
+            TRACE( "truncating view %p-%p to %p\n",
+                   view->base, (char *)view->base + view->size, addr );
+            view->size = (char *)addr - (char *)view->base;
+            continue;
+        }
+
+        /* Slice the view by truncating the existing one and creating a new tail */
+        TRACE( "slicing view %p-%p between %p-%p\n",
+               view->base, (char *)view->base + view->size, addr, end );
+
+        new_size = (char *)view->base + view->size - end;
+        view->size = (char *)addr - (char *)view->base;
+
+        /* Temporarily force VPROT_NOEXEC to avoid a potential mprotect call */
+        if (!create_view( &new_view, end, new_size, view->protect|VPROT_NOEXEC ))
+        {
+            memcpy( &new_view->prot[0],
+                    &view->prot[(end - (char *)view->base) >> page_shift],
+                    new_size >> page_shift );
+            if (!(view->protect & VPROT_NOEXEC))
+                new_view->protect &= ~VPROT_NOEXEC;
+        }
+        break;
+    }
+
+done:
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return ret;
+}
+
+static void *virtual_mremap_wrapper( void *addr, size_t old_len, size_t new_len, int flags, ...)
+{
+    struct file_view *view;
+    void *ptr = (void *)-1;
+    sigset_t sigset;
+    char *old_end;
+
+    ERR( "%p, %lu, %lu, 0x%x, ...\n", addr, (ULONG_PTR)old_len, (ULONG_PTR)new_len, flags );
+
+    if ((flags & MREMAP_FIXED))
+    {
+        va_list args;
+
+        va_start( args, flags );
+        ptr = va_arg( args, void* );
+        va_end( args );
+
+        if ((ptr=wine_mremap( addr, old_len, new_len, flags, ptr )) != (void *)-1)
+            virtual_munmap_wrapper( addr, old_len );
+        return ptr;
+    }
+
+    if ((flags & ~MREMAP_MAYMOVE) != 0)
+    {
+        errno = EINVAL;
+        return (void *)-1;
+    }
+
+    old_len = ROUND_SIZE( addr, old_len );
+    new_len = ROUND_SIZE( addr, new_len );
+    addr    = ROUND_ADDR( addr, page_mask );
+    old_end = (char *)addr + old_len;
+
+    /* If the new mapping is smaller than the old, just unmap the end */
+    if (new_len <= old_len)
+    {
+        if (new_len < old_len)
+        {
+            /* Shouldn't error... */
+            if (virtual_munmap_wrapper( (char *)addr + new_len, old_len - new_len ) != 0)
+                return (void *)-1;
+        }
+        return addr;
+    }
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    /* Make sure the new area does not wrap */
+    if ((char *)addr + new_len < (char *)addr)
+    {
+        /* Try to extend the view */
+        switch (wine_mmap_is_in_reserved_area( addr, new_len ))
+        {
+        case -1: /* partially in a reserved area */
+            break;
+        case 0:  /* not in a reserved area, do a normal remap */
+            ptr = wine_mremap( addr, old_len, new_len, 0 );
+            break;
+        default:
+        case 1:  /* in a reserved area, make sure the address is available */
+            if (!find_view_range( old_end, new_len-old_len ))
+                ptr = wine_mremap( addr, old_len, new_len, 0 );
+            break;
+        }
+    }
+
+    if (ptr != (void *)-1)
+    {
+        /* FIXME: What protections to give the new mappings? */
+        WORD vprot = VPROT_COMMITTED | VPROT_SYSTEM | VPROT_NOEXEC;
+        create_view( &view, old_end, new_len-old_len, vprot );
+    }
+    else if ((flags & MREMAP_MAYMOVE))
+    {
+        struct alloc_area alloc;
+
+        /* Couldn't modify existing view; find a new area */
+        alloc.size = new_len;
+        alloc.mask = page_mask;
+        alloc.top_down = 1;
+        alloc.limit = address_space_limit;
+        if (!wine_mmap_enum_reserved_areas( alloc_reserved_area_callback, &alloc, 1 ))
+        {
+            errno = ENOMEM;
+            goto done;
+        }
+
+        ptr = wine_mremap( addr, old_len, new_len, MREMAP_MAYMOVE|MREMAP_FIXED, alloc.result );
+        if (ptr != (void *)-1)
+        {
+            /* FIXME: What protections to give the new mappings? */
+            WORD vprot = VPROT_COMMITTED | VPROT_SYSTEM | VPROT_NOEXEC;
+            create_view( &view, ptr, new_len, vprot );
+
+            virtual_munmap_wrapper( addr, old_len );
+        }
+        else
+        {
+            WARN( "Failed to remap %p-%p to %p-%p\n",
+                   addr, (char *)addr + old_len,
+                   alloc.result, (char *)alloc.result + new_len );
+        }
+    }
+
+done:
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    ERR( "return %p;\n", ptr );
+    abort();
+    return ptr;
+}
+
+
+/***********************************************************************
  *           map_file_into_view
  *
  * Wrapper for mmap() to map a file into a view, falling back to read if mmap fails.
@@ -877,7 +1165,7 @@ static NTSTATUS map_file_into_view( struct file_view *view, int fd, size_t start
     {
         int flags = MAP_FIXED | (shared_write ? MAP_SHARED : MAP_PRIVATE);
 
-        if (mmap( (char *)view->base + start, size, prot, flags, fd, offset ) != (void *)-1)
+        if (wine_mmap( (char *)view->base + start, size, prot, flags, fd, offset ) != (void *)-1)
             goto done;
 
         if ((errno == EPERM) && (prot & PROT_EXEC))
@@ -994,7 +1282,7 @@ static NTSTATUS allocate_dos_memory( struct file_view **view, unsigned int vprot
         addr = wine_anon_mmap( low_64k, dosmem_size - 0x10000, unix_prot, 0 );
         if (addr != low_64k)
         {
-            if (addr != (void *)-1) munmap( addr, dosmem_size - 0x10000 );
+            if (addr != (void *)-1) wine_munmap( addr, dosmem_size - 0x10000 );
             return map_view( view, NULL, dosmem_size, 0xffff, 0, vprot );
         }
     }
@@ -1015,7 +1303,7 @@ static NTSTATUS allocate_dos_memory( struct file_view **view, unsigned int vprot
         }
         else
         {
-            if (addr != (void *)-1) munmap( addr, 0x10000 - page_size );
+            if (addr != (void *)-1) wine_munmap( addr, 0x10000 - page_size );
             addr = low_64k;
             TRACE( "failed to map low 64K range\n" );
         }
@@ -1442,7 +1730,17 @@ void virtual_init(void)
  */
 void virtual_init_threading(void)
 {
-    use_locks = 1;
+}
+
+
+/***********************************************************************
+ *           virtual_init_mmap
+ */
+void virtual_init_mmap(void)
+{
+    wine_hook_mmap = virtual_mmap_wrapper;
+    wine_hook_munmap = virtual_munmap_wrapper;
+    wine_hook_mremap = virtual_mremap_wrapper;
 }
 
 
@@ -1616,7 +1914,6 @@ BOOL virtual_handle_stack_fault( void *addr )
     struct file_view *view;
     BOOL ret = FALSE;
 
-    RtlEnterCriticalSection( &csVirtual );  /* no need for signal masking inside signal handler */
     if ((view = VIRTUAL_FindView( addr, 0 )))
     {
         void *page = ROUND_ADDR( addr, page_mask );
@@ -1633,7 +1930,6 @@ BOOL virtual_handle_stack_fault( void *addr )
             ret = TRUE;
         }
     }
-    RtlLeaveCriticalSection( &csVirtual );
     return ret;
 }
 
@@ -1914,7 +2210,7 @@ NTSTATUS WINAPI NtAllocateVirtualMemory( HANDLE process, PVOID *ret, ULONG zero_
 
     /* Reserve the memory */
 
-    if (use_locks) server_enter_uninterrupted_section( &csVirtual, &sigset );
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
 
     if ((type & MEM_RESERVE) || !base)
     {
@@ -1944,7 +2240,7 @@ NTSTATUS WINAPI NtAllocateVirtualMemory( HANDLE process, PVOID *ret, ULONG zero_
         }
     }
 
-    if (use_locks) server_leave_uninterrupted_section( &csVirtual, &sigset );
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
 
     if (status == STATUS_SUCCESS)
     {
diff --git a/dlls/quartz/parser.c b/dlls/quartz/parser.c
index 784c528..064a333 100644
--- a/dlls/quartz/parser.c
+++ b/dlls/quartz/parser.c
@@ -138,6 +138,8 @@ HRESULT WINAPI Parser_QueryInterface(IBaseFilter * iface, REFIID riid, LPVOID *
       || IsEqualIID(riid, &IID_IMediaFilter)
       || IsEqualIID(riid, &IID_IBaseFilter) )
         *ppv = This;
+    if (IsEqualIID(riid, &IID_IMediaSeeking))
+        *ppv = &This->sourceSeeking;
 
     if (*ppv)
     {
diff --git a/dlls/winealsa.drv/mmdevdrv.c b/dlls/winealsa.drv/mmdevdrv.c
index 8118103..407d699 100644
--- a/dlls/winealsa.drv/mmdevdrv.c
+++ b/dlls/winealsa.drv/mmdevdrv.c
@@ -1201,6 +1201,8 @@ static HRESULT WINAPI AudioClient_IsFormatSupported(IAudioClient *iface,
     const WAVEFORMATEXTENSIBLE *fmtex = (const WAVEFORMATEXTENSIBLE *)fmt;
     unsigned int max = 0, min = 0;
     int err;
+    snd_pcm_t *pcm = NULL;
+    snd_pcm_stream_t stream;
 
     TRACE("(%p)->(%x, %p, %p)\n", This, mode, fmt, out);
 
@@ -1221,10 +1223,16 @@ static HRESULT WINAPI AudioClient_IsFormatSupported(IAudioClient *iface,
 
     EnterCriticalSection(&This->lock);
 
-    if((err = snd_pcm_hw_params_any(This->pcm_handle, This->hw_params)) < 0){
-        hr = E_FAIL;
+    hr = E_FAIL;
+    if(This->dataflow == eRender)
+        stream = SND_PCM_STREAM_PLAYBACK;
+    else
+        stream = SND_PCM_STREAM_CAPTURE;
+    if((err = snd_pcm_open(&pcm, "default", stream,
+                    SND_PCM_NONBLOCK|SND_PCM_NO_AUTO_CHANNELS)) < 0)
+        goto exit;
+    if((err = snd_pcm_hw_params_any(pcm, This->hw_params)) < 0)
         goto exit;
-    }
 
     formats = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
             snd_pcm_format_mask_sizeof());
@@ -1347,6 +1355,8 @@ static HRESULT WINAPI AudioClient_IsFormatSupported(IAudioClient *iface,
     }
 
 exit:
+    if (pcm)
+        snd_pcm_close(pcm);
     LeaveCriticalSection(&This->lock);
     HeapFree(GetProcessHeap(), 0, formats);
 
@@ -1428,10 +1438,17 @@ static HRESULT WINAPI AudioClient_GetMixFormat(IAudioClient *iface,
         goto exit;
     }
 
-    if(max_channels > 2){
+    if(max_channels > 4){
+        if (max_channels > 8)
+            /* No idea about actual amount of channels */
+            fmt->Format.nChannels = 2;
+        else
+            /* Bigger than 4 gives problems, need to remap channels,
+             * since ALSA layout is not identical to windows'
+             * so it isn't handled currently */
+            fmt->Format.nChannels = 4;
         FIXME("Don't know what to do with %u channels, pretending there's "
-                "only 2 channels\n", max_channels);
-        fmt->Format.nChannels = 2;
+                "only %i channels\n", max_channels, fmt->Format.nChannels);
     }else
         fmt->Format.nChannels = max_channels;
 
diff --git a/dlls/winealsa.drv/waveout.c b/dlls/winealsa.drv/waveout.c
index 88153e7..27fbeec 100644
--- a/dlls/winealsa.drv/waveout.c
+++ b/dlls/winealsa.drv/waveout.c
@@ -1,11 +1,11 @@
 /*
- * Sample Wine Driver for Advanced Linux Sound System (ALSA)
- *      Based on version <final> of the ALSA API
+ * Wine Driver for ALSA api, based on winecoreaudio.drv
  *
  * Copyright    2002 Eric Pouech
  *              2002 Marco Pietrobono
  *              2003 Christian Costa : WaveIn support
  *              2006-2007 Maarten Lankhorst
+ *              2010 Maarten Lankhorst for Codeweavers
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -22,10 +22,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-/*======================================================================*
- *                  Low level WAVE OUT implementation			*
- *======================================================================*/
-
 #include "config.h"
 #include "wine/port.h"
 
@@ -62,1121 +58,631 @@
 #include "wine/library.h"
 #include "wine/unicode.h"
 #include "wine/debug.h"
+#include "wine/list.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wave);
 
 WINE_WAVEDEV	*WOutDev;
-DWORD            ALSA_WodNumMallocedDevs;
-DWORD            ALSA_WodNumDevs;
+DWORD           ALSA_WodNumMallocedDevs;
+DWORD           ALSA_WodNumDevs;
 
-/**************************************************************************
- * 			wodNotifyClient			[internal]
- */
-static void wodNotifyClient(WINE_WAVEDEV* wwo, WORD wMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
-{
-    TRACE("wMsg = 0x%04x dwParm1 = %lx dwParam2 = %lx\n", wMsg, dwParam1, dwParam2);
+static DWORD wave_timerid;
 
-    switch (wMsg) {
-    case WOM_OPEN:
-    case WOM_CLOSE:
-    case WOM_DONE:
-        DriverCallback(wwo->waveDesc.dwCallback, wwo->wFlags, (HDRVR)wwo->waveDesc.hWave,
-                       wMsg, wwo->waveDesc.dwInstance, dwParam1, dwParam2);
-	break;
-    default:
-	FIXME("Unknown callback message %u\n", wMsg);
-    }
-}
+typedef struct waveimpl {
+    DWORD devid;
+    WCHAR *friendlyname;
+    DWORD vol;
+    CRITICAL_SECTION crst;
+    struct list head;
+} waveimpl;
 
-/**************************************************************************
- * 				wodUpdatePlayedTotal	[internal]
- *
- */
-static BOOL wodUpdatePlayedTotal(WINE_WAVEDEV* wwo, snd_pcm_status_t* ps)
-{
-    snd_pcm_sframes_t delay;
-    snd_pcm_sframes_t avail;
-    snd_pcm_uframes_t buf_size = 0;
-    snd_pcm_state_t state;
-
-    state = snd_pcm_state(wwo->pcm);
-    avail = snd_pcm_avail_update(wwo->pcm);
-    snd_pcm_hw_params_get_buffer_size(wwo->hw_params, &buf_size);
-    delay = buf_size - avail;
-
-    if (state != SND_PCM_STATE_RUNNING && state != SND_PCM_STATE_PREPARED)
-    {
-        WARN("Unexpected state (%d) while updating Total Played, resetting\n", state);
-        wine_snd_pcm_recover(wwo->pcm, -EPIPE, 0);
-        delay=0;
-    }
+typedef struct wavestreamimpl {
+    WAVEFORMATEX *wfx;
 
-    /* A delay < 0 indicates an underrun; for our purposes that's 0.  */
-    if (delay < 0)
-    {
-        WARN("Unexpected delay (%ld) while updating Total Played, resetting\n", delay);
-        delay=0;
-    }
+    WAVEHDR *queue, *loop;
+    DWORD ofs, numloops, stopped, bytesplayed;
 
-    InterlockedExchange((LONG*)&wwo->dwPlayedTotal, wwo->dwWrittenTotal - snd_pcm_frames_to_bytes(wwo->pcm, delay));
-    return TRUE;
-}
+    /* callback stuff */
+    DWORD_PTR cbflags, cbhandle, cbinstance;
+    HDRVR wavehandle;
 
-/**************************************************************************
- * 				wodPlayer_BeginWaveHdr          [internal]
- *
- * Makes the specified lpWaveHdr the currently playing wave header.
- * If the specified wave header is a begin loop and we're not already in
- * a loop, setup the loop.
- */
-static void wodPlayer_BeginWaveHdr(WINE_WAVEDEV* wwo, LPWAVEHDR lpWaveHdr)
-{
-    wwo->lpPlayPtr = lpWaveHdr;
-
-    if (!lpWaveHdr) return;
-
-    if (lpWaveHdr->dwFlags & WHDR_BEGINLOOP) {
-	if (wwo->lpLoopPtr) {
-	    WARN("Already in a loop. Discarding loop on this header (%p)\n", lpWaveHdr);
-	} else {
-            TRACE("Starting loop (%dx) with %p\n", lpWaveHdr->dwLoops, lpWaveHdr);
-	    wwo->lpLoopPtr = lpWaveHdr;
-	    /* Windows does not touch WAVEHDR.dwLoops,
-	     * so we need to make an internal copy */
-	    wwo->dwLoops = lpWaveHdr->dwLoops;
-	}
-    }
-    wwo->dwPartialOffset = 0;
-}
-
-/**************************************************************************
- * 				wodPlayer_PlayPtrNext	        [internal]
- *
- * Advance the play pointer to the next waveheader, looping if required.
- */
-static LPWAVEHDR wodPlayer_PlayPtrNext(WINE_WAVEDEV* wwo)
-{
-    LPWAVEHDR lpWaveHdr = wwo->lpPlayPtr;
-
-    wwo->dwPartialOffset = 0;
-    if ((lpWaveHdr->dwFlags & WHDR_ENDLOOP) && wwo->lpLoopPtr) {
-	/* We're at the end of a loop, loop if required */
-	if (--wwo->dwLoops > 0) {
-	    wwo->lpPlayPtr = wwo->lpLoopPtr;
-	} else {
-	    /* Handle overlapping loops correctly */
-	    if (wwo->lpLoopPtr != lpWaveHdr && (lpWaveHdr->dwFlags & WHDR_BEGINLOOP)) {
-		FIXME("Correctly handled case ? (ending loop buffer also starts a new loop)\n");
-		/* shall we consider the END flag for the closing loop or for
-		 * the opening one or for both ???
-		 * code assumes for closing loop only
-		 */
-	    } else {
-                lpWaveHdr = lpWaveHdr->lpNext;
-            }
-            wwo->lpLoopPtr = NULL;
-            wodPlayer_BeginWaveHdr(wwo, lpWaveHdr);
-	}
-    } else {
-	/* We're not in a loop.  Advance to the next wave header */
-	wodPlayer_BeginWaveHdr(wwo, lpWaveHdr = lpWaveHdr->lpNext);
-    }
+    struct list entry;
+    DWORD cachevol;
+    snd_pcm_hw_params_t *hw_params;
+    snd_pcm_t *pcm;
+} wavestreamimpl;
 
-    return lpWaveHdr;
-}
+static waveimpl *waveout_head;
+static DWORD waveout_count;
 
-/**************************************************************************
- * 			     wodPlayer_DSPWait			[internal]
- * Returns the number of milliseconds to wait for the DSP buffer to play a
- * period
- */
-static DWORD wodPlayer_DSPWait(const WINE_WAVEDEV *wwo)
-{
-    /* time for one period to be played */
-    unsigned int val=0;
-    int dir=0;
-    int err=0;
-    err = snd_pcm_hw_params_get_period_time(wwo->hw_params, &val, &dir);
-    return val / 1000;
+static void wodNotifyClient(wavestreamimpl *wwo, DWORD msg, DWORD_PTR par1, DWORD_PTR par2) {
+    DriverCallback(wwo->cbhandle, wwo->cbflags, wwo->wavehandle,
+                   msg, wwo->cbinstance, par1, par2);
 }
 
-/**************************************************************************
- * 			     wodPlayer_NotifyWait               [internal]
- * Returns the number of milliseconds to wait before attempting to notify
- * completion of the specified wavehdr.
- * This is based on the number of bytes remaining to be written in the
- * wave.
- */
-static DWORD wodPlayer_NotifyWait(const WINE_WAVEDEV* wwo, LPWAVEHDR lpWaveHdr)
-{
-    DWORD dwMillis;
-
-    if (lpWaveHdr->reserved < wwo->dwPlayedTotal) {
-        dwMillis = 1;
-    } else {
-        dwMillis = (lpWaveHdr->reserved - wwo->dwPlayedTotal) * 1000 / wwo->format.Format.nAvgBytesPerSec;
-        if (!dwMillis) dwMillis = 1;
-    }
-
-    return dwMillis;
-}
+static void wodNotifyDoneList(wavestreamimpl *wwo, LPWAVEHDR lpWaveHdr) {
+    while (lpWaveHdr) {
+        LPWAVEHDR lpNext = lpWaveHdr->lpNext;
 
+        lpWaveHdr->lpNext = NULL;
+        lpWaveHdr->dwFlags = (lpWaveHdr->dwFlags & ~WHDR_INQUEUE) | WHDR_DONE;
+        wodNotifyClient(wwo, WOM_DONE, (DWORD_PTR)lpWaveHdr, 0);
 
-/**************************************************************************
- * 			     wodPlayer_WriteMaxFrags            [internal]
- * Writes the maximum number of frames possible to the DSP and returns
- * the number of frames written.
- */
-static int wodPlayer_WriteMaxFrags(WINE_WAVEDEV* wwo, DWORD* frames)
-{
-    /* Only attempt to write to free frames */
-    LPWAVEHDR lpWaveHdr = wwo->lpPlayPtr;
-    DWORD dwLength = snd_pcm_bytes_to_frames(wwo->pcm, lpWaveHdr->dwBufferLength - wwo->dwPartialOffset);
-    int toWrite = min(dwLength, *frames);
-    int written;
-
-    TRACE("Writing wavehdr %p.%u[%u]\n", lpWaveHdr, wwo->dwPartialOffset, lpWaveHdr->dwBufferLength);
-
-    if (toWrite > 0) {
-	written = (wwo->write)(wwo->pcm, lpWaveHdr->lpData + wwo->dwPartialOffset, toWrite);
-	if ( written < 0) {
-	    /* XRUN occurred. let's try to recover */
-	    wine_snd_pcm_recover(wwo->pcm, written, 0);
-	    written = (wwo->write)(wwo->pcm, lpWaveHdr->lpData + wwo->dwPartialOffset, toWrite);
-	}
-	if (written <= 0) {
-	    /* still in error */
-	    ERR("Error in writing wavehdr. Reason: %s\n", snd_strerror(written));
-	    return written;
-	}
-    } else
-	written = 0;
-
-    wwo->dwPartialOffset += snd_pcm_frames_to_bytes(wwo->pcm, written);
-    if (wwo->dwPartialOffset + wwo->format.Format.nBlockAlign - 1 >= lpWaveHdr->dwBufferLength) {
-	/* this will be used to check if the given wave header has been fully played or not... */
-	wwo->dwPartialOffset = lpWaveHdr->dwBufferLength;
-	/* If we wrote all current wavehdr, skip to the next one */
-	wodPlayer_PlayPtrNext(wwo);
+        lpWaveHdr = lpNext;
     }
-    *frames -= written;
-    wwo->dwWrittenTotal += snd_pcm_frames_to_bytes(wwo->pcm, written);
-    TRACE("dwWrittenTotal=%u\n", wwo->dwWrittenTotal);
-
-    return written;
 }
 
+static void wodNext(wavestreamimpl *wwo, WAVEHDR **beginnotify, WAVEHDR **endnotify) {
+    LPWAVEHDR hdr = wwo->queue;
 
-/**************************************************************************
- * 				wodPlayer_NotifyCompletions	[internal]
- *
- * Notifies and remove from queue all wavehdrs which have been played to
- * the speaker (ie. they have cleared the ALSA buffer).  If force is true,
- * we notify all wavehdrs and remove them all from the queue even if they
- * are unplayed or part of a loop.
- */
-static DWORD wodPlayer_NotifyCompletions(WINE_WAVEDEV* wwo, BOOL force)
-{
-    LPWAVEHDR		lpWaveHdr;
-
-    /* Start from lpQueuePtr and keep notifying until:
-     * - we hit an unwritten wavehdr
-     * - we hit the beginning of a running loop
-     * - we hit a wavehdr which hasn't finished playing
-     */
-    for (;;)
-    {
-        lpWaveHdr = wwo->lpQueuePtr;
-        if (!lpWaveHdr) {TRACE("Empty queue\n"); break;}
-        if (!force)
-        {
-            snd_pcm_uframes_t frames;
-            snd_pcm_hw_params_get_period_size(wwo->hw_params, &frames, NULL);
-
-            if (lpWaveHdr == wwo->lpPlayPtr) {TRACE("play %p\n", lpWaveHdr); break;}
-            if (lpWaveHdr == wwo->lpLoopPtr) {TRACE("loop %p\n", lpWaveHdr); break;}
-            if (lpWaveHdr->reserved > wwo->dwPlayedTotal + frames) {TRACE("still playing %p (%lu/%u)\n", lpWaveHdr, lpWaveHdr->reserved, wwo->dwPlayedTotal);break;}
+    hdr->dwBytesRecorded = wwo->ofs;
+    wwo->ofs = 0;
+    if (wwo->loop && wwo->queue->dwFlags & WHDR_ENDLOOP) {
+        if (wwo->numloops-- > 1) {
+            wwo->queue = wwo->loop;
+            return;
         }
-        wwo->dwPlayedTotal += lpWaveHdr->reserved - wwo->dwPlayedTotal;
-	wwo->lpQueuePtr = lpWaveHdr->lpNext;
 
-	lpWaveHdr->dwFlags &= ~WHDR_INQUEUE;
-	lpWaveHdr->dwFlags |= WHDR_DONE;
-
-	wodNotifyClient(wwo, WOM_DONE, (DWORD_PTR)lpWaveHdr, 0);
+        if (!*beginnotify)
+            *beginnotify = wwo->loop;
+        wwo->loop = NULL;
     }
-    return  (lpWaveHdr && lpWaveHdr != wwo->lpPlayPtr && lpWaveHdr != wwo->lpLoopPtr) ?
-        wodPlayer_NotifyWait(wwo, lpWaveHdr) : INFINITE;
-}
-
 
-/**************************************************************************
- * 				wodPlayer_Reset			[internal]
- *
- * wodPlayer helper. Resets current output stream.
- */
-static	void	wodPlayer_Reset(WINE_WAVEDEV* wwo, BOOL reset)
-{
-    int                         err;
-    TRACE("(%p)\n", wwo);
-
-    wodUpdatePlayedTotal(wwo, NULL);
-    /* updates current notify list */
-    wodPlayer_NotifyCompletions(wwo, FALSE);
-
-    if ( (err = snd_pcm_drop(wwo->pcm)) < 0) {
-	FIXME("flush: %s\n", snd_strerror(err));
-	wwo->hThread = 0;
-	wwo->state = WINE_WS_STOPPED;
-	ExitThread(-1);
+    if (!wwo->loop) {
+        if (!*beginnotify)
+            *beginnotify = hdr;
+        *endnotify = hdr;
     }
-    if ( (err = snd_pcm_prepare(wwo->pcm)) < 0 )
-        ERR("pcm prepare failed: %s\n", snd_strerror(err));
-
-    if (reset) {
-        enum win_wm_message	msg;
-        DWORD_PTR	        param;
-        HANDLE		        ev;
-
-        /* remove any buffer */
-        wodPlayer_NotifyCompletions(wwo, TRUE);
-
-        wwo->lpPlayPtr = wwo->lpQueuePtr = wwo->lpLoopPtr = NULL;
-        wwo->state = WINE_WS_STOPPED;
-        wwo->dwPlayedTotal = wwo->dwWrittenTotal = 0;
-        /* Clear partial wavehdr */
-        wwo->dwPartialOffset = 0;
-
-        /* remove any existing message in the ring */
-        EnterCriticalSection(&wwo->msgRing.msg_crst);
-        /* return all pending headers in queue */
-        while (ALSA_RetrieveRingMessage(&wwo->msgRing, &msg, &param, &ev))
-        {
-            if (msg != WINE_WM_HEADER)
-            {
-                FIXME("shouldn't have headers left\n");
-                SetEvent(ev);
-                continue;
-            }
-            ((LPWAVEHDR)param)->dwFlags &= ~WHDR_INQUEUE;
-            ((LPWAVEHDR)param)->dwFlags |= WHDR_DONE;
+    wwo->queue = hdr->lpNext;
 
-            wodNotifyClient(wwo, WOM_DONE, param, 0);
-        }
-        ALSA_ResetRingMessage(&wwo->msgRing);
-        LeaveCriticalSection(&wwo->msgRing.msg_crst);
-    } else {
-        if (wwo->lpLoopPtr) {
-            /* complicated case, not handled yet (could imply modifying the loop counter */
-            FIXME("Pausing while in loop isn't correctly handled yet, expect strange results\n");
-            wwo->lpPlayPtr = wwo->lpLoopPtr;
-            wwo->dwPartialOffset = 0;
-            wwo->dwWrittenTotal = wwo->dwPlayedTotal; /* this is wrong !!! */
-        } else {
-            LPWAVEHDR   ptr;
-            DWORD       sz = wwo->dwPartialOffset;
-
-            /* reset all the data as if we had written only up to lpPlayedTotal bytes */
-            /* compute the max size playable from lpQueuePtr */
-            for (ptr = wwo->lpQueuePtr; ptr != wwo->lpPlayPtr; ptr = ptr->lpNext) {
-                sz += ptr->dwBufferLength;
-            }
-            /* because the reset lpPlayPtr will be lpQueuePtr */
-            if (wwo->dwWrittenTotal > wwo->dwPlayedTotal + sz) ERR("grin\n");
-            wwo->dwPartialOffset = sz - (wwo->dwWrittenTotal - wwo->dwPlayedTotal);
-            wwo->dwWrittenTotal = wwo->dwPlayedTotal;
-            wwo->lpPlayPtr = wwo->lpQueuePtr;
-        }
-        wwo->state = WINE_WS_PAUSED;
-    }
-}
+    if (wwo->queue && wwo->queue->dwFlags & WHDR_BEGINLOOP) {
+        if (!wwo->loop) {
+            TRACE("Starting loop (%d) with %p\n", wwo->queue->dwLoops, wwo->queue);
 
-/**************************************************************************
- * 		      wodPlayer_ProcessMessages			[internal]
- */
-static void wodPlayer_ProcessMessages(WINE_WAVEDEV* wwo)
-{
-    LPWAVEHDR           lpWaveHdr;
-    enum win_wm_message	msg;
-    DWORD_PTR		param;
-    HANDLE		ev;
-    int                 err;
-
-    while (ALSA_RetrieveRingMessage(&wwo->msgRing, &msg, &param, &ev)) {
-     TRACE("Received %s %lx\n", ALSA_getCmdString(msg), param);
-
-	switch (msg) {
-	case WINE_WM_PAUSING:
-	    if ( snd_pcm_state(wwo->pcm) == SND_PCM_STATE_RUNNING )
-	     {
-                if ( snd_pcm_hw_params_can_pause(wwo->hw_params) )
-		{
-		    err = snd_pcm_pause(wwo->pcm, 1);
-		    if ( err < 0 )
-			ERR("pcm_pause failed: %s\n", snd_strerror(err));
-		    wwo->state = WINE_WS_PAUSED;
-		}
-		else
-		{
-		    wodPlayer_Reset(wwo,FALSE);
-		}
-	     }
-	    SetEvent(ev);
-	    break;
-	case WINE_WM_RESTARTING:
-            if (wwo->state == WINE_WS_PAUSED)
-            {
-		if ( snd_pcm_state(wwo->pcm) == SND_PCM_STATE_PAUSED )
-		 {
-		    err = snd_pcm_pause(wwo->pcm, 0);
-		    if ( err < 0 )
-		        ERR("pcm_pause failed: %s\n", snd_strerror(err));
-		 }
-                wwo->state = WINE_WS_PLAYING;
-            }
-	    SetEvent(ev);
-	    break;
-	case WINE_WM_HEADER:
-	    lpWaveHdr = (LPWAVEHDR)param;
-
-	    /* insert buffer at the end of queue */
-	    {
-		LPWAVEHDR*	wh;
-		for (wh = &(wwo->lpQueuePtr); *wh; wh = &((*wh)->lpNext));
-		*wh = lpWaveHdr;
-	    }
-            if (!wwo->lpPlayPtr)
-                wodPlayer_BeginWaveHdr(wwo,lpWaveHdr);
-	    if (wwo->state == WINE_WS_STOPPED)
-		wwo->state = WINE_WS_PLAYING;
-	    break;
-	case WINE_WM_RESETTING:
-	    wodPlayer_Reset(wwo,TRUE);
-	    SetEvent(ev);
-	    break;
-        case WINE_WM_BREAKLOOP:
-            if (wwo->state == WINE_WS_PLAYING && wwo->lpLoopPtr != NULL) {
-                /* ensure exit at end of current loop */
-                wwo->dwLoops = 1;
-            }
-	    SetEvent(ev);
-            break;
-	case WINE_WM_CLOSING:
-	    /* sanity check: this should not happen since the device must have been reset before */
-	    if (wwo->lpQueuePtr || wwo->lpPlayPtr) ERR("out of sync\n");
-	    wwo->hThread = 0;
-	    wwo->state = WINE_WS_CLOSED;
-	    SetEvent(ev);
-	    ExitThread(0);
-	    /* shouldn't go here */
-	default:
-	    FIXME("unknown message %d\n", msg);
-	    break;
-	}
+            wwo->loop = wwo->queue;
+            wwo->numloops = wwo->queue->dwLoops;
+        } else
+            WARN("Already in a loop. Discarding loop on this header (%p)\n", wwo->queue);
     }
 }
 
-/**************************************************************************
- * 			     wodPlayer_FeedDSP			[internal]
- * Feed as much sound data as we can into the DSP and return the number of
- * milliseconds before it will be necessary to feed the DSP again.
- */
-static DWORD wodPlayer_FeedDSP(WINE_WAVEDEV* wwo)
-{
-    DWORD               availInQ;
+static void CALLBACK wodTick(UINT id, UINT msg, DWORD_PTR dwUser,
+                             DWORD_PTR dw1, DWORD_PTR dw2) {
+    DWORD x;
+    wavestreamimpl *cur;
 
-    wodUpdatePlayedTotal(wwo, NULL);
-    availInQ = snd_pcm_avail_update(wwo->pcm);
+    for (x = 0; x < waveout_count; ++x) {
+        EnterCriticalSection(&waveout_head[x].crst);
+        LIST_FOR_EACH_ENTRY(cur, &waveout_head[x].head, wavestreamimpl, entry) {
+            DWORD pad, avail;
+            WAVEHDR *begin = NULL, *end = NULL;
+            DWORD block = cur->wfx->nBlockAlign;
+            snd_pcm_uframes_t buflen, psize;
 
-    /* no more room... no need to try to feed */
-    if (availInQ > 0) {
-        /* Feed from partial wavehdr */
-        if (wwo->lpPlayPtr && wwo->dwPartialOffset != 0) {
-            wodPlayer_WriteMaxFrags(wwo, &availInQ);
-        }
-
-        /* Feed wavehdrs until we run out of wavehdrs or DSP space */
-        if (wwo->dwPartialOffset == 0 && wwo->lpPlayPtr) {
-            do {
-                TRACE("Setting time to elapse for %p to %u\n",
-                      wwo->lpPlayPtr, wwo->dwWrittenTotal + wwo->lpPlayPtr->dwBufferLength);
-                /* note the value that dwPlayedTotal will return when this wave finishes playing */
-                wwo->lpPlayPtr->reserved = wwo->dwWrittenTotal + wwo->lpPlayPtr->dwBufferLength;
-            } while (wodPlayer_WriteMaxFrags(wwo, &availInQ) && wwo->lpPlayPtr && availInQ > 0);
+            if (cur->stopped)
+                continue;
+            snd_pcm_hw_params_get_buffer_size(cur->hw_params, &buflen);
+            snd_pcm_hw_params_get_period_size(cur->hw_params, &psize, NULL);
+            if (buflen > 4 * psize)
+                buflen = 4 * psize;
+            pad = snd_pcm_avail_update(cur->pcm);
+            if (pad > buflen)
+                pad = buflen;
+            pad *= block;
+
+            while (pad && cur->queue) {
+                int ret;
+                avail = cur->queue->dwBufferLength - cur->ofs;
+                if (avail > pad)
+                    avail = pad;
+
+                ret = snd_pcm_writei(cur->pcm, cur->queue->lpData + cur->ofs, avail/block);
+                if (ret < 0) {
+                    ret = wine_snd_pcm_recover(cur->pcm, ret, 0);
+                    if (ret >= 0)
+                        ret = snd_pcm_writei(cur->pcm, cur->queue->lpData + cur->ofs, avail/block);
+                    else {
+                        WARN("Could not write: %s\n", snd_strerror(ret));
+                        break;
+                    }
+                }
+                avail = ret * block;
+                cur->ofs += avail;
+                pad -= avail;
+                if (cur->queue->dwBufferLength - cur->ofs < block)
+                    wodNext(cur, &begin, &end);
+                cur->bytesplayed += avail;
+            }
+            if (begin) {
+                end->lpNext = NULL;
+                wodNotifyDoneList(cur, begin);
+            }
         }
+        LeaveCriticalSection(&waveout_head[x].crst);
     }
-
-    return wodPlayer_DSPWait(wwo);
 }
 
-/**************************************************************************
- * 				wodPlayer			[internal]
- */
-static	DWORD	CALLBACK	wodPlayer(LPVOID pmt)
-{
-    WORD	  uDevID = (DWORD_PTR)pmt;
-    WINE_WAVEDEV* wwo = &WOutDev[uDevID];
-    DWORD         dwNextFeedTime = INFINITE;   /* Time before DSP needs feeding */
-    DWORD         dwNextNotifyTime = INFINITE; /* Time before next wave completion */
-    DWORD         dwSleepTime;
-
-    wwo->state = WINE_WS_STOPPED;
-    SetEvent(wwo->hStartUpEvent);
-
-    for (;;) {
-        /** Wait for the shortest time before an action is required.  If there
-         *  are no pending actions, wait forever for a command.
-         */
-        dwSleepTime = min(dwNextFeedTime, dwNextNotifyTime);
-        TRACE("waiting %ums (%u,%u)\n", dwSleepTime, dwNextFeedTime, dwNextNotifyTime);
-        ALSA_WaitRingMessage(&wwo->msgRing, dwSleepTime);
-	wodPlayer_ProcessMessages(wwo);
-	if (wwo->state == WINE_WS_PLAYING) {
-	    dwNextFeedTime = wodPlayer_FeedDSP(wwo);
-	    dwNextNotifyTime = wodPlayer_NotifyCompletions(wwo, FALSE);
-	    if (dwNextFeedTime == INFINITE) {
-		/* FeedDSP ran out of data, but before giving up, */
-		/* check that a notification didn't give us more */
-		wodPlayer_ProcessMessages(wwo);
-		if (wwo->lpPlayPtr) {
-		    TRACE("recovering\n");
-		    dwNextFeedTime = wodPlayer_FeedDSP(wwo);
-		}
-	    }
-	} else {
-	    dwNextFeedTime = dwNextNotifyTime = INFINITE;
-	}
-    }
-    return 0;
-}
-
-/**************************************************************************
- * 			wodGetDevCaps				[internal]
- */
-static DWORD wodGetDevCaps(WORD wDevID, LPWAVEOUTCAPSW lpCaps, DWORD dwSize)
-{
-    TRACE("(%u, %p, %u);\n", wDevID, lpCaps, dwSize);
-
-    if (lpCaps == NULL) return MMSYSERR_NOTENABLED;
-
-    if (wDevID >= ALSA_WodNumDevs) {
-	TRACE("Asked for device %d, but only %d known!\n", wDevID, ALSA_WodNumDevs);
-	return MMSYSERR_BADDEVICEID;
-    }
-
-    memcpy(lpCaps, &WOutDev[wDevID].outcaps, min(dwSize, sizeof(*lpCaps)));
+static DWORD wodGetDevCaps(waveimpl *dev, LPWAVEOUTCAPSW lpCaps, DWORD dwSize) {
+    WAVEOUTCAPSW caps;
+    TRACE("(%p, %p, %u)\n", dev, lpCaps, dwSize);
+
+    if (!lpCaps)
+        return MMSYSERR_NOTENABLED;
+
+    caps.wMid = MM_CREATIVE;
+    caps.wPid = MM_CREATIVE_SBP16_WAVEOUT;
+    caps.vDriverVersion = 0x0100;
+    lstrcpynW(caps.szPname, dev->friendlyname, sizeof(caps.szPname)/sizeof(*caps.szPname));
+    caps.dwFormats = 0xfffff;
+    caps.wChannels = 2;
+    caps.wReserved1 = 1;
+    caps.dwSupport = WAVECAPS_SAMPLEACCURATE|WAVECAPS_VOLUME
+                     |WAVECAPS_LRVOLUME|WAVECAPS_DIRECTSOUND;
+    memcpy(lpCaps, &caps, min(dwSize, sizeof(caps)));
     return MMSYSERR_NOERROR;
 }
 
-/**************************************************************************
- * 				wodOpen				[internal]
- */
-static DWORD wodOpen(WORD wDevID, LPWAVEOPENDESC lpDesc, DWORD dwFlags)
-{
-    WINE_WAVEDEV*	        wwo;
-    snd_pcm_t *                 pcm = NULL;
-    snd_hctl_t *                hctl = NULL;
-    snd_pcm_hw_params_t *       hw_params;
-    snd_pcm_sw_params_t *       sw_params;
-    snd_pcm_access_t            access;
-    snd_pcm_format_t            format = -1;
-    unsigned int                rate;
-    unsigned int                buffer_time = 120000;
-    unsigned int                period_time = 22000;
-    snd_pcm_uframes_t           buffer_size;
-    snd_pcm_uframes_t           period_size;
-    int                         flags;
-    int                         err=0;
-    int                         dir=0;
-    DWORD                       retcode = 0;
-
-    TRACE("(%u, %p, %08X);\n", wDevID, lpDesc, dwFlags);
-    if (lpDesc == NULL) {
-	WARN("Invalid Parameter !\n");
-	return MMSYSERR_INVALPARAM;
-    }
-    if (wDevID >= ALSA_WodNumDevs) {
-	TRACE("Asked for device %d, but only %d known!\n", wDevID, ALSA_WodNumDevs);
-	return MMSYSERR_BADDEVICEID;
-    }
-
-    /* only PCM format is supported so far... */
-    if (!ALSA_supportedFormat(lpDesc->lpFormat)) {
-	WARN("Bad format: tag=%04X nChannels=%d nSamplesPerSec=%d !\n",
-	     lpDesc->lpFormat->wFormatTag, lpDesc->lpFormat->nChannels,
-	     lpDesc->lpFormat->nSamplesPerSec);
-	return WAVERR_BADFORMAT;
-    }
-
-    if (dwFlags & WAVE_FORMAT_QUERY) {
-	TRACE("Query format: tag=%04X nChannels=%d nSamplesPerSec=%d !\n",
-	     lpDesc->lpFormat->wFormatTag, lpDesc->lpFormat->nChannels,
-	     lpDesc->lpFormat->nSamplesPerSec);
-	return MMSYSERR_NOERROR;
-    }
+static snd_pcm_format_t get_format(WAVEFORMATEX *wfx) {
+    WAVEFORMATEXTENSIBLE *wfe = (WAVEFORMATEXTENSIBLE *)wfx;
 
-    wwo = &WOutDev[wDevID];
-
-    if (wwo->pcm != NULL) {
-        WARN("%d already allocated\n", wDevID);
-        return MMSYSERR_ALLOCATED;
-    }
-
-    if (dwFlags & WAVE_DIRECTSOUND)
-        FIXME("Why are we called with DirectSound flag? It doesn't use MMSYSTEM any more\n");
-        /* not supported, ignore it */
-    dwFlags &= ~WAVE_DIRECTSOUND;
-
-    flags = SND_PCM_NONBLOCK;
-
-    if ( (err = snd_pcm_open(&pcm, wwo->pcmname, SND_PCM_STREAM_PLAYBACK, flags)) < 0)
-    {
-        ERR("Error open: %s\n", snd_strerror(err));
-	return MMSYSERR_NOTENABLED;
-    }
+    if (!wfx->nChannels || wfx->nSamplesPerSec < DSBFREQUENCY_MIN || wfx->nSamplesPerSec > DSBFREQUENCY_MAX)
+        return SND_PCM_FORMAT_UNKNOWN;
 
-    if (wwo->ctlname)
-    {
-        err = snd_hctl_open(&hctl, wwo->ctlname, 0);
-        if (err >= 0)
-        {
-            snd_hctl_load(hctl);
+    if (wfx->wFormatTag == WAVE_FORMAT_PCM) {
+        switch (wfx->wBitsPerSample) {
+            case 8: return SND_PCM_FORMAT_U8;
+            case 16: return SND_PCM_FORMAT_S16_LE;
+            default:
+                WARN("Unknown bpp for WAVE_FORMAT_PCM: %i\n", wfx->wBitsPerSample);
+                return SND_PCM_FORMAT_UNKNOWN;
         }
-        else
-        {
-            WARN("Could not open hctl for [%s]: %s\n", wwo->ctlname, snd_strerror(err));
-            hctl = NULL;
+    } else if (wfx->wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
+        if (IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)) {
+            if ((wfe->Samples.wValidBitsPerSample == 32 ||
+                !wfe->Samples.wValidBitsPerSample) &&
+                wfx->wBitsPerSample == 32)
+                return SND_PCM_FORMAT_FLOAT_LE;
+        } else if (IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM)) {
+            switch (wfx->wBitsPerSample) {
+                case 8: return SND_PCM_FORMAT_U8;
+                case 16: return SND_PCM_FORMAT_S16_LE;
+                case 24: return SND_PCM_FORMAT_S24_3LE;
+                case 32:
+                    if (wfe->Samples.wValidBitsPerSample == 32 ||
+                        !wfe->Samples.wValidBitsPerSample)
+                        return SND_PCM_FORMAT_S32_LE;
+                    if (wfe->Samples.wValidBitsPerSample == 24)
+                        return SND_PCM_FORMAT_S24_LE;
+                default:
+                    WARN("Unknown bpp for WAVE_FORMAT_PCM: %i\n", wfx->wBitsPerSample);
+                    return SND_PCM_FORMAT_UNKNOWN;
+            }
         }
     }
+    WARN("Unknown tag %x\n", wfx->wFormatTag);
+    return SND_PCM_FORMAT_UNKNOWN;
+}
 
-    wwo->wFlags = HIWORD(dwFlags & CALLBACK_TYPEMASK);
+static DWORD wodOpen(waveimpl *dev, wavestreamimpl **pInstance, LPWAVEOPENDESC lpDesc, DWORD dwFlags) {
+    wavestreamimpl *wwo;
+    WAVEFORMATEX *wfx;
+    DWORD extra, ret;
+    snd_pcm_format_t format;
+    snd_pcm_hw_params_t *hw_params;
+    snd_pcm_sw_params_t *sw_params;
+    snd_pcm_uframes_t size;
+    unsigned rate;
+    int err;
+
+    TRACE("(%p, %p, %p, %08x)\n", dev, pInstance, lpDesc, dwFlags);
+    if (!lpDesc) {
+        WARN("Invalid Parameter!\n");
+        return MMSYSERR_INVALPARAM;
+    }
+    wfx = lpDesc->lpFormat;
+
+    TRACE("Format: tag=%04X nChannels=%d nSamplesPerSec=%d wBitsPerSample=%d\n",
+          wfx->wFormatTag, wfx->nChannels, wfx->nSamplesPerSec, wfx->wBitsPerSample);
+
+    format = get_format(wfx);
+    if (format == SND_PCM_FORMAT_UNKNOWN)
+        return WAVERR_BADFORMAT;
+
+    if (wfx->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
+        extra = sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);
+    else
+        extra = 0;
 
-    wwo->waveDesc = *lpDesc;
-    ALSA_copyFormat(lpDesc->lpFormat, &wwo->format);
+    wwo = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*wwo));
+    if (!wwo)
+        return MMSYSERR_NOMEM;
 
-    TRACE("Requested this format: %dx%dx%d %s\n",
-          wwo->format.Format.nSamplesPerSec,
-          wwo->format.Format.wBitsPerSample,
-          wwo->format.Format.nChannels,
-          ALSA_getFormat(wwo->format.Format.wFormatTag));
+    ret = MMSYSERR_NOMEM;
+    wwo->wfx = HeapAlloc(GetProcessHeap(), 0, sizeof(*wwo)+extra);
+    if (!wwo->wfx)
+        goto error;
 
-    if (wwo->format.Format.wBitsPerSample == 0) {
-	WARN("Resetting zeroed wBitsPerSample\n");
-	wwo->format.Format.wBitsPerSample = 8 *
-	    (wwo->format.Format.nAvgBytesPerSec /
-	     wwo->format.Format.nSamplesPerSec) /
-	    wwo->format.Format.nChannels;
+    err = snd_pcm_open(&wwo->pcm, WOutDev[dev->devid].pcmname, SND_PCM_STREAM_PLAYBACK, SND_PCM_NONBLOCK);
+    if (err < 0) {
+        FIXME("Could not open sound device: %s\n", snd_strerror(err));
+        ret = MMSYSERR_NOTENABLED;
+        goto error;
     }
 
-#define EXIT_ON_ERROR(f,e,txt) do \
-{ \
-    int err; \
-    if ( (err = (f) ) < 0) \
-    { \
-	WARN(txt ": %s\n", snd_strerror(err)); \
-	retcode=e; \
-	goto errexit; \
-    } \
-} while(0)
+    if (wfx->wFormatTag == WAVE_FORMAT_PCM)
+        memcpy(wwo->wfx, wfx, sizeof(PCMWAVEFORMAT));
+    else
+        memcpy(wwo->wfx, wfx, sizeof(*wwo)+extra);
+    wwo->wfx->cbSize = extra;
+    wwo->wfx->nBlockAlign = wfx->nChannels*wfx->wBitsPerSample/8;
+    wwo->wfx->nAvgBytesPerSec = wfx->nSamplesPerSec*wfx->nBlockAlign;
 
+    wwo->hw_params = hw_params = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, snd_pcm_hw_params_sizeof() );
     sw_params = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, snd_pcm_sw_params_sizeof() );
-    hw_params = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, snd_pcm_hw_params_sizeof() );
-    if (!hw_params || !sw_params)
-    {
-        retcode = MMSYSERR_NOMEM;
-        goto errexit;
-    }
-    snd_pcm_hw_params_any(pcm, hw_params);
-
-    access = SND_PCM_ACCESS_MMAP_INTERLEAVED;
-    if ( ( err = snd_pcm_hw_params_set_access(pcm, hw_params, access ) ) < 0) {
-        WARN("mmap not available. switching to standard write.\n");
-        access = SND_PCM_ACCESS_RW_INTERLEAVED;
-	EXIT_ON_ERROR( snd_pcm_hw_params_set_access(pcm, hw_params, access ), MMSYSERR_INVALPARAM, "unable to set access for playback");
-	wwo->write = snd_pcm_writei;
-    }
-    else
-	wwo->write = snd_pcm_mmap_writei;
+    snd_pcm_hw_params_any(wwo->pcm, hw_params);
+
+    snd_pcm_hw_params_set_access(wwo->pcm, hw_params, SND_PCM_ACCESS_RW_INTERLEAVED);
+    snd_pcm_hw_params_set_channels(wwo->pcm, hw_params, wwo->wfx->nChannels);
+    ret = WAVERR_BADFORMAT;
+    if ((err = snd_pcm_hw_params_set_format(wwo->pcm, hw_params, format)) < 0) {
+        WARN("unable to set required format %s: %s\n", snd_pcm_format_name(format), snd_strerror(err));
+        goto error;
+    }
+    rate = wwo->wfx->nSamplesPerSec;
+    err = snd_pcm_hw_params_set_rate_near(wwo->pcm, hw_params, &rate, NULL);
+    if (err < 0 || !ALSA_NearMatch(rate, wwo->wfx->nSamplesPerSec)) {
+        WARN("Could not set rate to %i\n", wwo->wfx->nSamplesPerSec);
+        goto error;
+    }
+    rate = 10000;
+    snd_pcm_hw_params_set_period_time_near(wwo->pcm, hw_params, &rate, NULL);
+    rate = 100000;
+    snd_pcm_hw_params_set_buffer_time_near(wwo->pcm, hw_params, &rate, NULL);
+    if ((err = snd_pcm_hw_params(wwo->pcm, hw_params)) < 0) {
+        WARN("unable to set required hardware parameters: %s\n", snd_strerror(err));
+        goto error;
+    }
+
+    snd_pcm_hw_params_get_period_size(hw_params, &size, NULL);
+    snd_pcm_sw_params_current(wwo->pcm, sw_params);
+    snd_pcm_sw_params_set_start_threshold(wwo->pcm, sw_params, 1);
+    snd_pcm_sw_params_set_silence_size(wwo->pcm, sw_params, 0);
+    snd_pcm_sw_params_set_avail_min(wwo->pcm, sw_params, size);
+    snd_pcm_sw_params_set_silence_threshold(wwo->pcm, sw_params, 0);
+    snd_pcm_sw_params(wwo->pcm, sw_params);
+
+    snd_pcm_prepare(wwo->pcm);
+    snd_pcm_start(wwo->pcm);
+
+    wwo->cachevol = 0xffffffff;
+    wwo->cbflags = HIWORD(dwFlags & CALLBACK_TYPEMASK);
+    wwo->cbhandle = lpDesc->dwCallback;
+    wwo->cbinstance = lpDesc->dwInstance;
+    wwo->wavehandle = (HDRVR)lpDesc->hWave;
+
+    ret = MMSYSERR_NOERROR;
+    if (dwFlags & WAVE_FORMAT_QUERY)
+        goto error;
+
+    HeapFree(GetProcessHeap(), 0, sw_params);
+
+    EnterCriticalSection(&dev->crst);
+    list_add_before(&dev->head, &wwo->entry);
+    if (!wave_timerid) {
+        timeBeginPeriod(1);
+        wave_timerid = timeSetEvent(10, 1, wodTick, 0L, TIME_PERIODIC | TIME_KILL_SYNCHRONOUS);
+    }
+    LeaveCriticalSection(&dev->crst);
+    *pInstance = wwo;
+    TRACE("opened instance %p\n", wwo);
 
-    if ((err = snd_pcm_hw_params_set_channels(pcm, hw_params, wwo->format.Format.nChannels)) < 0) {
-        WARN("unable to set required channels: %d\n", wwo->format.Format.nChannels);
-        EXIT_ON_ERROR( snd_pcm_hw_params_set_channels(pcm, hw_params, wwo->format.Format.nChannels ), WAVERR_BADFORMAT, "unable to set required channels" );
-    }
+    wodNotifyClient(wwo, WOM_OPEN, 0L, 0L);
+    return MMSYSERR_NOERROR;
 
-    if ((wwo->format.Format.wFormatTag == WAVE_FORMAT_PCM) ||
-        ((wwo->format.Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE) &&
-        IsEqualGUID(&wwo->format.SubFormat, &KSDATAFORMAT_SUBTYPE_PCM))) {
-        format = (wwo->format.Format.wBitsPerSample == 8) ? SND_PCM_FORMAT_U8 :
-                 (wwo->format.Format.wBitsPerSample == 16) ? SND_PCM_FORMAT_S16_LE :
-                 (wwo->format.Format.wBitsPerSample == 24) ? SND_PCM_FORMAT_S24_3LE :
-                 (wwo->format.Format.wBitsPerSample == 32) ? SND_PCM_FORMAT_S32_LE : -1;
-    } else if ((wwo->format.Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE) &&
-        IsEqualGUID(&wwo->format.SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)){
-        format = (wwo->format.Format.wBitsPerSample == 32) ? SND_PCM_FORMAT_FLOAT_LE : -1;
-    } else {
-        ERR("invalid format: %0x04x\n", wwo->format.Format.wFormatTag);
-        retcode = WAVERR_BADFORMAT;
-        goto errexit;
+error:
+    if (wwo->pcm) {
+        snd_pcm_drop(wwo->pcm);
+        snd_pcm_close(wwo->pcm);
     }
+    HeapFree(GetProcessHeap(), 0, sw_params);
+    HeapFree(GetProcessHeap(), 0, wwo->hw_params);
+    HeapFree(GetProcessHeap(), 0, wwo->wfx);
+    HeapFree(GetProcessHeap(), 0, wwo);
+    return ret;
+}
 
-    if ((err = snd_pcm_hw_params_set_format(pcm, hw_params, format)) < 0) {
-        WARN("unable to set required format: %s\n", snd_pcm_format_name(format));
-        EXIT_ON_ERROR( snd_pcm_hw_params_set_format(pcm, hw_params, format), WAVERR_BADFORMAT, "unable to set required format" );
-    }
+static DWORD wodClose(waveimpl *dev, wavestreamimpl *wwo) {
+    TRACE("(%p, %p)\n", dev, wwo);
 
-    rate = wwo->format.Format.nSamplesPerSec;
-    dir=0;
-    err = snd_pcm_hw_params_set_rate_near(pcm, hw_params, &rate, &dir);
-    if (err < 0) {
-	WARN("Rate %d Hz not available for playback: %s\n", wwo->format.Format.nSamplesPerSec, snd_strerror(rate));
-        retcode = WAVERR_BADFORMAT;
-        goto errexit;
+    EnterCriticalSection(&dev->crst);
+    if (wwo->queue) {
+        LeaveCriticalSection(&dev->crst);
+        WARN("buffers still playing !\n");
+        return WAVERR_STILLPLAYING;
     }
-    if (!ALSA_NearMatch(rate, wwo->format.Format.nSamplesPerSec)) {
-        WARN("Rate doesn't match (requested %d Hz, got %d Hz)\n", wwo->format.Format.nSamplesPerSec, rate);
-        retcode = WAVERR_BADFORMAT;
-        goto errexit;
-    }
-
-    TRACE("Got this format: %dx%dx%d %s\n",
-          wwo->format.Format.nSamplesPerSec,
-          wwo->format.Format.wBitsPerSample,
-          wwo->format.Format.nChannels,
-          ALSA_getFormat(wwo->format.Format.wFormatTag));
-
-    dir=0;
-    EXIT_ON_ERROR( snd_pcm_hw_params_set_buffer_time_near(pcm, hw_params, &buffer_time, &dir), MMSYSERR_INVALPARAM, "unable to set buffer time");
-    dir=0;
-    EXIT_ON_ERROR( snd_pcm_hw_params_set_period_time_near(pcm, hw_params, &period_time, &dir), MMSYSERR_INVALPARAM, "unable to set period time");
-
-    EXIT_ON_ERROR( snd_pcm_hw_params(pcm, hw_params), MMSYSERR_INVALPARAM, "unable to set hw params for playback");
-
-    err = snd_pcm_hw_params_get_period_size(hw_params, &period_size, &dir);
-    err = snd_pcm_hw_params_get_buffer_size(hw_params, &buffer_size);
 
-    snd_pcm_sw_params_current(pcm, sw_params);
+    snd_pcm_drop(wwo->pcm);
+    snd_pcm_close(wwo->pcm);
+    list_remove(&wwo->entry);
+    LeaveCriticalSection(&dev->crst);
 
-    EXIT_ON_ERROR( snd_pcm_sw_params_set_start_threshold(pcm, sw_params, 1), MMSYSERR_ERROR, "unable to set start threshold");
-    EXIT_ON_ERROR( snd_pcm_sw_params_set_silence_size(pcm, sw_params, 0), MMSYSERR_ERROR, "unable to set silence size");
-    EXIT_ON_ERROR( snd_pcm_sw_params_set_avail_min(pcm, sw_params, period_size), MMSYSERR_ERROR, "unable to set avail min");
-    EXIT_ON_ERROR( snd_pcm_sw_params_set_silence_threshold(pcm, sw_params, 0), MMSYSERR_ERROR, "unable to set silence threshold");
-    EXIT_ON_ERROR( snd_pcm_sw_params(pcm, sw_params), MMSYSERR_ERROR, "unable to set sw params for playback");
-#undef EXIT_ON_ERROR
+    wodNotifyClient(wwo, WOM_CLOSE, 0L, 0L);
+    HeapFree(GetProcessHeap(), 0, wwo->hw_params);
+    HeapFree(GetProcessHeap(), 0, wwo->wfx);
+    HeapFree(GetProcessHeap(), 0, wwo);
 
-    snd_pcm_prepare(pcm);
-
-    if (TRACE_ON(wave))
-	ALSA_TraceParameters(hw_params, sw_params, FALSE);
-
-    /* now, we can save all required data for later use... */
-
-    wwo->dwBufferSize = snd_pcm_frames_to_bytes(pcm, buffer_size);
-    wwo->lpQueuePtr = wwo->lpPlayPtr = wwo->lpLoopPtr = NULL;
-    wwo->dwPlayedTotal = wwo->dwWrittenTotal = 0;
-    wwo->dwPartialOffset = 0;
-
-    ALSA_InitRingMessage(&wwo->msgRing);
-
-    wwo->hStartUpEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
-    wwo->hThread = CreateThread(NULL, 0, wodPlayer, (LPVOID)(DWORD_PTR)wDevID, 0, &(wwo->dwThreadID));
-    if (!wwo->hThread) {
-        ERR("Thread creation for the wodPlayer failed!\n");
-        CloseHandle(wwo->hStartUpEvent);
-        retcode = MMSYSERR_NOMEM;
-        goto errexit;
-    }
-    SetThreadPriority(wwo->hThread, THREAD_PRIORITY_TIME_CRITICAL);
-    WaitForSingleObject(wwo->hStartUpEvent, INFINITE);
-    CloseHandle(wwo->hStartUpEvent);
-    wwo->hStartUpEvent = NULL;
-
-    TRACE("handle=%p\n", pcm);
-    TRACE("wBitsPerSample=%u, nAvgBytesPerSec=%u, nSamplesPerSec=%u, nChannels=%u nBlockAlign=%u!\n",
-	  wwo->format.Format.wBitsPerSample, wwo->format.Format.nAvgBytesPerSec,
-	  wwo->format.Format.nSamplesPerSec, wwo->format.Format.nChannels,
-	  wwo->format.Format.nBlockAlign);
-
-    HeapFree( GetProcessHeap(), 0, sw_params );
-    wwo->hw_params = hw_params;
-    wwo->hctl = hctl;
-    wwo->pcm = pcm;
-
-    wodNotifyClient(wwo, WOM_OPEN, 0L, 0L);
     return MMSYSERR_NOERROR;
-
-errexit:
-    if (pcm)
-        snd_pcm_close(pcm);
-
-    if (hctl)
-    {
-        snd_hctl_free(hctl);
-        snd_hctl_close(hctl);
-    }
-
-    HeapFree( GetProcessHeap(), 0, hw_params );
-    HeapFree( GetProcessHeap(), 0, sw_params );
-    if (wwo->msgRing.ring_buffer_size > 0)
-        ALSA_DestroyRingMessage(&wwo->msgRing);
-
-    return retcode;
 }
 
+static DWORD wodWrite(waveimpl *dev, wavestreamimpl *wwo, LPWAVEHDR hdr, DWORD dwSize) {
+    LPWAVEHDR *wh;
 
-/**************************************************************************
- * 				wodClose			[internal]
- */
-static DWORD wodClose(WORD wDevID)
-{
-    WINE_WAVEDEV*	wwo;
-
-    TRACE("(%u);\n", wDevID);
+    TRACE("(%p, %p, %p, %u, %08X)\n", dev, wwo, hdr, hdr->dwBufferLength, dwSize);
 
-    if (wDevID >= ALSA_WodNumDevs) {
-	TRACE("Asked for device %d, but only %d known!\n", wDevID, ALSA_WodNumDevs);
-	return MMSYSERR_BADDEVICEID;
+    if (!hdr->lpData || !(hdr->dwFlags & WHDR_PREPARED)) {
+        WARN("unprepared\n");
+        return WAVERR_UNPREPARED;
     }
 
-    wwo = &WOutDev[wDevID];
-    if (wwo->pcm == NULL) {
-	WARN("Requested to close already closed device %d!\n", wDevID);
-	return MMSYSERR_BADDEVICEID;
+    if (hdr->dwFlags & WHDR_INQUEUE) {
+        TRACE("still playing %p\n", hdr);
+        return WAVERR_STILLPLAYING;
     }
 
-    if (wwo->lpQueuePtr) {
-	WARN("buffers still playing !\n");
-	return WAVERR_STILLPLAYING;
-    } else {
-	if (wwo->hThread) {
-	    ALSA_AddRingMessage(&wwo->msgRing, WINE_WM_CLOSING, 0, TRUE);
-	}
-        ALSA_DestroyRingMessage(&wwo->msgRing);
-
-	HeapFree( GetProcessHeap(), 0, wwo->hw_params );
-	wwo->hw_params = NULL;
-
-        if (wwo->hctl)
-        {
-            snd_hctl_free(wwo->hctl);
-            snd_hctl_close(wwo->hctl);
-            wwo->hctl = NULL;
-        }
-
-	snd_pcm_close(wwo->pcm);
-	wwo->pcm = NULL;
+    hdr->dwFlags = (hdr->dwFlags & ~WHDR_DONE) | WHDR_INQUEUE;
+    hdr->lpNext = NULL;
 
-	wodNotifyClient(wwo, WOM_CLOSE, 0L, 0L);
+    EnterCriticalSection(&dev->crst);
+    if (!wwo->queue && hdr->dwFlags & WHDR_BEGINLOOP) {
+        wwo->loop = hdr;
+        wwo->numloops = hdr->dwLoops;
     }
+    if (!wwo->queue)
+        wwo->ofs = 0;
+
+    wh = &(wwo->queue);
+    while (*wh)
+        wh = &((*wh)->lpNext);
+    *wh = hdr;
+    LeaveCriticalSection(&dev->crst);
 
     return MMSYSERR_NOERROR;
 }
 
+static DWORD wodPause(waveimpl *dev, wavestreamimpl *wwo) {
+    TRACE("(%p, %p)\n", dev, wwo);
 
-/**************************************************************************
- * 				wodWrite			[internal]
- *
- */
-static DWORD wodWrite(WORD wDevID, LPWAVEHDR lpWaveHdr, DWORD dwSize)
-{
-    TRACE("(%u, %p, %08X);\n", wDevID, lpWaveHdr, dwSize);
-
-    if (wDevID >= ALSA_WodNumDevs) {
-	TRACE("Asked for device %d, but only %d known!\n", wDevID, ALSA_WodNumDevs);
-	return MMSYSERR_BADDEVICEID;
-    }
-
-    if (WOutDev[wDevID].pcm == NULL) {
-	WARN("Requested to write to closed device %d!\n", wDevID);
-	return MMSYSERR_BADDEVICEID;
-    }
-
-    if (lpWaveHdr->lpData == NULL || !(lpWaveHdr->dwFlags & WHDR_PREPARED))
-	return WAVERR_UNPREPARED;
+    EnterCriticalSection(&dev->crst);
+    wwo->stopped = 1;
+    if (snd_pcm_state(wwo->pcm) == SND_PCM_STATE_RUNNING)
+        snd_pcm_drain(wwo->pcm);
+    else
+        snd_pcm_drop(wwo->pcm);
+    LeaveCriticalSection(&dev->crst);
 
-    if (lpWaveHdr->dwFlags & WHDR_INQUEUE)
-	return WAVERR_STILLPLAYING;
+    return MMSYSERR_NOERROR;
+}
 
-    lpWaveHdr->dwFlags &= ~WHDR_DONE;
-    lpWaveHdr->dwFlags |= WHDR_INQUEUE;
-    lpWaveHdr->lpNext = 0;
+static DWORD wodRestart(waveimpl *dev, wavestreamimpl *wwo) {
+    TRACE("(%p, %p)\n", dev, wwo);
 
-    ALSA_AddRingMessage(&WOutDev[wDevID].msgRing, WINE_WM_HEADER, (DWORD_PTR)lpWaveHdr, FALSE);
+    EnterCriticalSection(&dev->crst);
+    wwo->stopped = 0;
+    snd_pcm_prepare(wwo->pcm);
+    snd_pcm_start(wwo->pcm);
+    LeaveCriticalSection(&dev->crst);
 
     return MMSYSERR_NOERROR;
 }
 
-/**************************************************************************
- * 			wodPause				[internal]
- */
-static DWORD wodPause(WORD wDevID)
-{
-    TRACE("(%u);!\n", wDevID);
+static DWORD wodReset(waveimpl *dev, wavestreamimpl *wwo) {
+    LPWAVEHDR savedqueue;
 
-    if (wDevID >= ALSA_WodNumDevs) {
-	TRACE("Asked for device %d, but only %d known!\n", wDevID, ALSA_WodNumDevs);
-	return MMSYSERR_BADDEVICEID;
-    }
+    TRACE("(%p, %p)\n", dev, wwo);
 
-    if (WOutDev[wDevID].pcm == NULL) {
-	WARN("Requested to pause closed device %d!\n", wDevID);
-	return MMSYSERR_BADDEVICEID;
-    }
+    EnterCriticalSection(&dev->crst);
 
-    ALSA_AddRingMessage(&WOutDev[wDevID].msgRing, WINE_WM_PAUSING, 0, TRUE);
+    if (wwo->loop)
+        savedqueue = wwo->loop;
+    else
+        savedqueue = wwo->queue;
+    wwo->queue = wwo->loop = NULL;
+    wwo->ofs = 0;
+    snd_pcm_drop(wwo->pcm);
+    snd_pcm_prepare(wwo->pcm);
+    snd_pcm_start(wwo->pcm);
+    LeaveCriticalSection(&dev->crst);
+
+    wodNotifyDoneList(wwo, savedqueue);
 
     return MMSYSERR_NOERROR;
 }
 
-/**************************************************************************
- * 			wodRestart				[internal]
- */
-static DWORD wodRestart(WORD wDevID)
-{
-    TRACE("(%u);\n", wDevID);
-
-    if (wDevID >= ALSA_WodNumDevs) {
-	TRACE("Asked for device %d, but only %d known!\n", wDevID, ALSA_WodNumDevs);
-	return MMSYSERR_BADDEVICEID;
-    }
-
-    if (WOutDev[wDevID].pcm == NULL) {
-	WARN("Requested to restart closed device %d!\n", wDevID);
-	return MMSYSERR_BADDEVICEID;
-    }
-
-    if (WOutDev[wDevID].state == WINE_WS_PAUSED) {
-	ALSA_AddRingMessage(&WOutDev[wDevID].msgRing, WINE_WM_RESTARTING, 0, TRUE);
-    }
+static DWORD wodBreakLoop(waveimpl *dev, wavestreamimpl *wwo) {
+    TRACE("(%p, %p)\n", dev, wwo);
 
-    /* FIXME: is NotifyClient with WOM_DONE right ? (Comet Busters 1.3.3 needs this notification) */
-    /* FIXME: Myst crashes with this ... hmm -MM
-       return wodNotifyClient(wwo, WOM_DONE, 0L, 0L);
-    */
+    EnterCriticalSection(&dev->crst);
+    if (wwo->loop != NULL)
+        wwo->numloops = 1;
+    LeaveCriticalSection(&dev->crst);
 
     return MMSYSERR_NOERROR;
 }
 
-/**************************************************************************
- * 			wodReset				[internal]
- */
-static DWORD wodReset(WORD wDevID)
-{
-    TRACE("(%u);\n", wDevID);
+static DWORD wodGetPosition(waveimpl *dev, wavestreamimpl *wwo, LPMMTIME lpTime, DWORD uSize) {
+    DWORD val;
 
-    if (wDevID >= ALSA_WodNumDevs) {
-	TRACE("Asked for device %d, but only %d known!\n", wDevID, ALSA_WodNumDevs);
-	return MMSYSERR_BADDEVICEID;
-    }
+    TRACE("(%p, %p, %p, %u)\n", dev, wwo, lpTime, uSize);
 
-    if (WOutDev[wDevID].pcm == NULL) {
-	WARN("Requested to reset closed device %d!\n", wDevID);
-	return MMSYSERR_BADDEVICEID;
-    }
+    if (!lpTime)
+        return MMSYSERR_INVALPARAM;
 
-    ALSA_AddRingMessage(&WOutDev[wDevID].msgRing, WINE_WM_RESETTING, 0, TRUE);
+    EnterCriticalSection(&dev->crst);
+    val = wwo->bytesplayed;
+    LeaveCriticalSection(&dev->crst);
 
-    return MMSYSERR_NOERROR;
+    return ALSA_bytes_to_mmtime(lpTime, val, (WAVEFORMATPCMEX*)wwo->wfx);
 }
 
-/**************************************************************************
- * 				wodGetPosition			[internal]
- */
-static DWORD wodGetPosition(WORD wDevID, LPMMTIME lpTime, DWORD uSize)
-{
-    WINE_WAVEDEV*	wwo;
+static DWORD wodGetVolume(waveimpl *dev, wavestreamimpl *wwo, LPDWORD lpdwVol) {
+    TRACE("(%p, %p, %p)\n", dev, wwo, lpdwVol);
 
-    TRACE("(%u, %p, %u);\n", wDevID, lpTime, uSize);
+    if (wwo)
+        *lpdwVol = wwo->cachevol;
+    else
+        *lpdwVol = dev->vol;
 
-    if (wDevID >= ALSA_WodNumDevs) {
-	TRACE("Asked for device %d, but only %d known!\n", wDevID, ALSA_WodNumDevs);
-	return MMSYSERR_BADDEVICEID;
-    }
+    return MMSYSERR_NOERROR;
+}
 
-    if (WOutDev[wDevID].pcm == NULL) {
-	WARN("Requested to get position of closed device %d!\n", wDevID);
-	return MMSYSERR_BADDEVICEID;
-    }
+static DWORD wodSetVolume(waveimpl *dev, wavestreamimpl *wwo, DWORD dwParam) {
+    TRACE("(%p, %p, %08x)\n", dev, wwo, dwParam);
 
-    if (lpTime == NULL)	return MMSYSERR_INVALPARAM;
+    if (wwo)
+        wwo->cachevol = dwParam;
+    else
+        dev->vol = dwParam;
 
-    wwo = &WOutDev[wDevID];
-    return ALSA_bytes_to_mmtime(lpTime, wwo->dwPlayedTotal, &wwo->format);
+    return MMSYSERR_NOERROR;
 }
 
-/**************************************************************************
- * 				wodBreakLoop			[internal]
- */
-static DWORD wodBreakLoop(WORD wDevID)
-{
-    TRACE("(%u);\n", wDevID);
+static DWORD wodGetNumDevs(void) {
+    TRACE("\n");
 
-    if (wDevID >= ALSA_WodNumDevs) {
-	TRACE("Asked for device %d, but only %d known!\n", wDevID, ALSA_WodNumDevs);
-	return MMSYSERR_BADDEVICEID;
-    }
+    return waveout_count;
+}
 
-    if (WOutDev[wDevID].pcm == NULL) {
-	WARN("Requested to breakloop of closed device %d!\n", wDevID);
-	return MMSYSERR_BADDEVICEID;
-    }
+static DWORD wodDevInterfaceSize(waveimpl *dev, LPDWORD dwParam1) {
+    TRACE("(%p, %p)\n", dev, dwParam1);
 
-    ALSA_AddRingMessage(&WOutDev[wDevID].msgRing, WINE_WM_BREAKLOOP, 0, TRUE);
+    *dwParam1 = (lstrlenW(dev->friendlyname)+1)*sizeof(*dev->friendlyname);
     return MMSYSERR_NOERROR;
 }
 
-/**************************************************************************
- * 				wodGetVolume			[internal]
- */
-static DWORD wodGetVolume(WORD wDevID, LPDWORD lpdwVol)
-{
-    WORD	       wleft, wright;
-    WINE_WAVEDEV*      wwo;
-    int                min, max;
-    int                left, right;
-    DWORD              rc;
-
-    TRACE("(%u, %p);\n", wDevID, lpdwVol);
-    if (wDevID >= ALSA_WodNumDevs) {
-	TRACE("Asked for device %d, but only %d known!\n", wDevID, ALSA_WodNumDevs);
-	return MMSYSERR_BADDEVICEID;
+static DWORD wodDevInterface(waveimpl *dev, PWCHAR dwParam1, DWORD dwParam2) {
+    DWORD size;
+
+    TRACE("\n");
+    wodDevInterfaceSize(dev, &size);
+    if (dwParam2 >= size) {
+        lstrcpyW(dwParam1, dev->friendlyname);
+        return MMSYSERR_NOERROR;
     }
+    return MMSYSERR_INVALPARAM;
+}
 
-    if (lpdwVol == NULL)
-	return MMSYSERR_NOTENABLED;
+static DWORD wodInit(void) {
+    DWORD i = 0;
+    ALSA_WaveInit();
+    waveout_count = ALSA_WodNumDevs;
 
-    wwo = &WOutDev[wDevID];
+    waveout_head = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*waveout_head) * waveout_count);
+    while (i < waveout_count) {
+        waveimpl *wave = waveout_head + i;
 
-    rc = ALSA_CheckSetVolume(wwo->hctl, &left, &right, &min, &max, NULL, NULL, NULL);
-    if (rc == MMSYSERR_NOERROR)
-    {
-#define VOLUME_ALSA_TO_WIN(x) (  ( (((x)-min) * 65535) + (max-min)/2 ) /(max-min))
-        wleft = VOLUME_ALSA_TO_WIN(left);
-        wright = VOLUME_ALSA_TO_WIN(right);
-#undef VOLUME_ALSA_TO_WIN
-        TRACE("left=%d,right=%d,converted to windows left %d, right %d\n", left, right, wleft, wright);
-        *lpdwVol = MAKELONG( wleft, wright );
+        wave->friendlyname = WOutDev[i].outcaps.szPname;
+        wave->devid = i++;
+        InitializeCriticalSection(&wave->crst);
+        wave->crst.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": waveimpl.crst");
+        list_init(&wave->head);
     }
-    else
-        TRACE("CheckSetVolume failed; rc %d\n", rc);
-
-    return rc;
+    return 1;
 }
 
-/**************************************************************************
- * 				wodSetVolume			[internal]
- */
-static DWORD wodSetVolume(WORD wDevID, DWORD dwParam)
-{
-    WORD	       wleft, wright;
-    WINE_WAVEDEV*      wwo;
-    int                min, max;
-    int                left, right;
-    DWORD              rc;
-
-    TRACE("(%u, %08X);\n", wDevID, dwParam);
-    if (wDevID >= ALSA_WodNumDevs) {
-	TRACE("Asked for device %d, but only %d known!\n", wDevID, ALSA_WodNumDevs);
-	return MMSYSERR_BADDEVICEID;
-    }
+static DWORD wodExit(void) {
+    DWORD i;
 
-    wwo = &WOutDev[wDevID];
-
-    rc = ALSA_CheckSetVolume(wwo->hctl, NULL, NULL, &min, &max, NULL, NULL, NULL);
-    if (rc == MMSYSERR_NOERROR)
-    {
-        wleft  = LOWORD(dwParam);
-        wright = HIWORD(dwParam);
-#define VOLUME_WIN_TO_ALSA(x) ( (  ( ((x) * (max-min)) + 32767) / 65535) + min )
-        left = VOLUME_WIN_TO_ALSA(wleft);
-        right = VOLUME_WIN_TO_ALSA(wright);
-#undef VOLUME_WIN_TO_ALSA
-        rc = ALSA_CheckSetVolume(wwo->hctl, NULL, NULL, NULL, NULL, NULL, &left, &right);
-        if (rc == MMSYSERR_NOERROR)
-            TRACE("set volume:  wleft=%d, wright=%d, converted to alsa left %d, right %d\n", wleft, wright, left, right);
-        else
-            TRACE("SetVolume failed; rc %d\n", rc);
+    if (wave_timerid) {
+        timeKillEvent(wave_timerid);
+        timeEndPeriod(1);
     }
 
-    return rc;
-}
+    for (i = 0; i < waveout_count; ++i) {
+        waveimpl *wave = waveout_head + i;
+        wavestreamimpl *cur, *next;
 
-/**************************************************************************
- * 				wodGetNumDevs			[internal]
- */
-static	DWORD	wodGetNumDevs(void)
-{
-    return ALSA_WodNumDevs;
+        LIST_FOR_EACH_ENTRY_SAFE(cur, next, &wave->head, wavestreamimpl, entry) {
+            wodReset(wave, cur);
+            wodClose(wave, cur);
+        }
+        HeapFree(GetProcessHeap(), 0, wave->friendlyname);
+        wave->crst.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection(&wave->crst);
+    }
+    HeapFree(GetProcessHeap(), 0, waveout_head);
+    waveout_count = 0;
+    return 1;
 }
 
-/**************************************************************************
- * 				wodDevInterfaceSize		[internal]
- */
-static DWORD wodDevInterfaceSize(UINT wDevID, LPDWORD dwParam1)
+DWORD WINAPI ALSA_wodMessage(UINT wDevID, UINT wMsg, DWORD_PTR dwUser,
+                             DWORD_PTR dwParam1, DWORD_PTR dwParam2)
 {
-    TRACE("(%u, %p)\n", wDevID, dwParam1);
+    wavestreamimpl *wwo = (wavestreamimpl*)dwUser;
+    waveimpl *dev = &waveout_head[wDevID];
 
-    *dwParam1 = MultiByteToWideChar(CP_UNIXCP, 0, WOutDev[wDevID].interface_name, -1,
-                                    NULL, 0 ) * sizeof(WCHAR);
-    return MMSYSERR_NOERROR;
-}
+    TRACE("(%u, %04x, %p, %p, %p)\n",
+          wDevID, wMsg, (void*)dwUser, (void*)dwParam1, (void*)dwParam2);
 
-/**************************************************************************
- * 				wodDevInterface			[internal]
- */
-static DWORD wodDevInterface(UINT wDevID, PWCHAR dwParam1, DWORD dwParam2)
-{
-    if (dwParam2 >= MultiByteToWideChar(CP_UNIXCP, 0, WOutDev[wDevID].interface_name, -1,
-                                        NULL, 0 ) * sizeof(WCHAR))
-    {
-        MultiByteToWideChar(CP_UNIXCP, 0, WOutDev[wDevID].interface_name, -1,
-                            dwParam1, dwParam2 / sizeof(WCHAR));
-	return MMSYSERR_NOERROR;
+    switch (wMsg) {
+        case DRVM_INIT:
+            return wodInit();
+        case DRVM_EXIT:
+            return wodExit();
+        case DRVM_ENABLE:
+        case DRVM_DISABLE:
+            return TRUE;
+        case WODM_GETNUMDEVS:
+            return wodGetNumDevs();
     }
-    return MMSYSERR_INVALPARAM;
-}
 
-/**************************************************************************
- * 				wodMessage (WINEALSA.@)
- */
-DWORD WINAPI ALSA_wodMessage(UINT wDevID, UINT wMsg, DWORD_PTR dwUser,
-                             DWORD_PTR dwParam1, DWORD_PTR dwParam2)
-{
-    TRACE("(%u, %s, %08lX, %08lX, %08lX);\n",
-	  wDevID, ALSA_getMessage(wMsg), dwUser, dwParam1, dwParam2);
+    if (wDevID >= waveout_count) {
+        ERR("Bad device id %u/%u\n", wDevID, waveout_count);
+        return MMSYSERR_BADDEVICEID;
+    }
 
     switch (wMsg) {
-    case DRVM_INIT:
-        ALSA_WaveInit();
-    case DRVM_EXIT:
-    case DRVM_ENABLE:
-    case DRVM_DISABLE:
-	/* FIXME: Pretend this is supported */
-	return 0;
-    case WODM_OPEN:	 	return wodOpen		(wDevID, (LPWAVEOPENDESC)dwParam1,	dwParam2);
-    case WODM_CLOSE:	 	return wodClose		(wDevID);
-    case WODM_GETDEVCAPS:	return wodGetDevCaps	(wDevID, (LPWAVEOUTCAPSW)dwParam1,	dwParam2);
-    case WODM_GETNUMDEVS:	return wodGetNumDevs	();
-    case WODM_GETPITCH:	 	return MMSYSERR_NOTSUPPORTED;
-    case WODM_SETPITCH:	 	return MMSYSERR_NOTSUPPORTED;
-    case WODM_GETPLAYBACKRATE:	return MMSYSERR_NOTSUPPORTED;
-    case WODM_SETPLAYBACKRATE:	return MMSYSERR_NOTSUPPORTED;
-    case WODM_WRITE:	 	return wodWrite		(wDevID, (LPWAVEHDR)dwParam1,		dwParam2);
-    case WODM_PAUSE:	 	return wodPause		(wDevID);
-    case WODM_GETPOS:	 	return wodGetPosition	(wDevID, (LPMMTIME)dwParam1, 		dwParam2);
-    case WODM_BREAKLOOP: 	return wodBreakLoop     (wDevID);
-    case WODM_PREPARE:	 	return MMSYSERR_NOTSUPPORTED;
-    case WODM_UNPREPARE: 	return MMSYSERR_NOTSUPPORTED;
-    case WODM_GETVOLUME:	return wodGetVolume	(wDevID, (LPDWORD)dwParam1);
-    case WODM_SETVOLUME:	return wodSetVolume	(wDevID, dwParam1);
-    case WODM_RESTART:		return wodRestart	(wDevID);
-    case WODM_RESET:		return wodReset		(wDevID);
-    case DRV_QUERYDEVICEINTERFACESIZE: return wodDevInterfaceSize       (wDevID, (LPDWORD)dwParam1);
-    case DRV_QUERYDEVICEINTERFACE:     return wodDevInterface           (wDevID, (PWCHAR)dwParam1, dwParam2);
-    case DRV_QUERYDSOUNDIFACE:	return wodDsCreate	(wDevID, (PIDSDRIVER*)dwParam1);
-    case DRV_QUERYDSOUNDDESC:	return wodDsDesc	(wDevID, (PDSDRIVERDESC)dwParam1);
-
-    default:
-	FIXME("unknown message %d!\n", wMsg);
+        case WODM_OPEN:
+            return wodOpen(dev, (wavestreamimpl**)dwUser, (LPWAVEOPENDESC)dwParam1, dwParam2);
+        case WODM_CLOSE:
+            return wodClose(dev, wwo);
+        case WODM_WRITE:
+            return wodWrite(dev, wwo, (LPWAVEHDR)dwParam1, dwParam2);
+        case WODM_PAUSE:
+            return wodPause(dev, wwo);
+        case WODM_GETPOS:
+            return wodGetPosition(dev, wwo, (LPMMTIME)dwParam1, dwParam2);
+        case WODM_BREAKLOOP:
+            return wodBreakLoop(dev, wwo);
+        case WODM_GETDEVCAPS:
+            return wodGetDevCaps(dev, (LPWAVEOUTCAPSW)dwParam1, dwParam2);
+
+        case WODM_GETVOLUME:
+            return wodGetVolume(dev, wwo, (LPDWORD)dwParam1);
+        case WODM_SETVOLUME:
+            return wodSetVolume(dev, wwo, dwParam1);
+        case WODM_RESTART:
+            return wodRestart(dev, wwo);
+        case WODM_RESET:
+            return wodReset(dev, wwo);
+
+        case DRV_QUERYDEVICEINTERFACESIZE:
+            return wodDevInterfaceSize(dev, (LPDWORD)dwParam1);
+        case DRV_QUERYDEVICEINTERFACE:
+            return wodDevInterface(dev, (PWCHAR)dwParam1, dwParam2);
+
+        case DRV_QUERYDSOUNDDESC:
+            return wodDsDesc(wDevID, (DSDRIVERDESC*)dwParam1);
+        case DRV_QUERYDSOUNDIFACE:
+            return wodDsCreate(wDevID, (IDsDriver**)dwParam1);
+
+        default:
+            FIXME("unknown message %04x!\n", wMsg);
+        case WODM_PREPARE:
+        case WODM_UNPREPARE:
+        case WODM_GETPITCH:
+        case WODM_SETPITCH:
+        case WODM_GETPLAYBACKRATE:
+        case WODM_SETPLAYBACKRATE:
+            return MMSYSERR_NOTSUPPORTED;
     }
-    return MMSYSERR_NOTSUPPORTED;
 }
diff --git a/dlls/winegstreamer/gsttffilter.c b/dlls/winegstreamer/gsttffilter.c
index b113c4e..23eaa65 100644
--- a/dlls/winegstreamer/gsttffilter.c
+++ b/dlls/winegstreamer/gsttffilter.c
@@ -117,8 +117,8 @@ typedef struct GstTfImpl {
     TransformFilter tf;
     IUnknown *seekthru_unk;
     const char *gstreamer_name;
-    GstElement *filter;
-    GstPad *my_src, *my_sink, *their_src, *their_sink;
+    GstElement *filter, *filter2;
+    GstPad *my_src, *my_sink, *their_src, *their_sink, *their_src2, *their_sink2;
     LONG cbBuffer;
 } GstTfImpl;
 
@@ -127,6 +127,8 @@ static HRESULT WINAPI Gstreamer_transform_ProcessBegin(TransformFilter *iface) {
     int ret;
 
     ret = gst_element_set_state(This->filter, GST_STATE_PLAYING);
+    if (This->filter2)
+        gst_element_set_state(This->filter2, GST_STATE_PLAYING);
     TRACE("Returned: %i\n", ret);
     return S_OK;
 }
@@ -270,6 +272,8 @@ static HRESULT WINAPI Gstreamer_transform_ProcessEnd(TransformFilter *iface) {
 
     LeaveCriticalSection(&This->tf.filter.csFilter);
     ret = gst_element_set_state(This->filter, GST_STATE_READY);
+    if (This->filter2)
+        gst_element_set_state(This->filter2, GST_STATE_READY);
     EnterCriticalSection(&This->tf.filter.csFilter);
     TRACE("Returned: %i\n", ret);
     return S_OK;
@@ -281,6 +285,9 @@ static void Gstreamer_transform_pad_added(GstElement *filter, GstPad *pad, GstTf
     if (!GST_PAD_IS_SRC(pad))
         return;
 
+    if (!This->their_src)
+        gst_object_ref(pad);
+
     ret = gst_pad_link(pad, This->my_sink);
     if (ret < 0)
         WARN("Failed to link with %i\n", ret);
@@ -363,7 +370,14 @@ static HRESULT Gstreamer_transform_ConnectInput(GstTfImpl *This, const AM_MEDIA_
     found = !!This->their_src;
     if (!found)
         g_signal_connect(This->filter, "pad-added", G_CALLBACK(Gstreamer_transform_pad_added), This);
-    ret = gst_pad_link(This->my_src, This->their_sink);
+
+    if (This->filter2) {
+        ret = gst_pad_link(This->my_src, This->their_sink2);
+        if (ret >= 0)
+            ret = gst_pad_link(This->their_src2, This->their_sink);
+    } else
+        ret = gst_pad_link(This->my_src, This->their_sink);
+
     if (ret < 0) {
         WARN("Failed to link with %i\n", ret);
         return E_FAIL;
@@ -388,16 +402,36 @@ static HRESULT WINAPI Gstreamer_transform_Cleanup(TransformFilter *tf, PIN_DIREC
             gst_element_set_state(This->filter, GST_STATE_NULL);
             gst_object_unref(This->filter);
         }
+        if (This->filter2) {
+            gst_element_set_state(This->filter2, GST_STATE_NULL);
+            gst_object_unref(This->filter2);
+        }
         This->filter = NULL;
-        if (This->my_src) {
+
+        if (This->filter2) {
+            gst_pad_unlink(This->my_src, This->their_sink2);
+            gst_pad_unlink(This->their_src2, This->their_sink);
+            gst_pad_unlink(This->their_src, This->my_sink);
+        } else if (This->my_src)
             gst_pad_unlink(This->my_src, This->their_sink);
-            gst_object_unref(This->my_src);
-        }
-        if (This->my_sink) {
+        if (This->their_src)
             gst_pad_unlink(This->their_src, This->my_sink);
+
+        if (This->my_src)
+            gst_object_unref(This->my_src);
+        if (This->their_sink)
+            gst_object_unref(This->their_sink);
+        if (This->their_src)
+            gst_object_unref(This->their_src);
+        if (This->their_sink2)
+            gst_object_unref(This->their_sink2);
+        if (This->their_src2)
+            gst_object_unref(This->their_src2);
+        if (This->my_sink)
             gst_object_unref(This->my_sink);
-        }
         This->my_sink = This->my_src = This->their_sink = This->their_src = NULL;
+        This->their_src2 = This->their_sink2 = NULL;
+        This->filter2 = NULL;
         FIXME("%p stub\n", This);
     }
     return S_OK;
@@ -627,7 +661,7 @@ static HRESULT WINAPI Gstreamer_YUV_SetMediaType(TransformFilter *tf, PIN_DIRECT
     AM_MEDIA_TYPE *outpmt = &This->tf.pmt;
     HRESULT hr;
     int avgtime;
-    DWORD width, height;
+    int width, height;
 
     if (dir != PINDIR_INPUT)
         return S_OK;
@@ -643,8 +677,10 @@ static HRESULT WINAPI Gstreamer_YUV_SetMediaType(TransformFilter *tf, PIN_DIRECT
         avgtime = vih->AvgTimePerFrame;
         width = vih->bmiHeader.biWidth;
         height = vih->bmiHeader.biHeight;
-        if ((LONG)vih->bmiHeader.biHeight > 0)
-            vih->bmiHeader.biHeight = -vih->bmiHeader.biHeight;
+        if (height < 0) {
+            height = -height;
+            vih->bmiHeader.biHeight = height;
+        }
         vih->bmiHeader.biBitCount = 24;
         vih->bmiHeader.biCompression = BI_RGB;
     } else {
@@ -652,8 +688,10 @@ static HRESULT WINAPI Gstreamer_YUV_SetMediaType(TransformFilter *tf, PIN_DIRECT
         avgtime = vih->AvgTimePerFrame;
         width = vih->bmiHeader.biWidth;
         height = vih->bmiHeader.biHeight;
-        if ((LONG)vih->bmiHeader.biHeight > 0)
-            vih->bmiHeader.biHeight = -vih->bmiHeader.biHeight;
+        if (height < 0) {
+            height = -height;
+            vih->bmiHeader.biHeight = height;
+        }
         vih->bmiHeader.biBitCount = 24;
         vih->bmiHeader.biCompression = BI_RGB;
     }
@@ -666,20 +704,74 @@ static HRESULT WINAPI Gstreamer_YUV_SetMediaType(TransformFilter *tf, PIN_DIRECT
                                  "format", GST_TYPE_FOURCC, amt->subtype.Data1,
                                  "width", G_TYPE_INT, width,
                                  "height", G_TYPE_INT, height,
-                                 "framerate", GST_TYPE_FRACTION, 10000000, avgtime,
+                                 "framerate", GST_TYPE_FRACTION, 10000000, (int)avgtime,
                                  NULL);
     capsout = gst_caps_new_simple("video/x-raw-rgb",
-                                  "endianness", G_TYPE_INT, 4321,
-                                  "width", G_TYPE_INT, width,
-                                  "height", G_TYPE_INT, height,
-                                  "framerate", GST_TYPE_FRACTION, 10000000, avgtime,
                                   "bpp", G_TYPE_INT, 24,
                                   "depth", G_TYPE_INT, 24,
+                                  "endianness", G_TYPE_INT, 4321,
                                   "red_mask", G_TYPE_INT, 0xff,
                                   "green_mask", G_TYPE_INT, 0xff00,
                                   "blue_mask", G_TYPE_INT, 0xff0000,
+                                  "width", G_TYPE_INT, width,
+                                  "height", G_TYPE_INT, height,
+                                  "framerate", GST_TYPE_FRACTION, 10000000, (int)avgtime,
                                    NULL);
 
+    This->filter2 = gst_element_factory_make("videoflip", NULL);
+    if (This->filter2) {
+        GstIterator *it;
+        int done = 0;
+
+        g_object_set(This->filter2, "method", 5, NULL);
+
+        it = gst_element_iterate_sink_pads(This->filter2);
+        while (!done) {
+            gpointer item;
+
+            switch (gst_iterator_next(it, &item)) {
+            case GST_ITERATOR_RESYNC:
+                gst_iterator_resync (it);
+                break;
+            case GST_ITERATOR_OK:
+                This->their_sink2 = item;
+            case GST_ITERATOR_ERROR:
+            case GST_ITERATOR_DONE:
+                done = 1;
+                break;
+            }
+        }
+        gst_iterator_free(it);
+
+        done = 0;
+        it = gst_element_iterate_src_pads(This->filter2);
+        while (!done) {
+            gpointer item;
+
+            switch (gst_iterator_next(it, &item)) {
+            case GST_ITERATOR_RESYNC:
+                gst_iterator_resync (it);
+                break;
+            case GST_ITERATOR_OK:
+                This->their_src2 = item;
+            case GST_ITERATOR_ERROR:
+            case GST_ITERATOR_DONE:
+                done = 1;
+                break;
+            }
+        }
+        gst_iterator_free(it);
+
+        if (!This->their_src2 || !This->their_sink2) {
+            if (This->their_src2)
+                gst_object_unref(This->their_src2);
+            if (This->their_sink2)
+                gst_object_unref(This->their_sink2);
+            gst_object_unref(This->filter2);
+            This->filter2 = 0;
+        }
+    }
+
     hr = Gstreamer_transform_ConnectInput(This, amt, capsin, capsout);
     gst_caps_unref(capsin);
     gst_caps_unref(capsout);
diff --git a/dlls/winemmaudio.drv/Makefile.in b/dlls/winemmaudio.drv/Makefile.in
new file mode 100644
index 0000000..9335843
--- /dev/null
+++ b/dlls/winemmaudio.drv/Makefile.in
@@ -0,0 +1,9 @@
+MODULE    = winemmaudio.drv
+IMPORTS   = uuid winmm user32 kernel32 ole32 oleaut32
+
+C_SRCS = \
+	capture.c \
+	mmaudio.c \
+	render.c
+
+@MAKE_DLL_RULES@
diff --git a/dlls/winemmaudio.drv/capture.c b/dlls/winemmaudio.drv/capture.c
new file mode 100644
index 0000000..0634f2a
--- /dev/null
+++ b/dlls/winemmaudio.drv/capture.c
@@ -0,0 +1,546 @@
+/*
+ * Wine Driver for Windows CoreAudio Api, based on winecoreaudio.drv
+ *
+ * Copyright 1994 Martin Ayotte
+ * Copyright 1999 Eric Pouech (async playing in waveOut/waveIn)
+ * Copyright 2000 Eric Pouech (loops in waveOut)
+ * Copyright 2002 Chris Morgan (jack version of this file)
+ * Copyright 2005, 2006 Emmanuel Maillard
+ * Copyright 2010 Maarten Lankhorst for Codeweavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define COBJMACROS
+#define CINTERFACE
+#define NONAMELESSUNION
+
+#include <stdarg.h>
+#include <math.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winnls.h"
+#include "wingdi.h"
+#include "winerror.h"
+#include "mmddk.h"
+#include "mmreg.h"
+#include "dsound.h"
+#include "dsdriver.h"
+#include "ks.h"
+#include "ksmedia.h"
+
+#include "coreaudio.h"
+
+#include "wine/unicode.h"
+#include "wine/library.h"
+#include "wine/debug.h"
+#include "wine/list.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(wave);
+
+static DWORD wave_timerid;
+
+typedef struct waveimpl {
+    DWORD devid;
+    IMMDevice *dev;
+    WCHAR *friendlyname;
+    DWORD vol;
+    CRITICAL_SECTION crst;
+    struct list head;
+} waveimpl;
+
+typedef struct wavestreamimpl {
+    WAVEFORMATEX *wfx;
+
+    WAVEHDR *queue;
+    DWORD ofs, stopped, bytesplayed;
+
+    /* callback stuff */
+    DWORD_PTR cbflags, cbhandle, cbinstance;
+    HDRVR wavehandle;
+
+    IAudioClient *ac;
+    IAudioCaptureClient *cap;
+    struct list entry;
+} wavestreamimpl;
+
+static waveimpl *waveout_head;
+static DWORD waveout_count;
+
+static void widNotifyClient(wavestreamimpl *wwo, DWORD msg, DWORD_PTR par1, DWORD_PTR par2) {
+    if (wwo->cbflags == DCB_NULL)
+        return;
+
+    DriverCallback(wwo->cbhandle, wwo->cbflags, wwo->wavehandle,
+                   msg, wwo->cbinstance, par1, par2);
+}
+
+static void widNotifyDoneList(wavestreamimpl *wwo, LPWAVEHDR lpWaveHdr) {
+    while (lpWaveHdr) {
+        LPWAVEHDR lpNext = lpWaveHdr->lpNext;
+
+        lpWaveHdr->lpNext = NULL;
+        lpWaveHdr->dwFlags = (lpWaveHdr->dwFlags & ~WHDR_INQUEUE) | WHDR_DONE;
+        widNotifyClient(wwo, WIM_DATA, (DWORD_PTR)lpWaveHdr, 0);
+
+        lpWaveHdr = lpNext;
+    }
+}
+
+static void CALLBACK widTick(UINT id, UINT msg, DWORD_PTR dwUser,
+                             DWORD_PTR dw1, DWORD_PTR dw2) {
+    DWORD x;
+    wavestreamimpl *cur;
+
+    for (x = 0; x < waveout_count; ++x) {
+        EnterCriticalSection(&waveout_head[x].crst);
+        LIST_FOR_EACH_ENTRY(cur, &waveout_head[x].head, wavestreamimpl, entry) {
+            WAVEHDR *begin = NULL, *end = NULL;
+            DWORD block = cur->wfx->nBlockAlign;
+
+            if (cur->stopped)
+                continue;
+
+            while (cur->queue) {
+                BYTE *data = NULL;
+                DWORD flags = 0, ofs = 0, pad = 0;
+                IAudioCaptureClient_GetBuffer(cur->cap, &data, &pad, &flags, NULL, NULL);
+                if (!pad)
+                    break;
+                pad *= block;
+
+                while (pad && cur->queue) {
+                    LPWAVEHDR hdr = cur->queue;
+                    DWORD avail = (hdr->dwBufferLength/block)*block - cur->ofs;
+                    if (avail > pad)
+                        avail = pad;
+
+                    memcpy(hdr->lpData + cur->ofs, data + ofs, avail);
+                    cur->ofs += avail;
+                    pad -= avail;
+                    ofs += avail;
+                    if (hdr->dwBufferLength - cur->ofs < block) {
+                        hdr->dwBytesRecorded = cur->ofs;
+                        cur->ofs = 0;
+                        cur->queue = hdr->lpNext;
+                        if (!begin)
+                            begin = hdr;
+                        end = hdr;
+                    }
+                }
+                IAudioCaptureClient_ReleaseBuffer(cur->cap, (ofs + pad)/block);
+                cur->bytesplayed += ofs;
+            }
+            if (begin) {
+                end->lpNext = NULL;
+                widNotifyDoneList(cur, begin);
+            }
+        }
+        LeaveCriticalSection(&waveout_head[x].crst);
+    }
+}
+
+static DWORD widGetDevCaps(waveimpl *dev, LPWAVEOUTCAPSW lpCaps, DWORD dwSize) {
+    WAVEOUTCAPSW caps;
+    TRACE("(%p, %p, %u)\n", dev, lpCaps, dwSize);
+
+    if (!lpCaps)
+        return MMSYSERR_NOTENABLED;
+
+    caps.wMid = MM_CREATIVE;
+    caps.wPid = MM_CREATIVE_SBP16_WAVEOUT;
+    caps.vDriverVersion = 0x0100;
+    lstrcpynW(caps.szPname, dev->friendlyname, sizeof(caps.szPname)/sizeof(*caps.szPname));
+    caps.dwFormats = 0xfffff;
+    caps.wChannels = 2;
+    caps.wReserved1 = 1;
+    caps.dwSupport = WAVECAPS_SAMPLEACCURATE|WAVECAPS_LRVOLUME|WAVECAPS_DIRECTSOUND;
+    memcpy(lpCaps, &caps, min(dwSize, sizeof(caps)));
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD widOpen(waveimpl *dev, wavestreamimpl **pInstance, LPWAVEOPENDESC lpDesc, DWORD dwFlags) {
+    wavestreamimpl *wwo;
+    WAVEFORMATEX *wfx, *wfxout = NULL;
+    DWORD extra, ret;
+    IAudioClient *ac;
+    HRESULT hr;
+
+    TRACE("(%p, %p, %p, %08x)\n", dev, pInstance, lpDesc, dwFlags);
+    if (!lpDesc) {
+        WARN("Invalid Parameter!\n");
+        return MMSYSERR_INVALPARAM;
+    }
+    wfx = lpDesc->lpFormat;
+
+    TRACE("Format: tag=%04X nChannels=%d nSamplesPerSec=%d wBitsPerSample=%d\n",
+          wfx->wFormatTag, wfx->nChannels, wfx->nSamplesPerSec, wfx->wBitsPerSample);
+
+    hr = IMMDevice_Activate(dev->dev, &IID_IAudioClient, CLSCTX_INPROC_SERVER, NULL, (void**)&ac);
+    if (SUCCEEDED(hr))
+        hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, wfx, &wfxout);
+    if (FAILED(hr)) {
+        WARN("Failed to get format from audioclient: %08x\n", hr);
+        if (ac)
+            IAudioClient_Release(ac);
+        CoTaskMemFree(wfxout);
+        return WAVERR_BADFORMAT;
+    }
+
+    if (dwFlags & WAVE_FORMAT_QUERY) {
+        CoTaskMemFree(wfxout);
+        return MMSYSERR_NOERROR;
+    }
+    if (wfx->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
+        extra = sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);
+    else
+        extra = 0;
+
+    wwo = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*wwo));
+    if (!wwo)
+        return MMSYSERR_NOMEM;
+
+    if (!wfxout) {
+        ret = MMSYSERR_NOMEM;
+        wwo->wfx = CoTaskMemAlloc(sizeof(*wwo)+extra);
+        if (!wwo->wfx)
+            goto error;
+
+        if (wfx->wFormatTag == WAVE_FORMAT_PCM)
+            memcpy(wwo->wfx, wfx, sizeof(PCMWAVEFORMAT));
+        else
+            memcpy(wwo->wfx, wfx, sizeof(*wwo)+extra);
+        wwo->wfx->cbSize = extra;
+        wwo->wfx->nBlockAlign = wfx->nChannels*wfx->wBitsPerSample/8;
+        wwo->wfx->nAvgBytesPerSec = wfx->nSamplesPerSec*wfx->nBlockAlign;
+    } else
+        wwo->wfx = wfxout;
+
+    wwo->ac = ac;
+    ret = WAVERR_BADFORMAT;
+    hr = IAudioClient_Initialize(ac, AUDCLNT_SHAREMODE_SHARED,
+                                 AUDCLNT_STREAMFLAGS_RATEADJUST,
+                                 500000, 0, wwo->wfx, NULL);
+    if (FAILED(hr)) {
+        WARN("Could not initialize audioclient: %08x\n", hr);
+        goto error;
+    }
+    hr = IAudioClient_GetService(ac, &IID_IAudioCaptureClient, (void**)&wwo->cap);
+    if (FAILED(hr)) {
+        WARN("Could not get capture client: %08x\n", hr);
+        goto error;
+    }
+    wwo->stopped = 1;
+    wwo->cbflags = HIWORD(dwFlags & CALLBACK_TYPEMASK);
+    wwo->cbhandle = lpDesc->dwCallback;
+    wwo->cbinstance = lpDesc->dwInstance;
+    wwo->wavehandle = (HDRVR)lpDesc->hWave;
+
+    EnterCriticalSection(&dev->crst);
+    list_add_before(&dev->head, &wwo->entry);
+    if (!wave_timerid) {
+        timeBeginPeriod(1);
+        wave_timerid = timeSetEvent(10, 1, widTick, 0L, TIME_PERIODIC | TIME_KILL_SYNCHRONOUS);
+    }
+    LeaveCriticalSection(&dev->crst);
+    *pInstance = wwo;
+    TRACE("opened instance %p\n", wwo);
+
+    widNotifyClient(wwo, WIM_OPEN, 0L, 0L);
+    return MMSYSERR_NOERROR;
+
+error:
+    if (wwo->cap)
+        IAudioCaptureClient_Release(wwo->cap);
+    IAudioClient_Release(ac);
+    CoTaskMemFree(wwo->wfx);
+    HeapFree(GetProcessHeap(), 0, wwo);
+    return ret;
+}
+
+static DWORD widClose(waveimpl *dev, wavestreamimpl *wwo) {
+    TRACE("(%p, %p)\n", dev, wwo);
+
+    EnterCriticalSection(&dev->crst);
+    if (wwo->queue) {
+        LeaveCriticalSection(&dev->crst);
+        WARN("buffers still playing !\n");
+        return WAVERR_STILLPLAYING;
+    }
+
+    widNotifyClient(wwo, WIM_CLOSE, 0L, 0L);
+    list_remove(&wwo->entry);
+
+    IAudioCaptureClient_Release(wwo->cap);
+    IAudioClient_Release(wwo->ac);
+    CoTaskMemFree(wwo->wfx);
+    HeapFree(GetProcessHeap(), 0, wwo);
+    LeaveCriticalSection(&dev->crst);
+
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD widWrite(waveimpl *dev, wavestreamimpl *wwo, LPWAVEHDR hdr, DWORD dwSize) {
+    LPWAVEHDR *wh;
+
+    TRACE("(%p, %p, %p, %u, %08X)\n", dev, wwo, hdr, hdr->dwBufferLength, dwSize);
+
+    if (!hdr->lpData || !(hdr->dwFlags & WHDR_PREPARED)) {
+        TRACE("unprepared\n");
+        return WAVERR_UNPREPARED;
+    }
+
+    if (hdr->dwFlags & WHDR_INQUEUE) {
+        TRACE("still playing\n");
+        return WAVERR_STILLPLAYING;
+    }
+
+    hdr->dwFlags = (hdr->dwFlags & ~WHDR_DONE) | WHDR_INQUEUE;
+    hdr->lpNext = NULL;
+
+    EnterCriticalSection(&dev->crst);
+    if (!wwo->queue)
+        wwo->ofs = 0;
+
+    wh = &(wwo->queue);
+    while (*wh)
+        wh = &((*wh)->lpNext);
+    *wh = hdr;
+    LeaveCriticalSection(&dev->crst);
+
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD widStart(waveimpl *dev, wavestreamimpl *wwo) {
+    TRACE("(%p, %p)\n", dev, wwo);
+
+    EnterCriticalSection(&dev->crst);
+    wwo->stopped = 0;
+    IAudioClient_Start(wwo->ac);
+    LeaveCriticalSection(&dev->crst);
+
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD widStop(waveimpl *dev, wavestreamimpl *wwo) {
+    TRACE("(%p, %p)\n", dev, wwo);
+
+    EnterCriticalSection(&dev->crst);
+    wwo->stopped = 1;
+    IAudioClient_Stop(wwo->ac);
+    LeaveCriticalSection(&dev->crst);
+
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD widReset(waveimpl *dev, wavestreamimpl *wwo) {
+    LPWAVEHDR savedqueue;
+
+    TRACE("(%p, %p)\n", dev, wwo);
+
+    EnterCriticalSection(&dev->crst);
+
+    savedqueue = wwo->queue;
+    wwo->queue = NULL;
+    wwo->ofs = 0;
+    wwo->stopped = 1;
+    IAudioClient_Stop(wwo->ac);
+    IAudioClient_Reset(wwo->ac);
+
+    LeaveCriticalSection(&dev->crst);
+
+    widNotifyDoneList(wwo, savedqueue);
+
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD widGetPosition(waveimpl *dev, wavestreamimpl *wwo, LPMMTIME lpTime, DWORD uSize) {
+    DWORD val;
+
+    TRACE("(%p, %p, %p, %u)\n", dev, wwo, lpTime, uSize);
+
+    if (!lpTime)
+        return MMSYSERR_INVALPARAM;
+
+    EnterCriticalSection(&dev->crst);
+    val = wwo->bytesplayed;
+    LeaveCriticalSection(&dev->crst);
+
+    return bytes_to_mmtime(lpTime, val, wwo->wfx);
+}
+
+static DWORD widGetNumDevs(void) {
+    TRACE("\n");
+
+    return waveout_count;
+}
+
+static DWORD widDevInterfaceSize(waveimpl *dev, LPDWORD dwParam1) {
+    TRACE("(%p, %p)\n", dev, dwParam1);
+
+    *dwParam1 = (lstrlenW(dev->friendlyname)+1)*sizeof(*dev->friendlyname);
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD widDevInterface(waveimpl *dev, PWCHAR dwParam1, DWORD dwParam2) {
+    DWORD size;
+
+    TRACE("\n");
+    widDevInterfaceSize(dev, &size);
+    if (dwParam2 >= size) {
+        lstrcpyW(dwParam1, dev->friendlyname);
+        return MMSYSERR_NOERROR;
+    }
+    return MMSYSERR_INVALPARAM;
+}
+
+/* To be removed */
+static DWORD widDsDesc(waveimpl *dev, PDSDRIVERDESC desc)
+{
+    TRACE("(%p, %p)\n", dev, desc);
+
+    WideCharToMultiByte(CP_ACP, 0, dev->friendlyname, -1,
+                        desc->szDesc, sizeof(desc->szDesc)-1, NULL, NULL);
+    desc->szDesc[sizeof(desc->szDesc)-1] = 0;
+    strcpy(desc->szDrvname, "winemmaudio.drv");
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD widInit(void) {
+    IMMDeviceCollection *col;
+    DWORD i = 0;
+
+    if (!devenum)
+        return 1;
+    IMMDeviceEnumerator_EnumAudioEndpoints(devenum, eCapture, DEVICE_STATE_ACTIVE, &col);
+    if (!col)
+        return 1;
+    IMMDeviceCollection_GetCount(col, &waveout_count);
+    waveout_head = HeapAlloc(GetProcessHeap(), 0, sizeof(*waveout_head) * waveout_count);
+
+    while (i < waveout_count) {
+        waveimpl *wave = waveout_head + i;
+        IPropertyStore *store;
+        PROPVARIANT pv = { VT_EMPTY };
+
+        IMMDeviceCollection_Item(col, i, &wave->dev);
+        if (!wave->dev)
+            break;
+        IMMDevice_OpenPropertyStore(wave->dev, STGM_READ, &store);
+        if (!store) {
+            IUnknown_Release(wave->dev);
+            break;
+        }
+        IPropertyStore_GetValue(store, (PROPERTYKEY*)&DEVPKEY_Device_FriendlyName, &pv);
+        IPropertyStore_Release(store);
+        wave->friendlyname = pv.u.pwszVal;
+        wave->devid = i++;
+        InitializeCriticalSection(&wave->crst);
+        wave->crst.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": waveimpl.crst");
+        list_init(&wave->head);
+    }
+    IMMDeviceCollection_Release(col);
+    waveout_count = i;
+    return 1;
+}
+
+static DWORD widExit(void) {
+    DWORD i;
+
+    if (wave_timerid) {
+        timeKillEvent(wave_timerid);
+        timeEndPeriod(1);
+    }
+
+    for (i = 0; i < waveout_count; ++i) {
+        waveimpl *wave = waveout_head + i;
+        wavestreamimpl *cur, *next;
+
+        LIST_FOR_EACH_ENTRY_SAFE(cur, next, &wave->head, wavestreamimpl, entry) {
+            widReset(wave, cur);
+            widClose(wave, cur);
+        }
+        CoTaskMemFree(wave->friendlyname);
+        IMMDevice_Release(wave->dev);
+        wave->crst.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection(&wave->crst);
+    }
+    HeapFree(GetProcessHeap(), 0, waveout_head);
+    waveout_count = 0;
+    return 1;
+}
+
+DWORD WINAPI widMessage(UINT wDevID, UINT wMsg, DWORD_PTR dwUser,
+                        DWORD_PTR dwParam1, DWORD_PTR dwParam2)
+{
+    wavestreamimpl *wwo = (wavestreamimpl*)dwUser;
+    waveimpl *dev = &waveout_head[wDevID];
+
+    TRACE("(%u, %04x, %p, %p, %p)\n",
+          wDevID, wMsg, (void*)dwUser, (void*)dwParam1, (void*)dwParam2);
+
+    switch (wMsg) {
+        case DRVM_INIT:
+            return widInit();
+        case DRVM_EXIT:
+            return widExit();
+        case DRVM_ENABLE:
+        case DRVM_DISABLE:
+            return TRUE;
+        case WIDM_GETNUMDEVS:
+            return widGetNumDevs();
+    }
+
+    if (wDevID >= waveout_count) {
+        ERR("Bad device id %u/%u\n", wDevID, waveout_count);
+        return MMSYSERR_BADDEVICEID;
+    }
+
+    switch (wMsg) {
+        case WIDM_OPEN:
+            return widOpen(dev, (wavestreamimpl**)dwUser, (LPWAVEOPENDESC)dwParam1, dwParam2);
+        case WIDM_CLOSE:
+            return widClose(dev, wwo);
+        case WIDM_ADDBUFFER:
+            return widWrite(dev, wwo, (LPWAVEHDR)dwParam1, dwParam2);
+        case WIDM_GETPOS:
+            return widGetPosition(dev, wwo, (LPMMTIME)dwParam1, dwParam2);
+        case WIDM_GETDEVCAPS:
+            return widGetDevCaps(dev, (LPWAVEOUTCAPSW)dwParam1, dwParam2);
+
+        case WIDM_START:
+            return widStart(dev, wwo);
+        case WIDM_STOP:
+            return widStop(dev, wwo);
+        case WIDM_RESET:
+            return widReset(dev, wwo);
+
+        case DRV_QUERYDEVICEINTERFACESIZE:
+            return widDevInterfaceSize(dev, (LPDWORD)dwParam1);
+        case DRV_QUERYDEVICEINTERFACE:
+            return widDevInterface(dev, (PWCHAR)dwParam1, dwParam2);
+
+        case DRV_QUERYDSOUNDDESC:
+            return widDsDesc(dev, (DSDRIVERDESC*)dwParam1);
+
+        default:
+            FIXME("unknown message %04x!\n", wMsg);
+        case WIDM_PREPARE:
+        case WIDM_UNPREPARE:
+        case DRV_QUERYDSOUNDIFACE:
+            return MMSYSERR_NOTSUPPORTED;
+    }
+}
diff --git a/dlls/winemmaudio.drv/coreaudio.h b/dlls/winemmaudio.drv/coreaudio.h
new file mode 100644
index 0000000..9797b0a
--- /dev/null
+++ b/dlls/winemmaudio.drv/coreaudio.h
@@ -0,0 +1,32 @@
+/* Definition for CoreAudio drivers : wine multimedia system
+ *
+ * Copyright 2005-2007 Emmanuel Maillard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_COREAUDIO_H
+#define __WINE_COREAUDIO_H
+
+#include "mmdeviceapi.h"
+#include "audioclient.h"
+#include "endpointvolume.h"
+#include "audiopolicy.h"
+#include "devpkey.h"
+
+extern IMMDeviceEnumerator *devenum;
+extern DWORD bytes_to_mmtime(MMTIME *time, DWORD pos, WAVEFORMATEX *wfx);
+
+#endif /* __WINE_COREAUDIO_H */
diff --git a/dlls/winemmaudio.drv/mmaudio.c b/dlls/winemmaudio.drv/mmaudio.c
new file mode 100644
index 0000000..5316ad0
--- /dev/null
+++ b/dlls/winemmaudio.drv/mmaudio.c
@@ -0,0 +1,125 @@
+/*
+ * Wine Driver for Windows Core Audio
+ *
+ * Copyright 2010 Maarten Lankhorst for Codeweavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define COBJMACROS
+#define CINTERFACE
+
+#include "config.h"
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
+#include "mmddk.h"
+#include "ks.h"
+#include "ksmedia.h"
+
+#include "ole2.h"
+#include "initguid.h"
+
+#include "coreaudio.h"
+#include "wine/library.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mmaudio);
+
+IMMDeviceEnumerator *devenum = NULL;
+
+DWORD bytes_to_mmtime(MMTIME *time, DWORD pos, WAVEFORMATEX *wfx)
+{
+    TRACE("Position in bytes=%u\n", pos);
+
+    switch (time->wType) {
+    case TIME_SAMPLES:
+        time->u.sample = pos / wfx->nBlockAlign;
+        TRACE("TIME_SAMPLES=%u\n", time->u.sample);
+        break;
+    case TIME_MS:
+        time->u.ms = 1000.0 * pos / wfx->nAvgBytesPerSec;
+        TRACE("TIME_MS=%u\n", time->u.ms);
+        break;
+    case TIME_SMPTE: {
+        DWORD sec, frame;
+
+        pos /= wfx->nBlockAlign;
+        time->u.smpte.fps = 30;
+        pos += (wfx->nSamplesPerSec / time->u.smpte.fps) - 1;
+        sec = pos / wfx->nSamplesPerSec;
+
+        time->u.smpte.sec = sec % 60;
+        time->u.smpte.min = (sec / 60) % 60;
+        time->u.smpte.hour = sec / 3600;
+        frame = pos * time->u.smpte.fps / wfx->nSamplesPerSec;
+        time->u.smpte.frame = frame % time->u.smpte.fps;
+        TRACE("TIME_SMPTE=%02u:%02u:%02u:%02u\n",
+              time->u.smpte.hour, time->u.smpte.min, time->u.smpte.sec, time->u.smpte.frame);
+        break;
+    }
+    default:
+        WARN("Format %d not supported, using TIME_BYTES !\n", time->wType);
+        time->wType = TIME_BYTES;
+        /* fall through */
+    case TIME_BYTES:
+        time->u.cb = pos;
+        TRACE("TIME_BYTES=%u\n", time->u.cb);
+        break;
+    }
+    return MMSYSERR_NOERROR;
+}
+
+LRESULT CALLBACK DriverProc(DWORD_PTR dwDevID, HDRVR hDriv, UINT wMsg,
+                            LPARAM dwParam1, LPARAM dwParam2)
+{
+    HRESULT hr;
+
+    TRACE("(%08lX, %p, %04x, %08lX, %08lX)\n",
+          dwDevID, hDriv, wMsg, dwParam1, dwParam2);
+
+    switch (wMsg) {
+        case DRV_LOAD: {
+            CoInitializeEx(NULL, COINIT_MULTITHREADED);
+            hr = CoCreateInstance(&CLSID_MMDeviceEnumerator, NULL,
+                                  CLSCTX_INPROC_SERVER,
+                                  &IID_IMMDeviceEnumerator, (void**)&devenum);
+            if (hr == S_OK)
+                return 1;
+            ERR("Could not create device enumerator: %08x\n", hr);
+            return 0;
+        }
+        case DRV_FREE:
+            if (devenum)
+                IMMDeviceEnumerator_Release(devenum);
+        case DRV_OPEN:
+        case DRV_CLOSE:
+        case DRV_INSTALL:
+        case DRV_REMOVE:
+        case DRV_ENABLE:
+        case DRV_DISABLE:
+        case DRV_QUERYCONFIGURE:
+            return 1;
+        case DRV_CONFIGURE:
+            MessageBoxA(0, "Audio driver forwarding to mmdevapi", "mmdevapi", MB_OK);
+            return 1;
+        default:
+            return 0;
+    }
+}
diff --git a/dlls/winemmaudio.drv/render.c b/dlls/winemmaudio.drv/render.c
new file mode 100644
index 0000000..77eb9a5
--- /dev/null
+++ b/dlls/winemmaudio.drv/render.c
@@ -0,0 +1,662 @@
+/*
+ * Wine Driver for Windows CoreAudio Api, based on winecoreaudio.drv
+ *
+ * Copyright 1994 Martin Ayotte
+ * Copyright 1999 Eric Pouech (async playing in waveOut/waveIn)
+ * Copyright 2000 Eric Pouech (loops in waveOut)
+ * Copyright 2002 Chris Morgan (jack version of this file)
+ * Copyright 2005, 2006 Emmanuel Maillard
+ * Copyright 2010 Maarten Lankhorst for Codeweavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define COBJMACROS
+#define CINTERFACE
+#define NONAMELESSUNION
+
+#include <stdarg.h>
+#include <math.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winnls.h"
+#include "wingdi.h"
+#include "winerror.h"
+#include "mmddk.h"
+#include "mmreg.h"
+#include "dsound.h"
+#include "dsdriver.h"
+#include "ks.h"
+#include "ksmedia.h"
+
+#include "coreaudio.h"
+
+#include "wine/unicode.h"
+#include "wine/library.h"
+#include "wine/debug.h"
+#include "wine/list.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(wave);
+
+static DWORD wave_timerid;
+
+typedef struct waveimpl {
+    DWORD devid;
+    IMMDevice *dev;
+    WCHAR *friendlyname;
+    DWORD vol;
+    CRITICAL_SECTION crst;
+    struct list head;
+} waveimpl;
+
+typedef struct wavestreamimpl {
+    WAVEFORMATEX *wfx;
+
+    WAVEHDR *queue, *loop;
+    DWORD ofs, numloops, stopped, bytesplayed;
+
+    /* callback stuff */
+    DWORD_PTR cbflags, cbhandle, cbinstance;
+    HDRVR wavehandle;
+
+    IAudioClient *ac;
+    IAudioRenderClient *render;
+    IAudioStreamVolume *vol;
+    struct list entry;
+    DWORD cachevol;
+} wavestreamimpl;
+
+static waveimpl *waveout_head;
+static DWORD waveout_count;
+
+static void wodNotifyClient(wavestreamimpl *wwo, DWORD msg, DWORD_PTR par1, DWORD_PTR par2) {
+    if (wwo->cbflags == DCB_NULL)
+        return;
+
+    DriverCallback(wwo->cbhandle, wwo->cbflags, wwo->wavehandle,
+                   msg, wwo->cbinstance, par1, par2);
+}
+
+static void wodNotifyDoneList(wavestreamimpl *wwo, LPWAVEHDR lpWaveHdr) {
+    while (lpWaveHdr) {
+        LPWAVEHDR lpNext = lpWaveHdr->lpNext;
+
+        lpWaveHdr->lpNext = NULL;
+        lpWaveHdr->dwFlags = (lpWaveHdr->dwFlags & ~WHDR_INQUEUE) | WHDR_DONE;
+        wodNotifyClient(wwo, WOM_DONE, (DWORD_PTR)lpWaveHdr, 0);
+
+        lpWaveHdr = lpNext;
+    }
+}
+
+static void wodNext(wavestreamimpl *wwo, WAVEHDR **beginnotify, WAVEHDR **endnotify) {
+    LPWAVEHDR hdr = wwo->queue;
+
+    hdr->dwBytesRecorded = wwo->ofs;
+    wwo->ofs = 0;
+    if (wwo->loop && wwo->queue->dwFlags & WHDR_ENDLOOP) {
+        if (wwo->numloops-- > 1) {
+            wwo->queue = wwo->loop;
+            return;
+        }
+
+        if (!*beginnotify)
+            *beginnotify = wwo->loop;
+        wwo->loop = NULL;
+    }
+
+    if (!wwo->loop) {
+        if (!*beginnotify)
+            *beginnotify = hdr;
+        *endnotify = hdr;
+    }
+    wwo->queue = hdr->lpNext;
+
+    if (wwo->queue && wwo->queue->dwFlags & WHDR_BEGINLOOP) {
+        if (!wwo->loop) {
+            TRACE("Starting loop (%d) with %p\n", wwo->queue->dwLoops, wwo->queue);
+
+            wwo->loop = wwo->queue;
+            wwo->numloops = wwo->queue->dwLoops;
+        } else
+            WARN("Already in a loop. Discarding loop on this header (%p)\n", wwo->queue);
+    }
+}
+
+static void CALLBACK wodTick(UINT id, UINT msg, DWORD_PTR dwUser,
+                             DWORD_PTR dw1, DWORD_PTR dw2) {
+    DWORD x;
+    wavestreamimpl *cur;
+
+    for (x = 0; x < waveout_count; ++x) {
+        EnterCriticalSection(&waveout_head[x].crst);
+        LIST_FOR_EACH_ENTRY(cur, &waveout_head[x].head, wavestreamimpl, entry) {
+            DWORD size, pad = 0, avail;
+            WAVEHDR *begin = NULL, *end = NULL;
+            DWORD block = cur->wfx->nBlockAlign;
+
+            if (cur->stopped)
+                continue;
+            IAudioClient_GetBufferSize(cur->ac, &size);
+            IAudioClient_GetCurrentPadding(cur->ac, &pad);
+            pad = (size - pad)*block;
+
+            while (pad && cur->queue) {
+                BYTE *data = NULL;
+                avail = cur->queue->dwBufferLength - cur->ofs;
+                if (avail > pad)
+                    avail = pad;
+
+                IAudioRenderClient_GetBuffer(cur->render, avail/block, &data);
+                if (!data)
+                    break;
+                memcpy(data, cur->queue->lpData + cur->ofs, avail);
+                IAudioRenderClient_ReleaseBuffer(cur->render, avail/block, 0);
+                cur->ofs += avail;
+                pad -= avail;
+                if (cur->queue->dwBufferLength - cur->ofs < block)
+                    wodNext(cur, &begin, &end);
+                cur->bytesplayed += avail;
+            }
+            if (begin) {
+                end->lpNext = NULL;
+                wodNotifyDoneList(cur, begin);
+            }
+        }
+        LeaveCriticalSection(&waveout_head[x].crst);
+    }
+}
+
+static DWORD wodGetDevCaps(waveimpl *dev, LPWAVEOUTCAPSW lpCaps, DWORD dwSize) {
+    WAVEOUTCAPSW caps;
+    TRACE("(%p, %p, %u)\n", dev, lpCaps, dwSize);
+
+    if (!lpCaps)
+        return MMSYSERR_NOTENABLED;
+
+    caps.wMid = MM_CREATIVE;
+    caps.wPid = MM_CREATIVE_SBP16_WAVEOUT;
+    caps.vDriverVersion = 0x0100;
+    lstrcpynW(caps.szPname, dev->friendlyname, sizeof(caps.szPname)/sizeof(*caps.szPname));
+    caps.dwFormats = 0xfffff;
+    caps.wChannels = 2;
+    caps.wReserved1 = 1;
+    caps.dwSupport = WAVECAPS_SAMPLEACCURATE|WAVECAPS_VOLUME
+                     |WAVECAPS_LRVOLUME|WAVECAPS_DIRECTSOUND;
+    memcpy(lpCaps, &caps, min(dwSize, sizeof(caps)));
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD wodOpen(waveimpl *dev, wavestreamimpl **pInstance, LPWAVEOPENDESC lpDesc, DWORD dwFlags) {
+    wavestreamimpl *wwo;
+    WAVEFORMATEX *wfx, *wfxout = NULL;
+    DWORD extra, ret;
+    IAudioClient *ac;
+    HRESULT hr;
+
+    TRACE("(%p, %p, %p, %08x)\n", dev, pInstance, lpDesc, dwFlags);
+    if (!lpDesc) {
+        WARN("Invalid Parameter!\n");
+        return MMSYSERR_INVALPARAM;
+    }
+    wfx = lpDesc->lpFormat;
+
+    TRACE("Format: tag=%04X nChannels=%d nSamplesPerSec=%d wBitsPerSample=%d\n",
+          wfx->wFormatTag, wfx->nChannels, wfx->nSamplesPerSec, wfx->wBitsPerSample);
+
+    hr = IMMDevice_Activate(dev->dev, &IID_IAudioClient, CLSCTX_INPROC_SERVER, NULL, (void**)&ac);
+    if (SUCCEEDED(hr))
+        hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, wfx, &wfxout);
+    if (FAILED(hr)) {
+        WARN("Failed to get format from audioclient: %08x\n", hr);
+        if (ac)
+            IAudioClient_Release(ac);
+        CoTaskMemFree(wfxout);
+        return WAVERR_BADFORMAT;
+    }
+
+    if (dwFlags & WAVE_FORMAT_QUERY) {
+        CoTaskMemFree(wfxout);
+        return MMSYSERR_NOERROR;
+    }
+    if (wfx->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
+        extra = sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);
+    else
+        extra = 0;
+
+    wwo = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*wwo));
+    if (!wwo)
+        return MMSYSERR_NOMEM;
+
+    if (!wfxout) {
+        ret = MMSYSERR_NOMEM;
+        wwo->wfx = CoTaskMemAlloc(sizeof(*wwo)+extra);
+        if (!wwo->wfx)
+            goto error;
+
+        if (wfx->wFormatTag == WAVE_FORMAT_PCM)
+            memcpy(wwo->wfx, wfx, sizeof(PCMWAVEFORMAT));
+        else
+            memcpy(wwo->wfx, wfx, sizeof(*wwo)+extra);
+        wwo->wfx->cbSize = extra;
+        wwo->wfx->nBlockAlign = wfx->nChannels*wfx->wBitsPerSample/8;
+        wwo->wfx->nAvgBytesPerSec = wfx->nSamplesPerSec*wfx->nBlockAlign;
+    } else
+        wwo->wfx = wfxout;
+
+    wwo->ac = ac;
+    ret = WAVERR_BADFORMAT;
+    hr = IAudioClient_Initialize(ac, AUDCLNT_SHAREMODE_SHARED,
+                                 AUDCLNT_STREAMFLAGS_RATEADJUST,
+                                 500000, 0, wwo->wfx, NULL);
+    if (FAILED(hr)) {
+        WARN("Could not initialize audioclient: %08x\n", hr);
+        goto error;
+    }
+    hr = IAudioClient_GetService(ac, &IID_IAudioRenderClient, (void**)&wwo->render);
+    if (FAILED(hr)) {
+        WARN("Could not get render client: %08x\n", hr);
+        goto error;
+    }
+    hr = IAudioClient_GetService(ac, &IID_IAudioStreamVolume, (void**)&wwo->vol);
+    if (FAILED(hr)) {
+        WARN("Could not get stream audio volume: %08x\n", hr);
+        /* Not fatal yet, wine doesn't support IAudioStreamVolume */
+    } else
+        FIXME("Succeeded? Tell maarten to remove !wwo->vol case\n");
+    wwo->cachevol = 0xffffffff;
+    wwo->cbflags = HIWORD(dwFlags & CALLBACK_TYPEMASK);
+    wwo->cbhandle = lpDesc->dwCallback;
+    wwo->cbinstance = lpDesc->dwInstance;
+    wwo->wavehandle = (HDRVR)lpDesc->hWave;
+
+    EnterCriticalSection(&dev->crst);
+    list_add_before(&dev->head, &wwo->entry);
+    if (!wave_timerid) {
+        timeBeginPeriod(1);
+        wave_timerid = timeSetEvent(10, 1, wodTick, 0L, TIME_PERIODIC | TIME_KILL_SYNCHRONOUS);
+    }
+    IAudioClient_Start(wwo->ac);
+    LeaveCriticalSection(&dev->crst);
+    *pInstance = wwo;
+    TRACE("opened instance %p\n", wwo);
+
+    wodNotifyClient(wwo, WOM_OPEN, 0L, 0L);
+    return MMSYSERR_NOERROR;
+
+error:
+    if (wwo->vol)
+        IAudioStreamVolume_Release(wwo->vol);
+    if (wwo->render)
+        IAudioRenderClient_Release(wwo->render);
+    IAudioClient_Release(ac);
+    CoTaskMemFree(wwo->wfx);
+    HeapFree(GetProcessHeap(), 0, wwo);
+    return ret;
+}
+
+static DWORD wodClose(waveimpl *dev, wavestreamimpl *wwo) {
+    TRACE("(%p, %p)\n", dev, wwo);
+
+    EnterCriticalSection(&dev->crst);
+    if (wwo->queue) {
+        LeaveCriticalSection(&dev->crst);
+        WARN("buffers still playing !\n");
+        return WAVERR_STILLPLAYING;
+    }
+
+    wodNotifyClient(wwo, WOM_CLOSE, 0L, 0L);
+    list_remove(&wwo->entry);
+
+    /* Should be unconditional when !wwo->vol is no longer ignorable */
+    if (wwo->vol)
+        IAudioStreamVolume_Release(wwo->vol);
+    IAudioRenderClient_Release(wwo->render);
+    IAudioClient_Release(wwo->ac);
+    CoTaskMemFree(wwo->wfx);
+    HeapFree(GetProcessHeap(), 0, wwo);
+    LeaveCriticalSection(&dev->crst);
+
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD wodWrite(waveimpl *dev, wavestreamimpl *wwo, LPWAVEHDR hdr, DWORD dwSize) {
+    LPWAVEHDR *wh;
+
+    TRACE("(%p, %p, %p, %u, %08X)\n", dev, wwo, hdr, hdr->dwBufferLength, dwSize);
+
+    if (!hdr->lpData || !(hdr->dwFlags & WHDR_PREPARED)) {
+        TRACE("unprepared\n");
+        return WAVERR_UNPREPARED;
+    }
+
+    if (hdr->dwFlags & WHDR_INQUEUE) {
+        TRACE("still playing\n");
+        return WAVERR_STILLPLAYING;
+    }
+
+    hdr->dwFlags = (hdr->dwFlags & ~WHDR_DONE) | WHDR_INQUEUE;
+    hdr->lpNext = NULL;
+
+    EnterCriticalSection(&dev->crst);
+    if (!wwo->queue && hdr->dwFlags & WHDR_BEGINLOOP) {
+        wwo->loop = hdr;
+        wwo->numloops = hdr->dwLoops;
+    }
+    if (!wwo->queue)
+        wwo->ofs = 0;
+
+    wh = &(wwo->queue);
+    while (*wh)
+        wh = &((*wh)->lpNext);
+    *wh = hdr;
+    LeaveCriticalSection(&dev->crst);
+
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD wodPause(waveimpl *dev, wavestreamimpl *wwo) {
+    TRACE("(%p, %p)\n", dev, wwo);
+
+    EnterCriticalSection(&dev->crst);
+    wwo->stopped = 1;
+    IAudioClient_Stop(wwo->ac);
+    LeaveCriticalSection(&dev->crst);
+
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD wodRestart(waveimpl *dev, wavestreamimpl *wwo) {
+    TRACE("(%p, %p)\n", dev, wwo);
+
+    EnterCriticalSection(&dev->crst);
+    wwo->stopped = 0;
+    IAudioClient_Start(wwo->ac);
+    LeaveCriticalSection(&dev->crst);
+
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD wodReset(waveimpl *dev, wavestreamimpl *wwo) {
+    LPWAVEHDR savedqueue;
+
+    TRACE("(%p, %p)\n", dev, wwo);
+
+    EnterCriticalSection(&dev->crst);
+
+    if (wwo->loop)
+        savedqueue = wwo->loop;
+    else
+        savedqueue = wwo->queue;
+    wwo->queue = wwo->loop = NULL;
+    wwo->ofs = 0;
+    IAudioClient_Stop(wwo->ac);
+    IAudioClient_Reset(wwo->ac);
+    IAudioClient_Start(wwo->ac);
+
+    LeaveCriticalSection(&dev->crst);
+
+    wodNotifyDoneList(wwo, savedqueue);
+
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD wodBreakLoop(waveimpl *dev, wavestreamimpl *wwo) {
+    TRACE("(%p, %p)\n", dev, wwo);
+
+    EnterCriticalSection(&dev->crst);
+    if (wwo->loop != NULL)
+        wwo->numloops = 1;
+    LeaveCriticalSection(&dev->crst);
+
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD wodGetPosition(waveimpl *dev, wavestreamimpl *wwo, LPMMTIME lpTime, DWORD uSize) {
+    DWORD val;
+
+    TRACE("(%p, %p, %p, %u)\n", dev, wwo, lpTime, uSize);
+
+    if (!lpTime)
+        return MMSYSERR_INVALPARAM;
+
+    EnterCriticalSection(&dev->crst);
+    val = wwo->bytesplayed;
+    LeaveCriticalSection(&dev->crst);
+
+    return bytes_to_mmtime(lpTime, val, wwo->wfx);
+}
+
+static DWORD wodGetVolume(waveimpl *dev, wavestreamimpl *wwo, LPDWORD lpdwVol) {
+    TRACE("(%p, %p, %p)\n", dev, wwo, lpdwVol);
+
+    if (wwo && wwo->vol) {
+        float vol[8] = { 1.0, 1.0 };
+
+        IAudioStreamVolume_GetAllVolumes(wwo->vol, wwo->wfx->nChannels, vol);
+        if (wwo->wfx->nChannels == 1)
+            vol[1] = vol[0];
+        *lpdwVol = (DWORD)pow(65536.f, vol[0]) - 1U;
+        *lpdwVol |= ((DWORD)pow(65536.f, vol[1]) - 1U)<<16U;
+
+        FIXME("Tell maarten to remove the !wwo->vol case, since the wwo->vol case works now\n");
+    } else if (wwo && !wwo->vol) {
+        *lpdwVol = wwo->cachevol;
+        WARN("stub: Wine misses code to support volume\n");
+    } else {
+        FIXME("Touch IChannelAudioVolume\n");
+        *lpdwVol = dev->vol;
+    }
+
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD wodSetVolume(waveimpl *dev, wavestreamimpl *wwo, DWORD dwParam) {
+    TRACE("(%p, %p, %08x)\n", dev, wwo, dwParam);
+
+    if (wwo && wwo->vol) {
+        float vol[8];
+        IAudioStreamVolume_GetAllVolumes(wwo->vol, wwo->wfx->nChannels, vol);
+        vol[0] = LOWORD(dwParam);
+        vol[1] = HIWORD(dwParam);
+        vol[0] = log(vol[0]+1)/log(65536.f);
+        vol[1] = log(vol[0]+1)/log(65536.f);
+        IAudioStreamVolume_SetAllVolumes(wwo->vol, wwo->wfx->nChannels, vol);
+
+        FIXME("Tell maarten to remove the !wwo->vol case, since the wwo->vol case works now\n");
+    } else if (wwo && !wwo->vol) {
+        wwo->cachevol = dwParam;
+        WARN("stub: Wine misses code to support volume\n");
+    } else {
+        FIXME("Touch IChannelAudioVolume\n");
+        dev->vol = dwParam;
+    }
+
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD wodGetNumDevs(void) {
+    TRACE("\n");
+
+    return waveout_count;
+}
+
+static DWORD wodDevInterfaceSize(waveimpl *dev, LPDWORD dwParam1) {
+    TRACE("(%p, %p)\n", dev, dwParam1);
+
+    *dwParam1 = (lstrlenW(dev->friendlyname)+1)*sizeof(*dev->friendlyname);
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD wodDevInterface(waveimpl *dev, PWCHAR dwParam1, DWORD dwParam2) {
+    DWORD size;
+
+    TRACE("\n");
+    wodDevInterfaceSize(dev, &size);
+    if (dwParam2 >= size) {
+        lstrcpyW(dwParam1, dev->friendlyname);
+        return MMSYSERR_NOERROR;
+    }
+    return MMSYSERR_INVALPARAM;
+}
+
+/* To be removed */
+static DWORD wodDsDesc(waveimpl *dev, PDSDRIVERDESC desc)
+{
+    TRACE("(%p, %p)\n", dev, desc);
+
+    WideCharToMultiByte(CP_ACP, 0, dev->friendlyname, -1,
+                        desc->szDesc, sizeof(desc->szDesc)-1, NULL, NULL);
+    desc->szDesc[sizeof(desc->szDesc)-1] = 0;
+    strcpy(desc->szDrvname, "winemmaudio.drv");
+    return MMSYSERR_NOERROR;
+}
+
+static DWORD wodInit(void) {
+    IMMDeviceCollection *col;
+    DWORD i = 0;
+
+    if (!devenum)
+        return 1;
+    IMMDeviceEnumerator_EnumAudioEndpoints(devenum, eRender, DEVICE_STATE_ACTIVE, &col);
+    if (!col)
+        return 1;
+    IMMDeviceCollection_GetCount(col, &waveout_count);
+    waveout_head = HeapAlloc(GetProcessHeap(), 0, sizeof(*waveout_head) * waveout_count);
+
+    while (i < waveout_count) {
+        waveimpl *wave = waveout_head + i;
+        IPropertyStore *store;
+        PROPVARIANT pv = { VT_EMPTY };
+
+        IMMDeviceCollection_Item(col, i, &wave->dev);
+        if (!wave->dev)
+            break;
+        IMMDevice_OpenPropertyStore(wave->dev, STGM_READ, &store);
+        if (!store) {
+            IUnknown_Release(wave->dev);
+            break;
+        }
+        IPropertyStore_GetValue(store, (PROPERTYKEY*)&DEVPKEY_Device_FriendlyName, &pv);
+        IPropertyStore_Release(store);
+        wave->friendlyname = pv.u.pwszVal;
+        wave->devid = i++;
+        InitializeCriticalSection(&wave->crst);
+        wave->crst.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": waveimpl.crst");
+        list_init(&wave->head);
+    }
+    IMMDeviceCollection_Release(col);
+    waveout_count = i;
+    return 1;
+}
+
+static DWORD wodExit(void) {
+    DWORD i;
+
+    if (wave_timerid) {
+        timeKillEvent(wave_timerid);
+        timeEndPeriod(1);
+    }
+
+    for (i = 0; i < waveout_count; ++i) {
+        waveimpl *wave = waveout_head + i;
+        wavestreamimpl *cur, *next;
+
+        LIST_FOR_EACH_ENTRY_SAFE(cur, next, &wave->head, wavestreamimpl, entry) {
+            wodReset(wave, cur);
+            wodClose(wave, cur);
+        }
+        CoTaskMemFree(wave->friendlyname);
+        IMMDevice_Release(wave->dev);
+        wave->crst.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection(&wave->crst);
+    }
+    HeapFree(GetProcessHeap(), 0, waveout_head);
+    waveout_count = 0;
+    return 1;
+}
+
+DWORD WINAPI wodMessage(UINT wDevID, UINT wMsg, DWORD_PTR dwUser,
+                        DWORD_PTR dwParam1, DWORD_PTR dwParam2)
+{
+    wavestreamimpl *wwo = (wavestreamimpl*)dwUser;
+    waveimpl *dev = &waveout_head[wDevID];
+
+    TRACE("(%u, %04x, %p, %p, %p)\n",
+          wDevID, wMsg, (void*)dwUser, (void*)dwParam1, (void*)dwParam2);
+
+    switch (wMsg) {
+        case DRVM_INIT:
+            return wodInit();
+        case DRVM_EXIT:
+            return wodExit();
+        case DRVM_ENABLE:
+        case DRVM_DISABLE:
+            return TRUE;
+        case WODM_GETNUMDEVS:
+            return wodGetNumDevs();
+    }
+
+    if (wDevID >= waveout_count) {
+        ERR("Bad device id %u/%u\n", wDevID, waveout_count);
+        return MMSYSERR_BADDEVICEID;
+    }
+
+    switch (wMsg) {
+        case WODM_OPEN:
+            return wodOpen(dev, (wavestreamimpl**)dwUser, (LPWAVEOPENDESC)dwParam1, dwParam2);
+        case WODM_CLOSE:
+            return wodClose(dev, wwo);
+        case WODM_WRITE:
+            return wodWrite(dev, wwo, (LPWAVEHDR)dwParam1, dwParam2);
+        case WODM_PAUSE:
+            return wodPause(dev, wwo);
+        case WODM_GETPOS:
+            return wodGetPosition(dev, wwo, (LPMMTIME)dwParam1, dwParam2);
+        case WODM_BREAKLOOP:
+            return wodBreakLoop(dev, wwo);
+        case WODM_GETDEVCAPS:
+            return wodGetDevCaps(dev, (LPWAVEOUTCAPSW)dwParam1, dwParam2);
+
+        case WODM_GETVOLUME:
+            return wodGetVolume(dev, wwo, (LPDWORD)dwParam1);
+        case WODM_SETVOLUME:
+            return wodSetVolume(dev, wwo, dwParam1);
+        case WODM_RESTART:
+            return wodRestart(dev, wwo);
+        case WODM_RESET:
+            return wodReset(dev, wwo);
+
+        case DRV_QUERYDEVICEINTERFACESIZE:
+            return wodDevInterfaceSize(dev, (LPDWORD)dwParam1);
+        case DRV_QUERYDEVICEINTERFACE:
+            return wodDevInterface(dev, (PWCHAR)dwParam1, dwParam2);
+
+        case DRV_QUERYDSOUNDDESC:
+            return wodDsDesc(dev, (DSDRIVERDESC*)dwParam1);
+
+        default:
+            FIXME("unknown message %04x!\n", wMsg);
+        case WODM_PREPARE:
+        case WODM_UNPREPARE:
+        case WODM_GETPITCH:
+        case WODM_SETPITCH:
+        case WODM_GETPLAYBACKRATE:
+        case WODM_SETPLAYBACKRATE:
+        case DRV_QUERYDSOUNDIFACE:
+            return MMSYSERR_NOTSUPPORTED;
+    }
+}
diff --git a/dlls/winemmaudio.drv/winemmaudio.drv.spec b/dlls/winemmaudio.drv/winemmaudio.drv.spec
new file mode 100644
index 0000000..f781d01
--- /dev/null
+++ b/dlls/winemmaudio.drv/winemmaudio.drv.spec
@@ -0,0 +1,4 @@
+@ stdcall -private DriverProc(long long long long long)
+@ stdcall -private widMessage(long long long long long)
+@ stdcall -private wodMessage(long long long long long)
+#@ stdcall -private mxdMessage(long long long long long)
diff --git a/dlls/winepulse.drv/Makefile.in b/dlls/winepulse.drv/Makefile.in
new file mode 100644
index 0000000..0f595f1
--- /dev/null
+++ b/dlls/winepulse.drv/Makefile.in
@@ -0,0 +1,9 @@
+MODULE    = winepulse.drv
+IMPORTS   = dxguid uuid winmm user32 advapi32 ole32
+EXTRALIBS = @PULSELIBS@ @LIBPTHREAD@
+EXTRAINCL = @PULSEINCL@
+
+C_SRCS = \
+	mmdevdrv.c
+
+@MAKE_DLL_RULES@
diff --git a/dlls/winepulse.drv/mmdevdrv.c b/dlls/winepulse.drv/mmdevdrv.c
new file mode 100644
index 0000000..7915798
--- /dev/null
+++ b/dlls/winepulse.drv/mmdevdrv.c
@@ -0,0 +1,2087 @@
+/*
+ * Copyright 2010-2011 Maarten Lankhorst for CodeWeavers
+ * Copyright 2011 Andrew Eikum for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ * Pulseaudio driver support.. hell froze over
+ */
+
+#define NONAMELESSUNION
+#define COBJMACROS
+#include "config.h"
+#include <poll.h>
+#include <pthread.h>
+
+#include <stdarg.h>
+#include <unistd.h>
+#include <math.h>
+#include <stdio.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winnls.h"
+#include "winreg.h"
+#include "wine/debug.h"
+#include "wine/unicode.h"
+#include "wine/list.h"
+
+#include "ole2.h"
+#include "dshow.h"
+#include "dsound.h"
+#include "propsys.h"
+
+#include "initguid.h"
+#include "ks.h"
+#include "ksmedia.h"
+#include "mmdeviceapi.h"
+#include "audioclient.h"
+#include "endpointvolume.h"
+#include "audiopolicy.h"
+
+#include "wine/list.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(pulse);
+
+static const REFERENCE_TIME MinimumPeriod = 100000;
+
+static pa_context *pulse_ctx;
+static pa_mainloop *pulse_ml;
+
+static HANDLE pulse_thread;
+static pthread_mutex_t pulse_lock = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t pulse_cond = PTHREAD_COND_INITIALIZER;
+
+static struct list session_list = LIST_INIT( session_list );
+
+typedef struct _AudioSession {
+    GUID guid;
+
+    EDataFlow dataflow;
+
+    float master_vol;
+    UINT32 channel_count;
+    float *channel_vols;
+
+    struct list entry;
+} AudioSession;
+
+typedef struct ACImpl {
+    IAudioClient IAudioClient_iface;
+    IAudioRenderClient IAudioRenderClient_iface;
+    IAudioCaptureClient IAudioCaptureClient_iface;
+    IAudioSessionControl2 IAudioSessionControl2_iface;
+    ISimpleAudioVolume ISimpleAudioVolume_iface;
+    IAudioClock IAudioClock_iface;
+    IAudioClock2 IAudioClock2_iface;
+
+    LONG ref;
+
+    IMMDevice *parent;
+
+    EDataFlow dataflow;
+    DWORD flags;
+    AUDCLNT_SHAREMODE share;
+    HANDLE event;
+
+    BOOL initted, started;
+    UINT32 bufsize_frames;
+    BYTE *locked_ptr, *tmp_buffer;
+    UINT32 locked, peeked, extra_buffered;
+    UINT64 play_ofs;
+
+    pa_stream *stream;
+    pa_sample_spec ss;
+    pa_channel_map map;
+
+    /* Mixer format + period times */
+    pa_sample_spec mix_ss;
+    pa_channel_map mix_map;
+    REFERENCE_TIME min_period, def_period;
+} ACImpl;
+
+static const WCHAR defaultW[] = {'P','u','l','s','e','a','u','d','i','o',0};
+
+static const IAudioClientVtbl AudioClient_Vtbl;
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl;
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl;
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl;
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl;
+static const IAudioClockVtbl AudioClock_Vtbl;
+static const IAudioClock2Vtbl AudioClock2_Vtbl;
+
+static inline ACImpl *impl_from_IAudioClient(IAudioClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClient_iface);
+}
+
+static inline ACImpl *impl_from_IAudioRenderClient(IAudioRenderClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioRenderClient_iface);
+}
+
+static inline ACImpl *impl_from_IAudioCaptureClient(IAudioCaptureClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioCaptureClient_iface);
+}
+
+static inline ACImpl *impl_from_IAudioSessionControl2(IAudioSessionControl2 *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioSessionControl2_iface);
+}
+
+static inline ACImpl *impl_from_ISimpleAudioVolume(ISimpleAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, ISimpleAudioVolume_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock(IAudioClock *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock2(IAudioClock2 *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock2_iface);
+}
+
+/* Following pulseaudio design here, mainloop has the lock taken whenever
+ * it is handling something for pulse, and the lock is required whenever
+ * doing any pa_* call that can affect the state in any way
+ *
+ * pa_cond_wait is used when waiting on results, because the mainloop needs
+ * the same lock taken to affect the state
+ *
+ * This is basically the same as the pa_threaded_mainloop implementation,
+ * but that cannot be used because it uses pthread_create directly
+ *
+ * pa_threaded_mainloop_(un)lock -> pthread_mutex_(un)lock
+ * pa_threaded_mainloop_signal -> pthread_cond_signal
+ * pa_threaded_mainloop_wait -> pthread_cond_wait
+ */
+
+static int pulse_poll_func(struct pollfd *ufds, unsigned long nfds, int timeout, void *userdata) {
+    int r;
+    pthread_mutex_unlock(&pulse_lock);
+    r = poll(ufds, nfds, timeout);
+    pthread_mutex_lock(&pulse_lock);
+    return r;
+}
+
+static DWORD CALLBACK pulse_mainloop_thread(void *tmp) {
+    int ret;
+    pulse_ml = pa_mainloop_new();
+    pa_mainloop_set_poll_func(pulse_ml, pulse_poll_func, NULL);
+    pthread_mutex_lock(&pulse_lock);
+    pthread_cond_signal(&pulse_cond);
+    pa_mainloop_run(pulse_ml, &ret);
+    pthread_mutex_unlock(&pulse_lock);
+    pa_mainloop_free(pulse_ml);
+    CloseHandle(pulse_thread);
+    return ret;
+}
+
+static void pulse_contextcallback(pa_context *c, void *userdata);
+
+static HRESULT pulse_connect(void)
+{
+    int len;
+    WCHAR path[PATH_MAX], *name;
+    char *str;
+
+    if (!pulse_thread)
+    {
+        if (!(pulse_thread = CreateThread(NULL, 0, pulse_mainloop_thread, NULL, 0, NULL)))
+        {
+            ERR("Failed to create mainloop thread.");
+            return E_FAIL;
+        }
+        pthread_cond_wait(&pulse_cond, &pulse_lock);
+    }
+
+    if (pulse_ctx && PA_CONTEXT_IS_GOOD(pa_context_get_state(pulse_ctx)))
+        return S_OK;
+    if (pulse_ctx)
+        pa_context_unref(pulse_ctx);
+
+    GetModuleFileNameW(NULL, path, sizeof(path)/sizeof(*path));
+    name = strrchrW(path, '\\');
+    if (!name)
+        name = path;
+    else
+        name++;
+    len = WideCharToMultiByte(CP_UNIXCP, 0, name, -1, NULL, 0, NULL, NULL);
+    str = pa_xmalloc(len);
+    WideCharToMultiByte(CP_UNIXCP, 0, name, -1, str, len, NULL, NULL);
+    TRACE("Name: %s\n", str);
+    pulse_ctx = pa_context_new(pa_mainloop_get_api(pulse_ml), str);
+    pa_xfree(str);
+    if (!pulse_ctx) {
+        ERR("Failed to create context\n");
+        return E_FAIL;
+    }
+
+    pa_context_set_state_callback(pulse_ctx, pulse_contextcallback, NULL);
+
+    TRACE("libpulse protocol version: %u. API Version %u\n", pa_context_get_protocol_version(pulse_ctx), PA_API_VERSION);
+    if (pa_context_connect(pulse_ctx, NULL, 0, NULL) < 0)
+        goto fail;
+
+    /* Wait for connection */
+    while (pthread_cond_wait(&pulse_cond, &pulse_lock)) {
+        pa_context_state_t state = pa_context_get_state(pulse_ctx);
+
+        if (state == PA_CONTEXT_FAILED || state == PA_CONTEXT_TERMINATED)
+            goto fail;
+
+        if (state == PA_CONTEXT_READY)
+            break;
+    }
+
+    TRACE("Connected to server %s with protocol version: %i.\n",
+        pa_context_get_server(pulse_ctx),
+        pa_context_get_server_protocol_version(pulse_ctx));
+    return S_OK;
+
+fail:
+    pa_context_unref(pulse_ctx);
+    pulse_ctx = NULL;
+    return E_FAIL;
+}
+
+static void pulse_contextcallback(pa_context *c, void *userdata) {
+    switch (pa_context_get_state(c)) {
+        default:
+            FIXME("Unhandled state: %i\n", pa_context_get_state(c));
+        case PA_CONTEXT_CONNECTING:
+        case PA_CONTEXT_UNCONNECTED:
+        case PA_CONTEXT_AUTHORIZING:
+        case PA_CONTEXT_SETTING_NAME:
+            TRACE("State change to %i\n", pa_context_get_state(c));
+            return;
+
+        case PA_CONTEXT_READY:
+            TRACE("Ready\n");
+            break;
+
+        case PA_CONTEXT_TERMINATED:
+        case PA_CONTEXT_FAILED:
+            ERR("Context failed: %s\n", pa_strerror(pa_context_errno(c)));
+    }
+    pthread_cond_signal(&pulse_cond);
+}
+
+static void pulse_stream_state(pa_stream *s, void *user);
+
+static HRESULT pulse_stream_valid(ACImpl *This) {
+    if (!This->initted)
+        return AUDCLNT_E_NOT_INITIALIZED;
+    if (!This->stream || pa_stream_get_state(This->stream) != PA_STREAM_READY)
+        return AUDCLNT_E_DEVICE_INVALIDATED;
+    return S_OK;
+}
+
+static void dump_attr(const pa_buffer_attr *attr) {
+    TRACE("maxlength: %u\n", attr->maxlength);
+    TRACE("minreq: %u\n", attr->minreq);
+    TRACE("fragsize: %u\n", attr->fragsize);
+    TRACE("tlength: %u\n", attr->tlength);
+    TRACE("prebuf: %u\n", attr->prebuf);
+}
+
+static void pulse_op_cb(pa_stream *s, int success, void *user) {
+    TRACE("Success: %i\n", success);
+    *(int*)user = success;
+    pthread_cond_signal(&pulse_cond);
+}
+
+static void pulse_attr_update(pa_stream *s, void *user) {
+    const pa_buffer_attr *attr = pa_stream_get_buffer_attr(s);
+    TRACE("New attributes or device moved:\n");
+    dump_attr(attr);
+}
+
+static HRESULT pulse_stream_connect(ACImpl *This) {
+    int ret;
+    char buffer[64];
+    static LONG number;
+    pa_buffer_attr attr;
+    if (This->stream) {
+        pa_stream_disconnect(This->stream);
+        while (pa_stream_get_state(This->stream) == PA_STREAM_READY)
+            pthread_cond_wait(&pulse_cond, &pulse_lock);
+        pa_stream_unref(This->stream);
+    }
+    ret = InterlockedIncrement(&number);
+    sprintf(buffer, "audio stream #%i", ret);
+    This->stream = pa_stream_new(pulse_ctx, buffer, &This->ss, &This->map);
+    pa_stream_set_state_callback(This->stream, pulse_stream_state, This);
+    pa_stream_set_buffer_attr_callback(This->stream, pulse_attr_update, This);
+    pa_stream_set_moved_callback(This->stream, pulse_attr_update, This);
+
+    attr.maxlength = attr.tlength = This->bufsize_frames * pa_frame_size(&This->ss);
+    attr.minreq = attr.fragsize = pa_usec_to_bytes(This->min_period/10, &This->ss);
+    attr.prebuf = 0;
+    dump_attr(&attr);
+    if (This->dataflow == eRender)
+        ret = pa_stream_connect_playback(This->stream, NULL, &attr,
+        PA_STREAM_START_CORKED|PA_STREAM_START_UNMUTED|PA_STREAM_AUTO_TIMING_UPDATE|PA_STREAM_INTERPOLATE_TIMING|PA_STREAM_EARLY_REQUESTS, NULL, NULL);
+    else
+        ret = pa_stream_connect_record(This->stream, NULL, &attr,
+        PA_STREAM_START_CORKED|PA_STREAM_START_UNMUTED|PA_STREAM_AUTO_TIMING_UPDATE|PA_STREAM_INTERPOLATE_TIMING|PA_STREAM_EARLY_REQUESTS);
+    if (ret < 0) {
+        WARN("Returns %i\n", ret);
+        return AUDCLNT_E_ENDPOINT_CREATE_FAILED;
+    }
+    while (pa_stream_get_state(This->stream) == PA_STREAM_CREATING)
+        pthread_cond_wait(&pulse_cond, &pulse_lock);
+    if (pa_stream_get_state(This->stream) != PA_STREAM_READY)
+        return AUDCLNT_E_ENDPOINT_CREATE_FAILED;
+    return S_OK;
+}
+
+static void pulse_stream_state(pa_stream *s, void *user)
+{
+    pa_stream_state_t state = pa_stream_get_state(s);
+    TRACE("Stream state changed to %i\n", state);
+    pthread_cond_signal(&pulse_cond);
+}
+
+HRESULT WINAPI AUDDRV_GetEndpointIDs(EDataFlow flow, WCHAR ***ids, void ***keys,
+        UINT *num, UINT *def_index)
+{
+    HRESULT hr = S_OK;
+    TRACE("%d %p %p %p\n", flow, ids, num, def_index);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_connect();
+    pthread_mutex_unlock(&pulse_lock);
+    if (FAILED(hr))
+        return hr;
+    *num = 1;
+    *def_index = 0;
+
+    *ids = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR *));
+    if(!*ids)
+        return E_OUTOFMEMORY;
+
+    (*ids)[0] = HeapAlloc(GetProcessHeap(), 0, sizeof(defaultW));
+    if(!(*ids)[0]){
+        HeapFree(GetProcessHeap(), 0, *ids);
+        return E_OUTOFMEMORY;
+    }
+
+    lstrcpyW((*ids)[0], defaultW);
+
+    *keys = HeapAlloc(GetProcessHeap(), 0, sizeof(void *));
+    (*keys)[0] = NULL;
+
+    return S_OK;
+}
+
+HRESULT WINAPI AUDDRV_GetAudioEndpoint(void *key, IMMDevice *dev,
+        EDataFlow dataflow, IAudioClient **out)
+{
+    HRESULT hr;
+    ACImpl *This;
+
+    TRACE("%p %p %d %p\n", key, dev, dataflow, out);
+    if(dataflow != eRender && dataflow != eCapture)
+        return E_UNEXPECTED;
+
+    *out = NULL;
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_connect();
+    pthread_mutex_unlock(&pulse_lock);
+    if (FAILED(hr))
+        return hr;
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ACImpl));
+    if(!This)
+        return E_OUTOFMEMORY;
+
+    This->IAudioClient_iface.lpVtbl = &AudioClient_Vtbl;
+    This->IAudioRenderClient_iface.lpVtbl = &AudioRenderClient_Vtbl;
+    This->IAudioCaptureClient_iface.lpVtbl = &AudioCaptureClient_Vtbl;
+    This->IAudioSessionControl2_iface.lpVtbl = &AudioSessionControl2_Vtbl;
+    This->ISimpleAudioVolume_iface.lpVtbl = &SimpleAudioVolume_Vtbl;
+    This->IAudioClock_iface.lpVtbl = &AudioClock_Vtbl;
+    This->IAudioClock2_iface.lpVtbl = &AudioClock2_Vtbl;
+    This->dataflow = dataflow;
+    This->parent = dev;
+    IMMDevice_AddRef(This->parent);
+
+    *out = &This->IAudioClient_iface;
+    IAudioClient_AddRef(&This->IAudioClient_iface);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_QueryInterface(IAudioClient *iface,
+        REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+    if(IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IAudioClient))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClient_AddRef(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioClient_Release(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    if(!ref){
+        if (This->stream) {
+            pthread_mutex_lock(&pulse_lock);
+            if (pa_stream_get_state(This->stream) == PA_STREAM_READY)
+                pa_stream_disconnect(This->stream);
+            pa_stream_unref(This->stream);
+            pthread_mutex_unlock(&pulse_lock);
+        }
+        IMMDevice_Release(This->parent);
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static void dump_fmt(const WAVEFORMATEX *fmt)
+{
+    TRACE("wFormatTag: 0x%x (", fmt->wFormatTag);
+    switch(fmt->wFormatTag){
+    case WAVE_FORMAT_PCM:
+        TRACE("WAVE_FORMAT_PCM");
+        break;
+    case WAVE_FORMAT_IEEE_FLOAT:
+        TRACE("WAVE_FORMAT_IEEE_FLOAT");
+        break;
+    case WAVE_FORMAT_EXTENSIBLE:
+        TRACE("WAVE_FORMAT_EXTENSIBLE");
+        break;
+    default:
+        TRACE("Unknown");
+        break;
+    }
+    TRACE(")\n");
+
+    TRACE("nChannels: %u\n", fmt->nChannels);
+    TRACE("nSamplesPerSec: %u\n", fmt->nSamplesPerSec);
+    TRACE("nAvgBytesPerSec: %u\n", fmt->nAvgBytesPerSec);
+    TRACE("nBlockAlign: %u\n", fmt->nBlockAlign);
+    TRACE("wBitsPerSample: %u\n", fmt->wBitsPerSample);
+    TRACE("cbSize: %u\n", fmt->cbSize);
+
+    if(fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE){
+        WAVEFORMATEXTENSIBLE *fmtex = (void*)fmt;
+        TRACE("dwChannelMask: %08x\n", fmtex->dwChannelMask);
+        TRACE("Samples: %04x\n", fmtex->Samples.wReserved);
+        TRACE("SubFormat: %s\n", wine_dbgstr_guid(&fmtex->SubFormat));
+    }
+}
+
+static WAVEFORMATEX *clone_format(const WAVEFORMATEX *fmt)
+{
+    WAVEFORMATEX *ret;
+    size_t size;
+
+    if(fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
+        size = sizeof(WAVEFORMATEXTENSIBLE);
+    else
+        size = sizeof(WAVEFORMATEX);
+
+    ret = HeapAlloc(GetProcessHeap(), 0, size);
+    if(!ret)
+        return NULL;
+
+    memcpy(ret, fmt, size);
+
+    ret->cbSize = size - sizeof(WAVEFORMATEX);
+
+    return ret;
+}
+
+static DWORD get_channel_mask(unsigned int channels)
+{
+    switch(channels){
+    case 0:
+        return 0;
+    case 1:
+        return SPEAKER_FRONT_CENTER;
+    case 2:
+        return SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;
+    case 3:
+        return SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT |
+            SPEAKER_LOW_FREQUENCY;
+    case 4:
+        return SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_BACK_LEFT |
+            SPEAKER_BACK_RIGHT;
+    case 5:
+        return SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_BACK_LEFT |
+            SPEAKER_BACK_RIGHT | SPEAKER_LOW_FREQUENCY;
+    case 6:
+        return SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_BACK_LEFT |
+            SPEAKER_BACK_RIGHT | SPEAKER_LOW_FREQUENCY | SPEAKER_FRONT_CENTER;
+    case 7:
+        return SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_BACK_LEFT |
+            SPEAKER_BACK_RIGHT | SPEAKER_LOW_FREQUENCY | SPEAKER_FRONT_CENTER |
+            SPEAKER_BACK_CENTER;
+    case 8:
+        return SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_BACK_LEFT |
+            SPEAKER_BACK_RIGHT | SPEAKER_LOW_FREQUENCY | SPEAKER_FRONT_CENTER |
+            SPEAKER_SIDE_LEFT | SPEAKER_SIDE_RIGHT;
+    }
+    FIXME("Unknown speaker configuration: %u\n", channels);
+    return 0;
+}
+
+static HRESULT WINAPI AudioClient_Initialize(IAudioClient *iface,
+        AUDCLNT_SHAREMODE mode, DWORD flags, REFERENCE_TIME duration,
+        REFERENCE_TIME period, const WAVEFORMATEX *fmt,
+        const GUID *sessionguid)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("(%p)->(%x, %x, %s, %s, %p, %s)\n", This, mode, flags,
+          wine_dbgstr_longlong(duration), wine_dbgstr_longlong(period), fmt, debugstr_guid(sessionguid));
+
+    if(!fmt)
+        return E_POINTER;
+
+    if(mode != AUDCLNT_SHAREMODE_SHARED && mode != AUDCLNT_SHAREMODE_EXCLUSIVE)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    if(flags & ~(AUDCLNT_STREAMFLAGS_CROSSPROCESS |
+                AUDCLNT_STREAMFLAGS_LOOPBACK |
+                AUDCLNT_STREAMFLAGS_EVENTCALLBACK |
+                AUDCLNT_STREAMFLAGS_NOPERSIST |
+                AUDCLNT_STREAMFLAGS_RATEADJUST |
+                AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED)){
+        TRACE("Unknown flags: %08x\n", flags);
+        return E_INVALIDARG;
+    }
+
+    pthread_mutex_lock(&pulse_lock);
+    if(This->initted){
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_ALREADY_INITIALIZED;
+    }
+    pa_channel_map_init(&This->map);
+    This->ss.rate = fmt->nSamplesPerSec;
+    This->ss.format = PA_SAMPLE_INVALID;
+    switch(fmt->wFormatTag){
+    case WAVE_FORMAT_PCM:
+        if(fmt->wBitsPerSample == 8)
+            This->ss.format = PA_SAMPLE_U8;
+        else if(fmt->wBitsPerSample == 16)
+            This->ss.format = PA_SAMPLE_S16LE;
+        if (fmt->nChannels == 1 || fmt->nChannels == 2)
+            pa_channel_map_init_auto(&This->map, fmt->nChannels, PA_CHANNEL_MAP_ALSA);
+        break;
+    case WAVE_FORMAT_IEEE_FLOAT:
+        This->ss.format = PA_SAMPLE_FLOAT32LE;
+        if (fmt->nChannels == 1 || fmt->nChannels == 2)
+            pa_channel_map_init_auto(&This->map, fmt->nChannels, PA_CHANNEL_MAP_ALSA);
+        break;
+    case WAVE_FORMAT_EXTENSIBLE: {
+        WAVEFORMATEXTENSIBLE *wfe = (WAVEFORMATEXTENSIBLE*)fmt;
+        DWORD mask = wfe->dwChannelMask;
+        DWORD i = 0;
+        if (fmt->cbSize != (sizeof(*wfe) - sizeof(*fmt)) && fmt->cbSize != sizeof(*wfe))
+            break;
+        if (IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))
+            This->ss.format = PA_SAMPLE_FLOAT32LE;
+        else if (IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM))
+        {
+            DWORD valid = wfe->Samples.wValidBitsPerSample;
+            if (!valid)
+                valid = fmt->wBitsPerSample;
+            if (!valid || valid > fmt->wBitsPerSample)
+                break;
+            switch (fmt->wBitsPerSample) {
+                case 8:
+                    if (valid == 8)
+                        This->ss.format = PA_SAMPLE_U8;
+                    break;
+                case 16:
+                    if (valid == 16)
+                        This->ss.format = PA_SAMPLE_S16LE;
+                    break;
+                case 24:
+                    if (valid == 24)
+                        This->ss.format = PA_SAMPLE_S24LE;
+                    break;
+                case 32:
+                    if (valid == 24)
+                        This->ss.format = PA_SAMPLE_S24_32LE;
+                    else if (valid == 32)
+                        This->ss.format = PA_SAMPLE_S32LE;
+                default:
+                    break;
+            }
+        }
+        This->map.channels = fmt->nChannels;
+        if (!mask)
+            mask = get_channel_mask(fmt->nChannels);
+        if (mask & SPEAKER_FRONT_LEFT) This->map.map[i++] = PA_CHANNEL_POSITION_FRONT_LEFT;
+        if (mask & SPEAKER_FRONT_RIGHT) This->map.map[i++] = PA_CHANNEL_POSITION_FRONT_RIGHT;
+        if (mask & SPEAKER_FRONT_CENTER) This->map.map[i++] = PA_CHANNEL_POSITION_FRONT_CENTER;
+        if (mask & SPEAKER_LOW_FREQUENCY) This->map.map[i++] = PA_CHANNEL_POSITION_SUBWOOFER;
+        if (mask & SPEAKER_BACK_LEFT) This->map.map[i++] = PA_CHANNEL_POSITION_REAR_LEFT;
+        if (mask & SPEAKER_BACK_RIGHT) This->map.map[i++] = PA_CHANNEL_POSITION_REAR_RIGHT;
+        if (mask & SPEAKER_BACK_CENTER) This->map.map[i++] = PA_CHANNEL_POSITION_REAR_CENTER;
+        if (mask & SPEAKER_FRONT_LEFT_OF_CENTER) This->map.map[i++] = PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER;
+        if (mask & SPEAKER_FRONT_RIGHT_OF_CENTER) This->map.map[i++] = PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER;
+        if (mask & SPEAKER_BACK_CENTER) This->map.map[i++] = PA_CHANNEL_POSITION_REAR_CENTER;
+        if (mask & SPEAKER_SIDE_LEFT) This->map.map[i++] = PA_CHANNEL_POSITION_SIDE_LEFT;
+        if (mask & SPEAKER_SIDE_RIGHT) This->map.map[i++] = PA_CHANNEL_POSITION_SIDE_RIGHT;
+        if (mask & SPEAKER_TOP_CENTER) This->map.map[i++] = PA_CHANNEL_POSITION_TOP_CENTER;
+        if (mask & SPEAKER_TOP_FRONT_LEFT) This->map.map[i++] = PA_CHANNEL_POSITION_TOP_FRONT_LEFT;
+        if (mask & SPEAKER_TOP_FRONT_CENTER) This->map.map[i++] = PA_CHANNEL_POSITION_TOP_FRONT_CENTER;
+        if (mask & SPEAKER_TOP_FRONT_RIGHT) This->map.map[i++] = PA_CHANNEL_POSITION_TOP_FRONT_RIGHT;
+        if (mask & SPEAKER_TOP_BACK_LEFT) This->map.map[i++] = PA_CHANNEL_POSITION_TOP_REAR_LEFT;
+        if (mask & SPEAKER_TOP_BACK_CENTER) This->map.map[i++] = PA_CHANNEL_POSITION_TOP_REAR_CENTER;
+        if (mask & SPEAKER_TOP_BACK_RIGHT) This->map.map[i++] = PA_CHANNEL_POSITION_TOP_REAR_RIGHT;
+        if (mask & SPEAKER_ALL) {
+            This->map.map[i++] = PA_CHANNEL_POSITION_MONO;
+            FIXME("Is the 'all' channel mapped correctly?\n");
+        }
+        if (i != fmt->nChannels || mask & SPEAKER_RESERVED) {
+            This->map.channels = 0;
+            FIXME("Invalid channel mask: %i/%i and %x\n", i, fmt->nChannels, mask);
+            break;
+        }
+        /* Special case for mono since pulse appears to map it differently */
+        if (mask == SPEAKER_FRONT_CENTER)
+            This->map.map[0] = PA_CHANNEL_POSITION_MONO;
+        break;
+        }
+        default: FIXME("Unhandled tag %x\n", fmt->wFormatTag);
+    }
+    This->ss.channels = This->map.channels;
+    hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+    if (!pa_channel_map_valid(&This->map) || This->ss.format == PA_SAMPLE_INVALID) {
+        WARN("Invalid format! Channel spec valid: %i, format: %i\n", pa_channel_map_valid(&This->map), This->ss.format);
+        dump_fmt(fmt);
+        goto exit;
+    }
+    if (duration < 5000000)
+        This->bufsize_frames = fmt->nSamplesPerSec/2;
+    else if (duration < 20000000)
+        This->bufsize_frames = ceil((duration / 10000000.) * fmt->nSamplesPerSec);
+    else
+        This->bufsize_frames = 2 * fmt->nSamplesPerSec;
+
+    hr = pulse_stream_connect(This);
+    if (SUCCEEDED(hr)) {
+        /* Update frames according to new size */
+        This->bufsize_frames = pa_stream_get_buffer_attr(This->stream)->tlength / pa_frame_size(&This->ss);
+        //hr = AudioSession_CreateSession(This, sessionguid ? sessionguid : &GUID_NULL);
+        if (SUCCEEDED(hr))
+            This->initted = TRUE;
+    }
+    This->share = mode;
+    This->flags = flags;
+
+exit:
+    if(FAILED(hr)) {
+        if (This->stream) {
+            pa_stream_disconnect(This->stream);
+            pa_stream_unref(This->stream);
+            This->stream = NULL;
+        }
+    }
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetBufferSize(IAudioClient *iface,
+        UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if(!out)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (SUCCEEDED(hr))
+        *out = This->bufsize_frames;
+    pthread_mutex_unlock(&pulse_lock);
+
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetStreamLatency(IAudioClient *iface,
+        REFERENCE_TIME *latency)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    const pa_buffer_attr *attr;
+    REFERENCE_TIME lat;
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, latency);
+
+    if(!latency)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+    attr = pa_stream_get_buffer_attr(This->stream);
+    if (This->dataflow == eCapture)
+        lat = attr->fragsize / pa_frame_size(&This->ss);
+    else
+        lat = attr->minreq / pa_frame_size(&This->ss);
+    *latency = 10000000;
+    *latency *= lat;
+    *latency /= This->ss.rate;
+    pthread_mutex_unlock(&pulse_lock);
+    TRACE("Latency: %u ms\n", (DWORD)(*latency / 10000));
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_GetCurrentPadding(IAudioClient *iface,
+        UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if(!out)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if(This->dataflow == eRender){
+        UINT32 avail = pa_stream_writable_size(This->stream) / pa_frame_size(&This->ss);
+        if (avail + This->extra_buffered >= This->bufsize_frames)
+            *out = 0;
+        else
+            *out = This->bufsize_frames - avail - This->extra_buffered;
+    }else if(This->dataflow == eCapture){
+        if (!This->peeked) {
+            DWORD frag, readable = pa_stream_readable_size(This->stream);
+            pa_stream_peek(This->stream, (const void**)&This->locked_ptr, &frag);
+            if (frag != readable) {
+                DWORD done = frag;
+                This->tmp_buffer = HeapAlloc(GetProcessHeap(), 0, readable);
+                memcpy(This->tmp_buffer, This->locked_ptr, frag);
+                pa_stream_drop(This->stream);
+                while (done < readable) {
+                    pa_stream_peek(This->stream, (const void **)&This->locked_ptr, &frag);
+                    memcpy(This->tmp_buffer + done, This->locked_ptr, frag);
+                    pa_stream_drop(This->stream);
+                    done += frag;
+                }
+                if (done > readable)
+                    ERR("Read %u instead of %u\n", done, This->peeked);
+                This->locked_ptr = NULL;
+            }
+            This->peeked = readable;
+        }
+        *out = This->peeked / pa_frame_size(&This->ss);
+    }else{
+        pthread_mutex_unlock(&pulse_lock);
+        return E_UNEXPECTED;
+    }
+    pthread_mutex_unlock(&pulse_lock);
+
+    TRACE("Pad: %u\n", *out);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_IsFormatSupported(IAudioClient *iface,
+        AUDCLNT_SHAREMODE mode, const WAVEFORMATEX *fmt,
+        WAVEFORMATEX **out)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+    WAVEFORMATEX *closest = NULL;
+    WAVEFORMATEXTENSIBLE *wfe;
+
+    TRACE("(%p)->(%x, %p, %p)\n", This, mode, fmt, out);
+
+    if(!fmt || (mode == AUDCLNT_SHAREMODE_SHARED && !out))
+        return E_POINTER;
+
+    if(mode != AUDCLNT_SHAREMODE_SHARED && mode != AUDCLNT_SHAREMODE_EXCLUSIVE)
+        return E_INVALIDARG;
+
+    if(fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
+            fmt->cbSize < sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX))
+        return E_INVALIDARG;
+
+    dump_fmt(fmt);
+
+    closest = clone_format(fmt);
+    if(!closest){
+        hr = E_OUTOFMEMORY;
+        goto exit;
+    }
+    wfe = (WAVEFORMATEXTENSIBLE*)closest;
+    if (closest->wFormatTag == WAVE_FORMAT_EXTENSIBLE && !wfe->dwChannelMask) {
+        wfe->dwChannelMask = get_channel_mask(closest->nChannels);
+        hr = S_FALSE;
+        WARN("Fixed up channel mask %p -> %p\n", fmt, closest);
+    }
+
+exit:
+    if(hr == S_OK || !out){
+        HeapFree(GetProcessHeap(), 0, closest);
+        if(out)
+            *out = NULL;
+    }else if(closest){
+        closest->nBlockAlign =
+            closest->nChannels * closest->wBitsPerSample / 8;
+        closest->nAvgBytesPerSec =
+            closest->nBlockAlign * closest->nSamplesPerSec;
+        *out = closest;
+    }
+
+    TRACE("returning: %08x %p\n", hr, out ? *out : NULL);
+    return hr;
+}
+
+static void pulse_probe_settings(ACImpl *This) {
+    pa_stream *stream;
+    pa_channel_map map;
+    pa_sample_spec ss;
+    pa_buffer_attr attr;
+    int ret;
+    unsigned int length = 0;
+
+    if (This->mix_ss.rate)
+        return;
+
+    pa_channel_map_init_auto(&map, 2, PA_CHANNEL_MAP_ALSA);
+    ss.rate = 48000;
+    ss.format = PA_SAMPLE_FLOAT32LE;
+    ss.channels = map.channels;
+
+    attr.maxlength = -1;
+    attr.tlength = -1;
+    attr.minreq = attr.fragsize = pa_frame_size(&ss);
+    attr.prebuf = 0;
+
+    stream = pa_stream_new(pulse_ctx, "format test stream", &ss, &map);
+    if (stream)
+        pa_stream_set_state_callback(stream, pulse_stream_state, NULL);
+    if (!stream)
+        ret = -1;
+    else if (This->dataflow == eRender)
+        ret = pa_stream_connect_playback(stream, NULL, &attr,
+        PA_STREAM_START_CORKED|PA_STREAM_FIX_RATE|PA_STREAM_FIX_FORMAT|PA_STREAM_FIX_CHANNELS|PA_STREAM_EARLY_REQUESTS, NULL, NULL);
+    else
+        ret = pa_stream_connect_record(stream, NULL, &attr,
+        PA_STREAM_START_CORKED|PA_STREAM_FIX_RATE|PA_STREAM_FIX_FORMAT|PA_STREAM_FIX_CHANNELS|PA_STREAM_EARLY_REQUESTS);
+    if (ret >= 0) {
+        while (pa_stream_get_state(stream) == PA_STREAM_CREATING)
+            pthread_cond_wait(&pulse_cond, &pulse_lock);
+        if (pa_stream_get_state(stream) == PA_STREAM_READY) {
+            ss = *pa_stream_get_sample_spec(stream);
+            map = *pa_stream_get_channel_map(stream);
+            if (This->dataflow == eRender)
+                length = pa_stream_get_buffer_attr(stream)->minreq;
+            else
+                length = pa_stream_get_buffer_attr(stream)->fragsize;
+            pa_stream_disconnect(stream);
+            while (pa_stream_get_state(stream) == PA_STREAM_READY)
+                pthread_cond_wait(&pulse_cond, &pulse_lock);
+        }
+    }
+    if (stream)
+        pa_stream_unref(stream);
+    This->mix_ss = ss;
+    This->mix_map = map;
+    if (length)
+        This->def_period = This->min_period = pa_bytes_to_usec(10 * length, &This->mix_ss);
+    else
+        This->min_period = MinimumPeriod;
+    if (This->def_period <= MinimumPeriod)
+        This->def_period = MinimumPeriod;
+}
+
+static HRESULT WINAPI AudioClient_GetMixFormat(IAudioClient *iface,
+        WAVEFORMATEX **pwfx)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    WAVEFORMATEXTENSIBLE *fmt;
+    HRESULT hr = S_OK;
+    int i;
+
+    TRACE("(%p)->(%p)\n", This, pwfx);
+
+    if(!pwfx)
+        return E_POINTER;
+
+    *pwfx = CoTaskMemAlloc(sizeof(WAVEFORMATEXTENSIBLE));
+    if(!*pwfx)
+        return E_OUTOFMEMORY;
+
+    fmt = (WAVEFORMATEXTENSIBLE*)*pwfx;
+
+    pthread_mutex_lock(&pulse_lock);
+    pulse_probe_settings(This);
+    pthread_mutex_unlock(&pulse_lock);
+
+    (*pwfx)->wFormatTag = WAVE_FORMAT_EXTENSIBLE;
+    (*pwfx)->cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
+    (*pwfx)->nChannels = This->mix_ss.channels;
+    (*pwfx)->wBitsPerSample = 8 * pa_sample_size_of_format(This->mix_ss.format);
+    (*pwfx)->nSamplesPerSec = This->mix_ss.rate;
+    (*pwfx)->nBlockAlign = (*pwfx)->nChannels * (*pwfx)->wBitsPerSample / 8;
+    (*pwfx)->nAvgBytesPerSec = (*pwfx)->nSamplesPerSec * (*pwfx)->nBlockAlign;
+    if (This->mix_ss.format != PA_SAMPLE_S24_32LE)
+        fmt->Samples.wValidBitsPerSample = (*pwfx)->wBitsPerSample;
+    else
+        fmt->Samples.wValidBitsPerSample = 24;
+    if (This->mix_ss.format == PA_SAMPLE_FLOAT32LE)
+        fmt->SubFormat = KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
+    else
+        fmt->SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
+
+    fmt->dwChannelMask = 0;
+    for (i = 0; i < This->mix_map.channels; ++i)
+        switch (This->mix_map.map[i]) {
+            default: FIXME("Unhandled channel %s\n", pa_channel_position_to_string(This->mix_map.map[i])); break;
+            case PA_CHANNEL_POSITION_FRONT_LEFT: fmt->dwChannelMask |= SPEAKER_FRONT_LEFT; break;
+            case PA_CHANNEL_POSITION_FRONT_RIGHT: fmt->dwChannelMask |= SPEAKER_FRONT_RIGHT; break;
+            case PA_CHANNEL_POSITION_MONO:
+            case PA_CHANNEL_POSITION_FRONT_CENTER: fmt->dwChannelMask |= SPEAKER_FRONT_CENTER; break;
+            case PA_CHANNEL_POSITION_REAR_LEFT: fmt->dwChannelMask |= SPEAKER_BACK_LEFT; break;
+            case PA_CHANNEL_POSITION_REAR_RIGHT: fmt->dwChannelMask |= SPEAKER_BACK_RIGHT; break;
+            case PA_CHANNEL_POSITION_SUBWOOFER: fmt->dwChannelMask |= SPEAKER_LOW_FREQUENCY; break;
+            case PA_CHANNEL_POSITION_SIDE_LEFT: fmt->dwChannelMask |= SPEAKER_SIDE_LEFT; break;
+            case PA_CHANNEL_POSITION_SIDE_RIGHT: fmt->dwChannelMask |= SPEAKER_SIDE_RIGHT; break;
+        }
+    dump_fmt((WAVEFORMATEX*)fmt);
+    if(FAILED(hr)) {
+        CoTaskMemFree(*pwfx);
+        *pwfx = NULL;
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetDevicePeriod(IAudioClient *iface,
+        REFERENCE_TIME *defperiod, REFERENCE_TIME *minperiod)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+
+    TRACE("(%p)->(%p, %p)\n", This, defperiod, minperiod);
+
+    if(!defperiod && !minperiod)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    pulse_probe_settings(This);
+    if(defperiod)
+        *defperiod = This->def_period;
+    if(minperiod)
+        *minperiod = This->min_period;
+    pthread_mutex_unlock(&pulse_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Start(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+    int success;
+    pa_operation *o;
+
+    TRACE("(%p)\n", This);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if((This->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) && !This->event){
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_EVENTHANDLE_NOT_SET;
+    }
+
+    if(This->started){
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_NOT_STOPPED;
+    }
+
+    o = pa_stream_cork(This->stream, 0, pulse_op_cb, &success);
+    if (o) {
+        while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+            pthread_cond_wait(&pulse_cond, &pulse_lock);
+        pa_operation_unref(o);
+    } else
+        success = 0;
+    if (!success)
+        hr = E_FAIL;
+    if (SUCCEEDED(hr))
+        This->started = TRUE;
+    if (This->event)
+        SetEvent(This->event);
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_Stop(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+    pa_operation *o;
+    int success;
+
+    TRACE("(%p)\n", This);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if(!This->started){
+        pthread_mutex_unlock(&pulse_lock);
+        return S_FALSE;
+    }
+
+    o = pa_stream_cork(This->stream, 1, pulse_op_cb, &success);
+    if (o) {
+        while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+            pthread_cond_wait(&pulse_cond, &pulse_lock);
+        pa_operation_unref(o);
+    } else
+        success = 0;
+    if (!success)
+        hr = E_FAIL;
+    if (SUCCEEDED(hr))
+        This->started = FALSE;
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_Reset(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    pa_usec_t time;
+    pa_operation *o;
+    int success;
+    HRESULT hr = S_OK;
+
+    TRACE("(%p)\n", This);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if(This->started){
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_NOT_STOPPED;
+    }
+
+    if (pa_stream_get_time(This->stream, &time) >= 0)
+        This->play_ofs += time * This->ss.rate / 1000000;
+
+    o = pa_stream_flush(This->stream, pulse_op_cb, &success);
+    if (o) {
+        while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+            pthread_cond_wait(&pulse_cond, &pulse_lock);
+        pa_operation_unref(o);
+    } else
+        success = 0;
+    if (!success)
+        hr = S_FALSE;
+    pthread_mutex_unlock(&pulse_lock);
+
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_SetEventHandle(IAudioClient *iface,
+        HANDLE event)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, event);
+
+    if(!event)
+        return E_INVALIDARG;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if(!(This->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK)){
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED;
+    }
+    This->event = event;
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_GetService(IAudioClient *iface, REFIID riid,
+        void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    pthread_mutex_unlock(&pulse_lock);
+    if (FAILED(hr))
+        return hr;
+
+    if(IsEqualIID(riid, &IID_IAudioRenderClient)){
+        if(This->dataflow != eRender)
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        *ppv = &This->IAudioRenderClient_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioCaptureClient)){
+        if(This->dataflow != eCapture)
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        *ppv = &This->IAudioCaptureClient_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioSessionControl)){
+        *ppv = &This->IAudioSessionControl2_iface;
+    }else if(IsEqualIID(riid, &IID_ISimpleAudioVolume)){
+        *ppv = &This->ISimpleAudioVolume_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioClock)){
+        *ppv = &This->IAudioClock_iface;
+    }
+
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    FIXME("stub %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static const IAudioClientVtbl AudioClient_Vtbl =
+{
+    AudioClient_QueryInterface,
+    AudioClient_AddRef,
+    AudioClient_Release,
+    AudioClient_Initialize,
+    AudioClient_GetBufferSize,
+    AudioClient_GetStreamLatency,
+    AudioClient_GetCurrentPadding,
+    AudioClient_IsFormatSupported,
+    AudioClient_GetMixFormat,
+    AudioClient_GetDevicePeriod,
+    AudioClient_Start,
+    AudioClient_Stop,
+    AudioClient_Reset,
+    AudioClient_SetEventHandle,
+    AudioClient_GetService
+};
+
+static HRESULT WINAPI AudioRenderClient_QueryInterface(
+        IAudioRenderClient *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioRenderClient))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioRenderClient_AddRef(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioRenderClient_Release(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioRenderClient_GetBuffer(IAudioRenderClient *iface,
+        UINT32 frames, BYTE **data)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    UINT32 requested, avail;
+    HRESULT hr = S_OK;
+
+    TRACE("(%p)->(%u, %p)\n", This, frames, data);
+
+    if(!data)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if(FAILED(hr) || This->locked){
+        pthread_mutex_unlock(&pulse_lock);
+        return FAILED(hr) ? hr : AUDCLNT_E_OUT_OF_ORDER;
+    }
+    avail = pa_stream_writable_size(This->stream) / pa_frame_size(&This->ss);
+    if (avail < frames){
+        pthread_mutex_unlock(&pulse_lock);
+        WARN("Wanted to write %u, but only %u available\n", frames, avail);
+        return AUDCLNT_E_BUFFER_TOO_LARGE;
+    }
+
+    requested = frames * pa_frame_size(&This->ss);
+    pa_stream_begin_write(This->stream, (void**)data, &requested);
+    This->locked = frames;
+    if (requested / pa_frame_size(&This->ss) < frames) {
+        pa_stream_cancel_write(This->stream);
+        FIXME("Unable to allocate all (%u/%u) preparing our own buffer\n", requested / pa_frame_size(&This->ss), frames);
+        *data = This->locked_ptr = This->tmp_buffer = HeapAlloc(GetProcessHeap(), 0, frames * pa_frame_size(&This->ss));
+    } else {
+        This->locked_ptr = *data;
+    }
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static void free_heap(void *p)
+{
+    HeapFree(GetProcessHeap(), 0, p);
+}
+
+static HRESULT WINAPI AudioRenderClient_ReleaseBuffer(
+        IAudioRenderClient *iface, UINT32 written_frames, DWORD flags)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    int written;
+
+    TRACE("(%p)->(%u, %x)\n", This, written_frames, flags);
+
+    pthread_mutex_lock(&pulse_lock);
+    if(!This->locked || !written_frames){
+        if (This->tmp_buffer) {
+            HeapFree(GetProcessHeap(), 0, This->tmp_buffer);
+            This->tmp_buffer = NULL;
+        } else if (This->locked)
+            pa_stream_cancel_write(This->stream);
+        This->locked = 0;
+        pthread_mutex_unlock(&pulse_lock);
+        return written_frames ? AUDCLNT_E_OUT_OF_ORDER : S_OK;
+    }
+
+    if(flags & AUDCLNT_BUFFERFLAGS_SILENT){
+        if(This->ss.format == PA_SAMPLE_U8)
+            memset(This->locked_ptr, 128, written_frames * pa_frame_size(&This->ss));
+        else
+            memset(This->locked_ptr, 0, written_frames * pa_frame_size(&This->ss));
+    }
+
+    This->locked = 0;
+    if (!This->tmp_buffer)
+        written = pa_stream_write(This->stream, This->locked_ptr, written_frames * pa_frame_size(&This->ss), NULL, 0, PA_SEEK_RELATIVE);
+    else
+        written = pa_stream_write(This->stream, This->locked_ptr, written_frames * pa_frame_size(&This->ss), free_heap, 0, PA_SEEK_RELATIVE);
+    This->tmp_buffer = NULL;
+    TRACE("Released %u, wrote %i\n", written_frames * pa_frame_size(&This->ss), written);
+    pthread_mutex_unlock(&pulse_lock);
+
+    return S_OK;
+}
+
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl = {
+    AudioRenderClient_QueryInterface,
+    AudioRenderClient_AddRef,
+    AudioRenderClient_Release,
+    AudioRenderClient_GetBuffer,
+    AudioRenderClient_ReleaseBuffer
+};
+
+static HRESULT WINAPI AudioCaptureClient_QueryInterface(
+        IAudioCaptureClient *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioCaptureClient))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioCaptureClient_AddRef(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioCaptureClient_Release(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetBuffer(IAudioCaptureClient *iface,
+        BYTE **data, UINT32 *frames, DWORD *flags, UINT64 *devpos,
+        UINT64 *qpcpos)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p, %p, %p, %p, %p)\n", This, data, frames, flags,
+            devpos, qpcpos);
+
+    if(!data || !frames || !flags)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if(FAILED(hr) || This->locked){
+        pthread_mutex_unlock(&pulse_lock);
+        return FAILED(hr) ? hr : AUDCLNT_E_OUT_OF_ORDER;
+    }
+    *data = NULL;
+    *flags = 0;
+    *frames = This->peeked / pa_frame_size(&This->ss);
+    if (*frames)
+        *data = This->locked_ptr ? This->locked_ptr : This->tmp_buffer;
+    This->locked = *frames;
+    pthread_mutex_unlock(&pulse_lock);
+    if(devpos || qpcpos)
+        IAudioClock_GetPosition(&This->IAudioClock_iface, devpos, qpcpos);
+
+    return *frames ? S_OK : AUDCLNT_S_BUFFER_EMPTY;
+}
+
+static HRESULT WINAPI AudioCaptureClient_ReleaseBuffer(
+        IAudioCaptureClient *iface, UINT32 done)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+
+    TRACE("(%p)->(%u)\n", This, done);
+
+    pthread_mutex_lock(&pulse_lock);
+    if (done) {
+        if (This->locked_ptr) {
+            pa_stream_drop(This->stream);
+            This->locked_ptr = NULL;
+        } else {
+            HeapFree(GetProcessHeap(), 0, This->tmp_buffer);
+            This->tmp_buffer = NULL;
+        }
+        This->peeked = 0;
+    }
+    This->locked = 0;
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetNextPacketSize(
+        IAudioCaptureClient *iface, UINT32 *frames)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+
+    TRACE("(%p)->(%p)\n", This, frames);
+    return AudioClient_GetCurrentPadding(&This->IAudioClient_iface, frames);
+}
+
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl =
+{
+    AudioCaptureClient_QueryInterface,
+    AudioCaptureClient_AddRef,
+    AudioCaptureClient_Release,
+    AudioCaptureClient_GetBuffer,
+    AudioCaptureClient_ReleaseBuffer,
+    AudioCaptureClient_GetNextPacketSize
+};
+
+static HRESULT WINAPI SimpleAudioVolume_QueryInterface(
+        ISimpleAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_ISimpleAudioVolume))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI SimpleAudioVolume_AddRef(ISimpleAudioVolume *iface)
+{
+    ACImpl *This = impl_from_ISimpleAudioVolume(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI SimpleAudioVolume_Release(ISimpleAudioVolume *iface)
+{
+    ACImpl *This = impl_from_ISimpleAudioVolume(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMasterVolume(
+        ISimpleAudioVolume *iface, float level, const GUID *context)
+{
+    ACImpl *This = impl_from_ISimpleAudioVolume(iface);
+
+    FIXME("(%p)->(%f, %p) - stub\n", This, level, context);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMasterVolume(
+        ISimpleAudioVolume *iface, float *level)
+{
+    ACImpl *This = impl_from_ISimpleAudioVolume(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, level);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMute(ISimpleAudioVolume *iface,
+        BOOL mute, const GUID *context)
+{
+    ACImpl *This = impl_from_ISimpleAudioVolume(iface);
+
+    FIXME("(%p)->(%u, %p) - stub\n", This, mute, context);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMute(ISimpleAudioVolume *iface,
+        BOOL *mute)
+{
+    ACImpl *This = impl_from_ISimpleAudioVolume(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, mute);
+
+    return E_NOTIMPL;
+}
+
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl  =
+{
+    SimpleAudioVolume_QueryInterface,
+    SimpleAudioVolume_AddRef,
+    SimpleAudioVolume_Release,
+    SimpleAudioVolume_SetMasterVolume,
+    SimpleAudioVolume_GetMasterVolume,
+    SimpleAudioVolume_SetMute,
+    SimpleAudioVolume_GetMute
+};
+
+static HRESULT WINAPI AudioClock_QueryInterface(IAudioClock *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IAudioClock))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IAudioClock2))
+        *ppv = &This->IAudioClock2_iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClock_AddRef(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioClock_Release(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioClock_GetFrequency(IAudioClock *iface, UINT64 *freq)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%p)\n", This, freq);
+
+    *freq = This->ss.rate;
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClock_GetPosition(IAudioClock *iface, UINT64 *pos,
+        UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    pa_usec_t time;
+
+    TRACE("(%p)->(%p, %p)\n", This, pos, qpctime);
+
+    if(!pos)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    if (pa_stream_get_time(This->stream, &time) >= 0)
+        *pos = time * This->ss.rate / 1000000 - This->play_ofs;
+    else
+        *pos = This->play_ofs;
+    TRACE("Position: %u\n", (unsigned)*pos);
+    pthread_mutex_unlock(&pulse_lock);
+
+    if(qpctime){
+        LARGE_INTEGER stamp, freq;
+        QueryPerformanceCounter(&stamp);
+        QueryPerformanceFrequency(&freq);
+        *qpctime = (stamp.QuadPart * (INT64)10000000) / freq.QuadPart;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClock_GetCharacteristics(IAudioClock *iface,
+        DWORD *chars)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%p)\n", This, chars);
+
+    if(!chars)
+        return E_POINTER;
+
+    *chars = AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ;
+
+    return S_OK;
+}
+
+static const IAudioClockVtbl AudioClock_Vtbl =
+{
+    AudioClock_QueryInterface,
+    AudioClock_AddRef,
+    AudioClock_Release,
+    AudioClock_GetFrequency,
+    AudioClock_GetPosition,
+    AudioClock_GetCharacteristics
+};
+
+static HRESULT WINAPI AudioClock2_QueryInterface(IAudioClock2 *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClock_QueryInterface(&This->IAudioClock_iface, riid, ppv);
+}
+
+static ULONG WINAPI AudioClock2_AddRef(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioClock2_Release(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioClock2_GetDevicePosition(IAudioClock2 *iface,
+        UINT64 *pos, UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return AudioClock_GetPosition(&This->IAudioClock_iface, pos, qpctime);
+}
+
+static const IAudioClock2Vtbl AudioClock2_Vtbl =
+{
+    AudioClock2_QueryInterface,
+    AudioClock2_AddRef,
+    AudioClock2_Release,
+    AudioClock2_GetDevicePosition
+};
+
+static HRESULT WINAPI AudioSessionControl_QueryInterface(
+        IAudioSessionControl2 *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioSessionControl) ||
+            IsEqualIID(riid, &IID_IAudioSessionControl2))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioSessionControl_AddRef(IAudioSessionControl2 *iface)
+{
+    ACImpl *This = impl_from_IAudioSessionControl2(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioSessionControl_Release(IAudioSessionControl2 *iface)
+{
+    ACImpl *This = impl_from_IAudioSessionControl2(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioSessionControl_GetState(IAudioSessionControl2 *iface,
+        AudioSessionState *state)
+{
+    ACImpl *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, state);
+
+    if(!state)
+        return E_POINTER;
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetDisplayName(
+        IAudioSessionControl2 *iface, WCHAR **name)
+{
+    ACImpl *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, name);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDisplayName(
+        IAudioSessionControl2 *iface, const WCHAR *name, const GUID *session)
+{
+    ACImpl *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, name, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetIconPath(
+        IAudioSessionControl2 *iface, WCHAR **path)
+{
+    ACImpl *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, path);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetIconPath(
+        IAudioSessionControl2 *iface, const WCHAR *path, const GUID *session)
+{
+    ACImpl *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, path, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetGroupingParam(
+        IAudioSessionControl2 *iface, GUID *group)
+{
+    ACImpl *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, group);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetGroupingParam(
+        IAudioSessionControl2 *iface, const GUID *group, const GUID *session)
+{
+    ACImpl *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%s, %s) - stub\n", This, debugstr_guid(group),
+            debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_RegisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    ACImpl *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_UnregisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    ACImpl *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    ACImpl *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionInstanceIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    ACImpl *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetProcessId(
+        IAudioSessionControl2 *iface, DWORD *pid)
+{
+    ACImpl *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%p)\n", This, pid);
+
+    if(!pid)
+        return E_POINTER;
+
+    *pid = GetCurrentProcessId();
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_IsSystemSoundsSession(
+        IAudioSessionControl2 *iface)
+{
+    ACImpl *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)\n", This);
+
+    return S_FALSE;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDuckingPreference(
+        IAudioSessionControl2 *iface, BOOL optout)
+{
+    ACImpl *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%d)\n", This, optout);
+
+    return S_OK;
+}
+
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl =
+{
+    AudioSessionControl_QueryInterface,
+    AudioSessionControl_AddRef,
+    AudioSessionControl_Release,
+    AudioSessionControl_GetState,
+    AudioSessionControl_GetDisplayName,
+    AudioSessionControl_SetDisplayName,
+    AudioSessionControl_GetIconPath,
+    AudioSessionControl_SetIconPath,
+    AudioSessionControl_GetGroupingParam,
+    AudioSessionControl_SetGroupingParam,
+    AudioSessionControl_RegisterAudioSessionNotification,
+    AudioSessionControl_UnregisterAudioSessionNotification,
+    AudioSessionControl_GetSessionIdentifier,
+    AudioSessionControl_GetSessionInstanceIdentifier,
+    AudioSessionControl_GetProcessId,
+    AudioSessionControl_IsSystemSoundsSession,
+    AudioSessionControl_SetDuckingPreference
+};
+
+typedef struct _SessionMgr {
+    IAudioSessionManager2 IAudioSessionManager2_iface;
+
+    LONG ref;
+
+    IMMDevice *device;
+} SessionMgr;
+
+HRESULT WINAPI AudioSessionManager_QueryInterface(IAudioSessionManager2 *iface,
+        REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioSessionManager) ||
+            IsEqualIID(riid, &IID_IAudioSessionManager2))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static inline SessionMgr *impl_from_IAudioSessionManager2(IAudioSessionManager2 *iface)
+{
+    return CONTAINING_RECORD(iface, SessionMgr, IAudioSessionManager2_iface);
+}
+
+ULONG WINAPI AudioSessionManager_AddRef(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    return ref;
+}
+
+ULONG WINAPI AudioSessionManager_Release(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    if(!ref)
+        HeapFree(GetProcessHeap(), 0, This);
+    return ref;
+}
+
+HRESULT WINAPI AudioSessionManager_GetAudioSessionControl(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        IAudioSessionControl **out)
+{
+#if 0
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %x, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if(FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if(!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = (IAudioSessionControl*)&wrapper->IAudioSessionControl2_iface;
+
+    return S_OK;
+#else
+    FIXME("stub\n");
+    return E_NOTIMPL;
+#endif
+}
+
+HRESULT WINAPI AudioSessionManager_GetSimpleAudioVolume(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        ISimpleAudioVolume **out)
+{
+#if 0
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %x, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if(FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if(!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = &wrapper->ISimpleAudioVolume_iface;
+
+    return S_OK;
+#else
+    FIXME("stub\n");
+    return E_NOTIMPL;
+#endif
+}
+
+HRESULT WINAPI AudioSessionManager_GetSessionEnumerator(
+        IAudioSessionManager2 *iface, IAudioSessionEnumerator **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, out);
+    return E_NOTIMPL;
+}
+
+HRESULT WINAPI AudioSessionManager_RegisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+HRESULT WINAPI AudioSessionManager_UnregisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+HRESULT WINAPI AudioSessionManager_RegisterDuckNotification(
+        IAudioSessionManager2 *iface, const WCHAR *session_id,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+HRESULT WINAPI AudioSessionManager_UnregisterDuckNotification(
+        IAudioSessionManager2 *iface,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static const IAudioSessionManager2Vtbl AudioSessionManager2_Vtbl =
+{
+    AudioSessionManager_QueryInterface,
+    AudioSessionManager_AddRef,
+    AudioSessionManager_Release,
+    AudioSessionManager_GetAudioSessionControl,
+    AudioSessionManager_GetSimpleAudioVolume,
+    AudioSessionManager_GetSessionEnumerator,
+    AudioSessionManager_RegisterSessionNotification,
+    AudioSessionManager_UnregisterSessionNotification,
+    AudioSessionManager_RegisterDuckNotification,
+    AudioSessionManager_UnregisterDuckNotification
+};
+
+HRESULT WINAPI AUDDRV_GetAudioSessionManager(IMMDevice *device,
+        IAudioSessionManager2 **out)
+{
+    SessionMgr *This;
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(SessionMgr));
+    if(!This)
+        return E_OUTOFMEMORY;
+
+    This->IAudioSessionManager2_iface.lpVtbl = &AudioSessionManager2_Vtbl;
+    This->device = device;
+    This->ref = 1;
+
+    *out = &This->IAudioSessionManager2_iface;
+
+    return S_OK;
+}
diff --git a/dlls/winepulse.drv/winepulse.drv.spec b/dlls/winepulse.drv/winepulse.drv.spec
new file mode 100644
index 0000000..819ea12
--- /dev/null
+++ b/dlls/winepulse.drv/winepulse.drv.spec
@@ -0,0 +1,4 @@
+# MMDevAPI driver functions
+@ stdcall -private GetEndpointIDs(long ptr ptr ptr ptr) AUDDRV_GetEndpointIDs
+@ stdcall -private GetAudioEndpoint(ptr ptr long ptr) AUDDRV_GetAudioEndpoint
+@ stdcall -private GetAudioSessionManager(ptr ptr) AUDDRV_GetAudioSessionManager
diff --git a/include/config.h.in b/include/config.h.in
index f0016c8..20fd6e9 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -1211,6 +1211,9 @@
 /* Define to the soname of the libcurses library. */
 #undef SONAME_LIBCURSES
 
+/* Define to the soname of the libdbus-1 library. */
+#undef SONAME_LIBDBUS_1
+
 /* Define to the soname of the libfontconfig library. */
 #undef SONAME_LIBFONTCONFIG
 
diff --git a/include/wine/library.h b/include/wine/library.h
index 242bb69..6aa77b4 100644
--- a/include/wine/library.h
+++ b/include/wine/library.h
@@ -75,6 +75,12 @@ extern int wine_call_on_stack( int (*func)(void *), void *arg, void *stack );
 
 /* memory mappings */
 
+extern void *(*wine_mmap)( void *addr, size_t size, int prot, int flags, int fd, LONGLONG offset );
+extern int (*wine_munmap)( void *addr, size_t size );
+extern void *(*wine_mremap)( void *addr, size_t old_len, size_t new_len, int flags, ... );
+extern void *(*wine_hook_mmap)( void *addr, size_t size, int prot, int flags, int fd, LONGLONG offset );
+extern int (*wine_hook_munmap)( void *addr, size_t size );
+extern void *(*wine_hook_mremap)( void *addr, size_t old_len, size_t new_len, int flags, ... );
 extern void *wine_anon_mmap( void *start, size_t size, int prot, int flags );
 extern void wine_mmap_add_reserved_area( void *addr, size_t size );
 extern void wine_mmap_remove_reserved_area( void *addr, size_t size, int unmap );
diff --git a/libs/wine/loader.c b/libs/wine/loader.c
index df0a6b5..a5ca56f 100644
--- a/libs/wine/loader.c
+++ b/libs/wine/loader.c
@@ -786,6 +786,32 @@ static void apple_main_thread( void (*init_func)(void) )
 
 
 /***********************************************************************
+ *           set_rttime_limit
+ *
+ * set a limit on the cpu time used
+ */
+static void set_rttime_limit(void)
+{
+#if defined(HAVE_SETRLIMIT) && defined(__linux__)
+#ifndef RLIMIT_RTTIME
+#define RLIMIT_RTTIME 15
+#endif
+    struct rlimit rlimit;
+
+    if (!getrlimit( RLIMIT_RTTIME, &rlimit ))
+    {
+        /* 50 ms realtime, then 10 ms to undo realtime */
+        if (rlimit.rlim_max > 150000000ULL)
+            rlimit.rlim_max = 150000000ULL;
+        rlimit.rlim_cur = rlimit.rlim_max - 10000000ULL;
+
+        setrlimit( RLIMIT_RTTIME, &rlimit );
+    }
+#endif
+}
+
+
+/***********************************************************************
  *           wine_init
  *
  * Main Wine initialisation.
@@ -804,6 +830,7 @@ void wine_init( int argc, char *argv[], char *error, int error_size )
 #ifdef RLIMIT_AS
     set_max_limit( RLIMIT_AS );
 #endif
+    set_rttime_limit();
 
     wine_init_argv0_path( argv[0] );
     build_dll_path();
diff --git a/libs/wine/mmap.c b/libs/wine/mmap.c
index 63a597d..2f5adf4 100644
--- a/libs/wine/mmap.c
+++ b/libs/wine/mmap.c
@@ -43,6 +43,13 @@
 
 #ifdef HAVE_MMAP
 
+void *(*wine_mmap)( void *addr, size_t size, int prot, int flags, int fd, LONGLONG offset );
+int (*wine_munmap)( void *addr, size_t size );
+void *(*wine_mremap)( void *addr, size_t old_len, size_t new_len, int flags, ... );
+void *(*wine_hook_mmap)( void *addr, size_t size, int prot, int flags, int fd, LONGLONG offset );
+int (*wine_hook_munmap)( void *addr, size_t size );
+void *(*wine_hook_mremap)( void *addr, size_t old_len, size_t new_len, int flags, ... );
+
 struct reserved_area
 {
     struct list entry;
@@ -140,12 +147,12 @@ static int try_mmap_fixed (void *addr, size_t len, int prot, int flags,
 
         /* Perform the mapping with MAP_FIXED set.  This is safe
            now, as none of the pages is currently in use. */
-        result = mmap( addr, len, prot, flags | MAP_FIXED, fildes, off );
+        result = wine_mmap( addr, len, prot, flags | MAP_FIXED, fildes, off );
         if ( result == addr )
             _exit(0);
 
         if ( result != (void *) -1 ) /* This should never happen ... */
-            munmap( result, len );
+            wine_munmap( result, len );
 
        _exit(1);
     }
@@ -174,7 +181,7 @@ static int try_mmap_fixed (void *addr, size_t len, int prot, int flags,
 
     if (!vm_allocate(mach_task_self(),&result,len,0))
     {
-        if (mmap( (void *)result, len, prot, flags | MAP_FIXED, fildes, off ) != MAP_FAILED)
+        if (wine_mmap( (void *)result, len, prot, flags | MAP_FIXED, fildes, off ) != MAP_FAILED)
             return 1;
         vm_deallocate(mach_task_self(),result,len);
     }
@@ -213,7 +220,7 @@ void *wine_anon_mmap( void *start, size_t size, int prot, int flags )
             return start;
 #endif
     }
-    return mmap( start, size, prot, flags, get_fdzero(), 0 );
+    return wine_mmap( start, size, prot, flags, get_fdzero(), 0 );
 }
 
 
@@ -232,8 +239,8 @@ static inline int mmap_reserve( void *addr, size_t size )
 #elif defined(__APPLE__)
     return try_mmap_fixed( addr, size, PROT_NONE, flags, get_fdzero(), 0 );
 #endif
-    ptr = mmap( addr, size, PROT_NONE, flags, get_fdzero(), 0 );
-    if (ptr != addr && ptr != (void *)-1)  munmap( ptr, size );
+    ptr = wine_mmap( addr, size, PROT_NONE, flags, get_fdzero(), 0 );
+    if (ptr != addr && ptr != (void *)-1) wine_munmap( ptr, size );
     return (ptr == addr);
 }
 
@@ -259,8 +266,9 @@ static inline void reserve_area( void *addr, void *end )
             if (mincore( (caddr_t)addr + i, pagesize, &vec ) != -1) break;
 
         i &= ~granularity_mask;
-        if (i && mmap( addr, i, PROT_NONE, MAP_FIXED | MAP_PRIVATE | MAP_ANON | MAP_NORESERVE,
-                       get_fdzero(), 0 ) != (void *)-1)
+        if (i && wine_mmap( addr, i, PROT_NONE,
+                            MAP_FIXED | MAP_PRIVATE | MAP_ANON | MAP_NORESERVE,
+                            get_fdzero(), 0 ) != (void *)-1)
             wine_mmap_add_reserved_area( addr, i );
 
         i += granularity_mask + 1;
@@ -324,7 +332,7 @@ static inline void reserve_dos_area(void)
     ptr = wine_anon_mmap( (void *)page_size, dos_area_size - page_size, PROT_NONE, MAP_NORESERVE );
     if (ptr != (void *)page_size)
     {
-        if (ptr != (void *)-1) munmap( ptr, dos_area_size - page_size );
+        if (ptr != (void *)-1) wine_munmap( ptr, dos_area_size - page_size );
         return;
     }
     /* now add first page with MAP_FIXED */
@@ -493,7 +501,7 @@ void wine_mmap_remove_reserved_area( void *addr, size_t size, int unmap )
                 if ((char *)area->base + area->size > (char *)addr + size)
                 {
                     /* range overlaps beginning of area only -> shrink area */
-                    if (unmap) munmap( area->base, (char *)addr + size - (char *)area->base );
+                    if (unmap) wine_munmap( area->base, (char *)addr + size - (char *)area->base );
                     area->size -= (char *)addr + size - (char *)area->base;
                     area->base = (char *)addr + size;
                     break;
@@ -502,7 +510,7 @@ void wine_mmap_remove_reserved_area( void *addr, size_t size, int unmap )
                 {
                     /* range contains the whole area -> remove area completely */
                     ptr = list_next( &reserved_areas, ptr );
-                    if (unmap) munmap( area->base, area->size );
+                    if (unmap) wine_munmap( area->base, area->size );
                     list_remove( &area->entry );
                     free( area );
                     continue;
@@ -522,13 +530,13 @@ void wine_mmap_remove_reserved_area( void *addr, size_t size, int unmap )
                     }
                     else size = (char *)area->base + area->size - (char *)addr;
                     area->size = (char *)addr - (char *)area->base;
-                    if (unmap) munmap( addr, size );
+                    if (unmap) wine_munmap( addr, size );
                     break;
                 }
                 else
                 {
                     /* range overlaps end of area only -> shrink area */
-                    if (unmap) munmap( addr, (char *)area->base + area->size - (char *)addr );
+                    if (unmap) wine_munmap( addr, (char *)area->base + area->size - (char *)addr );
                     area->size = (char *)addr - (char *)area->base;
                 }
             }
diff --git a/libs/wine/wine.map b/libs/wine/wine.map
index 2159fac..380bf77 100644
--- a/libs/wine/wine.map
+++ b/libs/wine/wine.map
@@ -118,5 +118,11 @@ WINE_1.0
     wine_utf8_wcstombs;
     wine_wctype_table;
 
+    wine_mmap;
+    wine_munmap;
+    wine_mremap;
+    wine_hook_mmap;
+    wine_hook_munmap;
+    wine_hook_mremap;
   local: *;
 };
diff --git a/loader/main.c b/loader/main.c
index 8434d81..4339416 100644
--- a/loader/main.c
+++ b/loader/main.c
@@ -24,9 +24,6 @@
 #include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
-#ifdef HAVE_SYS_MMAN_H
-# include <sys/mman.h>
-#endif
 #ifdef HAVE_SYS_RESOURCE_H
 # include <sys/resource.h>
 #endif
@@ -139,7 +136,7 @@ static void check_vmsplit( void *stack )
     if (stack < (void *)0x80000000)
     {
         /* if the stack is below 0x80000000, assume we can safely try a munmap there */
-        if (munmap( (void *)0x80000000, 1 ) == -1 && errno == EINVAL)
+        if (wine_munmap( (void *)0x80000000, 1 ) == -1 && errno == EINVAL)
             fprintf( stderr,
                      "Warning: memory above 0x80000000 doesn't seem to be accessible.\n"
                      "Wine requires a 3G/1G user/kernel memory split to work properly.\n" );
@@ -196,6 +193,88 @@ static int pre_exec(void)
 #endif
 
 
+/***********************************************************************
+ * overrides for mmap, mmap64, munmap
+ */
+/* Because off_t can change size depending on _FILE_OFFSET_BITS=64 being set,
+ * we can't rely on it here. In most cases, the default off_t type follows the
+ * same pattern as long (4 bytes on 32-bit, 8 on 64).
+ * On FreeBSD, however, off_t is always a 64-bit type.
+ */
+#if defined(__FreeBSD__)
+typedef off_t offset_t;
+#else
+typedef long offset_t;
+#endif
+
+void *mmap( void *addr, size_t size, int prot, int flags, int fd, offset_t offset )
+{
+    return wine_hook_mmap( addr, size, prot, flags, fd, offset );
+}
+
+void *mmap64( void *addr, size_t size, int prot, int flags, int fd, off64_t offset )
+{
+    return wine_hook_mmap( addr, size, prot, flags, fd, offset );
+}
+
+int munmap( void *addr, size_t size )
+{
+    return wine_hook_munmap( addr, size );
+}
+
+#ifdef __linux__
+/* Linux also has a mremap function, which allows changing the size and address
+ * of a particular mapping */
+void *mremap( void *addr, size_t old_len, size_t new_len, int flags, ... )
+{
+    if((flags & 2)) /* MREMAP_FIXED */
+    {
+        void *extra;
+        va_list args;
+
+        va_start(args, flags);
+        extra = va_arg(args, void*);
+        va_end(args);
+
+        return wine_hook_mremap(addr, old_len, new_len, flags, extra);
+    }
+    return wine_hook_mremap(addr, old_len, new_len, flags);
+}
+#endif
+
+/**********************************************************************
+ *           init_mmap_functions
+ */
+static void init_mmap_functions(void)
+{
+    if (sizeof(offset_t) == sizeof(LONGLONG))
+        wine_hook_mmap = wine_mmap = wine_dlsym( RTLD_NEXT, "mmap", NULL, 0 );
+    else
+        wine_hook_mmap = wine_mmap = wine_dlsym( RTLD_NEXT, "mmap64", NULL, 0 );
+    wine_hook_munmap = wine_munmap = wine_dlsym( RTLD_NEXT, "munmap", NULL, 0 );
+
+    if (wine_mmap == NULL)
+    {
+        fprintf( stderr, "Could not find mmap function\n" );
+        exit(1);
+    }
+    if (wine_munmap == NULL)
+    {
+        fprintf( stderr, "Could not find munmap function\n" );
+        exit(1);
+    }
+
+#ifdef __linux__
+    wine_hook_mremap = wine_mremap = wine_dlsym( RTLD_NEXT, "mremap", NULL, 0 );
+    if (wine_mremap == NULL)
+    {
+        fprintf( stderr, "Could not find mremap function\n" );
+        exit(1);
+    }
+#endif
+}
+
+
 /**********************************************************************
  *           main
  */
@@ -204,6 +283,8 @@ int main( int argc, char *argv[] )
     char error[1024];
     int i;
 
+    init_mmap_functions();
+
     if (!getenv( "WINELOADERNOEXEC" ))  /* first time around */
     {
         static char noexec[] = "WINELOADERNOEXEC=1";
diff --git a/programs/winecfg/Makefile.in b/programs/winecfg/Makefile.in
index 9aafe32..3de7ccc 100644
--- a/programs/winecfg/Makefile.in
+++ b/programs/winecfg/Makefile.in
@@ -5,7 +5,6 @@ IMPORTS   = uuid comdlg32 comctl32 shell32 ole32 winmm shlwapi uxtheme user32 gd
 C_SRCS = \
 	about.c \
 	appdefaults.c \
-	audio.c \
 	drive.c \
 	drivedetect.c \
 	driveui.c \
diff --git a/programs/winecfg/audio.c b/programs/winecfg/audio.c
deleted file mode 100644
index f8b84d4..0000000
--- a/programs/winecfg/audio.c
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
- * Audio management UI code
- *
- * Copyright 2004 Chris Morgan
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- *
- */
-
-#define WIN32_LEAN_AND_MEAN
-#define NONAMELESSSTRUCT
-#define NONAMELESSUNION
-
-#include "config.h"
-#include "wine/port.h"
-
-#include <assert.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-
-#define COBJMACROS
-#include <windows.h>
-#include <wine/debug.h>
-#include <shellapi.h>
-#include <objbase.h>
-#include <shlguid.h>
-#include <shlwapi.h>
-#include <shlobj.h>
-#include <mmsystem.h>
-#include <mmreg.h>
-#include <mmddk.h>
-
-#include "ole2.h"
-#include "initguid.h"
-#include "devpkey.h"
-#include "mmdeviceapi.h"
-#include "audioclient.h"
-#include "audiopolicy.h"
-
-#include "winecfg.h"
-#include "resource.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(winecfg);
-
-static struct DSOUNDACCEL
-{
-  UINT displayID;
-  UINT visible;
-  const char* settingStr;
-} DSound_HW_Accels[] = {
-  {IDS_ACCEL_FULL,      1, "Full"},
-  {IDS_ACCEL_STANDARD,  0, "Standard"},
-  {IDS_ACCEL_BASIC,     0, "Basic"},
-  {IDS_ACCEL_EMULATION, 1, "Emulation"},
-  {0, 0, 0}
-};
-
-static const char* DSound_Rates[] = {
-  "48000",
-  "44100",
-  "22050",
-  "16000",
-  "11025",
-  "8000",
-  NULL
-};
-
-static const char* DSound_Bits[] = {
-  "8",
-  "16",
-  NULL
-};
-
-static void initAudioDlg (HWND hDlg)
-{
-    int i, j, found;
-    char* buf = NULL;
-
-    WINE_TRACE("\n");
-
-    SendDlgItemMessage(hDlg, IDC_DSOUND_HW_ACCEL, CB_RESETCONTENT, 0, 0);
-    buf = get_reg_key(config_key, keypath("DirectSound"), "HardwareAcceleration", "Full");
-
-    j = found = 0;
-    for (i = 0; 0 != DSound_HW_Accels[i].displayID; ++i) {
-      WCHAR accelStr[64];
-      int match;
-
-      match = (strcmp(buf, DSound_HW_Accels[i].settingStr) == 0);
-      if (match)
-      {
-        DSound_HW_Accels[i].visible = 1;
-        found = 1;
-      }
-
-      if (DSound_HW_Accels[i].visible)
-      {
-        LoadStringW (GetModuleHandle (NULL), DSound_HW_Accels[i].displayID,
-                     accelStr, sizeof(accelStr)/sizeof(accelStr[0]));
-        SendDlgItemMessageW (hDlg, IDC_DSOUND_HW_ACCEL, CB_ADDSTRING, 0, (LPARAM)accelStr);
-        if (match)
-          SendDlgItemMessage(hDlg, IDC_DSOUND_HW_ACCEL, CB_SETCURSEL, j, 0);
-        j++;
-      }
-    }
-    if (!found) {
-      WINE_ERR("Invalid Direct Sound HW Accel read from registry (%s)\n", buf);
-    }
-    HeapFree(GetProcessHeap(), 0, buf);
-
-    SendDlgItemMessage(hDlg, IDC_DSOUND_RATES, CB_RESETCONTENT, 0, 0);
-    for (i = 0; NULL != DSound_Rates[i]; ++i) {
-      SendDlgItemMessage(hDlg, IDC_DSOUND_RATES, CB_ADDSTRING, 0, (LPARAM) DSound_Rates[i]);
-    }
-    buf = get_reg_key(config_key, keypath("DirectSound"), "DefaultSampleRate", "44100");
-    for (i = 0; NULL != DSound_Rates[i]; ++i) {
-      if (strcmp(buf, DSound_Rates[i]) == 0) {
-	SendDlgItemMessage(hDlg, IDC_DSOUND_RATES, CB_SETCURSEL, i, 0);
-	break ;
-      }
-    }
-
-    SendDlgItemMessage(hDlg, IDC_DSOUND_BITS, CB_RESETCONTENT, 0, 0);
-    for (i = 0; NULL != DSound_Bits[i]; ++i) {
-      SendDlgItemMessage(hDlg, IDC_DSOUND_BITS, CB_ADDSTRING, 0, (LPARAM) DSound_Bits[i]);
-    }
-    buf = get_reg_key(config_key, keypath("DirectSound"), "DefaultBitsPerSample", "16");
-    for (i = 0; NULL != DSound_Bits[i]; ++i) {
-      if (strcmp(buf, DSound_Bits[i]) == 0) {
-	SendDlgItemMessage(hDlg, IDC_DSOUND_BITS, CB_SETCURSEL, i, 0);
-	break ;
-      }
-    }
-    HeapFree(GetProcessHeap(), 0, buf);
-}
-
-INT_PTR CALLBACK
-AudioDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
-{
-  switch (uMsg) {
-      case WM_COMMAND:
-        switch (LOWORD(wParam)) {
-          case IDC_AUDIO_TEST:
-              if(!PlaySound(MAKEINTRESOURCE(IDW_TESTSOUND), NULL, SND_RESOURCE | SND_SYNC))
-                  MessageBox(NULL, "Audio test failed!", "Error", MB_OK | MB_ICONERROR);
-              break;
-          case IDC_DSOUND_HW_ACCEL:
-            if (HIWORD(wParam) == CBN_SELCHANGE) {
-              int selected_dsound_accel;
-              int i, j = 0;
-
-              SendMessage(GetParent(hDlg), PSM_CHANGED, 0, 0);
-              selected_dsound_accel = SendDlgItemMessage(hDlg, IDC_DSOUND_HW_ACCEL, CB_GETCURSEL, 0, 0);
-              for (i = 0; DSound_HW_Accels[i].settingStr; ++i)
-              {
-                if (DSound_HW_Accels[i].visible)
-                {
-                  if (j == selected_dsound_accel)
-                  {
-                    set_reg_key(config_key, keypath("DirectSound"), "HardwareAcceleration",
-                      DSound_HW_Accels[i].settingStr);
-                    break;
-                  }
-                  j++;
-                }
-              }
-            }
-            break;
-          case IDC_DSOUND_RATES:
-            if (HIWORD(wParam) == CBN_SELCHANGE) {
-              int selected_dsound_rate;
-              SendMessage(GetParent(hDlg), PSM_CHANGED, 0, 0);
-              selected_dsound_rate = SendDlgItemMessage(hDlg, IDC_DSOUND_RATES, CB_GETCURSEL, 0, 0);
-              set_reg_key(config_key, keypath("DirectSound"), "DefaultSampleRate", DSound_Rates[selected_dsound_rate]);
-            }
-            break;
-          case IDC_DSOUND_BITS:
-            if (HIWORD(wParam) == CBN_SELCHANGE) {
-              int selected_dsound_bits;
-              SendMessage(GetParent(hDlg), PSM_CHANGED, 0, 0);
-              selected_dsound_bits = SendDlgItemMessage(hDlg, IDC_DSOUND_BITS, CB_GETCURSEL, 0, 0);
-              set_reg_key(config_key, keypath("DirectSound"), "DefaultBitsPerSample", DSound_Bits[selected_dsound_bits]);
-            }
-            break;
-        }
-        break;
-      case WM_SHOWWINDOW:
-        set_window_title(hDlg);
-        break;
-
-      case WM_NOTIFY:
-        switch(((LPNMHDR)lParam)->code) {
-            case PSN_KILLACTIVE:
-              SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
-              break;
-            case PSN_APPLY:
-              apply();
-              SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
-              break;
-            case PSN_SETACTIVE:
-              break;
-        }
-        break;
-      case WM_INITDIALOG:
-        initAudioDlg(hDlg);
-        break;
-  }
-
-  return FALSE;
-}
diff --git a/programs/winecfg/main.c b/programs/winecfg/main.c
index 7376309..020364b 100644
--- a/programs/winecfg/main.c
+++ b/programs/winecfg/main.c
@@ -60,7 +60,7 @@ PropSheetCallback (HWND hWnd, UINT uMsg, LPARAM lParam)
     return 0;
 }
 
-#define NUM_PROPERTY_PAGES 7
+#define NUM_PROPERTY_PAGES 6
 
 static INT_PTR
 doPropertySheet (HINSTANCE hInstance, HWND hOwner)
@@ -131,16 +131,6 @@ doPropertySheet (HINSTANCE hInstance, HWND hOwner)
     psp[pg].lParam = 0;
     pg++;
 
-    psp[pg].dwSize = sizeof (PROPSHEETPAGEW);
-    psp[pg].dwFlags = PSP_USETITLE;
-    psp[pg].hInstance = hInstance;
-    psp[pg].u.pszTemplate = MAKEINTRESOURCEW (IDD_AUDIOCFG);
-    psp[pg].u2.pszIcon = NULL;
-    psp[pg].pfnDlgProc = AudioDlgProc;
-    psp[pg].pszTitle =  load_string (IDS_TAB_AUDIO);
-    psp[pg].lParam = 0;
-    pg++;
-
     /*
      * Fill out the (General) PROPSHEETPAGE data structure 
      * for the property sheet
diff --git a/programs/winecfg/winecfg.h b/programs/winecfg/winecfg.h
index 1959409..9248edf 100644
--- a/programs/winecfg/winecfg.h
+++ b/programs/winecfg/winecfg.h
@@ -85,7 +85,6 @@ INT_PTR CALLBACK DriveDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lPara
 INT_PTR CALLBACK DriveEditDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 INT_PTR CALLBACK AppDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 INT_PTR CALLBACK LibrariesDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
-INT_PTR CALLBACK AudioDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 INT_PTR CALLBACK ThemeDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 INT_PTR CALLBACK AboutDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 
diff --git a/programs/winemenubuilder/winemenubuilder.c b/programs/winemenubuilder/winemenubuilder.c
index 2dce850..9c65004 100644
--- a/programs/winemenubuilder/winemenubuilder.c
+++ b/programs/winemenubuilder/winemenubuilder.c
@@ -2486,7 +2486,7 @@ static BOOL write_freedesktop_association_entry(const char *desktopPath, const c
         fclose(desktop);
     }
     else
-        WINE_ERR("error writing association file %s\n", wine_dbgstr_a(desktopPath));
+        WINE_WARN("error writing association file %s\n", wine_dbgstr_a(desktopPath));
     return ret;
 }
 
diff --git a/server/Makefile.in b/server/Makefile.in
index a2f1a52..7d9cdf8 100644
--- a/server/Makefile.in
+++ b/server/Makefile.in
@@ -1,5 +1,6 @@
 DEFS      = -D__WINESRC__
 EXTRALIBS = @LIBPOLL@
+MODCFLAGS = @DBUSINCL@
 
 C_SRCS = \
 	async.c \
@@ -31,6 +32,7 @@ C_SRCS = \
 	region.c \
 	registry.c \
 	request.c \
+	rtkit.c \
 	semaphore.c \
 	serial.c \
 	signal.c \
diff --git a/server/rtkit.c b/server/rtkit.c
new file mode 100644
index 0000000..ba7caec
--- /dev/null
+++ b/server/rtkit.c
@@ -0,0 +1,182 @@
+/*
+ * Rtkit dbus calls
+ * Copyright 2010 Maarten Lankhorst for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+#include "wine/library.h"
+
+#include <errno.h>
+#include <sys/types.h>
+#ifdef HAVE_SYS_SCHED_H
+#include <sys/sched.h>
+#endif
+#include <sys/resource.h>
+
+#if defined(HAVE_SETRLIMIT) && defined(__linux__) && defined(SONAME_LIBDBUS_1) && defined(HAVE_SCHED_H)
+
+#include <sched.h>
+#include <string.h>
+#include <unistd.h>
+#include <dbus/dbus.h>
+#include <stdio.h>
+#include "object.h"
+
+#ifndef RLIMIT_RTTIME
+#define RLIMIT_RTTIME 15
+#endif
+
+#define FUNCPTR(fn) static typeof(fn) *p ##fn
+
+FUNCPTR(dbus_error_init);
+FUNCPTR(dbus_error_free);
+FUNCPTR(dbus_bus_get);
+FUNCPTR(dbus_message_new_method_call);
+FUNCPTR(dbus_message_append_args);
+FUNCPTR(dbus_connection_send_with_reply_and_block);
+FUNCPTR(dbus_message_unref);
+FUNCPTR(dbus_set_error_from_message);
+#undef FUNCPTR
+
+static int translate_error( unsigned tid, const char *name )
+{
+    if (!strcmp( name, DBUS_ERROR_NO_MEMORY ))
+        return -ENOMEM;
+    if (!strcmp( name, DBUS_ERROR_SERVICE_UNKNOWN ) ||
+        !strcmp( name, DBUS_ERROR_NAME_HAS_NO_OWNER ))
+        return -ENOENT;
+    if (!strcmp( name, DBUS_ERROR_ACCESS_DENIED ) ||
+        !strcmp( name, DBUS_ERROR_AUTH_FAILED ))
+        return -EACCES;
+
+    if (debug_level)
+        fprintf( stderr, "%04x: Could not map error \"%s\"\n", tid, name );
+    return -EIO;
+}
+
+static void init_dbus(void)
+{
+#define FUNCPTR(fn) p ##fn = wine_dlsym( libdbus, #fn, NULL, 0 );
+    char error[512];
+    void *libdbus = wine_dlopen( SONAME_LIBDBUS_1, RTLD_NOW, error, sizeof( error ) );
+    FUNCPTR(dbus_error_init);
+    FUNCPTR(dbus_error_free);
+    FUNCPTR(dbus_bus_get);
+    FUNCPTR(dbus_message_new_method_call);
+    FUNCPTR(dbus_message_append_args);
+    FUNCPTR(dbus_connection_send_with_reply_and_block);
+    FUNCPTR(dbus_message_unref);
+    FUNCPTR(dbus_set_error_from_message);
+#undef FUNCPTR
+}
+
+static DBusConnection *get_dbus(void)
+{
+    static DBusConnection *bus;
+    DBusError error;
+
+    if (bus)
+        return bus;
+    init_dbus();
+    pdbus_error_init( &error );
+
+    bus = pdbus_bus_get( DBUS_BUS_SYSTEM, &error );
+    return bus;
+}
+
+int rtkit_make_realtime( pid_t process, pid_t thread, int priority )
+{
+    return -ENOTSUP;
+
+    DBusConnection *bus;
+    DBusMessage *m = NULL, *r = NULL;
+    dbus_uint64_t pid = process;
+    dbus_uint64_t tid = thread;
+    dbus_uint32_t rtprio = priority;
+    DBusError error;
+    int ret;
+
+    bus = get_dbus();
+    if (!bus)
+        return -ENOTSUP;
+
+    pdbus_error_init( &error );
+    m = pdbus_message_new_method_call( "org.freedesktop.RealtimeKit1",
+                                       "/org/freedesktop/RealtimeKit1",
+                                       "org.freedesktop.RealtimeKit1",
+                                       "MakeThreadRealtimeWithPID" );
+    if (!m)
+    {
+        ret = -ENOMEM;
+        goto out;
+    }
+
+    ret = pdbus_message_append_args( m, DBUS_TYPE_UINT64, &pid,
+                                     DBUS_TYPE_UINT64, &tid,
+                                     DBUS_TYPE_UINT32, &rtprio,
+                                     DBUS_TYPE_INVALID );
+    if (!ret)
+    {
+        ret = -ENOMEM;
+        goto out;
+    }
+    r = pdbus_connection_send_with_reply_and_block( bus, m, -1, &error );
+    if (!r)
+    {
+        ret = translate_error( tid, error.name );
+        goto out;
+    }
+    if (pdbus_set_error_from_message( &error, r ))
+        ret = translate_error( tid, error.name );
+    else
+        ret = 0;
+out:
+    if (m)
+        pdbus_message_unref( m );
+    if (r)
+        pdbus_message_unref( r );
+    pdbus_error_free( &error );
+    if (debug_level)
+        fprintf( stderr, "%04x: Setting realtime priority of %u returns %i\n", (int)tid, rtprio, ret );
+    return ret;
+}
+
+int rtkit_undo_realtime( pid_t thread )
+{
+    struct sched_param parm;
+    int ret;
+    memset( &parm, 0, sizeof( parm ) );
+    ret = sched_setscheduler( thread, SCHED_OTHER, &parm );
+    if (ret < 0)
+        return -errno;
+    return ret;
+}
+
+#else
+
+int rtkit_make_realtime( pid_t process, pid_t thread, int priority )
+{
+    return -ENOTSUP;
+}
+
+int rtkit_undo_realtime( pid_t thread )
+{
+    return -ENOTSUP;
+}
+
+#endif
diff --git a/server/thread.c b/server/thread.c
index f704473..b0ee027 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -52,6 +52,8 @@
 #include "user.h"
 #include "security.h"
 
+extern int rtkit_make_realtime(pid_t process, pid_t thread, int priority);
+extern int rtkit_undo_realtime(pid_t thread);
 
 #ifdef __i386__
 static const unsigned int supported_cpus = CPU_FLAG(CPU_x86);
@@ -466,7 +468,17 @@ static void set_thread_info( struct thread *thread,
         if ((req->priority >= min && req->priority <= max) ||
             req->priority == THREAD_PRIORITY_IDLE ||
             req->priority == THREAD_PRIORITY_TIME_CRITICAL)
+        {
+            if (thread->unix_tid == -1)
+                {}
+            else if (thread->priority == THREAD_PRIORITY_TIME_CRITICAL &&
+                     req->priority != THREAD_PRIORITY_TIME_CRITICAL)
+                rtkit_undo_realtime(thread->unix_tid);
+            else if (thread->priority != THREAD_PRIORITY_TIME_CRITICAL &&
+                     req->priority == THREAD_PRIORITY_TIME_CRITICAL)
+                rtkit_make_realtime(thread->unix_pid, thread->unix_tid, 1);
             thread->priority = req->priority;
+        }
         else
             set_error( STATUS_INVALID_PARAMETER );
     }
@@ -1194,6 +1206,10 @@ DECL_HANDLER(init_thread)
     }
     debug_level = max( debug_level, req->debug_level );
 
+    /* Raced with SetThreadPriority */
+    if (current->priority == THREAD_PRIORITY_TIME_CRITICAL)
+        rtkit_make_realtime(current->unix_pid, current->unix_tid, 1);
+
     reply->pid     = get_process_id( process );
     reply->tid     = get_thread_id( current );
     reply->version = SERVER_PROTOCOL_VERSION;
-- 
1.7.6.3

